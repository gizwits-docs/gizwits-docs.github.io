[{"title":" Gizwits QuickStart","url":"/en-us/quickstart.html","content":"Company Profile\nGizwits is a multinational technology company located in China, with its domestic headquarter and R&D center in Guangzhou Tianhe High-tech Industrial Park, and overseas headquarter on Madison Avenue in New York, US . There are labs and offices scattering in Shenzhen, Shanghai, Beijing and Hangzhou. Gizwits provides enterprise-oriented IoT development and cloud services, achieving major functions like facility management, network connectivity management, application development, data mining, intelligent analysis, financial billing and third party open system interconnection. Gizwits platform enables customers to connect with underlying devices, corporation business requirements, application developers and other IT systems, such as CRM, ERP and etc., within the company, and therefore forge integrated IoT solutions for enterprises in different industries. Up to now, Gizwits has serviced various industries like telematics, new energy, Industrial Internet, healthcare, consumer electronics, and ranked first with the largest market share in the field of domestic appliance.\nWith technical advantages on hardware access, data mining and application analysis, as well as years of practical experience, Gizwits has developed into the best IoT cloud service platform in the industry and occupied a core position in the value chain. Through the centralisation, processing and dissemination of data stream, Gitwits has sustained and propelled the innovation of business models and the improvement of industrial efficiency concerning IoT technology in different business segments, based on the big-platform-plus-small-front-end structure. Due to the deep rooting in the industry and the resources integration along the value chain for years, Gizwits has formed a comprehensive ecosystem of IoT development and services, by arranging deals between suppliers and customers to lower transaction costs, as well as releasing the enormous value of shared economy and acquiring dividends of the applications through third party interfaces, which finally achieve a win-win situation in its business ecology.  \nBy the end of 2016, Gizwits has acquired dozens of IoT related patents and copyrights in total and played a leading role in several major IoT projects for customers from China and globally renowned brands. Up to now, Gizwits have already formed a global strategic partnership with Microsoft, Amazon, Qualcomm and Intel:\nApple:\nThe MFi certified IoT software solutions provider in Asia-Pacific region for seven consecutive years, and constantly participate in the R&D process of Apple Homekit and promote further cooperation.\nMicrosoft:\nAssisted the DX (Development Experience) Department of Microsoft to accomplish the R&D process of the IoT development tools, and hold the summer camp for developers in 2015.\nIntel:\nAssisted Intel to connect the Edison module to the cloud, realizing self-service development functions and carry out the first session of makers competition in 2015.\nAmazon:\nRecently launched Smarthomeand Custom Skill on Amazon’s Alexa platform, extending the potential application scenarios of Echo to the smart appliance manufacturers in China.\nQualcomm:\nReleased cold chain property management solutions HIVE and smart charging piles managment platform, based on the global multi-mode cellular network IoT connectivity technology of Qualcomm MDM9206 chip.\nTechnical platforms like Arduino and SGS-THOMSON Microelectronics:\nCooperated with technical platforms and made joint effort to establish an open ecology among developers, including lowering the technical threshold, shortening the development cycle and reducing the development cost.\nTelecom carriers like Vodafone, China Telecom, China Mobile, China Unicom:\nApproached and cooperated with industry-leading telecom carriers on M2M IoT wireless communication technology and services, assisting enterprises in accelerating the “Internet Plus” upcycling course, and boosting the innovation and transformation process of IoT industry together.\nBy the end of 2016, more than 7 million online devices in total has been running on Gizwits platform, while over 50,000 application developers and 6,000 registered corporate users have developed tens of thousands of IoT programs using the handy tools provided by Gizwits. Proudly servicing renowned brands like Haier, Midea, State Grid Corporation of China, Mercedes Benz, A.O. Smith, Honeywell, 3M, AUX, TCL, NVC-Lighting, LETV, Galanz, Supor, Robam, Little Swan and etc., Gizwits has ranked first with the largest market share in the field of domestic appliance.\nCorporation Businesses\nBusiness Segments\nGizwits Intelligent Hardware Self-service Development Platform (Platform-as-a-service, Paas)\nGizWits Intelligent Hardware Self-service Development Platform is the world’first and soundest App Enablement Services platform in the industry, with the hugest IoT application developer community worldwide. Gizwits is able to help developers to efficiently and effectively accomplish the development, testing, launching and commercial operation processes of their projects through its integrated toolchain, including diversified API support, sound SDK, integrated development environment, automatic embedded systems and mobile application code generators.\nGizwits Intelligent Devices Application Management Platform\nGizwits Intelligent Devices Application Management Platform is able to conduct functions including remote monitoring, setting adjustments, software and system updates, troubleshooting, life cycle management and etc., against the connected intelligent devices, at the same time providing real-time warnings and feedbacks on the monitoring of gateways and application status , in order to prevent failures in advance and improve the overall satisfaction of customer services. Open APIs can help customers easily conduct system integration and value-added feature development. All data generated by the devices are stored on the cloud.  Gizwits also offer services like application support, data mining and financial billing for industries.\nGizwits Real-time Big Data Analysis and Applications Platform\nGizwits Real-time Big Data Analysis and Applications Platform has provided customers with full capacity to deal with big data and efficiently achieve the complex machine learning algorithms in IoT. Not only do Gizwits collect various kinds of relevant data during the process, but also categorize and analyze them, producing consolidated visualized analysis reports. Through real-time dynamic analysis, the conditions of intelligent devices are strictly monitored and would alert when out of order. Predictive, cognitive or complex business logic analysis would be perfectly fulfilled, whether by the prediction models trained and generated using history data, structured and unstructured, or the unique models developed based on the tools Gizwits platform provides.  \nSolutions\nFor different industries, Gizwits has relatively provided different types of solutions:\nGizwits Smart Water Appliance Integrated Solutions\nGizwits Smart Home Integrated Solutions\nGizwits Energy Management Integrated Solutions\nGizwits Assets Lease Integrated Solutions\nBusiness Facilities and Assets Management Integrated Solutions\nSelf-service IoT Reengineering System Integrated Solutions\nGizwits Recipes Cloud System\nGizwits Assets Lease System\nGizwits Smart Charging Pile Platform Solutions\nZinn Smart Rental Apartment Management System\nmore information\nMission\nHelp users speedily enter IoT industry and constantly create the hugest business value, through competitive IoT solutions, technical innovative tools, and data mining services.\nProspect\nTo be the most valuable IoT company worldwide, and to provide the best platform for stakeholders, staff, customers and business partners to achieve everyone’s dreams.\nPhilosophy\nBorn for intelligent hardwares\nCore Values\nConnection, Appreciation, Openness, Neutrality, Safety, Independence, Freedom, Ecology\nConnection - To provide secure and reliable IoT solutions to help users speedily achieve Internet-based transformation of hardware products.\nAppreciation - To provide value-added services such as data storage, statistical analysis, remote management, message push, personal customization and artificial intelligence.\nOpenness - To provide open-source softwares, self-service development tools, technical support and an open cloud APIs for intelligent hardware developers.\nNeutrallity - To be compatible with all mainstream communication chips and modules, support worldwide public cloud deployment and cross-platform connections.\nSecurity - To ensure the stable operation of intelligent devices through online deployment plans by millions of devices running simultaneously, with three sets of security systems protecting the data safety.\nPrivate - To provide users with support in establishing self-owned data centers, help users deploy and manage globalised IoT cloud platforms.\nEcology - To build a complete IoT ecosystem and provide diversified services for users, partners, and customers.\nFreedom - To put users’needs first by giving them freedom within an open codebase, unlimited data read-and-write functionality, and freedom of choice.\nContact us\nNew York 646.201.9357\n"},{"title":"privacy policy/terms of use","url":"/en-us/statement.html","content":"Welcome!\nSo you have purchased our Gizwits device and are starting to use the devices! Any information you share with us (e.g. for creating a Gizwits Account) will help us to provide you with services related to Gizwits device and to improve them to make them even better. We explain here our ways of collecting and using information, and how we protect your privacy. In this privacy policy, “personal data” means information that can be used to identify an individual, either from that information alone, or from that information and other information we have access to about that individual. We collect both personal and non-personal data to enable and facilitate the best user experience possible.\n​\nWhat information is collected and how do we use it?\nTypes of Personal Data Collected\n\nIn order to provide our services to you, we will ask you to provide necessary personal data that is required to provide those services. \n\nSet up and log in of Gizwits Account.Personal data that are collected for creating a Gizwits Account may include your email address or mobile phone number, device related information (e.g. IMEI number) and various location related information (e.g. location area code, mobile network and country codes).\n\nPurchasing your Gizwits products.When you make purchases through the Gizwits e-commerce website or other 3rd party c-commerce website such as amazon, we may collect your Gizwits Account ID (or mobile phone number or email addressed used to create your Gizwits Account), name, phone number, delivery address and order details, etc. Gizwits provides logistics services to deliver the products purchased on the e-commerce website. Gizwits has an after sales system to handle after sales services for users. When you use these services, we may also collect the order number, invoice date, list of purchased items and your contact details in order to process the services.\n\nSync Gizwits device data.When you synchronise the Gizwits device data, e.g. to Gizwits device Cloud Service, we may collect data relating to your activities and functionalities of Gizwits device, such as those obtained from our sensors and features on Gizwits device, your device on/off time, and smart alarm related information.\n\nSharing your content.When you share content or send information to family and friends, we may collect personal information of those people, such as their names, email addresses, telephone numbers, and mailing addresses (if we need to send a product to them). You hereby represent and warrant that you have obtained necessary consent for use of third parties’ personal data if you choose to provide them to us. When you share content or invite users to use Gizwits device, please note that other users may see personal data you share.\n\nProcessing the services.In providing the above services, we may also collect data in relation to your device, including your Gizwits device ID, firmware version, device OS version, model and system, and visiting IP and time.\n\n\n​\nHow the Personal Data is used\n\nTo provide you with our products and services, processing your orders, performing contractual obligations between you and us, to ensure the functions and safety of our products, to verify your identity, to prevent and trace fraudulent or inappropriate usage\n\nTo develop our products and services, together with general and statistical information\n\nTo communicate with you, including providing you with notifications on products and services that are updated or launched\n\nTo provide marketing and promotional materials to you on our products and services (please note that you may unsubscribe anytime)\n\nTo personalise product design and to provide you with services tailored for you, for example, recommending and displaying information and advertisements regarding products suited to you, and to invite you to participate in surveys relating to your use of Gizwits device\n\nTo conduct investigations regarding our products and services\n\nIf you participate in our lottery, contest or other promotions, we may use your personal data to manage such activities\n\nTo provide maintenance services, monitor software licenses, to improve our products or analyse the efficiency of our operations\n\n\nOther Information\nWe use statistical data that does not specifically identify you (non-personal data) to help in our operations and improve our products and services and provide a better user experience for you. Here are some of the non-personal data we may collect and how we use them:\n\nWhen you create a Gizwits Account, download our software, register in our e-commerce website, participate in online surveys or interact with us in other ways, we may collect your language preferences, postal code, area code number and time zone in which you use our products and services, and your profession.\n\nWhen you opt-in to participate in our User Experience Improvement Program, we may gather statistics relating to your use of our products functions, on an anonymous basis. This may include information relating to your use of our official website, products and services. If there is an abnormal shutdown or breakdown, we may collect information relating to your mobile device to diagnose the problem.\n\nWhen you use our services or functions that are based on location information, e.g. carry out a location search, take advantage of advertising, use weather functions, access information based on maps, etc., we may collect your geographical information.\n\nWhen you use our website, online services, interactive applications, email messages and advertising, we may use cookies and other technical elements (e.g. pixel labels) to collect and store non-personal data. These enable us to provide you with a better experience and improve our overall service quality, e.g. in saving your preferred language settings, sending emails in a readable format, to determine whether the emails have been opened or not, etc.\n\nWhen you use the Internet browser in using our products and services, we may collect log information, e.g. IP address, browser type, language, reference source, operating system, date and time marking and click rate data.\n\nWhen you first use and activate your Gizwits device, the device’s unique identification code and approximate geographical information may be collected.\n​\n\n\nYou have control over your information!\nWe recognise that privacy concerns differ from person to person. Therefore, we provide examples of ways we make available for you to choose to restrict the collection, use, disclosure or processing of your personal data and control your privacy settings, such as controlling the settings under the User Experience Improvement Program, Location Access functions, and your Gizwits Account.\n​\nAccess, Updating or Correcting Your Personal Data\nYou have the right to request access and/or correction or any other personal data that we hold about you. When you update your personal data, you will be asked to verify your identity before we proceed with your request. Once we obtain sufficient information to accommodate your request for access or correction of your personal data, we shall process in accordance with the laws of your country. While we try our utmost in acceding to your requests, unreasonably repetitive or unrealistic requests or those that put others’ privacy at risk may be declined.\nWe normally provide such services for free but reserve the right to charge a reasonable fee.\nIf you believe any information we are holding on you is incorrect or incomplete, please write to or email us as soon as possible at the email address below. Email: Gizwits_echo@Gizwits.com.\nFor details relating to the personal data in your Gizwits Account, you may also access and change them at Email: Gizwits_echo@Gizwits.com.\n​\nWithdrawal of Consent\nYou may withdraw your consent for the collection, use and/or disclosure of your personal data in our possession or control by submitting a request. This may be done by accessing your Gizwits Account management center at Email:  . We will process your request within a reasonable time from when the request was made, and thereafter not collect, use and/or disclose your personal data as per your request.\nPlease recognise that your withdrawal of consent could result in certain legal consequences. Depending on the extent of your withdrawal of consent for us to process your personal data, it may mean that you will not be able to enjoy Gizwits’s products and services.\n​\nWho do we share your information with?\nUnless we tell you in this privacy policy, we will keep your personal information confidential. We may disclose your personal data on occasion to third parties in order to provide the products or services that you have requested. Some of these third parties may be located outside your home country.\nDisclosure may include the scenarios listed in this section below. In each case described in this section, you can be assured that Gizwits will only share your personal data in accordance with your consent. You should know that when Gizwits shares your personal data with a third party under any circumstance described in this section, Gizwits will ensure that the third party is subject to practices and obligations to comply with the relevant data protection and privacy laws of your country. Gizwits will contractually ensure compliance by any foreign Third Party Service Providers with the privacy standards that apply in your home jurisdiction.\nDisclosure to Gizwits group companies and Third Party Service Providers\nIn order to conduct business operations smoothly, the Gizwits entity which collects your personal data may disclose your personal data from time to time to other Gizwits group companies (in communications, social media, technology or cloud business), or our third party service providers which are our mailing houses, delivery service providers, telecommunications companies, data centres, data storage facilities, and customer service providers, agents, related corporations, and/or other third parties (together “Third Party Service Providers”). Such Third Party Service Providers would be processing your personal data on Gizwits’s behalf or for one or more of the purposes listed above.\nPersonal data will only be shared by Gizwits to provide or improve our products or services and will not be shared for use for marketing purposes.\n​\nDisclosure to Others\nGizwits may disclose your personal data without further consent if required or permitted by law in the following cases:\ncases in which the disclosure is required or authorized based on the applicable laws and/or regulations;\ncases in which the disclosure is necessary to respond to an emergency that threatens the life, health or safety of the individual or another individual;\ncases in which the disclosure is necessary for the prevention of crime or legal proceedings;\ncases in which the purpose of such disclosure is clearly in the individual’s interests, and if consent cannot be obtained in a timely way;\ncases in which the disclosure is necessary for any investigation or proceedings;\ncases in which the disclosure is to any officer of a prescribed law enforcement agency upon production of written authorisation signed by the head or director of that law enforcement agency, or a person of a similar rank, certifying that the personal data is necessary for the purposes of the functions or duties of the officer; and/or\ncases in which the disclosure is to a public agency and such disclosure is necessary in the public interest.\n​\nInformation Not Requiring Consent\nWe may share anonymised information and statistics in aggregate form with third parties for business purposes, for example with advertisers on our website, or we may tell our business partners the number of customers in certain demographic groups who purchased certain products or who carried out certain transactions.\nFor the avoidance of doubt, in the event that we are permitted by law to collect, use or disclose your personal data without your consent, such permission granted by the law shall continue to apply.\n​\nInformation Safety Safeguards\nWe are committed to ensuring that your personal data is secure. In order to prevent unauthorised access, disclosure or other similar risks, we have put in place reasonable physical, electronic and managerial procedures to safeguard and secure the information we collect. We have put in place the following security procedures and technical and organisational measures to safeguard your personal data.\nInformation safety is very important to us. We will take all practicable steps to safeguard your personal data. Through our protective measures above, especially encrypted storage and transmission, your data is as secure as it can be. Certain details of encrypted data cannot be accessed by anyone except by you.\n​\nWhen this Privacy Policy applies\nOur Privacy Policy does not apply to products and services offered by a third party. Gizwits products and services may include third party’s products or services. When you use such products or services, they may collect your information too. For this reason, we strongly suggest you to read the third party’s privacy policy as you have taken time to read ours. We are not responsible for and cannot control how third parties use personal data which they collect from you. Our Privacy Policy does not apply to other sites linked from our services.\n​\nMinors\nWe consider it the responsibility of parents to monitor their children’s use of our products and services. Nevertheless, it is our policy not to require personal data from minors or offer to send any promotional materials to persons in that category. Gizwits does not seek or intend to seek to receive any personal data from minors. Should a parent or guardian have reasons to believe that a minor has provided Gizwits with personal data without their prior consent, please contact us to ensure that the personal data is removed and unsubscribe them from any of the applicable Gizwits services.\nOur Services are not directed to individuals under 13. We do not knowingly collect personal information from children under 13. If we become aware that a child under 13 has provided us with personal information, we will take steps to delete such information. If you become aware that a child has provided us with personal information, please contact us at Gizwits_echo@Gizwits.com.\n​\nUpdates To The Privacy Policy\nWe keep our Privacy Policy under regular review. If we change our Privacy Policy, we will post the changes on Gizwits websites, so that you may be aware of the information we collect and how we use it. Such changes to our Privacy Policy shall apply fro m the time that we post the same on the Gizwits websites. Your continued use of products and services on the websites, mobile phones and/or any other device will be taken as acceptance of the updated Privacy Policy. We will seek your fresh consent before we collect more personal data from you or when we wish to use or disclose your personal data for new purposes.\nprivacy policy/terms of use\n"},{"title":"Guide of APICloud open source framework","url":"/en-us/AppDev/APICloudFrame.html","content":"The APICloud open source framework (hereinafter referred to as APICloud Framework) is an App template developed with Gizwits SDK to implement basic functions such as SDK loading, initialization, user registration, login, device configuration, device discovery, and device connection. You can get a complete App after building the specific product control UI based on one of the Gizwits App open source frameworks which currently are available for iOS, Android and APICloud. The main advantage of the APICloud Framework is that it supports both iOS and Android with the same set of code. \nThe main purpose of this document is to show you how to use the APICloud Framework to rapidly develop a complete App. Of course, you can also start to build your own App from scratch by referring to the APICloud Framework source code.\nThe APICloud Framework code base: \nhttps://github.com/gizwits/GizOpenSourceAppKit_APICloud\nThe APICloud Gokit App is an example project that uses the APICloud Framework. Its source code can be find here:\nhttps://github.com/gizwits/gokit_demo_in_apicloud\nThe APICloud Framework code directory structure\nThe development based on APICloud is similar to web front-end development, and is also achieved using CSS/HTML/JavaScript which make up the APICloud Framework code directory structure as shown below: \n\nThe concrete function of each file is described as follows:\n\nQuick integration guide\nEach application in APICloud has a unique id as its identifier. The id does not exists in the APICloud Framework. Thus you need to create an APICloud project and get the project id to run the APICloud Framework.\nCreate a blank project\nRight-click on the blank part in the \"My App Projects\" column and click on “New->APICloud Project”; or click the navigation button on the menu bar and click \"New App Project\" to go to the project creation page.\n\nSelect \"Blank App\" and click \"Finish\". At this time, APICloud generates a blank project.\n\nGo to APICloud's development console: http://www.apicloud.com/console\nYou can see the App project created successfully.\n\nAPICloud Framework migration\nThe blank App project directory generated above is as follows. Remove the directories and files in the red box.\n\nThe following figure is the source code of the APICloud Framework. Copy the directories and files in the red box to the blank App project shown in the above figure. So the newly created blank App project source code is the same as the APICloud Framework except config.xml.\n\nUpate the config.xml file\nconfig.xml is the configuration file provided by APICloud. There exists a config.xml in each project, which provides id (the unique identifier of the project) on APICloud platform, the developer's personal account information, UI configuration and third-party modules used by the project. For more details, please visit: \nhttp://docs.apicloud.com/Dev-Guide/app-config-manual\nThe following figure shows the config.xml content of the APICloud Framework. Update the content in the red box with the corresponding values generated for the new project.\n\nIf QQ authentication is to be used in your project, you need to go to Tencent Developer Center to apply for the application and get the apiKey value. The value of param urlScheme is set to the string of tencent+apiKey; the value of param apikey is set to the apikey value from Tencent Developer Center.\nSubmit the project changes to APICloud platform as follows:\n\nImport GizWifiSDK\nAfter submitting the APICloud Framework migration and config.xml changes to the cloud, APICloud will automatically import the corresponding modules to be used based on the source code. However, GizWifiSDK needs to be imported manually.\n\nSearch for GizWifiSDK and import it.\n\nSet parameters for the product and application in the source code\nYou need to set the appid and appsecret for the Android App and iOS App in the source code, and set the ProductKey of the product created in Gizwits Developer Center at this time.\nGet the product ProductKey and ProductSecret in Gizwits Developer Center.\n\nGet AppID and AppSecret for Android App and iOS App.\n\nOpen index.html of the APICloud Framework:\n\nChanage the code in the red box above to the code in the red box below:\n\nyour_ios_appid: AppID of the iOS App created in Gizwits Developer Center\nyour_android_appid: AppID of the Android App created in Gizwits Developer Center\nyour_ios_appsecret: AppSecret of the iOS App created in Gizwits Developer Center\nyour_android_appid: AppSecret of the Android App created in Gizwits Developer Center\nyour_productKey: ProductKey of the product created in Gizwits Developer Center\nBesides, in deviceList.html file, set with the ProductKey of the product to which the devices retrieved by the App belong.\n\nChange the code in the red box above to the code in the red box below:\n\nDeploy App\nAfter completing all the steps above, run the App.\n\n\nDevice debugging instructions of APICloud\nThere are many methods for device debugging of APICloud, including cloud compilation, device debugging via USB, device debugging via Wi-Fi, etc. The most convenient and efficient one is device debugging via Wi-Fi. The following uses the APICIoud Studio tool as an example to illustrate how to use device synchronization via Wi-Fi. \nCompile Custom Loader\nAll third-party modules of APICloud are stored in the cloud. If the compilation and debugging methods are the same as the native App, it will take a long time and more resources to recompile the code every time you perform device debugging. Therefore, APICloud has introduced a compilation and debugging tool, which is called Custom Loader.\nEach App project has a Custom Loader, that is, when the third-party modules required by the App are configured in the cloud, and the local code has been updated, the Custom Loader can be compiled based on selected modules and settings to achieve device debugging.\nThe advantage of Custom Loader for device debugging is: if the code is modified when debugging, you don't need to recompile the Custom Loader but to perform device synchronization via Wi-Fi. During the device synchronization, APICloud will synchronize the changes into Custom Loader.\nTo compile Custom Loader, select the project you want to debug and right click as shown below:\n\nIf the compilation is successful, the following page will pop up, and Custom Loader can be installed by scanning the QR code.\n\nInstall Custom Loader\nAfter scanning the QR code and the installation result of Custom Loader is shown as follows:\n\n\nClick the white circle in the red box above to go to the following page, and fill in fields on this page for device synchronization via Wi-Fi.\n\nNote: Custom Loader can also be obtained in the following way:\n\nGet parameter values for device synchronization\nView synchronization parameters in APICloud Studio.\n\nSelect \"View the server address for device synchronization via Wi-Fi” under “Help”.\n\nSet the parameters in the installed Custom Loader to the above values, click \"Connect\". If the connection is successful, the circle on the page turns green.\n\n\nTest device synchronization via Wi-Fi\nAfter completing the Custom Loader configuration, you can test the device synchronization via Wi-Fi. \nSelect \"Device synchronization via Wi-Fi\" in APICloud Studio.\n\nThe App goes to the following page. After this step is completed, the App is successfully synchronized, then you can go on to the next round of the App test.\n\n\n"},{"title":"Guide of Android App third-party authentication and re-skin","url":"/en-us/AppDev/AndroidAuthReSkin.html","content":"See Guide of iOS third party authentication and re-skin\nSee Application process for third-party authentication platform\nOverview\nThis article mainly describes how to quickly implement QQ and WeChat authentication through the open source framework as well as re-skin for the App.\nQQ authentication\nTo support QQ authentication, you should first create an application on the Tencent open platform, obtain the APPID for the App, which will be used in the open source framework. \nGet APP ID and bind the application\nFor obtaining APP ID and binding Gizwits application, see Application Request Tutorial for QQ Open Platform.\nUpdate UIConfig.json\nType the APPID obtained from Tencent development platform into the configuration file UIConfig.json of the open source framework.\n\nAfter filling in the \"tencent_app_id\" and deploying it, you can log in using QQ authentication.\nWechat authentication\nTo implement WeChat authentication, you need to go to the WeChat open platform to apply for an application, obtain the APPID and APPSecret of the application which will be applied to the open source framework.\nGet APPID and APPSecret\nTo get APPID and APPSecret, see Application Request Tutorial for WeChat Open Platform.\nUpdate UIConfig.json\nType the APPID and APPSecret obtained from WeChat development platform into the open source framework configuration file UIConfig.json, as shown below.\n\nAfter filling in the \"wechat_app_id\" and \"wechat_app_secret\" and deploying it, you can log in using WeChat authentication.\nApp Re-Skin\nThe open source framework has the re-skin feature. Quick re-skin can be achieved by modifying the UIConfig.json file.\n\nAs shown in the red box, the code snippet for your custom skin has the following parameters:\nbuttonColor: button color\nbuttonTextColor: button text color\nnavigationBarColor: navigation bar color\nnavigationBarTextColor: navigation bar text color\nconfigProgressViewColor: configuration progress view color\nQuick res-skin can be achieved by modifying the corresponding color values. Refer to the following example:\nSample 1\n\"buttonColor\":\"6ebe37\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\"6ebe37\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\nThe result:\n\nSample 2\n\"buttonColor\":\"ff8a44\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\"ff8a44\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\nThe result:\n\nSample 3\n\"buttonColor\":\" 16b599\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\" 16b599\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\nThe result:\n\nSee Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of iOS SDK 2.0 integration\nGuide of Android SDK 2.0 integration\nGuide of APICloud SDK\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process for third-party authentication platform \n\n"},{"title":"Guide of Android App push notification integration","url":"/en-us/AppDev/AndroidPushNotification.html","content":"Overview\nThe Gizwits App open source framework (hereinafter referred as Framework) integrates Baidu push notification and Jiguang push notification, which help rapid development with few modifciation. This document describes how to integreate push notification based on the Framework. For more information on the Framework, please refer to the Quick Start documentation.\nQuick integration with Jiguang push notification\n1. Apply for Jiguang AppKey and Master Secret\nYou need to create an application on Jiguang official website and fill in the appropriate information based on the package name of the Framework, as shown below:\n1). Find the package name of the Framework\n\n2). Create an application on Jiguang platform\n\n3). Find the corresponding AppKey and Master Secret\n\n2. Bind third-party push notification in the Gizwits cloud\n2.1 Applying for D3 Engine service\n\nFind D3 Engine\n\n\n\nRequest to access D3 Engine\n\n\nThe use of D3 Engine service requires the approval of Gizwits. After request to access the service, you need to contact the Gizwits FAE for assistant.\n2.2 Binding Jiguang push notification in Gizwits cloud\nAfter approval, you can see the D3 Engine under the Services column, click \"Configuration\" -> \"Edit Push Notification Platform\"\n\nType the App Key and Master Secret you applied to Jiguang as the following figure and choose \"Bind\".\n\nThe following figure shows the successful binding of Jiguang push notification.\n\n2.3 Create a push notification rule using D3 Engine\n\nChoose Project List -> New Project. The following shows how to create a rule that will push a notification message to the App after your device comes online.\n\nDrag the \"Device Data\" box to the right and double click it.\n\nSet the trigger mode to \"Device comes online\" and click OK.\n\nDouble-click \"Push for App\" and set the notification content.\n\nClick \"Save\" to save the push notification rule.\n\n\nThe following figure shows that the push notification rule has been successfully saved.\n\n3. Update UIConfig.json\n\nFill in the Gizwits app_id and product_key and modify the push_type.\n\n\n\n4. Update AndroidManifest.xml\nUpdate the APP KEY in AndroidManifest.xml.\n\n5. Start the virtual device\n\n6. Run the APP\nThrough the above steps, the App is equipped with Jiguang push notification function. After being deployed to a mobile phone, register a user and login in, then bind the cloud virtual device by scanning its QR code.\n\n7. Test push notification\nRestart the virtual device to see whether your phone receives a push message.\n\nQuick integration with Baidu push notification\n1. Apply for Baidu API KEY\nYou need to create an application on Jiguang official website and fill in the appropriate information based on the package name of the Framework, as shown below:\n\n\nFind the corresponding API KEY and SECRET KEY.\n\n2. Bind third-party authentication in Gizwits cloud\n2.1 Apply for D3 Engine\nFor this step, refer to section 2.1 of Quick integration with Jiguang push notification.\n2.2 Bind Baidu push notification in Gizwits cloud\n\nType the API Key and Secret Key you applied to Baidu as the following figure and choose \"Bind\".\n\nThe following figure shows the successful binding of Baidu push notification.\n\n2.3 Create a push notification rule using D3 Engine\nFor this step, refer to section 2.3 of Quick integration with Jiguang push notification.\n3. Update UIConfig.json\nFill in app_id, app_secret, product_key, and set push_type to 2. Update the application API key of Baidu push notification you obtained in step 1.\n\n4. Start the virtual device\nThis step can refer to section 5 of Quick integration with Jiguang push notification.\n5. Run the App\nThrough the above steps, the App is equipped with Baidu push notification function. After being deployed to a mobile phone, register a user and login in, then bind the cloud virtual device by scanning its QR code. \n\n6. Test push notification\nRestart the virtual device to see whether your phone receives a push message.\n\nFAQ\n1. Need I request to access D3 Engine to use push notification?\nAnswer: Yes, D3 Engine currently only targets at enterprise developers. Therefore, only enterprise developers can request to access it.\n2. I completed the above steps using Jiguang push notification, but cannot receive the expected push notification.\nAnswer:\nFollow the steps below to troubleshoot the issue:\ni. Confirm whether the App package name has been modified. The default package name is \"com.gizwits.opensource.appkit\". If the package name has been modified, you need to update AndroidManifest.xml. Please refer to Jiguang document:\nhttp://docs.jiguang.cn/jpush/client/Android/android_guide/\nThen it is necessary to test whether it is successful to push messages to the App using Jiguang platform alone. Receiving Gizwits push messages hinges on the successful push from Jiguang platform. \nii. For the case that the App still can't receive the message when the push from Jiguang platform is successful. \nFirst, confirm that Gizwits platform successfully binds Jiguang push notification with its App Key and Master Secret.\n\nSecond, confirm that Gizwits platform successfully creates the rule.\n\nThird, if you still can't receive the message following the two steps above, check the following code:\n\nCheck whether the Result value arg0 in the callback of JPushInterface.setAlias ​​method is 0. If it is not 0, it means that the Jiguang alias is incorrect. You need to call this method to set the alias.\n\nCheck whether the Result value in the didChannelIDBind callback interface is GIZ_SDK_SUCCESS, and debug your code.\n"},{"title":"FAQ of Application Development","url":"/en-us/AppDev/AppDevFAQ.html","content":"1. Overview\nThis article lists some issues and related solutions that developers might encounter when using App, open source frameworks, App code auto-generator, or SDKs of Gizwits.\n2. FAQ\nQ: How to fix the issue of network access configuration failure when the device fails to access the Internet, and the App displays the configuration timeout?\nA: The network access configuration involves the App and the device. The following lists the cases that may cause the problem to occur.\n\nUse Gizwits App to configure (Download here: https://download.gizwits.com/zh-cn/p/98/99).\nCheck whether your mobile phone is located in the same network to be configured. Confirm whether the SSID and password of the router are entered correctly. Check that the module type selected during the configuration is correct.\nThe router to be configured must not use 5G band. There should be no link or login restriction and disable AP isolation. Try to replace the Wi-Fi router, or use a mobile phone hotspot as a router. It is not recommended to use public routers or those with port restrictions. \nCheck whether the device enters the configuration mode through the output log of the module debug interface. (Click here to see how to capture log: http://docs.gizwits.com/en-us /deviceDev/%E9%80%9A%E8%AE%AF%E6%A8%A1%E7%BB%84%E8%B0%83%E8%BF%95%E6%97%A5%E5%BF% 97%E6%8A%93%E5%8F%96%E6%95%99%E7%A8%8B.html\n\nQ: My device is configured successfully by the App, but on which the device is not displayed.\nA: Try to use the App that is compiled from the source code generated by the App code auto-generator with the open source framework. And confirm whether the product key in assets/UIConfig.json of the App project directory matches your own device.\nQ: It shows \"unknown error\" when registering a user account using the App that is compiled from the source code generated by the App code auto-generator with the open source framework.\nA: That's because a weak password are used for registration. Registration requires a strong password. The password should contain three of the the four character types: uppercase letters, lowercase letters, numbers, and special symbols. \nQ: Why can't a user account registered in the Gizwits App be logged in the App that is compiled from the source code generated by the App code auto-generator with the open source framework?\nA: That's because the former App and the latter App do not share the same appid. Their user systems are also different. If you need to register the user on the latter App again.\nQ: What is the \"Unknown device\\Do not support this device\\Failed to download the configuration file\" message displayed by Gizwits App? How to fix them?\nA: After IOE Demo loads the device list, it automatically downloads the device configuration file, which is parsed by the SDK in the form of JSON and binary data so as to control devices and get device status correctly. If the IOE Demo fails to download the configuration file of the corresponding device because of connection issues, or Gizwits cloud is not able to find the configuration file of the device, the above messages appears.\nQ: How to modify the open source App code to control my device?\nA: There are three key steps. It is recommended to adopt the App automatically generated so as to omit the first two steps:\n\nUpdate ProductKey and AppID in the source code to match your own devices.\nUpdate the data point names in the source code to match your own devices.\nModify the App UI according to your own device functions.\n\nQ: How to download the Demo App? Does it have common features?\nA: The Demo App can be downloaded from Gizwits Download Center or through searching for \"Gizwits\" in an app store. Because the Demo App has adaptive layout and communication protocols, all products on the Gizwits platform use the same Demo App and do not need to be downloaded separately.\nQ: Which type of WeChat Official Account is required for WebChat development, personal WeChat Official Account or enterprise WeChat Official Account?\nA: WeChat Official Account is divided into Service Account, Subscription Account, and WeChat at Work. The device function is currently a plug-in of WeChat Service Account. Before enabling device function, you should apply for WeChat Service Account. Unverified WeChat Service Account can also support device function, but there is a limit on the number of connected devices. Therefore, after enabling the device function of the unverified WeChat Service Account, you need to request the verification of your WeChat Service Account as soon as possible to increase the connected devices limit. Since WeChat Service Account is not currently available to individuals, individual developers can use a test user account to complete development and debugging. For details, please refer to WeChat official documents.\nQ: How does App determine whether the current device is located at the same LAN or not?\nA: The App SDK makes determination as following process: The App SDK send a broadcast packet to the LAN at which it is located every 1 second. If the device module receives this broadcast packet, it will reply with passcode to the App SDK. At this time, the App SDK can use the passcode to access the device. If the App SDK does not receive a reply, it will determine that the device in the device list is not located at the same LAN and will query the device status through WAN.\n"},{"title":"Video tutorial of the App open source framework","url":"/en-us/AppDev/VideoTutorial.html","content":"Overview\nThe App open source framework ((hereinafter referred to as Framework)) is a product of Gizwits, which contains a set of source code for the App common functions of Wi-Fi smart hardwares. As long as the Gizwits protocols are used for the product, you can directly leverage the source code of the Framework to rapidly develop its supporting App, which thereby meets the requirements of short App building cycle and low cost.\nThis tutorial will introduce you how to use the Framework to develop your own App. This tutorial is divided into the following chapters from easy to difficult, from basic functions to advanced functions:\n\nHow to create a Giziwits product\nHow to implement device control functions using core modules\nHow to customize an App based on the Framework\nHow to log in using WeChat\nHow to log in with QQ\nHow to use Baidu push notification\nHow to use Jiguang push notification\n\nThose functions of WeChat/QQ authentication and Baidu/Jiguang push notification are advanced features, which are not enabled by default in the Framework code. If you only want a simple device control App, just go through the first three chapters. To use advanced features, you can continue to follow the latter chapters.\nThe Framework tutorial 1-1\nTitle\nProduct and application creation in the Developer Center\nIntroduction\nBefore we develop an App, we need to learn how to create a new product in Gizwits Developer Center. First select the product category and schema, then add data points to the product, and finally create an application for the product. To help you better understand the entire creation process, there comes along usages of the Framework, data points, data point templates, Product Key, Product Secret, App ID and App Secret etc.\nVideo link\nhttps://v.qq.com/x/page/p0344jspddv.html\nThe Framework tutorial 1-2\nTitle\nBuild a simple iOS App using the Framework rapidly\nIntroduction\nTo extend the Framework tutorial 1-1, this tutorial is based on the Framework to build an iOS App that controls the Gokit red light switch. After downloading the code, create a click event in the layout file of the control page, then update the pruductkey in the Gokit MCU firmware, and finally show Gokit light control using the App. To help you better understand the entire process, there comes along the usages of the Framework modules, code features, instruction addition, iOS App and device configuration etc.\nVideo link\nhttps://v.qq.com/x/page/b0350blmgcf.html\nThe Framework tutorial 1-3\nTitle\nBuild a simple Android App using the Framework rapidly\nIntroduction\nTo extend the Framework tutorial 1-1, this tutorial is based on the Framework to build an Android App that controls the Gokit red light switch. After downloading the code, create a click event in the layout file of the device control page, then update the pruductkey in the Gokit MCU firmware, and finally show Gokit light control using the App. To help you better understand the entire process, there comes along the usages of the Framework modules, code features, instruction addition, Android App and device configuration etc.\nVideo link\nhttps://v.qq.com/x/page/p03512if92n.html\nPlease review the tutorial again quickly. If you like us or have any suggestion for us, you can say your ideas out loud in Gizwits forum. We will provide better and more complete teaching videos. \nStay tuned for more videos!\n"},{"title":"Guide of App open source framework for Android (including source code)","url":"/en-us/AppDev/androidframe.html","content":"Overview\nThe App open source framework (hereinafter referred to as Framework) of Gizwits is a App template developed by Gizwits SDK to achieve the SDK loading, initialization, user registration, user login, device configuration, device discovery, device connection, device listing and other basic functions. The Framework is a source code project which is available to all developers and currently supports iOS and Android platforms. App developers can create a complete App by implementing specific product control pages based on the Framework.\nThis document is the guide of the Gizwits IoT App Suite. It is intended to provide a rapid development template for developers of Gizwits IoT, which can also be used for reference.\nFor source code of the Framework for Android, find here:\nEclipse version:https://git.oschina.net/dantang/GizOpenSource_AppKit_Android\nAndroid Studio version：https://github.com/gizwits/GOpenSource_AppKit_Android_AS\nAndroid Gokit App is an example project that uses the Framework. Its source code can be find here:\nhttps://git.oschina.net/dantang/GoKit_Demo_Android\nIt can also be downloaded at the Download Center:\n\nThe Framework code directory structure\nA. Library: Third-party library directory including GizWifiSDK\nassets: contains UIConfig.json\nB. GizOpenSourceModules: contains\n\nGosApplication.java // SDK starts here\nCommonModule // Common helper classes, resource file reader classes\nConfigModule // Device configuration module, including AirLink and SoftAP\nUserModule // User module, including user login, user registration, password recovery\nDeviceModule // Device module, including device listing\nControlModule // Device control module with control examples\nSettingsModule // Settings module, containing settings of menu and submenus (About etc.)\nPushModule // Push notification module, encapsulating Baidu push SDK and Jiguang push SDK \nThirdAccountModule // Third-party authentication module(QQ, WeChat, etc.)\nview // Custom controls\nutils // Tools\nwxapi // For WeChat integration\nzxing // For scanning QR code\n\nQuick integration guide\nThe default program entry is GosUserLoginActivity in UserModule. \n1. Set initialization parameters\nGizwits AppID and AppSecret can be filled in GosApplication.java file of the project.\nIf you use a third-party authentication or push notification, you need to fill in the appropriate parameters from the related platforms. If you use the push notification, you need to uncomment the related macro line in order to enable the corresponding type of push notification. If you don’t uncomment all the related macro lines, it means you are not using any third-party push notification at the time. Only one type of third-party push is supported at the same time, hence don’t uncomment multiple third-party push notification macro lines.\nConfigurable parameters are:\n\napp_id: Gizwits app id\napp_secret: Gizwits app secret\nproduct_key: Gizwits product key \nwifi_type_select: whether the Wi-Fi module selection function is enabled\ntencent_app_id: app id for qq authentication\nwechat_app_id: app id for WeChat authentication\nwechat_app_secret: app secret for WeChat authentication\npush_type: Push notifciation type [0: Off, 1: Jiguang, 2: Baidu]\nbpush_app_key: app key for Baidu push notification\nopenAPI_URL: openAPI domain name and port, format: \"api.gizwits.com\". Defaults to 80 if unspecified.\nsite_URL:site domain name and port, format: \"site.gizwits.com\". Defaults to 80 if unspecified.\npush_URL: push notification service domain name and port, format: \"push.gizwits.com\". Defaults to 80 if unspecified.\nbuttonColor: Button color\nbuttonTextColor: Button text color\nnavigationBarColor: Navigation bar color\nnavigationBarTextColor: Navigation bar text color\nconfigProgressViewColor: Configuration progress view color\naddDeviceTitle: Title of “Add Device” page\nqq: whether to enable QQ auhentication [true: enabled]\nwechat: whether to enable WeChat auhentication [true: enabled] \nanonymousLogin: whether to enable anonymous login [true: enabled] \n\nAttention:\n\nThe appid of Jiguang push notification needs to be filled in line 243 of AndroidManifest.xml.\nFor WeChat authentication, you needs to set your own md5 value in Tencent api or it will not work normally.\nThe tencent_app_id needs to be filled in line 89 of AndroidManifest.xml\n\n2. Loading the control page\n1) The code provided in the Framework project implements the redirection to the control page without any modification. You only need to focus on the logic of the operation pages. If you want to click a device in the device list page and jump to the view you created, modify the corresponding redirection parameters in the GosDeviceListActivity.java file. Please modify the class definition of the target view as shown in the figure. If you use the blank page (GosDeviceControlActivity) provided by default to create the control page, you can skip this step.\n\n2) Register the device listener in the control page, and implement its callback, as shown in Figure:\n\nIt is used to receive the device state change notification reported by the SDK, which will be parsed in order to update the page.\n3) Set the listener for the current device in the control page, for example: \n    device.setListener(gizWifiDeviceListener);\n4) To implement the instruction issuing, you need to call the interface method of the GizWifiDevice instance in the SDK:\n    device.write(concurrentHashMap ,0); \nFor detailed parameter explanation, see the SDK guide.\n5) When exiting the control page, you need to unsubscribe from the current device, and call the interface method of the GizWifiDevice instance in the SDK with the parameter set to False:\n    device.setSubscribe(false);\n3. Add menu items on the settings page\nFor the addition or modification of an list item in the settings page, you need to add the corresponding control in activity_gos_settings.xml and add the corresponding event in the GosSettingsActivity.java file in the module (SettingsModule).\nFAQ\nA. Which Android versions does the Framework support?\nCurrently it supports Android 4.0 and higher.\nB. How to update the version number\nModify the versionName in the AndroidManifest.xml file of the project so as to change the version number display in the SettingsModule module. \n\nC. How to configure the push notification(the following uses Jiguang push notification as example)\nMake sure the package name in the AndroidManifest.xml file matches the application package name you filled in when you applied for the push notification service, which is shown as below. \n\n\nBesides, modify the corresponding settings for the push notification in the project's AndroidManifest.xml file.\n1)\n<permission android:name=”your App package name.permission.JPUSH_MESSAGE” android:protectionLevel=”signature” />\n(See line 13 of the AndroidManifest.xml file in the Framework)\n2)\n<uses-permission android:name=”your App package name.permission.JPUSH_MESSAGE” />\n(See line 17 of the AndroidManifest.xml file in the Framework)\n3)\nUnder DaemonService\n<category android:name=\"your App package name\" />\n(See line 159 of the AndroidManifest.xml file in the Framework)\n4)\nUnder PushPeceiver  \n<category android:name=”your App package name” />\n(See line 170 of the AndroidManifest.xml file in the Framework)\n5)\nUnder PushActivity\n<category android:name=\"your App package name\" />\n(See line 193 of the AndroidManifest.xml file in the Framework)\n6)\nUnder JPushReceiver\n<templategory android:name=\"your App package name\" />\n(See line 224 of the AndroidManifest.xml file in the Framework)\n7)\n<meta-data android:name=”JPUSH_APPKEY” android:value=”Your AppKey” />\n(See line 240 of the AndroidManifest.xml file in the Framework)\nSee Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of Gizwits Device SDK 2.0 for iOS\nGuide of Gizwits Device SDK 2.0 for Android\nGuide of Gizwits Device SDK for APICloud\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process for third-party authentication platform \n\n"},{"title":"Guide of iOS App third-party authentication and re-skin","url":"/en-us/AppDev/iOSAuthReSkin.html","content":"See Guide of Android third party authentication and re-skin\nSee Application process of third-party authentication platform\nOverview\nThis article mainly describes how to quickly implement QQ and WeChat authentication through open source framework as well as re-skin for the App.\nQQ authentication\nTo support QQ authentication, you should first create an application on the Tencent open platform, obtain the APPID for the App, which will be used in the open source framework. \nGet APP ID and bind the application\nFor obtaining APP ID and binding Gizwits application, see Application Request Tutorial for QQ Open Platform.\nConfiguration of the open source framework\nConfigure Tencent APPID\nType the APPID obtained from Tencent development platform into the configuration file UIConfig.json of the open source framework.\n\nConfigure URL Schemes\nThe user is supposed to navigate to the QQ authentication page for login. After successful login, it will be redirected to you own App. At this time, you need to give the QQ SDK a redirect URL, which is set through the URL Schemes.\nSelect Targets -> Info, click URL Types to see the following page:\n\nThere are two parts that should be modified in the red box: URL Schemes and Identifier.\nThe format of URL Schemes value is: tencent + Tencent's APP ID.\nIdentifier value generally adopts the reversed domain name to ensure its uniqueness. It can also be set to the Bundle Identify of the program.\nWechat authentication\nTo implement WeChat authentication, you need to go to the WeChat open platform to apply for an application, obtain the APPID and APPSecret of the application which will be applied to the open source framework.\nGet APPID and APPSecret\nTo get APPID and APPSecret, see Application Request Tutorial for WeChat Open Platform.\nConfiguration of the open source framework\nConfigure WeChat APPID\nType the APPID and APPSecret obtained from WeChat development platform into the open source framework configuration file UIConfig.json, as shown below\n\nConfigure URL Schemes\nThe user is supposed to navigate to the WeChat authentication page for login. After successful login, it will be redirected to you own App. At this time, you need to give the WeChat SDK a redirect URL, which is set through the URL Schemes.\nSelect Targets -> Info, click URL Types to see the following page:\n\nThere are two parts that should be modified in the red box: URL Schemes and Identifier.\nThe format of URL Schemes value is: WeChat APP ID.\nIdentifier value generally adopts the reversed domain name to ensure its uniqueness. It can also be set to the Bundle Identify of the program.\nApp Re-Skin\nThe open source framework has the re-skin feature. Quick re-skin can be achieved by modifying the UIConfig.json file.\n\nAs shown in the red box, the code snippet for your custom skin has the following parameters:\nbuttonColor: button color\nbuttonTextColor: button text color\nnavigationBarColor: navigation bar color\nnavigationBarTextColor: navigation bar text color\nconfigProgressViewColor: configuration progress view color\nstatusBarStyle: status bar color\nQuick res-skin can be achieved by modifying the corresponding color values. Refer to the following example:\nSample 1\n\"buttonColor\":\"6ebe37\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\"6ebe37\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\n\" statusBarStyle \":1\nThe result:\n\nSample 2\n\"buttonColor\":\"ff8a44\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\"ff8a44\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\n\" statusBarStyle \":1\nThe result:\n\nSample 3\n\"buttonColor\":\" 16b599\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\" 16b599\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\n\" statusBarStyle \":0\nThe result:\n\nSee Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of iOS SDK 2.0 integration\nGuide of Android SDK 2.0 integration\nGuide of APICloud SDK\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process of third-party authentication platform \n\n"},{"title":"Guide of iOS App push notification integration","url":"/en-us/AppDev/iOSPushNotification.html","content":"Overview\nThe Gizwits App open source framework (hereinafter referred as Framework) integrates Baidu push notification and Jiguang push notification, which help rapid development with few modifciation. This document describes how to integreate push notification based on the Framework. For more information on the Framework, please refer to the Quick Start documentation.\nQuick integration with Jiguang push notification\n1. Apply for Jiguang AppKey and Master Secret\n1.1 Creating a Jiguang Application\nClick https://www.jiguang.cn/app/form to create a Jiguang application.\n\nAs shown in the figure, you need to upload the Apple Developer Certificate, including the development certificate and the production certificate and their passwords.\n1.2 Apply for iOS development certificate\nLog in to the Apple Developer Center: https://developer.apple.com, apply and download the cer certificate, double-click the certificate to open it from the Keychain, select the certificate, choose \"login\" and \"My Certificates\", right-click the certificate, export p12 certificate.\n\nClick \"Export\" will pop up the following dialog box, set the certificate name and save path.\n\nClick “Save”. When prompted for a password, set the certificate password.\n\n1.3 Import Certificate to Jiguang\nAfter successfully importing the certificate as shown below, it will show \"verified\".\n\nAt this point, the Jiguang application has been created and the AppKey and Master Secret generated by the application can be used normally.\n\n2. Bind third-party push notification in the Gizwits cloud\n2.1 Applying for D3 Engine service\n\n\nThe use of D3 Engine service requires the approval of Gizwits. After request to access the service, you need to contact the Gizwits FAE for assistant.\n2.2 Binding Jiguang push notification in Gizwits cloud\nAfter approval, you can see the D3 Engine under the Services column, click \"Configuration\" -> \"Edit Push Notification Platform\"\n\nType the App Key and Master Secret you applied to Jiguang as the following figure and select the certificate type.\nNote: When selecting \"Development\" for the certificate type, only in the development environment your App is able to receive notifications.\n\n\n2.3 Create a push notification rule using D3 Engine\n\nChoose Project List -> New Project. The following shows how to create a rule that will push a notification message to the App after your device comes online.\n\nDrag the \"Device Data\" box to the right and double click it.\n\nSet the trigger mode to \"Device comes online\" and click OK.\n\nDouble-click \"Push for App\" and set the notification content.\n\n\n\n\n3. Modify the code of UIConfig.json\nFill in jpush_app_key, and set push_type to 1, indicating that Jiguang push notification is selected. Then fill in the values of app_id, app_secret, and product_key of the Gizwits application that is bound to Jiguang push notification.\n\n4. Configure push notification in XCode\nOpen the project, select Targets -> Capabilities, and turn on the Push Notifications button, which enables the project remote push functionality.\n\nAfter the button is turned on, an .entitlements file is automatically generated, as shown below, where the value in the red box indicates the push environment. Development indicates the development environment, and distribution indicates the production environment. When the value is set to development, push notification only takes effect in the development environment. When it is distribution, push notification takes effect only in the production environment.\n\n5. Start the virtual device\n\n6. Run the APP\nThrough the above steps, the App is equipped with Jiguang push notification function. After being deployed to a mobile phone, register a user and login in, then bind the cloud virtual device by scanning its QR code.\n\n7. Test push notification\nRestart the virtual device to see whether your phone receives a push message.\n\n8. Customize the push notification sound of Jiguang\nThe D3 Engine supports setting the push notification sound for each rule. Generally it needs to update two places.\n8.1 Configure push notification sound\nOpen a push notification rule as follows:\n\nSelect the push for App box (which is in red box above):\n\nClick \"Show JSON sample\":\n\nThe sample detail is as follows:\n{\n  \"baidu\": {\n    \"aps\": {\n      \"badge\": 0,\n      \"sound\": \"default\"\n    },\n    \"notification_builder_id\": 0,\n    \"notification_basic_style\": 0\n  },\n  \"jiguang\": {\n    \"ios\": {\n      \"sound\": \"sound.caf\",\n      \"badge\": 1\n    },\n    \"android\": {\n      \"builder_id\": 0,\n      \"alert_type\": 1,\n      \"style\": 1\n    }\n  }\n}\nHere we use Jiguang push notification. If the sound name is pushMusic.caf, the Advanced Parameter field need to be filled in as follows:\n{\n  \"jiguang\": {\n    \"ios\": {\n      \"sound\": \"pushMusic.caf\",\n      \"badge\": 1\n    }\n  }\n}\nSee below:\n\nClick \"OK\" to save and complete the settings.\nNote: The \"badge\" parameter is for the content of App Badge. When it is set to 1, the App that receives push notifications displays 1. But in general, the App that receives multiple push notifications will automatically accumulate the Badge number. If \"badge\" parameter is set to 1, no matter how many notifications are pushed, the Badge number will always be 1.\nIf you want the App to accumulate the number of received messages, remove \"badge\": 1. That means if it is not set, it will do the cumulative operation by default.\n8.2 Import push notification sound file to project\nAfter D3 Engine successfully configures the custom push notification sound, whenever a notification message is sent to the App, the system will first go to the App to find out whether there is a sound file with the relevant name. If there is, then the sound is played. If not, then play the default system sound.\nThe audio format of the push notification sound includes aiff, wav, and caf, and the playback time must be within 30 seconds. The file must also be placed in the mainBundle directory of the App. If any one of the above conditions is not met, the system will play the default notification sound instead.\nImport an audio file to the project as follows:\n\nAt this point, the configuration of push notification sound is completed. The App will play the audio after receiving a notification message.\nQuick integration with Baidu push notification\n1. Apply for Baidu API KEY\n1.1 Create a Baidu application\nGo to Baidu cloud push notification platform: http://push.baidu.com, create an application and configure required certificates.\n\nAs shown above, you need to upload the development certificate and production certificate in the pem format.\n1.2 Apply for Apple Certification\nThe process of applying for the cer certificate and its exporting is described in section 1.2 of \"Quick integrated with Jiguang push notification\". The following figure shows how to export the pem certificate from the p12 certificate.\nOpen a Terminal and enter the following command to export the pem certificate.\nopenssl pkcs12 -in <p12 certificate name> -out <pem certificate name> -nodes\n\n1.3 Import certificate to Baidu Push notification\nUpload the pem certificate to the figure in \"1.1 Create a Baidu application\". After that, \"Verified\" will be displayed, and the API KEY and SECRET KEY of Baidu push notification will be generated.\n\n2. Bind third-party authentication in Gizwits cloud\n2.1 Apply for D3 Engine\nFor this step, refer to section 2.1 of Quick integration with Jiguang push notification.\n2.2 Bind Baidu push notification in Gizwits cloud\n\nType the App Key and Master Secret you applied to Baidu as the following figure and select the certificate type.\nNote: When selecting \"Development\" for the certificate type, only in the development environment your App is able to receive notifications.\n\n\n2.3 Create a push notification rule using D3 Engine\nFor this step, refer to section 2.3 of Quick integration with Jiguang push notification.\n3. Modify the code of UIConfig.json\nFill in bpush _app_key, and set push_type to 1, indicating that Baidu push notification is selected. Then fill in the values of app_id, app_secret, and product_key of the Gizwits application that is bound to Baidu push notification.\n\nNote: Configuration of XCode push notification is also required here. For details, see \"4 Configure push notification in XCode \" in \"Quick integration with Jiguang push notification\".\n4. Modify the App launch interface for Baidu push notification\nThe App launch interface for Baidu push notification has a pushMode parameter, there are two optional values BPushModeDevelopment and BPushModeProduction.\nBPushModeDevelopment: Set Baidu push notification in development environment\nWhen the environment set above matches the current running environment of the APP, the push notification will take effect. \n\n5. Start the virtual device\nThis step can refer to section 5 of Quick integration with Jiguang push notification.\n6. Run the APP\nThrough the above steps, the App is equipped with Baidu push notification function. After being deployed to a mobile phone, register a user and login in, then bind the cloud virtual device by scanning its QR code. \n\n7. Test push notification\nRestart the virtual device to see whether your phone receives a push message.\n\n8. Customize the push notification sound of Baidu\n8.1 Configure push notification sound\nGo to the page of push notification sound configuration as follows. How to navigate to this page, please refer to the section “8.1 Configure push notification sound” of “Quick integration with Jiguang push notification”.\n\nThe sample detail is as follows:\n{\n  \"baidu\": {\n    \"aps\": {\n      \"badge\": 0,\n      \"sound\": \"default\"\n    },\n    \"notification_builder_id\": 0,\n    \"notification_basic_style\": 0\n  },\n  \"jiguang\": {\n    \"ios\": {\n      \"sound\": \"sound.caf\",\n      \"badge\": 1\n    },\n    \"android\": {\n      \"builder_id\": 0,\n      \"alert_type\": 1,\n      \"style\": 1\n    }\n  }\n}\nHere we use Baidu push notification. If the sound name is pushMusic.caf, the Advanced Parameter field need to be filled in as follows:\n{\n  \"baidu\": {\n    \"aps\": {\n      \"badge\": 0,\n      \"sound\": \"pushMusic.caf\"\n    }\n  }\n}\nThe setting is completed as follows:\n\nClick \"OK\" to save and complete the settings.\n8.2 Import push notification sound file to project\nPlease refer to section “8.2 Import push notification sound file to project” of “Quick integration with Jiguang push notification”.\nFAQ\n1. Need I request to access D3 Engine to use push notification?\nAnswer: Yes, D3 Engine currently only targets at enterprise developers. Therefore, only enterprise developers can request to access it.\n2. I completed the above steps using Jiguang push notification, but cannot receive the expected push notification.\nAnswer:\nStep 1: Check whether the XCode push notification switch is enabled. For details, see 2.4 Configure push notification in XCode.\nStep 2: Check whether the key value of the project .entitlements file matches the current test environment. Distribution represents the production environment,Development represents the development environment.\nStep 3: Determine if the Bundle ID of the project is the same as the Bundle ID of the certificate.\nNote: If using Baidu push notification, you also need to check whether the pushMode value of the App launch interface is consistent with the current test environment. For details, see “4. Modify the App launch interface for Baidu push notification” in Quick integration with Baidu push notification.\nIf after the above three steps, it still cannot be pushed, you need to verify the problem on the push notification platform.\nStep 4: Log in to the Jiguang/Baidu push notification platform, and test whether the push notification from the platform can reach the App.\nFor the case of being unable to push from the platform:\n1) Check whether the certificate has expired. Consider replacing the certificate.\nFor the case of being able to push from the platform:\n1) Confirm whether the push environment set on Gizwits D3 Engine is consistent with the current test environment, as shown in the \"Certificate Type\" below.\n2) Confirm whether the push notification APPID and Secret bound to the Gizwits application match those used in the App, as shown below.\n\n3) If it still fails, insert a breakpoint in the following figure. Then print the result value, and determine the specific error code. Diagnose and fix the issue according to the error code hints.\n\nUsually result is wrong, it needs to confirm further from the code shown in the figure below.\n\n3. How to set the App Badge value for Jiguang push notification\nAnswer: [JPUSHService setBadge:0];\n"},{"title":"Guide of Gizwits Device SDK 2.0 for iOS App","url":"/en-us/AppDev/iOSSDKA2.html","content":"SDK_API Reference Manual\nAttachment: iOS_SDK2.0_API Reference Manual\nOverview\n1. Objectives\nThe Gizwits Device SDK (hereinafter referred to as the SDK) encapsulates the communication process between mobile phones (including PAD and other devices) and smart devices, and the communication process between mobile phones and Gizwits Cloud. These processes involve configuring network access, device discovery, connectivity, device control, heartbeat, status report, and alarm notification. Using the SDK, you only need to focus on the App UI/UE and are able to rapidly complete your App development, while ignoring the related issues such as complex protocols and error handling.\nThe SDK has been further simplified based on the definition of the new APIs, and its process is briefer. You have no need to understand the concept of device connectivity underneath at all.\n2. Gizwits IoT Architecture\n\n3. Choose the right SDK\nGizwits currently offers three types of SDKs: the native Device SDK for iOS, the native Device SDK for Android, and the cross-platform APICloud SDK. you can choose any one of those SDKs that best aligns with your desired scenario and customize as needed. The APICloud SDK can be developed once with HTML5 and adapt to both iOS and Android. For details, please refer to Guide of Gizwits Device SDK for APICloud.\n4. Term definitions\n4.1 GAgent\nThe full name is Gizwits Agent, which runs on Wi-Fi modules, and through which devices access the Gizwits server. Currently, it is compatible with mainstream Wi-Fi modules of China. Developers can also implement their own custom modules to access Gizwits using the GAgent secondary development package provided by Gizwits.\n4.2 Micro Cycle\nConnections between smart devices and mobile phones, smart devices and smart devices via the same router to achieve WLAN communication (status check or control), which is called a Micro Cycle.\n4.3 Macro Cycle\nSmart devices access the Internet via routers to accomplish remote monitoring and control by users, which is called a Macro Cycle.\n4.4 ProductKey\nProduct identification code, a 32 characters long string that is automatically generated by the developer after creating a new product in Gizwits cloud. It is a unique code in the database of Gizwits cloud. After the developer writes the ProductKey to the device master MCU, the Gizwits identifies the device through this code and automatically completes the registration.\n4.5 DID\nDevice code. When a device is connected to Gizwits for the first time, Gizwits automatically generates a DID for the device based on its ProductKey and Wi-Fi module MAC address. DID which is used to associate with users and perform subsequent operations, should be unique across the entire network.\n4.6 PassCode\nDevice Pass Code, used to verify the user's binding/control permission. When the user initiates a device binding, the device pass code can be obtained by users with legal means to bind the device and perform operations such as device status check and control during the valid period. GAgent generates a random number as a device pass when it is first run. It is generated and stored in non-volatile memory. When the device goes online, it needs to be reported to the server.\n4.7 AppID\nApplication identification code. When you need to develop an application (including iOS, Android, Web application, etc.) for a smart device, an AppID is automatically generated in Gizwits cloud and associated with the device. This AppID is required for application development.\n4.8 Onboarding\nNetwork access configuration, the process of connecting a Wi-Fi-based IoT device to a router is called Onboarding. When the new device is used for the first time, it needs to know the router's SSID and password to connect to the Internet via the router. Since most IoT devices do not have their own screens and keyboards, it is necessary to send the router's SSID and password to the device through a smart phone. The network access SDK for Wi-Fi devices provided by Gizwits has such built-in configuration function.\n4.9 AirLink\nCollectively, the features of UDP broadcast messages that allow you to configure the network access for devices, such as SmartConfig and SmartLink, are called AirLink. It provides the standard onboarding operation procedures with a good user experience, which is compatible with configuration protocols from multiple Wi-Fi module manufacturers. The network access SDK for Wi-Fi devices provided by Gizwits has built-in AirLink function. \n4.10 SoftAP\nBecause each Smart Config protocol from different Wi-Fi module manufacturers is not fully mature and neither does it support 5G router signal. Gizwits has provided AirLink configuration mode and also supports SoftAP mode to configure devices to access routers. When a device enters the SoftAP configuration mode, the device itself becomes an AP, and the smart phone can directly connect to the device. Then the SSID and password of the router are input on the mobile phone and sent to the device which will automatically switch to the normal mode and try to connect to the router.\n5. Integration preparation\n5.1 Register a Gizwits developer account\nBefore using Gizwits services, you need to sign up for a developer account on site.gizwits.com. Please refer to Quick Start to complete your registration.\n5.2 Create device connection\nFor this section, please refer to Quick Start.\n5.3 Get App ID and product identification code (productkey)\nFor this section, please refer to Quick Start.\n5.4 Download the SDK\n\n5.5 Import the SDK\nFirst double click to unzip the file GizWifiSDK-iOS-xxx.zip. According to the needs of the application development, you can choose to use dynamic libraries or static libraries. The following are the loading methods for both dynamic and static libraries:\n5.5.1 Import dynamic libraries\nThe dynamic libraries are in the decompressed DynamicLibrary directory. For dynamic library loading, please follow the settings as shown below, otherwise the App will crash immediately after running.\n\n5.5.2 Importing a static SDK\nFirstly, after uncompressing, copy the files in the StaticLibrary directory to the specified project:\n\nSecondly, download OpenSSL library and add the corresponding dependency. After the download is completed, double-click and extract the lib-ios, then copy and add it to the specified project.\n\n\nThirdly, if Xcode7.2 or below is used, you need to add the libraries of AudioToolbox, SystemConfiguration, CoreTelephony.\n\nFourthly, you must remember to enable the ATS feature in Info.plist, otherwise some functions under iOS9 cannot be used normally.\n\nFinally, make sure that the following libraries exist in the project.\n\n5.6 Use GizWifiSDK via cocoapods (optional)\nStep 1: Check that installed cocoapods works properly.\npod –help\nStep 2: Edit the Podfile file corresponding to the project\n#Uncomment this line to define a global platform for your project #\nplatform :ios, ‘6.0’\n#source ‘https://github.com/gizwits/PodSpecs.git'\nSource ‘https://git.oschina.net/dantang/PodSpecs.git’\n#Select only one of the above two sources\ntarget ‘cocoapodsTest’ do pod ‘GizWifiSDK’, ‘2.04.04’ end\nStep 3: installation\npod install --no-repo-update\nStep 4: open the workspace project\nThe SDK workflow\n1. General flow chart\n\n2. Key point description\n1) The SDK has encapsulated all the activities related to user, configuration, discovery, connection, and control. You can use these APIs to develop the functions in the above flow chart without having to implement the communication protocol by yourself.\n2) The SDK adopts the callback method, so it is necessary to set up necessary delegates, such as the common delegate and the device delegates. For more information, please refer to the detailed workflow. The SDK calls the App in the main thread.\nDetailed workflow of the SDK\n1. Initialization\n1.1 Flow chart\n\n1.2 Import header files\nimport <GizWifiSDK/GizWifiSDK.h>\n1.3 Set up the common delegate\nRegistering the common delegate for the SDK is to enable the App to receive events from GizWifiSDK class, which involves the callback interfaces such as registration, login, device configuration, and device binding. This is a very important delegate in the use of the SDK, where the operations related to GizWifiSDK class will be called back. If the common delegate is not properly registered, the SDK will not work normally. When registering the delegate, you can implement callback interfaces on your behalf.\n1.4 Initialize the SDK\nBefore the SDK is launched, any feature is not working properly. When the SDK starts, it will be initialized and automatically discover devices in the current LAN. The SDK will report the discovered devices and corresponding events through the common delegate. You can set the SDK's common delegate first, then launch the SDK so as to handle these events.\nWhen the SDK starts, the App AppID needs to be specified. You should apply for an AppID for your own App in the Gizwits Developer Center. Please call the method in the App AppDelegate with the specified AppID. This method only needs to be called once.\nThe SDK's log can help you discover issues that occur while the App is running. By default, the SDK outputs all log information to the debug terminal and log files. The log files are saved in the Applications\\Documents\\GizWifiSDK\\GizSDKLog directory. If you do not want to output logs in the debugging terminal, you can change the log output level to GizLogPrintNone.\n[Code sample]\n[GizWifiSDK shareInstance].delegate = self;\n[GizWifiSDK startWithAppID:@\"your_app_id\"];\n\n// Callback for system events \n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didNotifyEvent:(GizEventType)eventType eventSource:(id)eventSource eventID:(GizWifiErrorCode)eventID eventMessage: (NSString *)eventMessage {\n    if(eventType == GizEventSDK) {\n        // SDK exception event \n        NSLog(@\"SDK event happened: [%@] = %@\", @(eventID), eventMessage);\n    } else if(eventType == GizEventDevice) {\n        // Device disconnection event \n        GizWifiDevice* mDevice = (GizWifiDevice*)eventSource;\n        NSLog(@\"device mac %@ disconnect caused by %@\", mDevice.macAddress, eventMessage);\n    } else if(eventType == GizEventM2MService) {\n        // M2M service exception event \n        NSLog(@\"M2M domain %@ exception happened: [%@] = %@\", (NSString*)eventSource, @(eventID), eventMessage);\n    } else if(eventType == GizEventToken) {\n        // Event of invalid token \n        NSLog(@\"token %@ expired: %@\", (NSString*)eventSource, eventMessage);\n    }\n}\n2. User Management\nThe user management of Gizwits Cloud includes functions such as user registration, login, password recovery, and personal information modification. Gizwits Cloud distinguishes users by APPID, and the users with different APPIDs are independent of each other. After changing the APPID of a user, you need to re-register the user.\nThe listener registration method involved in the following process is implemented using class inheritance.\n2.1 Flow chart\n\nThere are many ways for users to register, such as mobile phone number, user name, email address, etc. The App can take the method as needed. For other processes such as login, password change, personal information modification, etc., see the following section.\n2.2 User registration\nGizwits provides three user registration methods, such as register via mobile phone, regular user registration, and register via Email.\n2.2.1 Register as a mobile phone user\nTo register an account with your mobile phone, you need a valid mobile phone number. Two steps are required for registration: get the SMS verification code and register the user with the SMS verification code.\nStep 1: get the SMS verification code. The SDK sends a SMS verification code request to the cloud. If the request is successful, the cloud will respond a SMS verification code to the mobile phone.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] requestSendPhoneSMSCode:@\"your_app_secret\" phone:@\"your_phone_number\"];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRequestSendPhoneSMSCode:(NSError *)result token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\nStep 2: Register with SMS verification code. The App passes the SMS verification code received by the mobile phone to the SDK, and fills in the mobile phone number and password to register.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] registerUser:@\"your_phone_number\" password:@\"your_password\" verifyCode:@\"your_verify_code\" accountType:GizUserPhone];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRegisterUser:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.2.2 Register as a regular user\nRegister as a regular user account with a username and a password.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] registerUser:@\"your_user_name\" password:@\"your_password\" verifyCode:nil accountType:GizUserNormal];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRegisterUser:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.2.3 Register as an Email user\nRegister a user account with a valid email address. After the registration is successful, the cloud will send an Email of the successful registration to the specified Email address.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] registerUser:@\"your_email_address\" password:@\"your_password\" verifyCode:nil accountType:GizUserEmail];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRegisterUser:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.3 User login\nGizwits Cloud provides three user login methods: real-name login, anonymous login, and third-party authentication. Real-name login is suitable for those Apps which have login UI and need to register before use. Anonymous login is applicable to the Apps that do not have login UI and user accounts are automatically generated in the cloud when needed. The token obtained after login is valid in 7 days.\n2.3.1 Real-name login\nFor real-name login, the user name can be the registered mobile phone number, Email address, and regular user name. If the AppID is changed, the user account needs to be re-registered.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] userLogin:@\"your_user_name\" password:@\"your_user_password\"]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didUserLogin:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.3.2 Anonymous login\nEvery time a user logs in anonymously, the obtained uid is the same. When an anonymous user logs in, if the account does not exist, the cloud generates an anonymous account based on the device ID and logs in with it.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] userLoginAnonymous];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didUserLogin:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.3.3 Third-party authentication\nGizwit Cloud currently supports third-party authentication from Baidu, Sina, and Tencent. You can use the APIs of these three platforms to obtain uid and token to log into Gizwits Cloud. When using third-party authentication, you do not need to register on Gizwits Cloud, you can log in directly.\nYou can get uid and token through those APIs of Sina, Baidu or Tencent. For details, please refer to the corresponding development documentation. You can also use the following tools to obtain uid and token from these third-party platforms:\nShareSDK http://mob.com/\nBaiduSDK http://developer.baidu.com/wiki/index.php?title=%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E9%A6%96%E9%A1%B5/%E7%99%BE%E5%BA%A6%E5%B8%90%E5%8F%B7%E8%BF%9E%E6%8E%A5\n[Code sample]\n// Take Sina as example\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] userLoginWithThirdAccount:GizThirdSINA uid:@\"your_third_uid\" token:@\"your_third_token\"]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didUserLogin:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.4 Password reset\nIf you have forgotten your password, you can set a new password via mobile phone or Email, which are supported by the SDK. For the password reset via mobile phone, the verification code will sent to your mobile phone. For the password reset via Email, there will be a hyperlink delivered to your Email address which prompts you to complete the rest steps.\n2.4.1 Password reset via mobile phone\nFor the password reset via mobile phone, you need to get the SMS verification code. The approach of obtaining the SMS verification code is the same as when you registered with your mobile phone.\nStep 1: get SMS verification code\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] requestSendPhoneSMSCode:@\"your_app_secret\" phone:@\"your_phone_number\"];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRequestSendPhoneSMSCode:(NSError *)result token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\nStep 2: Reset your password with SMS verification code\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] resetPassword:@\"your_phone_number\" verifyCode:@\"your_verify_code\" newPassword:@\"your_new_password\" accountType:GizUserPhone]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserPassword:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.4.2 Password reset via Email\nFor the password reset via Email, the cloud sends a secure link to the specified Email address. You needs to check the Email in the mailbox and follow the instructions to perform the reset operation. It is possible that the password reset link is delivered into the trash folder of your mailbox, which you needs to be aware of.\nThe callback for the successful Email delivery is the same with the callback for the password change, so it is necessary to notice the distinction between these two cases.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] resetPassword:@\"your_email_address\" verifyCode:nil newPassword:@\"your_new_password\" accountType:GizUserEmail]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserPassword:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n            // The reset password Email is sent successfully, prompting the user to check\n    } else {\n            // The reset password Email failed to send, the error message pops up\n    }\n}\n2.5 Password change\nThe password can be changed after you log in.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] changeUserPassword:@\"your_token\" oldPassword:@\"your_old_password\" newPassword:@\"your_new_password\"]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserPassword:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.6 User type conversion\nAn anonymous user can be converted to a real-name user, such as a regular user or a user registered with mobile phone. After the conversion, the anonymous user's information will be transferred to the real-name user, and the original anonymous user account will be invalid. However, the user name or the mobile phone number of the target user must be unregistered before conversion, otherwise it will fail.\n2.6.1 An anonymous user converted to a regular user\nFor an anonymous user converted to a regular user, fill in the username, password, and token of the target regular user.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] transAnonymousUser:@\"your_token\" username:@\"your_user_name\" password:@\"your_password\" verifyCode:nil accountType:GizUserNormal]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didTransAnonymousUser:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.6.2 An anonymous user converted to a user registered with mobile phone\nFor an anonymous user converted to a mobile phone user, fill in the mobile phone number, password, SMS verification code, and token of the target user registered with mobile phone. The procedure of obtaining the SMS verification code is the same as when registering as a mobile phone user.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] transAnonymousUser:@\"your_token\" username:@\"your_phone_number\" password:@\"your_password\" verifyCode:@\"your_verify_code\" accountType:GizUserPhone]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didTransAnonymousUser:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.7 Update user information\nFor real-name users, Gizwis does not support the regular user name modification. But you can modify the Email address and mobile phone number, supplement personal information after logging in, and the Email address or mobile phone number to be modified must be already registered.\nAfter the real-name user has modified the email address or mobile phone number, he can log in using the modified email address or mobile phone number. The list of bound devices retrieved after login is the same as the original real-name user.\nWhen you modify your Email address or mobile phone number, you can supplement your personal information at the same time. When you do not want to modify your personal information, the corresponding parameter can be set to nil. In the case of the Email address or user name is successfully modified and the personal information fails to be modified, the callback method will return success and prompt the failure reason of the personal information modification in errorMessage.\n2.7.1 Modify Email address\nWhen only Email address is needed to be modified, the parameter of the personal information is set to nil, and the user type can be set to GizUserEmail. The following is a code sample to modify a user's Email address.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:@\"your_email_address\" SMSVerifyCode:nil userType:GizUserEmail additionalInfo:nil]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.7.2 Modify mobile phone number\nWhen only the user's mobile phone number is needed to be modified, the personal information parameter is set to nil, and the user type can be set to GizUserPhone. Before modifying your mobile phone number, you need to get the SMS verification code. The following code sample is used to modify the user's mobile phone number. For the code to get the SMS verification code, please refer to the registration with mobile phone number. \n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:@\"your_phone_number\" SMSVerifyCode: @\"your_verify_code\" userType:GizUserPhone additionalInfo:nil]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.7.3 Modify personal information\nWhen only the user's personal information is needed to be modified, the phone number or mailbox parameter is set to nil, and the user type can be set to GizUserNormal. The personal information can contain multiple items, which can be specified by GizUserInfo class. The information that you do not want to modify is set to nil, and the cloud will retain the last modified value.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n\nGizUserInfo* additialInfo = new GizUserInfo();\nadditialInfo.name = @\"nickname\";\nadditialInfo.userGender = GizUserGenderMale;\nadditialInfo.birthday = @\"1990-1-1\";\nadditialInfo.address = @\"Beijing\";\nadditialInfo.remark = @\"home\";\n\n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:nil SMSVerifyCode:nil userType:GizUserNormal additionalInfo:additialInfo]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.7.4 Modify both Email addres and personal information\nWhen modifying the Email address and personal information at the same time, the user type must be set to GizUserEmail.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n\nGizUserInfo* additialInfo = new GizUserInfo();\nadditialInfo.name = @\"nickname\";\nadditialInfo.userGender = GizUserGenderMale;\nadditialInfo.birthday = @\"1990-1-1\";\nadditialInfo.address = @\"Beijing\";\nadditialInfo.remark = @\"home\";\n\n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:@\"your_email_address\" SMSVerifyCode:nil userType:GizUserEmail additionalInfo:additialInfo]; \n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n2.7.5 Modify both mobile phone number and personal information\nWhen modifying the mobile phone number and personal information at the same time, the user type must be set to GizUserPhone. To modify the mobile phone number, you also need to get the SMS verification code first. For the SMS verification code, please refer to the registration with mobile phone. \n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n\nGizUserInfo* additialInfo = new GizUserInfo();\nadditialInfo.name = @\"nickname\";\nadditialInfo.userGender = GizUserGenderMale;\nadditialInfo.birthday = @\"1990-1-1\";\nadditialInfo.address = @\"Beijing\";\nadditialInfo.remark = @\"home\";\n\n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:@\"your_phone_number\" SMSVerifyCode: @\"your_verify_code\" userType:GizUserPhone additionalInfo:additialInfo];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n3. Configure device to access network\nBefore controlling a device, you need to connect the device to a router. If the router can access internet, the device connected to the router will automatically register to Gizwits Cloud.\nThere are two ways to configure the device to connect to the router. One is Airlink and the other is SoftAP. The App can adopt the favorite approach according to product requirements. Before configuration, the device must first enter the configuration mode, and then the App calls the configuration API to send the router SSID and password to be configured. After the device is successfully configured, the SDK returns the configured MAC address and product type identifier of the device to the App, which is convenient for the App to perform the next step. If the device has entered the configuration mode after reset and does not have time to get the DID from the cloud when the configuration is successful, the DID value obtained by the App is empty.\nIf the timeout period of the configuration API of the SDK is not over, the next configuration cannot be performed. In addition, because the broadcast packet of the successful device configuration can be received only if the App is connected to the same router, the above timeout period should reserve the time for the App to connect to the router.\nIt should be noted that if the device configured is not the expected product type for the App, the device will not appear in the App device list.\n3.1 Flow chart\n\n3.2 Configuration with AirLink\nAirLink uses UDP broadcast sent from a mobile phone which contains the target router SSID and password. The Wi-Fi module on the device automatically connects to the target router after receiving the broadcast packet, and then sends a configuration success broadcast after connecting to the router to notify the mobile phone that the configuration has been completed.\nAfter the Wi-Fi module enables AirLink mode, if it does not receive AirLink broadcast within one minute or is not able to connect to the router correctly, it will enter SoftAP mode.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] setDeviceOnboarding:@\"your_ssid\" key:@\"your_key\" mode:GizWifiAirLink softAPSSIDPrefix:nil timeout:60 wifiGAgentType:[NSArray arrayWithObjects: @(GizGAgentESP), nil]];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didSetDeviceOnboarding:(NSError *)result mac:(NSString *)mac did:(NSString *)did productKey:(NSString *)productKey {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n3.3 Configuration with SoftAP\nAfter the device enters SoftAP mode, a Wi-Fi hotspot is created on it. After the mobile phone is connected to this hotspot, the SSID and password to be used are sent to the device. After receiving the SoftAP configuration package, the Wi-Fi module on the device automatically connects to the target router. Just like the AirLink, after the router is connected, the configuration success broadcast is sent to notify the mobile phone that the configuration is completed.\nUsing the Wi-Fi module firmware provided by Gizwits, the Wi-Fi hotspot created by the device starts with “XPG-GAgent-” and the password is “123456789”. Modules provided by other vendors, SoftAP hotspot names are specified by respective vendors. The App can give the correct hotspot prefix as needed.\n[Code sample]\n// The MCU issues a serial port command to notify the module to enable SoftAP mode. For details, please refer to \"Gizwits Air Conditioner –Serial Port Communication Protocol Document for Gizwits Cloud Access \"\n\n// Get the phone connected to the module's SoftAP hotspot\n\n// Configure the device to access the network, send the Wi-Fi SSID and password to be used \n\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] setDeviceOnboarding:@\"your_ssid\" key:@\"your_key\" mode:GizWifiSoftAP softAPSSIDPrefix: @\"your_gagent_hotspot_prefix\" timeout:60 wifiGAgentType:nil]];\n\n// The module receives configuration information, try to connect to the router and automatically close the hotspot\n// Get the mobile phone connected to the Wi-Fi network to be used\n\n// Wait for configuration completion or timeout, call the configuration completion interface\n\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didSetDeviceOnboarding:(NSError *)result mac:(NSString *)mac did:(NSString *)did productKey:(NSString *)productKey {\n        if(result.code == GIZ_SDK_SUCCESS) {\n            // success\n        } else {\n            // failure\n        }\n}\n4. Device discovery and subscription\n4.1 Flow chart\n\n4.2 Device discovery\nAfter setting a delegate for the App and launching the SDK, the App can receive the push notification of device list from the SDK. Each time there are changes for the devices in the current LAN or bound devices, the SDK will automatically report the latest device list. When a device is powered off and then powered on, or a new device comes online, the device list will be refreshed. After the user logs in, the SDK will automatically report the list of devices that the user has bound to the App. The bound device can be obtained by the same user account on different mobile phones.\nIf the App wants to refresh the list of bound devices, you can call the bound device list API and specify the product type identifier that you care about. The SDK will return the filtered device list to the App.\nThe SDK provides a device list cache, and device objects in the device list remain valid throughout the App lifecycle. The cached device list is updated synchronously with the most recently discovered devices.\n[Code sample]\n// Refresh the UI with a cached device list\nNSArray* devices = [GizWifiSDK sharedInstance].deviceList;\n\n// Receive device list change report, refresh UI\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didDiscovered:(NSError *)result deviceList:(NSArray *)deviceList {\n        // Get the error message\n        if(result.code != GIZ_SDK_SUCCESS) {\n            NSLog(@\"result: %@\", result.localizedDescription);\n        }\n        // Display the device list after changed \n        NSLog(@\"discovered deviceList: %@\", deviceList);\n        devices = deviceList;\n}\n\n// Actively refresh the list of bound devices, specify the productKey to filter devices\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] getBoundDevices:@\"your_uid\" token:@\"your_token\" specialProductKeys:[NSArray arrayWithObjects: @\"your_product_key\", nil]];\n4.3 Set device delegate\nGet the device objects in the device list, set the device delegate for each of them, in order to refresh the device related UI. The App implements the corresponding callback according to its own needs.\n4.4 Device subscription and binding\nAfter the App gets the device list and sets delegate, you can subscribe to the device. The subscribed device will be automatically bound and automatically log in. After the device logs in successfully, it will automatically report the latest status.\nThe automatically bound devices are limited to the same LAN where your App resides. For devices that cannot be discovered in the LAN, the App can bind them manually. A device that is successfully bound must be subscribed before it can be used.\nWhether it is manual binding or automatic binding, the remark and alias information of the device must be set after the device is successfully bound.\nIf the device is unsubscribed, the connection will be disconnected and instructions are not able to be issued to the device.\n4.4.1 Device subscription\nAll devices obtained through the SDK can be subscribed, and the subscription result is returned via callback. Status query and instructions issuing can only be perform on those successfully subscribed devices when their network becomes available.\n[Code sample]\n// Take the first device instance in the device list as an example and set a delegate for it. \nGizWifiDevice* mDevice = nil;\nfor (int i = 0; i < deviceList.count; i++) {\n    mDevice = deviceList[0];\nmDevice.delegate = self;\n[mDevice setSubscribe:YES];\nbreak;\n}\n\n// Callback\n- (void)device:(GizWifiDevice *)device didSetSubscribe:(NSError *)result isSubscribed:(BOOL)isSubscribed {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // subscribe or unsubscribe successfully \n    }\n}\n4.4.2 Non-LAN device binding\nThe App can complete the binding of the non-LAN device through the MAC, productKey, and productSecret of the device. The above information can be used to generate a QR code, which will be used by the App to bind the device. GPRS devices, Bluetooth devices, etc. are devices that cannot be discovered through the Wi-Fi LAN, and all belong to non-LAN devices.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self;\n[[GizWifiSDK sharedInstance] bindRemoteDevice:@\"your_uid\" token:@\"your_token\" mac:@\"your_mac\" productKey:@\"your_product_key\" productSecret:@\"your_product_secret\"];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didBindDevice:(NSError *)result did:(NSString *)did {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n4.4.3 Set device binding information\nYou can also set the binding information of the device without subscribing to it. Find the device you want to modify the remark and alias information in the device list if it is bound already.\n[Code sample]\n// mDevice is the device entity object obtained from the device list, and the delegate is set for it.\nmDevice.delegate = self;\n[mDevice setCustomInfo:@\"your_remark\" alias:@\"your_alias\"]; \n\n// Callback\n- (void)device:(GizWifiDevice *)device didSetCustomInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n4.5 Unbind device\nThe bound device can be unbound. To unbind a device requires the App to invoke the API to complete the operation. The SDK does not support automatic unbinding. For the device subscribed to, after unbound, it will be un-subscribed and disconnected and not report status. Thus, the App will not get the device when it refreshes the device list.\n[Code sample]\n[GizWifiSDK sharedInstance].delegate = self;\n[[GizWifiSDK sharedInstance] unbindDevice:@\"your_uid\" token:@\"your_token\" did:@\"your_did\"];\n\n// Callback\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didUnbindDevice:(NSError *)result did:(NSString *)did {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n4.6 Get hardware information\nHardware information can be obtained without subscribing to the device. The App can get hardware information such as the module protocol version number and the MCU firmware version number, but only for the devices located in the same LAN.\n[Code sample]\n// mDevice is the device entity object obtained from the device list, and the delegate is set for it.\n\nmDevice.delegate = self;\n[mDevice getHardwareInfo]; \n\n// Callback\n- (void)device:(GizWifiDevice *)device didGetHardwareInfo:(NSError *)result hardwareInfo:(NSDictionary *)hardwareInfo {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n        NSString *hardWareInfo = [NSString stringWithFormat:@\"WiFi Hardware Version: %@,\\\n            WiFi Software Version: %@,\\\n            MCU Hardware Version: %@,\\\n            MCU Software Version: %@,\\\n            Firmware Id: %@,\\\n            Firmware Version: %@,\\\n            Product Key: %@“\n            , [hwInfo valueForKey: @\"wifiHardVersion\"]\n            , [hwInfo valueForKey: @\"wifiSoftVersion\"]\n            , [hwInfo valueForKey: @\"mcuHardVersion\"]\n            , [hwInfo valueForKey: @\"mcuSoftVersion\"]\n            , [hwInfo valueForKey: @\"wifiFirmwareId\"]\n            , [hwInfo valueForKey: @\"wifiFirmwareVer\"]\n            , [hwInfo valueForKey: @\"productKey\"];\n    } else {\n        // failure\n    }\n}\n5. Device control\nThe SDK controls devices and receives device status through dictionary key-value pairs. After receiving dictionary key-value pairs of an instruction sent by the App, the SDK parses the data that can be recognized by the device and sends it to the device. In the opposite direction, after receiving the data that the device replies or reports, the SDK parses it to dictionary key-value pairs and reports it to the App.\nThe GAgent firmware and Gizwits serial port communication protocol need to be flashed onto the smart device correctly. If data points are defined for the device, the instructions sent by the App must conform to the data point definition. If there is no data point defined for the device, the device instructions can be issued in a custom format.\n5.1 Flow chart\n\n5.2 Send device instructions\nAfter the device subscription becomes available, the App can send instructions. Device instructions are in dictionary format, with key-value pairs being data point names and values. The instruction result is returned in the didReceiveData callback.\nWhen the App issues an instruction in which the parameter sn can be specified, and the parameter sn in the callback can indicate whether the issued instruction is successfully sent. However, the callback parameter dataMap may be an empty dictionary, depending on whether the device passes the current data point status when replying.\nIf the App only concerns whether there is a device status report after the instruction is issued, the parameter sn of the issued instruction can be filled with 0, and the callback parameter sn is also 0.\n[Code sample]\n// Get the device object in the device list, set the delegate for it\nmDevice.delegate = self;\n\n// Send a light-on instruction to a device whose subscription is available\nint sn = 5;\n[self write: @{@\"LED_OnOff\": @(YES)} sn:@(sn)];\n\n// Callback\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)data withSN:(NSNumber *)sn {\nif(result.code == GIZ_SDK_SUCCESS) {\n    // The command sequence number matches, and the light-on instruction is executed successfully.\nif (sn == 5) {\n}\n    } else {\n        // Execution failure\n    }\n}\n5.3 Get device status\nAfter the device subscription becomes available, the App can receive the device status report at any time through the didReceiveData callback. When the device reports its status, the callback parameter sn is 0, and the callback parameter dataMap has the status reported by the device.\n[Code sample]\n(void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)data withSN:(NSNumber *)sn {\n    //Basic data, whose format is consistent with the sent data\n    NSDictionary *_data = [data valueForKey:@\"data\"];\n\n    // Alarm\n    NSArray *alarms = [data valueForKey:@\"alerts\"];\n\n    // Fault\n    NSArray *faults = [data valueForKey:@\"faults\"];\n\n    //Data via transparent transmission\n    NSDictionary *binary = [data valueForKey:@“binary\"];\n\n    //Deal with these types of data \n}\n5.4 Device status query\nAfter the device subscription becomes available, the App can query the device status. The device status query result is also obtained by the didReceiveData callback, and the callback parameter sn is 0. The callback parameter dataMap has the status of the returned status.\n[Code sample]\n// mDevice is the device entity object obtained from the device list, set a delegate for it\nmDevice.delegate = self;\n[mDevice getDeviceStatus];\n\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)data withSN:(NSNumber *)sn {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // The data parse is the same as section 3.5.3\n    } else {\n        // failure\n    }\n}\n6. Device task scheduling\nBy setting up a scheduled task for a device, you can have the device perform certain actions on a predetermined date and time. These tasks can be repeated on certain days of each month or on certain days of each week.\nScheduled tasks can be set first and then executed or stopped at any time. The scheduled task is enabled by default when it is created.\n6.1 Flow chart\n\n6.2 Create a scheduled task\nScheduled tasks can be executed repeatedly or only once, and repeated tasks are divided into monthly occurring tasks and weekly occurring tasks. However, you can only specify one type of repetition at the same time, that is, not repeated or repeated on a weekly basis or repeated on a monthly basis.\nWhen using the SDK API, the parameter weekDays is set for weekly occurring tasks and the parameter monthDays is set for monthly occurring tasks. However, if both are set, only the parameter weekDays will be used.\nThe following three examples are shown below.\n6.2.1 Create a one-time scheduled task\nSuppose we need to turn on a light at 6:30 am on January 16, 2017. In the following code, the date and time are set to the corresponding values, where the date is 2017-01-16, the time is 06:30 (in 24-hour format).\n[Code sample]\n// Set a scheduled task delegate\n[GizDeviceSchedulerCenter setDelegate:self];\n\n// Create a one-time scheduled task, which will turn on a light at 6:30 am on January 16, 2017\nGizDeviceScheduler *scheduler = [[GizDeviceScheduler alloc] init];\nscheduler.date = @\"2017-01-16\";\nscheduler.time = @\"06:30\";\nscheduler.remark = @\"一次性开灯任务\";\nscheduler.attrs = @{@\"LED_OnOff\": @YES};\n\n// Create a scheduled task for the device mDevice which is the device object obtained in the device list\n[GizDeviceSchedulerCenter createScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice scheduler:scheduler]; \n\n// Callback\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n6.2.2 Create a weekly occurring scheduled task\nWe now get the scheduled task executed on a weekly basis, and we have to turn on a light every Monday to Friday at 6:30 in the morning.\n[Code sample]\n// Set a scheduled task delegate\n[GizDeviceSchedulerCenter setDelegate:self];\n\n// The repeated scheduled task from Monday to Friday\nGizDeviceScheduler *scheduler = [[GizDeviceScheduler alloc] init];\nscheduler.time = @\"06:30\";\nscheduler.weekDays = @[@GizScheduleMonday, @GizScheduleTuesday, @GizScheduleWednesday, @GizScheduleThursday, @GizScheduleFriday];\nscheduler.remark = @\"按周重复执行的开灯任务\";\nscheduler.attrs = @{@\"LED_OnOff\": @YES};\n\n// Create a scheduled task for the device mDevice which is the device object obtained in the device list. \n[GizDeviceSchedulerCenter createScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice scheduler:scheduler]; \n\n// Callback\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n6.2.3 Create a monthly occurring scheduled task\nWe now get the scheduled tasks executed on a monthly basis, and we have to turn on the light on the 1st and 15th of each month at 6:30 in the morning. \nNote that do not set a weekly occurring scheduled task together with a monthly occurring scheduled task. If you do so, the monthly occurring scheduled task will be ignored. \n[Code sample]\n// Set a scheduled task delegate \n[GizDeviceSchedulerCenter setDelegate:self];\n\n// The task will be executed on the 1st and 15th of each month\nGizDeviceScheduler *scheduler = [[GizDeviceScheduler alloc] init];\nscheduler.time = @\"06:30\";\nscheduler.monthDays = @[@1, @15];\nscheduler.remark = @\"按月重复执行的开灯任务\";\nscheduler.attrs = @{@\"LED_OnOff\": @YES};\n\n// Create a scheduled task for the device mDevice which is the device object obtained in the device list. \n[GizDeviceSchedulerCenter createScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice scheduler:scheduler]; \n\n// Callback\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n6.3 Obtain the scheduled task list\nAfter creating a scheduled task, you can get a list of all scheduled tasks that have been created. After obtaining the scheduled task list, you can modify or delete any created scheduled task in the list.\n[Code sample]\n// Set a scheduled task delegate \n[GizDeviceSchedulerCenter setDelegate:self];\n\n// Update the scheduled task list for the device mDevice which is the device object obtained in the device list.\n[GizDeviceSchedulerCenter updateSchedulers:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice]; \n\n// Callback\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n6.4 Modify a scheduled task\nYou can modify a scheduled task that has been created. When modifying, the scheduled task object is taken out from the obtained scheduled task list.\nNote that once a scheduled task is created, it is assigned an ID that cannot be modified.\n[Code sample]\n// Set a scheduled task delegate \n[GizDeviceSchedulerCenter setDelegate:self];\n\n// Modify the previously created one-time scheduled task to a scheduled task that is executed repeatedly on the 1st and 15th of each month. The scheduler is the scheduled task object to be modified in the scheduled task list. \nscheduler.time = @\"06:30\";\nscheduler.remark = @\"开灯任务\";\nscheduler.attrs = @{@\"LED_OnOff\": @YES};\nscheduler.monthDays = @[@1, @15];\n\n// Modify the scheduled task for the device mDevice which is the device object obtained in the device list. \n[GizDeviceSchedulerCenter editScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice scheduler:scheduler]; \n\n// Callback\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n6.5 Delete a scheduled task\nIn the obtained scheduled task list, find the scheduled task ID to be deleted and delete it.\n[Code sample]\n// Set a scheduled task delegate\n[GizDeviceSchedulerCenter setDelegate:self];\n\n// Delete the scheduled task of the device mDevice which is the device object obtained in the device list. The parameter your_scheduler_id is the scheduled task ID to be deleted.\n[GizDeviceSchedulerCenter deleteScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice schedulerID:@\"your_scheduler_id\"]; \n\n// Callback\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n7. Device sharing\nAfter binding a device, you can let others use the device through device sharing. When multiple customers use the same device, device sharing provides device permission management with a more secure and convenient device binding. There are four types of device permissions for device binding:\n\nOwner: The primary account of the device, which can share the device;\nGuest: The shared account of the device, which can accept the sharing invitation and can no longer share the device to other users;\nSpecial: The account which has bound to the device at the earliest but has not shared the device, and will become the Owner of the device after sharing it;\nNormal: The account that has bound to the device but cannot share the device or become the Owner of the device.\n\nOnly the user bound to a device at the earliest or the Owner of a device can share the device. Once a device has an Owner account, other users can no longer bind the device. The Owner can view the currently users bound to the device and can unbind other users. When a device does not have an Owner, other users can bind the device.\n7.1 Flow chart\n\n7.2 Make a device sharing invitation\nBefore sharing your devices, check which devices you can share. Using the SDK, the App can traverse the list of devices and find those devices on which the currently logged in user has a permission of GizDeviceSharingSpecial or GizDeviceSharingOwner to create a device sharing invitation.\nThere are two ways to create a device sharing invitation: Account Sharing and QR code Sharing.\n7.2.1 Account Sharing\nFor Account sharing, the receiver's account can be a mobile phone number, an email address, a regular user name, or an anonymous account, but it must be a user who has already registered in Gizwits Cloud. If the user is already the Guest account of this device or has already bound the device, the sharing invitation will fail to be created. The account sharing invitation is valid for 24 hours, that is, the receiver must respond within 24 hours, otherwise the invitation will expire. \nYou need to specify the account type for Account Sharing. The guestUser parameter for the anonymous user should be set to the uid of the anonymous user. When the Account Sharing is created successfully, the sharingID will be returned in the callback parameter, but the QRCodeImage will not be returned. The following is only an example of device sharing to a user registered with mobile phone number:\n[Code sample]\n// Set a device sharing delegate\n[GizDeviceSharing setDelegate:self];\n\n// Find devices that can be shared in the device list\n\n// Share the device to a user registered with mobile phone number\n[GizDeviceSharing sharingDevice:@\"your_token\" deviceID: @\"your_device_id\" sharingWay:GizDeviceSharingByNormal guestUser:@\"guest_phone_number\" guestUserType:GizUserPhone]; \n\n// Callback\n- (void)didSharingDevice:(NSError*)result deviceID:(NSString*)deviceID sharingID:(NSInteger)sharingID QRCodeImage:(UIImage*)QRCodeImage {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n7.2.2 QR code Sharing\nFor the QR code Sharing, the QR code is valid for 15 minutes, that is, the receiver must scan the generated QR code within 15 minutes and respond, otherwise the QR code invitation will expire. When the QR code Sharing invitation is created successfully, the sharingID will be returned in the callback parameter, and the corresponding QRCodeImage will also be returned. The App can directly load the QR code image.\n[Code sample]\n// Set a device sharing delegate\n[GizDeviceSharing setDelegate:self];\n\n// Find devices that can be shared in the device list\n\n// Share the device through QR code Sharing\n[GizDeviceSharing sharingDevice:@\"your_token\" deviceID: @\"your_device_id\" sharingWay:GizDeviceSharingByQRCode guestUser:nil guestUserType:GizUserOther]; \n\n// Callback\n- (void)didSharingDevice:(NSError*)result deviceID:(NSString*)deviceID sharingID:(NSInteger)sharingID QRCodeImage:(UIImage*)QRCodeImage {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\n7.3 Accept sharing invitation\nThe Guest account can query the received sharing invitations. Only the Guest account can accept the sharing invitation.\n7.3.1 Accept Account Sharing invitation\nIf a sharing invitation received by the Guest has not yet been accepted, the Guest can accept or reject it.\n[Code sample]\n// Set a device sharing delegate\n[GizDeviceSharing setDelegate:self];\n\n// Query the received sharing invitations\n[GizDeviceSharing getDeviceSharingInfos:@\"your_token\" sharingType: GizDeviceSharingToMe deviceID: @\"your_device_id\"];\n\n// Callback for getting the invitation list \n- (void)didGetDeviceSharingInfos:(NSError*)result deviceID:(NSString*)deviceID deviceSharingInfos:(NSArray*)deviceSharingInfos {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // Get the invitation list successfully. Find the unaccepted sharing invitations in deviceSharingInfos, and your_sharing_id represents the sharing invitation to be accepted\n        NSInteger your_sharing_id = -1;\n        for (int i = 0; i < deviceSharingInfos.count; i++) {\n            GizDeviceSharingInfo* mDeviceSharing = [deviceSharingInfos objectAtIndex:i];\n            if (mDeviceSharing.status == GizDeviceSharingNotAccepted) {\n                your_sharing_id = mDeviceSharing.id;\n                break;\n            }\n        }\n\n        // Accept the invitation\n        if (your_sharing_id != -1) {\n            [GizDeviceSharing acceptDeviceSharing:@\"your_token\" sharingID:your_sharing_id accept:YES];\n        }\n    } else {\n        // Fail to get the invitation list\n    }\n}\n\n// Callback for accepting the sharing invitation    \n- (void)didAcceptDeviceSharing:(NSError*)result sharingID:(NSInteger)sharingID {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // success\n    } else {\n        // failure\n    }\n}\nSee Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of Gizwits Device SDK 2.0 for iOS App\nGuide of Gizwits Device SDK 2.0 for Android App\nGuide of Gizwits Device SDK for APICloud App\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process for third-party authentication platform \n\n"},{"title":"Guide of App open source framework for iOS (including source code)","url":"/en-us/AppDev/iosframe.html","content":"Overview\nThe App open source framework (hereinafter referred to as Framework) of Gizwits is a App template developed by Gizwits SDK to achieve the SDK loading, initialization, user registration, user login, device configuration, device discovery, device connection, device listing and other basic functions. The Framework is a source code project which is available to all developers and currently supports iOS and Android platforms. App developers can create a complete App by implementing specific product control pages based on the Framework.\nThis document is the guide of the Gizwits IoT App Suite. It is intended to provide a rapid development template for developers of Gizwits IoT, which can also be used for reference.\nFor source code of the Framework for iOS, find here:\nhttps://git.oschina.net/dantang/GizOpenSource_AppKit_iOS\niOS Gokit App is an example project that uses the Framework. Its source code can be find here:\nhttps://git.oschina.net/dantang/GoKit_Demo_iOS\nIt can also be downloaded at the Download Center:\n\nThe Framework code directory structure\nA. Library: Third-party library directory including GizWifiSDK\nB. GizOpenSourceModules: contains\n\nCommonModule: Common helper classes, resource files, and custom Cell\nConfigModule: Device configuration module, including AirLink and SoftAP\nUserModule: User module, including user login, user registration, password recovery\nDeviceModule: Device module, including device listing\nSettingsModule: Settings module, containing settings of menu and submenus (About etc.)\nPushModule: Push notification module, encapsulating Baidu push SDK and Jiguang push SDK \n\nQuick Integration Guide\n1. Set initialization parameters\nThe default program entry is LoginViewController in UserModule. Gizwits AppID, AppSecret and program styles can be filled in GOpenSourceModules/CommonModule/UIConfig.json file of the project.\nIf you use a third-party authentication or push notification, you need to fill in the appropriate parameters from the related platforms. If you use the push notification, you need to uncomment the related macro line in order to enable the corresponding type of push notification. If you don’t uncomment all the related macro lines, it means you are not using any third-party push notification at the time. Only one type of third-party push is supported at the same time, hence don’t uncomment multiple third-party push notification macro lines.\nConfigurable parameters are:\n\napp_id: Gizwits app id\napp_secret: Gizwits app secret\nproduct_key: Gizwits product key \nwifi_type_select: whether the Wi-Fi module selection function is enabled\ntencent_app_id: app id for qq authentication\nwechat_app_id: app id for WeChat authentication\nwechat_app_secret: app secret for WeChat authentication\npush_type: Push notifciation type [0: Off, 1: Jiguang, 2: Baidu]\nJpush_app_key: app key for Jiguang push notification\nbpush_app_key: app key for Baidu push notification\nopenAPIDomain: openAPI domain name and port, format: \"api.gizwits.com\". To specify the port, the format is: \"xxx.xxxxxxx.com:81&8443\"\nsiteDomain:site domain name and port, format: \"site.gizwits.com\". To specify the port, the format is: \"xxx.xxxxxxx.com:81&8443\"\npushDomain: push notification service domain name and port, format: \"push.gizwits.com\". To specify the port, the format is: \"xxx.xxxxxxx.com:81&8443\"\nbuttonColor: Button color\nbuttonTextColor: Button text color\nnavigationBarColor: Navigation bar color\nnavigationBarTextColor: Navigation bar text color\nconfigProgressViewColor: Configuration progress view color\nstatusBarStyle: Status bar text color [0: black, 1: white] \naddDeviceTitle: Title of “Add Device” page\nqq: whether to enable QQ auhentication [true: open]\nwechat: whether to enable WeChat auhentication [true: open] \nanonymousLogin: whether to enable anonymous login [true: open] \n\n2. Loading the control page\n1) The code provided in the Framework project implements the redirection to the control page without any modification. You only need to focus on the logic of the operation pages. If you want to click a device in the device list page and jump to the view you created, modify the corresponding redirection parameters in the AppDelegate.m file. Please modify the imported header files and class definition of the target view as shown in the figure. If you use the blank page (GosDeviceController) provided by default to create the control page, you can skip this step.\n2) Set the GizWifiDeviceDelegate in the control page, for example:\nself.device.delegate = self;\n3) Defining the delegate callback of the class in the control page to implement the GizWifiDeviceDelegate delegate method of the SDK:\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)data withSN:(NSNumber *)sn;\nIt is used to receive the device state change notification reported by the SDK, which will be parsed in order to update the page.\n4) To implement the instruction issuing, you need to call the interface method of the GizWifiDevice instance in the SDK:\n (void)write:(NSDictionary *)data withSN:(int)sn;\nFor detailed parameter explanation, see the SDK guide.\n5) When exiting the control page, you need to unsubscribe from the current device, and call the interface method of the GizWifiDevice instance in the SDK with the parameter set to NO:\n- (void)setSubscribe:(BOOL)subscribed;\n3. Add menu items on the settings page\nIf you need to add or modify an item in the settings page, you need to update the GosSettingsViewController class file in the SettingsModule. Find and modify the delegate method of the UITableView in the .m file.\nFAQ\nA. Which iOS versions are supported by the Framework?\nIt supports iOS 7 and later systems currently.\nB. How to change the version number?\nThe version number consists of two parts, the format is: project version number.program compilation time, where the project version number is set in the info, the program compilation time consists of the latter two digits of the year, month and day, which has a total of 6 characters. If you need to modify the display version number, you need to update the value of the property appVersionLabel in the viewDidLoad method of About page (GosAboutViewController) of SettingsModule.\nSee Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of iOS SDK 2.0 integration\nGuide of Android SDK 2.0 integration\nGuide of APICloud SDK\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process of third-party authentication platform \n\n"},{"title":"Aggregation API Guide","url":"/en-us/UserManual/DataAPI.html","content":"1. Overview\nAggregation API can aggregate the numeric data point data reported by devices, which supports to calculate the sum/average/maximum/minimum values of data point data for the intervals in hours/days/weeks/months. You can get aggregated data for multiple data points at a time.\nTo use this API, you must first initiate the access request. Only after the request is approved, the data reported will be aggregated.\nFor example, for the water consumption data point of a smart water meter, Aggregation API can be used to get the water consumption statistics per household per month, per week, and per day, so that monthly, weekly, and daily reports are available.\n2. Walkthrough for Advanced Data API of OpenAPI\nThe Advanced Data API of OpenAPI is used to obtain device aggregation data.\nAfter you have been granted the permission to use the aggregation API of OpenAPI, you can perform aggregation analysis of the numeric data point data reported by devices including calculating the sum/average/maximum/minimum values of data point data for the intervals in hours/days/weeks/months.\n2.1. Create a User\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/用户管理/post_app_users\nThe following figure shows how to.\n\n2.2. Anonymous user login\nThe API for anonymous user login is the same as creating an anonymous login user.\n2.3. Bind device\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/绑定管理/post_app_bind_mac\n\n2.4. Report device data\nUse the xpg tool provided by Gizwits to simulate a MCU reporting the current device data.\nThe usage of xpg is as follows:\nhttp://docs.gizwits.com/en-us/deviceDev/串口工具使用文档.html\n\n2.5. Data aggregation query\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/高级数据接口\n\nQuery result:\n\n3. Walkthrough for device data aggregation API of Enterprise API\nThe device data aggregation API only performs data aggregation query on a single device, which provides the aggregation operation for a Wi-Fi device numeric data point data in a certain period of time, including sum, average, maximum, and minimum.\nNote: Before using Enterprise API, you must first contact Gizwits technical support to apply for the Enterprise API access and set the whitelist on the API configuration page. \n3.1. Enterprise API access request\nApply for Enterprise API access:\nhttp://docs.gizwits.com/en-us/Cloud/ent_dev.html\n3.2. Set IP whitelist\n\nThe external IP of your current server is needed.\n\n3.3. Apply for aggregation API access\nContact the Gizwits technical personnel and apply for permission to use the device data aggregation API of Enterprise API.\n3.4. Get a token\nRequest URL:\nhttp://enterpriseapi.gizwits.com/v1/products/447c947fff3245a18dfc709371c34e69/access_token\nBody parameters:\n{\n\"enterprise_id\": \"string\",\n\"enterprise_secret\": \" string \",\n\"product_secret\": \" string \"\n}\n\nNote: It is not possible to request directly on the swagger because the IP of the swagger service is not in your IP whitelist. If you haven't set up a backend server yet, you can use the chrome browser plugin postman to make the request.\n3.5. Report the device state\n\n3.6. Invoke data aggregation API for a single device\nRequest URL:\nhttp://enterpriseapi.gizwits.com/v1/products/cdfb1e7f2d31474ca10396de88491372/devices/Zb248887fhMVZ2V2Jhz2xfq/agg_data?start_ts=1485151200000&end_ts=1485153000000&attrs=t1%2Ct2%2Ct3%2Ct4&aggregator=avg&unit=HOURS\nThe parameter values of the URL are:\n\nproduct_key\ndid\nstart_ts\nend_ts\nattrs\naggregator\nunit\n\nHeader parameters:\n\nAuthorize token \"enter token here\"\nContent-Type application/json\n\n\n4. Other support\nDevice data aggregation API is for enterprise developers. If you want to apply, please contact us through the official website.\nWebsite address: http://www.gizwits.com/about-us\nGizwits official QR code:\n\n"},{"title":"Device Linkage API Tutorial","url":"/en-us/UserManual/LinkageAPI.html","content":"1. Overview\nThe Wi-Fi device linkage is implemented by creating a linkage rule between devices. When a device triggers the rule, the cloud issues control instructions to the associated devices. For example, the customer has a smart light and a smart air conditioner, for which a rule can be created based on the device linkage function provided by the Gizwits cloud. When the smart light is turned on, the smart air conditioner will be turned on, whose diagram is as follows.\n\nNote: When creating linkage between two products, the two products must be associated with the same appid, otherwise, the error of appid does not exist will occur when requesting.\n2. Device linkage process\nPre-condition: The source device and target device must be associated to a same user. Then a rule set under the user will enable the linkage between devices.\nThe following is the flowchart of device linkage:\n\n3. Device linkage rules\n3.1. Get available variables\nDescription: Get all data point names and related variables of the device and product under the same pk associated with appid that can be used when creating rules.\n\nRequest URL: http://api.gizwits.com/app/rules/params?product_key=pk1,pk2\n\nRequest method: GET\n\nRequest Header:\n\n\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nString\nYes\nparams\nProvide a comma separated list of pk. When leaving blank, all pk associated to the appid are in use by default. When passing a pk that is not associated to the appid, the pk will be invalid.\n\n\nX-Gizwits-Application-Id\nString\nYes\nheader\nGizwits APPID\n\n\nX-Gizwits-User-Token\nString\nYes\nheader\nUser token\n\n\n\n3.2. Create a rule\nDescription: Create a device linkage rule.\n1.Request URL: http://api.gizwits.com/app/rules\n2.Request method: POST\n3.Request parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nOptions\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nString\nYes\nheader\n\nGizwits APPID\n\n\nX-Gizwits-User-Token\nString\nYes\nheader\n\nUser token\n\n\nproduct_key\nString\nYes\nbody\n\nProduct key\n\n\ndid\nString\nYes\nbody\n\nDevice did\n\n\nname\nString\nNo\nbody\n\nProduct name\n\n\nremark\nString\nNo\nbody\n\nDevice alias\n\n\ninterval\nInteger\nNo\nbody\n\nThe minimum trigger interval in seconds. After a rule with the parameter specified is triggered, it must wait until the specified interval elapses before next triggering.\n\n\nevent\nString\nYes\nbody\nonline/offline/alert/fault/data/extern\nTrigger mode. If this parameter is not set or set to empty, its value will be data by default.\n\n\nevent_attr\nObject\nNo\nbody\n\nIt’s required when the event parameter is set to alert or fault.\n\n\ninput\nArray\nNo\nbody\n\nEach object in the array represents the data of one device. Omit when you do not need to use device data.\n\n\ncondition\nArray\nNo\nbody\n\nEach sub array in the array represents a set of conditions. If this parameter is not set or set to empty, it means to trigger directly.\n\n\noutput\nArray\nYes\nbody\n\nEach sub array in the array represents a set of actions, of which at least one is required.\n\n\n\nTips\na.event\nIndicates the triggering method of the rule. The following is the meaning of the optional value:\n\nonline  - Device comes online\noffline – Device goes offline\nalert   - An alarm occurred on one of the alarm data points of the device\nfault   - An fault occurred on one of the fault data points of the device\ndata    - Device reports its state\nextern  - External API call fired\n\nIf this parameter is not set or set to empty, its value will be data by default.\nb.event_attr\nWhen the trigger mode is alert/fault, the data point name for this alarm/fault, and the occurrence/recovery of the alarm/fault, are specified by this parameter:\n\"event_attr\": {\n    \"attr_name\": \"datapoint_alert\", ---- Data point at which this alarm/failure occurred \n    \"value\": \"1\"                    ---- The occurrence/cancellation of an alarm/failure. 1 indicates occurrence. 0 indicates cancellation.\n}\nNote: \nThe \"occurrence\" of the alarm/fault mentioned here means that the reported data point value of the last alarm/failure of the device is 0, and its reported value is 1 this time, then the alarm/failure occurs.\nThe \"recovery\" of the alarm/failure mentioned here means that the reported data point value of the last alarm/failure of the device is 1, and its reported value is 0 this time, then the alarm/failure recoveries.\nOther cases are not \"occurrence\" and \"recovery\".\nc.did\nWhen the trigger mode is online/offline/alert/fault/data, the device that fires this rule is specified by this parameter. The device is designated as the master device in the following.\nd.input\nSpecifies the device data to be used in the rule. Each object in the array represents the data of one device. Omit if you do not need to use device data:\n[{\n    \"product_key\": \"pk1\", ---- Product key to which the device belongs\n    \"did\": \"did1\",        ---- Device did\n    \"prefix\": \"device1\"   ---- the prefix which is used to refer to the data point of the device in condition and output. If this parameter is set to device1, then device1.datapoint1 indicates referring to the data point datapoint1 of the device device1.\n}]\ne.condition\nSpecify the conditions to be satisfied by the trigger rule. The conditions in the array will be checked on a group-by-group basis in the cloud processing. When any set of conditions is met, the rule is triggered.\n[\n    [{\n        \"left\": \"device1.datapoint1\", ---- Left operand, whose value type needs to be the same as the right operand\n        \"opt\": \"==\",                  ---- Comparison operator, Available values are: >, >=, <, <=, ==, != (Note: Only numeric values can be compared)\n        \"right\": \"1\"                  ---- Right operand, whose value type needs to be the same as the left operand. When using a constant, note that \"1\" represents the number 1, \"'1'\" or \"\\\"1\\\" \"is the string \"1\"\n    }],\n    [{                                ---- Each sub array represents a set of conditions, a set of conditions is satisfied only when all the conditions in this set are satisfied \n        \"left\": \"device1.datapoint1\",\n        \"opt\": \"==\",\n        \"right\": \"1\"\n    },{\n        \"left\": \"device2.datapoint2\",\n        \"opt\": \">\",\n        \"right\": \"25\"\n    }]\n]\nf.output\nSpecify what needs to be done when the conditions are met. The cloud can be thought of as performing all groups of actions in parallel. Each group does not affect each other.\n    [\n        [{                            ---- Each sub array represents a set of actions, which are executed in sequence. If an action fails, subsequent actions will not be executed.\n            \"type\": \"devctrl\",        ---- type of output, devctrl indicates to control the device\n            \"did\": \"did1\",            ---- Specify the did of the device to be controlled\n            \"attrs\": {                 ---- key-value format\n                \"datapoint1\": 1,      ---- set datapoint1 to 1\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        },{\n            \"type\": \"delay\",          ---- type of output \n            \"delay\": 5                ---- Delay time in seconds\n        },{\n            \"type\": \"devctrl\",\n            \"did\": \"did3\",\n            \"raw\": \"1111111100000111\" ---- raw format\n        }],\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"did2\",\n            \"attrs\": {\n                \"datapoint1\": 1,\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        }]\n    ]\ng.Body sample\n{\n    \"product_key\": \"pk1\",\n    \"did\": \"did1\",\n    \"name\": \"name1\",\n    \"remark\": \"remark1\",\n    \"event\": \"data\",\n    \"event_attr\": {\n        \"attr_name\": \"datapoint_alert\",\n        \"value\": \"1\"\n    },\n    \"input\": [\n        {\n            \"product_key\": \"pk1\",\n            \"did\": \"did1\",\n            \"prefix\": \"device1\"\n        },\n        {\n            \"product_key\": \"pk2\",\n            \"did\": \"did2\",\n            \"prefix\": \"device2\"\n        }\n    ],\n    \"condition\": [\n        [{\n            \"left\": \"device1.datapoint1\", ---- Boolean type\n            \"opt\": \"==\",\n            \"right\": \"1\"\n        }],\n        [{\n            \"left\": \"device2.datapoint2\", ---- Numeric\n            \"opt\": \">\",\n            \"right\": \"25\"\n        }],\n        [{\n            \"left\": \"device2.datapoint3\", ---- Enumeration\n            \"opt\": \"!=\",\n            \"right\": \"'黄色'\"\n        },{\n            \"left\": \"device2.datapoint4\", ---- Extended type\n            \"opt\": \"==\",\n            \"right\": \"0xFF00\"\n        }]\n    ],\n    \"output\": [\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"did1\", \n            \"attrs\": {\n                \"datapoint1\": 1,\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        },{\n            \"type\": \"delay\",\n            \"delay\": 5\n        },{\n            \"type\": \"devctrl\",\n            \"did\": \"did3\",\n            \"raw\": \"1111111100000111\"\n        }],\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"did2\",\n            \"attrs\": {\n                \"datapoint1\": 1,\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        }]\n    ]\n}\n4.Sample rule\nWhen the data point Power_Switch of source device is switched on, the rule will be triggered to turn on the data point OnOff of the target device.\n{\n    \"product_key\": \"9005ab8399bb4338b6131a0522b3a57c\",\n    \"did\": \"7qSv5w62GK36NkUWFQu8AP\",\n    \"name\": \"\",\n    \"remark\": \"\",\n    \"event\": \"data\",\n      \"input\": [\n        {\n            \"product_key\":\"9005ab8399bb4338b6131a0522b3a57c\",\n            \"did\":\"7qSv5w62GK36NkUWFQu8AP\",\n            \"prefix\":\"device1\"\n        },\n        {\n            \"product_key\":\"98b133ecaa314d9d8224cd8cbc935c06\",\n            \"did\":\"qkDCqFiW3s4mbXWAqpFUnW\",\n            \"prefix\":\"device2\"\n        }\n    ],\n    \"condition\": [\n         [{\n            \"left\": \"device1.Power_Switch\", \n            \"opt\": \"==\",\n            \"right\": \"1\"\n        }]\n    ],\n    \"output\": [\n        [{\n            \"type\":\"devctrl\",\n            \"did\":\"qkDCqFiW3s4mbXWAqpFUnW\", \n            \"attrs\":{\n                \"OnOff\":1\n            }\n        }]\n    ]\n}\n3.3. Get user rules\nDescription: Get all rules created by a user.\n1.Request URL: http://api.gizwits.com/app/rules\n2.Request method: GET\n3.Request parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nString\nYes\nHeader\nGizwits APPID\n\n\nX-Gizwits-User-Token\nString\nYes\nHeader\nUser token\n\n\n\n3.4. Update a rule\nDescription: Update a rule whose identifier value is rule_id.\n1.Request URL: http://api.gizwits.com/app/rules/{rule_id}\n2.Request method: PUT\n3.Request parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nOptions\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nString\nYes\nheader\n\nGizwits APPID\n\n\nX-Gizwits-User-Token\nString\nYes\nheader\n\nUser token\n\n\nproduct_key\nString\nYes\nbody\n\nProduct key\n\n\ndid\nString\nYes\nbody\n\nDevice did\n\n\nname\nString\nNo\nbody\n\nProduct name\n\n\nremark\nString\nNo\nbody\n\nDevice alias\n\n\ninterval\nInteger\nNo\nbody\n\nThe minimum trigger interval in seconds. After a rule with the parameter specified is triggered, it must wait until the specified interval elapses before next triggering.\n\n\nevent\nString\nYes\nbody\nonline/offline/alert/fault/data/extern\nTrigger mode. If this parameter is not set or set to empty, its value will be data by default.\n\n\nevent_attr\nObject\nNo\nbody\n\nIt’s required when the event parameter is set to alert or fault.\n\n\ninput\nArray\nNo\nbody\n\nEach object in the array represents the data of one device. Omit when you do not need to use device data.\n\n\ncondition\nArray\nNo\nbody\n\nEach sub array in the array represents a set of conditions. If this parameter is not set or set to empty, it means to trigger directly.\n\n\noutput\nArray\nYes\nbody\n\nEach sub array in the array represents a set of actions, of which at least one is required.\n\n\n\n4.Sample rule\n{\n    \"product_key\": \"pk1\",\n    \"did\": \"did1\",\n    \"name\": \"name1\",\n    \"remark\": \"remark1\",\n    \"event\": \"data\",\n    \"event_attr\": {\n        \"attr_name\": \"datapoint_alert\",\n        \"value\": \"1\"\n    },\n    \"input\": [\n        {\n            \"product_key\": \"pk1\",\n            \"did\": \"did1\",\n            \"prefix\": \"device1\"\n        },\n        {\n            \"product_key\": \"pk2\",\n            \"did\": \"did2\",\n            \"prefix\": \"device2\"\n        }\n    ],\n    \"condition\": [\n        [{\n            \"left\": \"device1.datapoint1\",\n            \"opt\": \"==\",\n            \"right\": 1\n        }],\n        [{\n            \"left\": \"device2.datapoint2\",\n            \"opt\": \">\",\n            \"right\": 25\n        }],\n        [{\n            \"left\": \"device2.datapoint3\",\n            \"opt\": \"!=\",\n            \"right\": \"黄色\"\n        },{\n            \"left\": \"device2.datapoint4\",\n            \"opt\": \"==\",\n            \"right\": \"0xFF00\"\n        }]\n    ],\n    \"output\": [\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"did1\", \n            \"attrs\": {\n                \"datapoint1\": 1,\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        },{\n            \"type\": \"delay\",\n            \"delay\": 5\n        },{\n            \"type\": \"devctrl\",\n            \"did\": \"did3\",\n            \"raw\": \"1111111100000111\"\n        }],\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"did2\",\n            \"attrs\": {\n                \"datapoint1\": 1,\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        }]\n    ]\n}\n5.Sample for updating a rule\nWhen the data point Power_Switch of source device is switched on, the rule will be triggered to turn on the data point OnOff of the target device, and then wait 5s, and then set the data point Lightness of the target device to 25.\n{\n    \"product_key\": \"9005ab8399bb4338b6131a0522b3a57c\",\n    \"did\": \"7qSv5w62GK36NkUWFQu8AP\",\n    \"name\": \"\",\n    \"remark\": \"\",\n    \"event\": \"data\",\n    \"input\": [\n        {\n            \"product_key\": \"9005ab8399bb4338b6131a0522b3a57c\",\n            \"did\": \"7qSv5w62GK36NkUWFQu8AP\",\n            \"prefix\": \"device1\"\n        },\n        {\n            \"product_key\": \"98b133ecaa314d9d8224cd8cbc935c06\",\n            \"did\": \"qkDCqFiW3s4mbXWAqpFUnW\",\n            \"prefix\": \"device2\"\n        }\n    ],\n    \"condition\": [\n        [{\n            \"left\": \"device1.Power_Switch\",\n            \"opt\": \"==\",\n            \"right\": \"1\"\n        }]\n    ],\n    \"output\": [\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"qkDCqFiW3s4mbXWAqpFUnW\", \n            \"attrs\": {\n                \"OnOff\": 1\n            }\n        },{\n            \"type\": \"delay\",\n            \"delay\": 5\n        },{\n            \"type\": \"devctrl\",\n            \"did\": \"qkDCqFiW3s4mbXWAqpFUnW\",\n             \"attrs\": {\n                \"Lightness\": 25\n            }\n        }]\n    ]\n}\n3.5. Delete a rule\nDescription: Delete a rule whose identifier value is rule_id.\n\nRequest URL: http://api.gizwits.com/app/rules/{rule_id}\n\nRequest method: DELETE\n\nRequest parameters:\n\n\n\n\n\nParams\nData Type\nRequired\nParam Type\nOptions\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nString\nYes\nHeader\n\nGizwits APPID\n\n\nX-Gizwits-User-Token\nString\nYes\nHeader\n\nUser token\n\n\nrule_id\nInteger\nYes\nurl\n\nRule ID\n\n\n\n4. See Also\n\nOpen API documentation: http://docs.gizwits.com/en/Cloud/openapi_apps.html\nSwagger link: \nhttp://swagger.gizwits.com/doc/index/openapi_apps#/设备联动\n\n"},{"title":"Using Open API to control virtual device with Postman","url":"/en-us/UserManual/UseOpenAPI.html","content":"Overview\nThis guide explains how to leverage postman on the PC side to work with Open API provided by Gizwits on the cloud side, and walk you through user login, device binding, and device remote control etc. via HTTP requests. \n\nPrerequisites\n\nDevice: Developer Center - Personal Project - Virtual Device\nSoftware: Postman\nOther: developer account of Gizwits\nReference document: Open API guide\nHelper links:\nUnix timestamp\nMD5 encryption\n\n\n\nProduct Creation in Gizwits cloud\n1. Create a product\nAfter the registration is completed, log in to the Gizwits Developer Center and click on the \"Create Product\" menu in the upper right corner. Create a new product called \"Openapi\" on the next page and choose \"Wi-Fi/Mobile network access\", then complete product creation, as shown below:\n\n\n2. Create data points (product function points)\n2.1 Introduction to Data Points\nData point: An abstraction of the functionality of a device product that describes the product's functionality and its parameters. After the data point is created, the data format of the communication between the device and the cloud is determined, and the device and Gizwits cloud can mutually identify the data that the device interacts with the Gizwits Cloud. For more details, see \"data point definition tutorial\" in the upper right corner of the Developer Center Data Points page, which helps you create data points that belong to your own product, as shown below:\n\n2.2 Create data points\nTake the project \"Openapi\" as an example to briefly describe the relationship between cloud data points and product function points. Project \"Openapi\" is supposed to implement the function that turns on and off a light remotely. You need to create a “Boolean” writable data point in the cloud to work out it, as shown below:\n\nAfter adding the data point, click \"Apply\" as shown in the figure below to complete entire data point creation work for the product.\n\n2.3 Application configuration\nTake the \"Openapi\" personal project as an example, click on Service - Application Configuration - Add New Application, as shown below:\n\nAfter filling in the application name which can be cusomizable, select Android for the platform, click Add, as shown below:\n\nThen a new application will appear. Note that App ID is an important parameter to be used by the subsequent HTTP request, as shown below:\n\n3. Postman installation and import\n1) Go to the official website to download the latest postman client.\nPostman official website: https://www.getpostman.com\n2) After the registration is done, there only exists Postman own Echo in the left collections pane. You need to click “import” in the upper left corner, or follow the Open API documentation in the documentation center to proceed. For example, you can fill in such fields like url, header, key and value in the body according to the request type. \n\n3) Choose to import the prepared requests, as shown below:\n\nFill in Import From Link:\nhttps://www.getpostman.com/collections/d6c5981977683526877f\nThen click “import” and the folder shown below will appear:\n\n4. Use Postman for HTTP requests\nSteps:\n\n4.1 Obtaining User_token via anonymous login POST request\nFirst, use the anonymous login with POST request to obtain the Token. App ID can be found in section 2.3) Application configuration. Fill in the App ID in the Headers page, and phone_id in the Body page. Then click “Send” to send request, the result will pop up in the bottom box. If you get User_token in the Body, the request is successful, as shown below:\n\n\n4.2 Obtain did and passcode of virtual device\nGo to the Personal Project - Virtual Device, click “start virtual device”, get the virtual device did and passcode as shown below:\n\n\n4.3 Bind device through POST request with did and passcode\nChoose to use the POST request with did and passcode to bind the device. Fill in App ID and User_token obtained before in Headers, and above did and passcode in Body. If returning success, the binding is successful, as shown below:\n\n\n4.4 Bind device through POST request with MAC (Note: this step can be skipped if above step is successful)\nChoose to use the POST request with MAC to bind the device. Fill in the App ID and User_token obtained before in the Headers. The Timestamp is a Unix timestamp (its expiration time is 5 minutes). You can get Signature using MD5 encryption method {MD5 (product_secret+X-Gizwits-Timestamp).lower()}. Fill in the product_key and the device MAC in the Body, then click “send”. If the action is successful, you will find that the device is online as shown below:\nNote: The links for obtaining Timestamp and Signature are\n\nUnix timestamp\nMD5 encryption\n\n\n\n\n\n4.5 List bound devices through GET request to check device online/offline state\nChoose “Get request for listing bound devices”. Fill in App ID and User_token in the Headers. Click “Send”, then a JSON string will be returned. The value of \"is_online\" is true to indicate that the device is online, as shown below:\n\n4.6 Control device remotely through POST Request\nChoose “Control devices remotely through POST Request”. Fill in the App ID and User_token in the Headers, device ID (did) at the end of Url and the data point name and its value in the Body with JSON format. Click “Send”, and return empty to indicate success, as shown below:\n\n\n4.7 Verify whether the device is under control\nReturn to the personal project, and you can find that the Boolean data point named Led_onoff of the virtual device has been set to true according to the communication log, as shown below:\n\n"},{"title":"Generating device QR code for App binding","url":"/en-us/UserManual/UseQRCode.html","content":"Overview\nA QR code scanning API for App binding is reserved in the Gizwits App SDK, which can be used to directly bind devices by App through scanning the GPRS devices (or Wi-Fi devices). This article describes how to generate the device QR code through the API.\nSteps\n1. Navigate to the QR Code Generation Website\nOpen this URL in your browser http://qrcode.gizwitsapi.com:1800/doc/\n2. Enter the authorization code\nClick \"Authorize\" in the upper right corner, enter \"G\" in the dialog box that pops up, and click the \"Authorize\" button.\n \n3. Enter PK and MAC Address\nOpen the “Create QR Code Generation Task” API.\n \nEnter product_key and the MAC address sequence used to generate QR code.\n \n4. Generate QR code\nClick “Try it out!” to create a generation task. If it returns 201, the QR code is generated successfully.\n \n5. Query the generated QR code\nOpen the \"Query All QR Code Generation Tasks\" API.\n \nEnter product_key, click \"Try it out!\" to query the generation task.\n \nThe generated results include the relative path of the file download URLs.\n \n6. Download the QR code\nIn the browser, enter the full URL (http://qrcode.gizwitsapi.com:1800/+ URL in the figure above) to download the generated QR code images. \nThe download URL in this case is: \nhttp://qrcode.gizwitsapi .com:1800/static/zipfiles/1474.zip\n \nThe downloaded QR code is packaged in a zip file, as shown below.\n \n7. Binding device using App\nAfter decompressing QR code zip file, you can use the Gizwits debugging App to directly scan the QR code and bind the device.\n \nIn the App development, you need to call the device binding API through QR code in the Gizwits App SDK. QR code scanning can be implemented through a third-party framework (such as zxing). You can refer to the Gizwits open source framework code. The specific device binding API call in SDK is as follows, taking Android as an example:\n//Call device binding API\nGizWifiSDK.sharedInstance().bindDeviceByQRCode(user id,user token,QR code);\n//Callback for device binding\nGizWifiSDKListener sdkListener=new GizWifiSDKListener() {\n    @Override\n    public void didBindDevice(GizWifiErrorCode result, String did) {\n        super.didBindDevice(result, did);\n    //Callback for successful binding\n    }\n}\n"},{"title":"Real-time data synchronization demo for SNoti service","url":"/en-us/UserManual/UseSNoti.html","content":"1. Overview\nSNoti provides enterprises with an SSL communication API for pushing device-related events in real time and controlling the corresponding devices.\nNote: Before using the SNoti service, you must first apply for the SNoti service access and set the whitelist.\n\n2. Set up development environment\n2.1. Download Eclipse and JDK\nDownload link:\nHttp://jingyan.baidu.com/article/bea41d435bc695b4c41be648.html\n2.2. Install JDK\nInstallation process:\nHttp://jingyan.baidu.com/article/d7130635194f1513fcf47557.html\n2.3. Install Eclipse\nInstallation process:\nHttp://jingyan.baidu.com/article/d7130635194f1513fcf47557.html\n3. SNoti service Access\n3.1. Access request\nIf you decide to use SNoti for your product, you need to contact Gizwits technical support and provide the following information for the product, including product key and product name.\n \n \n\n3.2. Create credentials\n\n4. Run the demo\n4.1. Download SNoti demo source code\nSNoti demo source code download link:  \nhttps://github.com/gizwits/noti-java-demo/tree/v2.0.0-netty\nGizwits provides two sets of SNoti demo source code:\n\nV2.0.0-netty has a framework with its own dependency libraries.\nV2.0.0 has no framework, which will be explained below. Download it as shown below:\n\n \n4.2. Update settings in the source code\n\nFind AuthId and AuthSecret as follows:\n\n4.3. Control device\nNote: \n\nIf you attempt to test the virtual device on Gizwits official website, the MAC address should be assigned with virtual:site\nIf you need to access SNoti servers in US East region, the domain name should be changed to ussnoti.gizwits.com\nThe JSON data of issued control instructions follows UTF-8 format\n\n4.3.1. Issue control instructions in V4 product data point format\n\nTypes of writable data points include: Boolean, enumeration, numeric, and extended type. The format is \"name1\": value1, of which \"name1\" refers to the name of the data point, and value1 refers to the value of the data point. The value might be true/false (bool), a Unicode encoded string such as \\u62bd(enum), a number or byte array (such as [23,2,3], for extended type). See the following examples:\n\na. Boolean type, e.g. attrs={\"Switch\":false}\nb. Enumeration types, e.g. attrs={\"Mode\":\"Sleep Mode\"}//If issuing the enumeration type data point value with its original text string directly, it will fail. Thus, check if the format of the delivered text is UTF-8. If not, please send it after conversion. Take attrs={\"Mode\":\"休眠模式\"} as an example, since the delivered JSON data \"休眠模式\" is not in UTF-8 format, it should be converted to attrs={\"Mode\":\"休眠模式\"}. \n\nFollowing online UTF-8 encoder is recommended:\nhttp://tool.chinaz.com/tools/utf-8.aspx\n\n\nc. Numeric type, e.g. attrs={\"Motor_Speed\": 5}\nd. Extended type, e.g. attrs={\"extension\":[1,2,3,4,5,6,7,8,9,0]}\n\n4.3.2. Issue control instructions in V4 product custom format (for transparent transmission without data points)\n(1) Issue SNoti control instructions\n\nThe format for sending raw data looks like this: raw={1,22,33}\nNote: the binary data should be converted to a byte array. If you want to send 010203, it should be\n{\n\"raw\": [1, 2, 3]\n}\nIn general, a protocol payload is a hexadecimal array, such as [0x00, 0x00, 0x1a, ...].\nHere you need to convert it into a decimal array. For example, the payload of decimal 123 is supposed to be raw=[123]\n(2) Device reports its state\nAfter the device receives a control instruction issued by the cloud, the device actively reports its current state.\nFF FF 00 09 05 00 00 00 04 01 02 03 18\nBecause the data received is transparently transmitted, it is base64 encoded, and you have to decode it yourself. \n\n\nOnline base64 decoder link:\n http://www1.tc711.com/tool/BASE64.htm\n4.4. Run Maven project\n(1) Right-click the project, select Run As->Maven Install, and then click Run.\n\n(2) Run cmd.exe and open the target directory. Run java -jar gizwits-noti-demo-2.0.0-jar-with-dependencies.jar\n\n(3) Input rc to issue a control instruction. Check the cloud communication log to see if it succeeds.\nFigure 1: The project uses V4 product data point format to issue a control instruction\n\nFigure 2: The project uses V4 product custom format (transparent transmission without data points) to issue a control instruction\n\n(4) The device actively reports its current state.\nFF FF 00 09 05 00 00 00 04 01 02 03 18\nBecause the data received is transparently transmitted, it is base64 encoded, and you have to decode it yourself.\n\nBase64 decoding as follows\n\n5. Reference guide\nSNoti API:\nhttp://docs.gizwits.com/en-us/Cloud/NotificationAPI.html\n"},{"title":"Control device using Web Socket","url":"/en-us/UserManual/UseWebsocket.html","content":"Overview\nRemote device control with JavaScript in Web page is implemented by calling the open API and Web Socket API of Gizwits. Open API accomplishes operations such as anonymous user login, device binding, and listing bound devices. While Web Socket API accomplishes operations such as user login, device online and offline notification, data exchange between the browser and the cloud (data transparent transmission), heartbeat, and invalid message notification. \n\nWhen the device is successfully connected to the cloud, you can use the following process to control the device:\n\nPreparation\nCall Open API to log in as an anonymous user and bind devices.\n1. Get phone_id\nphone_id can be the unique identifier of user's phone. Otherwise when you already have your own user system and don't want users to sign up for a Gizwits account again, you can use this API to create a corresponding Gizwits anonymous account for each of your users. In this case, phone_id can be the unique identifier of the user in your system. For example, when integrating with WeChat application, phone_id can be set to the openid of the WeChat user.\n2. Create user\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/用户管理/post_app_users\n2.1. Fill in the appid\n\n2.2. Fill in the body\n\n2.3. Log in as an anonymous user and get a token\n\n3. Binding equipment\nPOST request URL:\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/绑定管理/post_app_bind_mac\n3.1. Fill in the appid\n\n3.2. Fill in the returned token when logged as an anonymous user\n\n3.3. Fill in Timestamp, Signature and Body parameters\n\nNote: \n\nTimestamp helper link, http://tool.chinaz.com/Tools/unixtime.aspx\nMD5 helper link, http://tool.oschina.net/encrypt?type=2\n\nAs shown below:\n\nControl device using Web Socket\n1. SDK for Web Socket API\nIts link is as follows:\nhttps://github.com/gizwits/gizwits-wechat-js-sdk\n2. Run index.html\n\n3. Control device using Web Socket\nhttps://gizwits.github.io/gizwits-wechat-js-sdk/v0.2.0.html\n\nControl device in two ways\n1. Standard data point protocol V4\n1.1. Initialize Gizwits WS Object\nThe request parameters are:\n\n\n\nParam\nDescription\nValue\n\n\n\n\napiHost\nGizwits Open API domain\napi.gizwits.com\n\n\ncommType\nStandard data point format protocol\nattrs_v4\n\n\nwechatOpenId\nOpenID of WeChat user (i.e. phone_id)\nString\n\n\ngizwitsAppId\nGizwits application identifier\nString\n\n\n\nInitialize as follows:\n\n1.2. Get a bound device list\nIf you want to obtain the bound device list, first confirm whether the user (i.e. openid) has bound the devices to be controlled.\n\n1.3. Create a Web Socket Connection\nSelect a device to control, and create a Web Socket connection.\n\n1.4. Read the current state of the device\nSelect the connected device and read the current state of the device.\n\n1.5. Control device\nSelect the connected devices and issue control instructions.\nFor example, send the control instruction {\"Swicth\":true} as follows:\n\n\nIf you want to set the value of the extended binary field to hexadecimal value 616263, each byte of the binary string is converted to a decimal element of an array after padding the extended field to the given length\nSet the Boolean type field to true or false\n\n{\n    \"boolean\":true,\n    \"binary\": [97,98,99,0,0,0,0,0,0,0]\n}\nControl the virtual device:\n\n2. Custom format protocol V4\nThe custom format protocol V4 is also called transparent transmission without data points.\n2.1. Initialize Gizwits WS Object\nThe request parameters are:\n\n\n\nParam\nDescription\nValue\n\n\n\n\napiHost\nGizwits Open API domain\napi.gizwits.com\n\n\ncommType\nCustom format protocol\ncustom\n\n\nwechatOpenId\nOpenID of WeChat user (i.e. phone_id)\nString\n\n\ngizwitsAppId\nGizwits application identifier\nString\n\n\n\n\n2.2. Get a bound device list\n\n2.3 Create a Web Socket connection\nSelect a device to control, and create a Web Socket connection.\n\n2.4. Read the current state of the device\nSelect the connected device and read the current state of the device:\n\n2.5. Issue control instructions\nSelect the connected device and issue the control instruction: [0,0,0,3,9,0,0,144,1,0,1,2,3,4] (Note: The instruction payload is decimal, of which 0,0,0,3 is for header, 9 for len, 0 for flag, 0,144 for cmd, 1 for action, 0, 1, 2, 3, 4 for business instruction), as follows:\n\nThe virtual device receives the instruction as follows:\nFF FF 00 0B 03 1E 00 00 01 00 01 02 03 04 37\n\n"},{"title":"App code auto-generator","url":"/en-us/UserManual/devApp.html","content":"Overview\nIn order to lower the barrier for the development of smart hardware App and reduce the investment in development resources, Gizwits has further developed the App open source code that implements the complete functions based on the \"App Open Source Framework\". After creating corresponding data points on the product project, Gizwits cloud generates an App reference code of the corresponding product according to the defined data points.\nThe automatically generated App code modularly integrates the necessary functions of a smart hardware App, mainly including:\n\nUser module: user registration, password recovery, third party anthentication (Wechat, QQ)\nNetwork access configuration (Arilink+SoftAP)\nDevice discovery and list\nDevice control\nPush notification: After the device raises the alarm, the alarm information is pushed to the App. The main push platforms we use are Jiguang Push and Baidu Push.\n\nAfter developers download the source code, they only need to optimize the UI and design the control logic and device control interface. The control page of the source code implements the standard flow of device control using Gizwits SDK. During the secondary development of the App, you only need to optimize related code according to the process to complete the control App of your own product.\nThe App code auto-generator currently supports Andriod, iOS, and APICloud.\nUser Guide\n1. Create an application\n1.1. After creating the product and data points in the Gizwits Developer Center, choose “Application Configuration”.\n\nNote that the naming of data points cannot be a common programming language keywords, such as switch, static, enum, native, etc. Otherwise, the generated code will be incorrect!\n1.2. Choose “New Application” on the Application Configuration page\n\n1.3. Create an Android application and an iOS application separately.\n\n\n\n2. Generate code\n2.1. Check the product secret and copy it to the clipboard.\n\n2.2. Click “Application Development”, select the Android application you just created, paste the product secret you copied, and click “Generate Code Package”.\n\n2.3. After a while, you can download the source code.\n\n2.4. The downloaded source code is a compressed file. After decompression, you can see the related source code.\n\n2.5. For the guide of the source code, please refer to the appendix \"source code explanation\" after decompression!\n\n3. See Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of iOS SDK 2.0 integration\nGuide of Android SDK 2.0 integration\nGuide of APICloud SDK\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process of third-party authentication platform \n\n"},{"title":"Device Grouping API Tutorial","url":"/en-us/UserManual/devgroup_API.html","content":"Overview\nThe device grouping API can group multiple devices. As long as instructions are sent to a device group, multiple devices under the group can be controlled collectively.\nTo use device grouping API, you must first create a group. After creating a group, bind a device with its MAC address, and then add the device to the group with the device did that corresponds to its MAC address in the device log. Then send an instruction to the group. The devices in the group receive the instruction and responds, and device grouping is completed.\nFor example, a company has multiple departments, each of which has multiple smart lights. Every morning anyone of a department comes in, he can just open all smart lights of his department at once. Every evening anyone of a department leaves, all smart lights of his department can be turned off at once.\nDevice grouping API usage\nThe device grouping API is used to group and control multiple devices. When you has set up device grouping API, this API can be called to add multiple devices to a group, so that multiple devices can be controlled collectively.\n1. Open the document center of Gizwits official website -> Cloud API -> OPEN API guide, click any “Debug console” hyperlink.\n\n\n2. Click Device Grouping -> Create a Group\n\n3. Click Create a Group -> Exclamation Point\nFill in App ID and token which can be referred to the section \"2.3 Create Application Configuration\" and \"3. Postman Installation and Import\" in the document \" Using Open API to control virtual device with Postman \". The document link is \nhttp://docs.gizwits.com/en-us/UserManual/UseOpenAPI.html\n\n\n4. Fill in the body after completing the App ID and token\n\n\n5. After getting the group id, check if there is any device in the group\n\n\n6. Bind a device with its MAC address\n\n\nTimestamp helper link\nhttp://tool.chinaz.com/Tools/unixtime.aspx\n\nSignature helper link\nhttp://tool.chinaz.com/Tools/md5.aspx\n\nAfter the device binding is successful, there will be a response body as follows \n\n7. After binding the device, we go back to the device group and add the device to the group\n\n\n8. Check the device log\n\n9. After successfully adding the device to the group, you will get the following response body\n\n10. Then you send instructions to the device group to control the device remotely\n\n11. In this way we can control a device in a group (RGB light on and off). Add multiple devices to a group in the same way, and we can control multiple devices in a group at the same time.\n\n"},{"title":"WeChat application development tutorial","url":"/en-us/WechatDev/WeChatDev.html","content":"WeChat SDK\nWeChat SDK on Github\nGoal-driven tutorial\nThis tutorial is driven by the goal and removes unnecessary details so that Gizwits's friends can quickly access WeChat. Well, let's get started!\nWhy access WeChat?\n\nWeChat has a large number of users.\nUsers are unwilling to install a new application for any vertical domain service.\nWeChat supports the popular operating systems, hence you applications are developed once and run everywhere.\nand more……\n\nBecause of these benefits we will leverage the power of WeChat which is built on two essentials:\n\nUser System (OpenId)\nWechat App (AirKiss and built-in browser)\n\nIn the end, we hope that customers will be able to use our smart devices just like the WeChat native features.\nDo you have a WeChat Official Account?\nFirst of all, we need to apply for a WeChat Official Account.\nNote that you cannot apply for a WeChat subscription account which does not support WeChat authentication. We will apply for a Service Account and complete the verification operation before we can enable the \"Device Function\" module and finally add a product.\nIn the end, you will get two artifacts:\n\nThe original ID of your Official Account\nQR code of your device\n\nOf course, you can also use a test account for debugging in the early stages of development.\nDo you have a device?\nBefore WeChat access, it is necessary to ensure that the device can normally communicate with Gizwits cloud. The detailed development flow of the device is as follows.\n\nNote that when burning AirKiss into the Wi-Fi module, you need to configure the original ID of your WeChat Official Account. In other words, in addition to burning the product_key of Gizwits into the MCU, it is also necessary to write the original ID of your WeChat Official Account into the Wi-Fi module firmware. Regarding the burning of firmware, if you have difficulties, please seek help from Gizwits Customer Service. \nDevice QR code\nThe WeChat App can add a device by scanning its QR code. To enable devices that have been successfully connected to Gizwits Cloud to be controlled by WeChat App, check the following settings when creating a product on the WeChat Official Accounts Platform. The settings are as follows:\n\nChoose \"Wi-Fi\" device for the connection type;\nSelect “Unique QR code for each product model” as the product adding method. After the product is added successfully, WeChat will generate only one QR code for each product model. After scanning this unique QR code, you can perform near-field discovery to bind devices using WeChat App. If you select “unique QR code for each product”, then a QR code will be generated for each product. Scanning the QR code can help directly bind the device, but it cannot bind the device through near-field discovery.\nFor the product configuration mode, choose \"network configuration by WeChat\" and \"Do not use encryption.\"\nDevice authentication\nThe device must not only write the original ID of your official account (note that it is not an APPID) into the Wi-Fi firmware, but also register the MAC address of all devices to the WeChat server. In the beginning, WeChat sets the quota with the limit of 100 devices per user, which means that you can only authenticate 100 devices at most.\nThe authentication method is to send a request to the WeChat API. For details, see WeChat Documentation - Device authentication. \nMany developers share the feedback that their authentication often fails. Here we give a set of examples based on Wi-Fi communication for reference.\n\nNote: The 12 characters of xxxxxxxxxxxx represents the device MAC address, and the id refers to the device ID, which is did of Gizwits. But Gizwits only assign a did value to a device until it comes online, so you cannot predict the value of did in advance. The usual practice is to set both id and MAC to the device MAC address.\nauth_key can be omitted, but set to an empty string, because this field cannot be absent.\nWhen the op_type is 0, it means adding one device, followed by the product_id field (product ID, which is generated after a product is added in the \"device function\" of WeChat Official Accounts Platform). When op_type is 1, it indicates that a device is updated, and the product_id field is omitted at the time.\nWhen performing bulk authentication, remember to update device_num at the top.\nIn this way, the hardware (device) part of preparation are completed.\nPrimary Achievement\nWell, to this point, you can reward yourself a little and enjoy the initial achievement!\nOpen your WeChat (ensure Wi-Fi network access is in use) and scan your product QR code.\n\nThere are two buttons below. The green button is for starting WeChat AirKiss, which sends the Wi-Fi SSID and password to the Wi-Fi module of the device.\nSome devices need to start matching mode at first in order to configure the network access, then perform the configuration on WeChat. After the configuration is complete, it will automatically jump to the device discovery page.\nOn the discovery page, you can certainly find the device (whether it is bound or not) if you are all set to go. Click the discovered device and bind it. WeChat will automatically jump to the page of WeChat Official Account. Then, you can find an additional item on the WeChat settings page: Devices.\nOf course, the above operations are just for binding devices. The following tutorial describes how to monitor the device data points.\nSDK that simplifies the operation\nIn order to simplify the development, we have encapsulated some necessary APIs into two SDKs: java-SDK and js-SDK, which encapsulate the Open API and WebSocket API of Gizwits respectively. They are used for back-end and front-end development.\nThese two SDKs will greatly simplify the operation of the API and help you take over token and user management. We only need to call related operations to bind and unbind devices.\nThese SDKs can be downloaded in the attachment of this article.\nSet up business server\nWhat we need now is to control the devices.\nSince devices can communication with Gizwits Cloud nomally, operations on the devices are actually how to interact with Gizwits Cloud.\nDevice Binding\nNow that you have bound the device in WeChat, you want to see the device online status. How to do?\nWe use WeChat OpenId as a unique identifier to generate an anonymous user. When do you register the anonymous user? When WeChat binds a device, it will push a device binding event message to our business server. At this time, we will simultaneously complete the registration of anonymous users, as well as the user/device binding operation.\n\nWhen WeChat is binding a device, it sends such an event message:\n\nWhat we need are OpenID and MAC, and then we call the operation provided by Gizwits Java-SDK:\nDeviceInfo deviceInfo = OpenApi.bindDevice(\n                                    wechatOpenId,\n                                    gizwitsAppId,\n                                    gizwitsProductKey,\n                                    gizwitsProductSecret,\n                                    Mac,\n                                    deviceAlias,\n                                    deviceRemark)\n\n\n\nParams\nType\nDescription\n\n\n\n\nwechatOpenId\nString\nWeChat OpenId, which is an anonymous user registered in Gizwits\n\n\ngizwitsAppId\nString\nThe ID of the App with which the Gizwits product is associated\n\n\ngizwitsProductKey\nString\nGizwits product key\n\n\ngizwitsProductSecret\nString\nGizwits product secret\n\n\nmac\nString\nDevice MAC address\n\n\ndeviceAlias\nString\nDevice alias\n\n\ndeviceRemark\nString\nDevice notes\n\n\n\nThis operation solves two problems at one time: registering an anonymous user and binding the user and the device. Many parameters have to be set. All parameters are of type String.\nIn which deviceAlias (device alias) and deviceRemark (device notes) can be set with empty string \"\". gizwitsProductKey is the key of the product you created in the Developer Center.\n\nThe gizwitsProductSecret, which is the secret corresponding to the product, can be found in the product details.\n\ngizwitsAppId is the ID of the App in Gizwits cloud. Because a product may be operated by multiple Apps, such as an iOS App, an Android App, a Web App, or even a light App such as WeChat, each of them is considered as a separate App. Therefore, after creating a product, you can also associate one or more Apps for the product. The gizwitsAppId here is the ID of the App that is associated with the product. Note that an App must be associated with the product before it can be used.\nWhen you call this operation, you can register an anonymous user and bind user/device. Is it convenient? Of course, you can further encapsulate this SDK for your convenience. It will not be explained here.\nUnbind Devices\nUnbinding operation is similar as binding operation. When WeChat pushes an unbinding event message, we will perform unbinding operation by calling the following method in the SDK:\nBoolean isSuccess = OpenApi.unbindDevice(wechatOpenId, gizwitsAppId, gizwitsDid);\n\n\n\nParams\nType\nDescription\n\n\n\n\nWechatOpenId\nString\nOpenId in WeChat, which is an anonymous user registered in Gizwits\n\n\ngizwitsAppId\nString\nThe ID of the App with which the Gizwits product is associated\n\n\n\nGet device online status\nBoolean isOnline = OpenApi.getDeviceOnlineStatus(wechatOpenId, gizwitsAppId, gizwitsDid);\n\n\n\nParams\nType\nDescription\n\n\n\n\nwechatOpenId\nString\nOpenId in WeChat, which is an anonymous user registered in Gizwits cloud\n\n\ngizwitsAppId\nString\nThe ID of the App with which the Gizwits product is associated\n\n\ngizwitsDid\nString\nThe device ID in Gizwits cloud, which will be re-registered when the device is reset\n\n\n\nCode sample\nPlease note that some developers might encounter deployment failure on server. Catalina log in tomcat will print:\njavax.net.ssl.SSLException: java.security.ProviderException: java.security.KeyException\nThis is because the SDK uses HTTPS for access.\nThe workaround is: Upgrade the nss library in the server environment.\nControl device on Wechat page\n\nWell, we have now bound the device and can also know the device online status. But how do we control our device? A good user experience of course depends on interactive pages.\nHere we will build an interactive page step by step to monitor our device!\nGet OpenId\nWhen a user navigate to the page, how do we know which user is it? We need to get the current user's OpenId to identify which user it is. How to get it? For details, see the official document of WeChat.\nIn simple terms, we send an authentication request to WeChat's server. WeChat will verify whether the URL we request is an authorized domain name. If the verification is successful, it will be forwarded to our URL with a few parameters.\nThe most important parameter is “code”. We can obtain OpenId through “code”. Then we print OpenId on the page. \n\nWebSocket connection of Gizwits\nFor Gizwits Cloud access with Web Socket, it’s encapsulated into a JS-SDK. you only need to include it on your page.\nInitialize Gizwits service\nThe first is to create a Gizwits service:\n\nThis Gizwits service will be responsible for all the following operations, including: connecting devices, reading device data points, controlling devices, etc.\n\n\n\nParams\nType\nDescription\n\n\n\n\nApiHost\nString\nThe API target domain name of Web Socket\n\n\nCommType\nString\nProtocol format: custom (custom protocol); attrs_v4 (standard data point protocol)\n\n\nwechatOpenId\nString\nWeChat user OpenId\n\n\nGizwitsAppId\nString\nThe ID of the App with which the Gizwits product is associated\n\n\n\nOf course, at this time, the Gizwits service does not run. We also need to initialize it. But before that, we can set a callback function that will execute automatically after the initialization is complete.\n\nWhen gizwits.init() is executed, the Gizwits service is initialized and all devices bound to the anonymous user OpenId are inserted into the array variable “devices” of the callback function. \nWhat we need to do should be written in the callback function gizwits.onInit.\nEach device in the devices list will have six attributes: product_key (product key), dev_alias (device alias), did (device ID), mac, is_online (online/offline state), and remark (device note). We can use them in light of circumstances.\nDevice List\nIn the above step, we have obtained a list of devices. In general, a customer may own multiple devices. Therefore, we can list all devices at this stage. It is up to the user to determine which device to control.\nConnect device\n\nYou can connect to the device that you want to operate on by: gizwits.connect(did). Of course, after the connection is successful, there is also a callback function: gizwits.onConnected. This callback function does not have incoming arguments.\nNote that before connecting the device, it must be initialized at first.\nSince initializing and connecting devices are not synchronous operations, if you simply perform them one after the other, you may get an error. Therefore, it is recommended that the operation of connecting device be placed in the callback function of the initialization method to ensure the execution sequence.\nAfter the connection is successful, you can receive the data reported by the device. The reported data is passed to the callback function: gizwits.onReceivedAttrs, whose format is as follows:\n\n\nRead device data points\nIt is also very simple to get the device data points. You just call the gizwits.read() method and pass in the did to get it immediately. Similarly, the data is obtained through the callback function gizwits.onReceivedAttrs, or gizwits.onReceivedRaw.\nConnection error\nWhen a Web Socket connection error occurs, the gizwits.onError function is called. If necessary, the function can be overridden; the error message is contained in the incoming argument of the callback function:\ngizwits.onError = function(value){\n    Console.log(\"error!!!!:::::\", value.toString());\n}\nDevice comes online/goes offline\nGizwits service will call gizwits.onOnlineStatusChanged callback function when a device comes online or goes offline.\nThe callback function has two arguments: did and on_online.\ngizwits.onOnlineStatusChanged = function(value) {\n    Alert(\"Device oneline/offline notification, did=\", value.did);\n    Alert(\"Device oneline/offline notification, is_online=\", value.is_online);\n}\nControl device\nThe last is the remote control of the device.\nFor the method calls used in remote control, use the method gizwitsws.send(command) if commType=custom, and the method gizwitsws.write(command) if the commType=attrs_v4.\nFor the method argument value, if commType=custom, enter p0, for example [,,...]; if commType=attrs_v4, enter datapoints, for example {\"power\":true}.\nThe following is a code example of controlling a RBG lamp:\nvar command = '{\"LED_R\": 0, \"LED_G\": 0, \"LED_B\": 0}';\ngizwits.write(did, JSON.parse(command));\nOf course, the premise of controlling devices is that we have connected a device to Gizwits cloud.\nConclusion\nAt this point, we have already achieved the core part of WeChat access. In this tutorial, Java-SDK and js-SDK help us a lot. We almost do not need to worry about how to call Gizwits cloud API as well as Web Socket operations, but directly call the SDK methods.\nFinally, I hope you can give more feedback so as to help us offer a more convenient development environment. \n"},{"title":"Learn about WeChat application development","url":"/en-us/WechatDev/WechatDevIntro.html","content":"Development Process\n1. Overview\nIf you need to use WeChat Official Accounts as the end user interface, you can read this document to understand how to develop it with the help of Gizwits, WeChat Official Accounts Platform and WeChat hardware platform. Since device connection and control based on WeChat Official Accounts involve interactions across multiple platforms, it is necessary to have a clear understanding of the role of each platform.  \n2. Overall access flowchart\n\n3. Gizwits Cloud\nAs shown in Figure 1, in the WeChat access scenario, the device function is defined through the graphical interface of the developer center (site.gizwits.com). Gizwits Cloud automatically generates a serial port communication protocol between the device MCU and the communication module. The device connectivity can be accomplished according to the communication protocal.\nAs shown in Figure 2, when devices connect to Gizwits Cloud, Gizwits provides API for WeChat applications, which supports the functions of sending device data to applications and issuing instructions from applications to devices.\n4. Private server\nThe Private server is a Web system that is independently deployed by developers to run its own WeChat application. The system uses the API provided by the Gizwits platform to perform real-time communication with device data and control in order to satisfy the need of device connection and serve the end users through WeChat channel by accessing the API of WeChat Official Accounts Platform. \nFirst of all, developers can design personalized HTML with interactive UI and functions for their own applications. (As shown in Figure 3 and 4)\n5. WeChat server\nThe WeChat server mainly provides a set of APIs for the communication between the device and the private server, which mainly includes binding/unbinding WeChat user account with devices, and receiving/sending device messages. For the API details, refer to the WeChat official documents. WeChat recently launched the WeChat hardware platform. Before implementing WeChat access, you need to go through WeChat Official Accounts Platform and WeChat hardware platform, which are subject to continuous update.\n6. WeChat client\nThe WeChat client provides an UI that interacts with end users. It can be thought of as a browser running on a mobile phone, which is just running under WeChat Official Accounts Platform. Developers can configure custom menus through WeChat Official Accounts Platform.\nLearn about WeChat\nLearn about WeChat Official Accounts Platform\nFor details, please refer to WeChat Official Accounts Platform\nFAQ\n1. What is Gizwits Web Socket API service?\nGizwits Web Socket API service is a set of APIs developed to meet the needs of device remote control, real-time display of device state based on HTML5 applications such as WeChat Official Accounts. The Web Socket API is mainly used to make up for the shortcomings of the HTTP protocol. It can transfer device data to web pages and display them in real time.\n2. What is the difference between Web Socket protocol and HTTP?\nThe HTTP is short-lived one-way communication initiated by the client to send requests to the server.\nWeb Socket is long-lived two-way communication, both server and client can send data actively.\n3. If the device is not successfully bound, can the device instructions be sent out by the Web Socket API?\nFor the device not successfully bound, the device instructions could not be successfully sent out.\n4. Which encoding schema is used by device control API that communicates with server?\nUTF-8 encoding schema. Non-ASCII characters in enumeration values of data points should be encoded in Unicode explicitly. \n5. Are there any detailed descriptions of parameters in the device control API protocol?\n\ndid: The did of the target device. \nattr: attribute value. \nraw: custom content.\n\ndid is in the result of device registration using Open API.\n\nThe value of attr is based on the definition of data points.\nThe value of raw is based on the p0 protocol.\n\nWeb Socket is just a form of m2m communication. Therefore, its parameters are the same as the corresponding parameters defined in the Open API. \n6. Does Web Socket API support SSL communication?\nYes.\n"},{"title":"FAQ on Cloud Application Development","url":"/en-us/cloud/CloudFAQ.html","content":"1. Overview\nThis article lists some of the problems that developers might face when using the development platform and APIs of Gizwits cloud, or carrying out web development and backend development and their solutions.\n2. FAQ\nQ: How long can the device log data under a project be retained in the cloud?\nA: The device log and history log in the cloud can be retained for 7 days.\nQ: How many data points can be added for one product key?\nA: Currently, there is no limit on the server side. 200 data points work properly according to test feedback.\nQ: Can the product key be modified?\nA: After the project is created, pk cannot be modified. If you want to change pk, you can export data points into a template, and then re-create a new project and import the template into it.\nQ: Do Open API and Web Socket API support SSL communication?\nA: Yes.\nQ: When the device is disconnected. Why do the cloud and App still show the device online for a while?\nA: The device may be abnormally disconnected due to various unexpected issues such as power failure, crash, and network disconnection. The default value of TCP keepalive is 2 minutes or so. \nQ: Under what circumstances will device online event reappear in the device log?\nA: When the module reconnects to the cloud during a heartbeat interval, the log in the cloud will print that the device goes online. It usually happens when debugging manually, or network reception being poor.\nQ: How to confirm whether OTA is successful?\nA: After the OTA, re-power the module and check the software version number of the module. If it shows the OTA version number, the OTA is successful. Even though the cloud shows that the OTA has failed, it is still successful as long as the version number is new.\nQ: Why is the error 9999 returned when calling the cloud Open API update user information?\nA: The Open API will return error 9999 when the new information to be updated is the same as the original.\nQ: Why does the prompt \"it is not the same series of firmware\" appear when performing OTA for GAgent?\nA: Because the hardware version number you provided is not correct. First, check the hardware version number of the GAgent to be upgraded, and then re-enter it into the firmware verification information.\nQ: When it is not able to upgrade the device Wi-Fi firmware via OTA, why does it upgrade again after re-power?\nA: The device will check whether the firmware version needs to be upgraded every time it restarts. If the device meets the upgrade requirements, even if the first upgrade fails, the device will perform upgrade again once the device is rebooted until the device is successfully upgraded.\nQ: What API can be used to obtain device data with web pages?  What are the differences among Open API, Web Socket API, and SNoti?\nA: All these three APIs can be used. The difference is that Open API is an HTTP request that is executed asynchronously (and involves interfaces such as user management, device sharing, and device grouping etc.). Web Socket API is capable of monitoring a single device in real time, and SNoti is able to monitor multiple devices in real time.\n"},{"title":"SNoti API","url":"/en-us/cloud/NotificationAPI.html","content":"v2.1.9\nOverview\nEnterprise users can ingest data from globally dispersed devices in real time through the secure data transmission channel provided by SNoti, which can be used to classify and organize device information, device status statistics, and device monitoring. SNoti enables you to send business instructions to control devices online in real time by remote control functions.\nClient Samples (Open Source Community Edition)\nThe user can choose any version of the following language-specific clients as appropriate for secondary development, or as a reference based on this.\n\nClient sample for Java\n\nCode repository: https://github.com/Bestfeel/noti-netty-client\n\n\nClient sample for Ruby\n\nCode repository: https://github.com/AbelLai/gizwits_sac_rb\n\n\nClient sample for Python\n\nCode repository: https://github.com/wangzhenandy/snoti_client_python\n\n\nClient demo for Java (Basic Edition)\n\nCode repository: https://github.com/gizwits/noti-java-demo/tree/v2.0.0\n\n\nClient demo for Java (Netty Framework Edition)\n\nCode repository: https://github.com/gizwits/noti-java-demo/tree/v2.0.0-netty\n\n\n\nRequest to access SNoti service\n\nThe enterprise developer signs in to the developer center and chooses “Add service”, as shown below\n \n\nClick “SNoti service” pointed by the arrow in the figure above to go to the next step and request to access the service\n \n\nAfter successfully adding the SNoti service, click “Create credentials on the service page. The auth_id has permission to obtain all device messages and control devices under the product.\n \n\n\nTerms\n\nauth_id & auth_secret: Product authentication ID and secret. A product can have multiple auth_id. One auth_id corresponds to a unique product. When the SNoti client logs in, it verifies the validity of auth_id and auth_secret.\nsubkey: using message distribution mechanism, with ProductKey + subkey as the only primary key, messages among different primary keys do not affect each other (ie, the same ProductKey uses a different subkey, can generate a message copy); subkey (subscription key) is a custom character string, case sensitive, 1 to 32 characters in length, which can contain numbers, letters, and underscores (ie [a-zA-Z0-9]);\nThe 12 message types (event_type) of the product are:\ndevice.online: device comes online \ndevice.offline: device goes offline\ndevice.status.raw: device reports a custom transparent transmission business instruction\ndevice.status.kv: device reports business instructions of data point type\ndevice.attr_fault: device fault events\ndevice.attr_alert: device alarm events\ndatapoints.changed: data point change events\ncenter_control.sub_device_added: central controller adds child devices\ncenter_control.sub_device_deleted: central controller deletes child devices\ndevice.bind: device binding messages\ndevice.unbind: device unbinding messages\ndevice.reset: device reset messages\ndevice.file.download: device file download messages\n\n\n\nWorkflow\nEvents are pushed through SSL protocol. The communication process is as follows:\n\nThe client establishes an SSL connection with this API (Gizwits Platform). The client does not need to provide a certificate, just trust the server certificate;\nThe client sends a login instruction to complete the verification;\nThe server pushes messages to the client in several ways as following:\nMultiple client login connections with the same product_key + subkey, messages are pushed to each client in turn; \nClients with the same product_key but different subkeys can receive copies of the specified message type from devices under the product. Clients do not interfere with each other.\nWhen the number of ack messages that the client has not sent out reaches the prefetch_count value of the client's login settings, messages will not be pushed to the client but will be sent to other clients.\nFor those messages without returned ack messages, the server will stop resending and wait. Only if the client is disconnected, they will be resent to connected clients.\nAfter all clients are disconnected, subsequent device messages are retained on the server and wait for the clients to receive them next time.\n\n\nClients receive event messages in real time and sends ack messages to the server.\nWhen the client does not send any message to the server within a certain time range, it needs to send a ping heartbeat request and the server responds to the pong heartbeat response.\nThe client can send remote control instructions to control the device. The SNoti service caches the M2M information corresponding to each product_key when the client logs in, which is used to send control instructions to the device. Note that when the product is officially released, it is necessary to restart SNoti clients to update the M2M information.\n\nAPI Specification\n\nDomain name: snoti.gizwits.com\nSSL service Port: 2017\n\nThe message payload is binary data, UTF-8 encoded. Please note that \"\\n\" must be added as a message suffix after each message.\n1. Connection and login\nAfter the client establishes an SSL connection with the Gizwits platform, the client sends the following string for authentication (login to the Gizwits platform):\n{\n\"cmd\": \"login_req\",\n\"prefetch_count\":<uint> (0 < prefetch_count <= 32767, indicates the maximum number of messages without ACKs. The default value is 50.)\n\"data\": [{\n“product_key\": <key string>,\n\"auth_id\": <auth_id string>,\n\"auth_secret\": <auth_secret string>,\n\"subkey\": <subkey string>,\n\"events\":[<event string>,...] (One or more events)\n},...] (One or more products)\n}\\n\nRequest parameters:\n\n\n\nParam\nRequired\nDescription\n\n\n\n\ncmd\nYes\nLogin type, must be login_req\n\n\nprefetch_count\nNo\nThe default value is 50\n\n\ndata.product_key\nYes\nProduct ID\n\n\ndata.auth_id\nYes\nProduct authentication ID\n\n\ndata.auth_secret\nYes\nProduct authentication secret\n\n\ndata.subkey\nYes\nSubscription key, a custom identifier for the client. It is case-sensitive with a length of 1 to 32 characters. It can contain numbers, letters, and underscores.\n\n\ndata.events\nYes\nThe message types received by clients, using a comma-separated list of strings, currently supporting device.attr_fault;device.attr_alert;device.online;device.offline device.status.raw;device.status.kv;datapoints.changed center_control .sub_device_added;center_control.sub_device_deleted device.bind;device.unbind;device.reset;device.file.download\n\n\n\nResponse from Gizwits platform：\n{\n\"cmd\": \"login_res\",\n\"data\": {\n\"result\": true | false,\n\"msg\": \"ok\" | <error msg>\n}\n}\\n\nIf result is false, the login failed and the connection will be closed.\n2. Heartbeat\nAfter an SSL connection is established between the client and the Gizwits platform, it is necessary to periodically send data to the Gizwits platform to maintain the validity of the connection. If no data is sent to the Gizwits platform within 5 minutes, the following heartbeat data should be sent to the Gizwits platform:\n{\n\"cmd\": \"ping\"\n}\\n\nResponse from Gizwits platform：\n{\n\"cmd\": \"pong\"\n}\\n\nIf you do not receive the reply of Gizwits platform in time, you can assume that the connection with Gizwits platform is closed and you need to reconnect.\n3. Device control\nAfter the client establishes an SSL connection with the Gizwits platform, the client can send the following string to control the device:\n{\n\"cmd\": \"remote_control_req\",\n\"msg_id\": <msg id string>,\n\"data\": [{\n“cmd\": \"write_attrs\" | \"write\" | \"write_v1\",\n\"data\": {\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"product_key\": <product_key string>,\n\"attrs\": {\n\"name1\": <value1>,(\"name1\" refers to the name of the data point, and <value1> refers to the value of the data point. The value can be true/false (bool), Unicode-encoded string such as \\u62bd(enum), numbers, or byte arrays (eg [23,2,3] for extended types))\n\"name2\": <value2>,\n… …\n}(Only used with cmd \"write_attrs\")\nOR\n\"raw\": [<byte>, <byte>, <byte>, … ...](Only used with cmd \"write\" or \"write_v1\")\n}\n},...] (One or more instructions)\n}\\n\nRequest paramters:\n\n\n\nParam\nRequired\nDescription\n\n\n\n\ncmd\nYes\nUsed to control device, must be remote_control_req\n\n\nmsg_id\nNo\nIdentify this message and will be returned in response message\n\n\ndata\nYes\nControl instruction, array type\n\n\ndata.cmd\nYes\nFor V4 product data point protocol format, fill in write_attrs; For V4 product custom protocol format, fill in write; For V1 product protocol format, fill in write_v1\n\n\ndata.source\nYes\nFixed value: noti\n\n\ndata.data.did\nYes\nDevice ID\n\n\ndata.data.mac\nYes\nDevice MAC address, length of 12 characters, case sensitive\n\n\ndata.data.product_key\nYes\nID of the product to which the device belongs\n\n\ndata.data.attrs / data.data.raw\nYes\nFor V4 product data point protocol format, choose data.data.attrs; For V4 product custom protocol format (refer to the business instructions transparent transmission of common data point protocol), choose data.data.raw; For V1 product protocol format, choose data.data. Raw \n\n\n\nResponse from Gizwits platform：\n{\n\"cmd\": \"remote_control_res”,\n\"msg_id\": <msg id string>,\n“result\": {\n\"succeed\": [\"did1\", \"did2\", … …]\n\"failed\": [\n{\"did3\": <reason str>}\n{\"did4\": <reason str>}\n… …\n]\n}\n}\\n\nThe value of msg_id is from the content of the msg_id field in the request message. If the field does not exist in the request message, this field will not appear in the reply message.\nIf the protocol itself incurs an error, Gizwits platform gives out an error response message. The message format is described below.\n4. Push events\nData point change event\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"datapoints_changed\",\n\"product_key\": <product_key string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\nDevice online event\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"device_online\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>，\n\"ip\": <ip string>,\n\"country\": <country string>,\n\"region\": <region string>,\n\"city\": <city string>\n}\\n\nDevice offline event\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"device_offline\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\nFault and alarm event\nWhen there are fault and alarm events, Gizwits platform will push the following message to the client:\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"attr_fault\" | \"attr_alert\",\n\"event_id\": <uuid string>, (The occurrence event and the recovery event of the fault or alarm of the same device share the same event id)\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>,\n\"data\": {\n\"attr_name\": <data point identification of the fault or alarm>,\n\"attr_displayname\": <data point display name of the fault or alarm>\n\"value\": 0 | 1 (0 means fault recovery or alarm cancellation, 1 means a fault or alarm occurred)\n}\n}\\n\nDevice state event\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"device_status_raw\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>,\n\"data\": <base64 encoding string> (base64 encoded string of raw data for device state)\n}\\n\nIf the product supports data point interpretation (Gizwits common data point protocol or custom data point protocol), the message format is:\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"device_status_kv\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>,\n\"data\": {\n<key1 string>: <value1>,\n<key2 string>: <value2>,\n...\n}\n}\nEvent for central controller adding child devices\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"sub_device_added\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"child_product_key\": <product_key string>,\n\"child_did\": <did string>,\n\"child_mac\": <mac string>,\n\"child_passcode\": <str, AES encrypted, see below>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\n\nchild_passcode uses AES encryption,\nAES complement mode is pcks7padding\nAES key is the md5 value of the central controller passcode (16 bytes)\nAES mode is AES.MODE_ECB\n\nEvent for central controller deleting child devices\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": “sub_device_deleted”,\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n            \"child_product_key\": <product_key string>,\n\"child_did\": <did string>,\n\"child_mac\": <mac string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\nDevice binding/unbinding event\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"device_bind\" | \"device_unbind\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"app_id\": <app_id string>,\n\"uid\": <uid string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\nDevice reset event\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"device_reset\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\nDevice file downloading event\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(For ACK)\n\"event_type\": \"device_file_download\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"download_url\": <download_url string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\nEvent ACK\nEvery time the client receives an event message, it needs to reply with the following ACK message:\n{\n\"cmd\": \"event_ack\",\n\"delivery_id\": <delivery_id> (According to the original data type)\n}\\n\nIf the Gizwits platform does not receive a response from the client, the event is repeatedly pushed until the Gizwits platform receives an ACK or it expires. In general, events are pushed in order of occurrence time. When prefetch_count > 1, there may be retransmission due to an event without ACK and therefore the event does not arrive in chronological order. For example, the event of failure recovery or alarm cancellation is received first. Hence, client developers should compare the value of event_id and created_at when processing.\n5. Error response\nGizwits platform returns the following message when the message sent by the client is not recognized by Gizwits platform:\n{\n\"cmd\": \"invalid_msg\"\n“error_code”: <code int>\n\"msg\": <msg string>\n}\\n\nThe client developer should check whether the message sent by the client is correct (Note: If the client does not add \"\\n\" at the end of the message, the server will consider that it has not received the complete message and continue to wait for more) .\nsubkey Management\nWhen in use, it is necessary to pay attention to what subkeys are currently used, and to clean up the subkeys that are no longer used as soon as possible to avoid unnecessary waste of resources. Acquisition and deletion of subkey are accomplished using HTTP API request.\n\nDomain name: snoti.gizwits.com\nHTTP API port: 2018\n\n1. Get subkey\nhttp://swagger.gizwits.com/doc/index/snoti_api_operator#!/product/get_v1_products_product_key_subkey\n2. Delete subkey\nhttp://swagger.gizwits.com/doc/index/snoti_api_operator#!/product/delete_v1_products_product_key_subkey\nFAQ\n1. What format need the device data to be received by SNoti client follow?\na. For devices not using data point protocol, the data with protocol command words 0x0091, 0x0093, 0x0094 can be transparently transmitted to SNoti client;\nb. For devices using common data point protocol, the protocol command word shall accommodate 0x0091, 0x0093, and 0x0094. Besides, the first command word of business instructions shall accommodate one of the following:\n\n0x04, business instructions need to follow data point format\n0x06, transparent transmission of business instructions\n\n2. When the SNoti client controls the device, which part of the Gizwits protocol does the raw instruction sent out reside in?\nThe Raw instruction refers to all instructions following the protocol command word 0x0090, excluding 0x0090. It is worth noting that the Raw instruction begins with 0x05 when using common data point transparent transmission.\n3. After the device is offline, the SNoti client sends instructions to the device. When the device comes online again, can it receive those instructions?\nNo.\n4. What does the [0-255] of the Raw instruction mean? Must it be decimal? If it is negative, how to deal with?\nThe integer range that a byte (1B) in the protocol can represent is: unsigned integer 0~255 or signed integer -128~127. In the SNoti protocol, an unsigned integer is used to represent a single byte. Some programming languages convert signed positive integer to unsigned integer with: result = bytes & 0xff.\n5. Can SNoti be used in the project with a central controller?\na. SNoti does not distinguish whether the product type is a central controller, but only needs to apply for the product auth_id;\nb. When you need to receive data of the central control gateway, use the auth_id corresponding to the central control gateway product;\nc. When you need to receive data of the child device, use the auth_id corresponding to the child device product.\n6. Are clients with different subkeys under the same product_key able to receive message pushed by SNoti?\nYes, different queues will be created for different subkeys which are independent of each other. Therefore, when data needs to be pushed to the clients, all clients of different subkeys can receive the push message, provided that the clients of the subkeys have set event listeners for the message when logging in. \n"},{"title":"Web Socket API","url":"/en-us/cloud/WebsocketAPI.html","content":"Demo\nhttps://github.com/gizwits/gizwits-wechat-js-sdk\nCommunication Model\nBrowsers (JavaScript) can communicate directly with Gizwits cloud via the Web Socket API. Thus browser (JavaScript) can control the device and receive device reported data through the Web Socket API.\n\nCommunication process\nThe communication between JavaScript and the cloud with Web Socket API mainly includes the following steps.\n\nUser login: The user logs in to the cloud through the uid and token obtained from the HTTP API.\nReceiving device online and offline state messages: The device can be controlled only after the device is bound.\nSend and receive device data.\nHeartbeat: The browser (JavaScript) periodically sends heartbeats to the cloud, and the cloud responds to heartbeat.\n\nAgreement\n1. Tips\n<str> represents a string placeholder, and <int> represents an integer placeholder.\n2. Web Socket service address\nws://<host>:<ws_port>/ws/app/v1 (unencrypted connection)\nwss://<host>:<wss_port>/ws/app/v1 (encrypted connection)\nOf which  is the value of the host field in the bound device list, <ws_port> is the value of the ws_port field in the bound device list, and <wss_port> is the value of the wss_port field in the bound device list. See the HTTP API of Get bound device list.\n3. Notes\n\nBefore the Web Socket interaction with the cloud, the user must be registered and have already bound the device.\nThe data that interacts with the cloud follows JSON format and is encoded in UTF-8. You can use JSON.stringify(json) to convert JavaScript objects into strings and send them to the cloud, or convert the received string data into JavaScript objects via var res = JSON.parse(evt.data).\nThe Web Socket test program should use http://<m2m_host>:8080/app (<m2m_host> is the value of the host field in the bound device list). You can also view the source code of this web page as an example for reference.\n\nSpecification\n1. User login\nBrowsers (JavaScript) must log in for further interaction with the cloud.\nBrowser ⇒ Cloud. The browser sends the following JSON string to the cloud.\n{\n    \"cmd\": \"login_req\",\n    \"data\":\n    {\n        \"appid\": <str>,\n        \"uid\": <str>,\n        \"token\": <str>,\n        \"p0_type\": \"attrs_v4\"|\"custom\", (\"attrs_v4\" refers to the interaction with the cloud through standard data point protocol, see the \"Standard data point operations\" section below. \"custom\" means to use a custom business logic protocol to interact with the cloud. See the \"Browser and cloud data exchange\" section below.)\n        \"heartbeat_interval\": <int>, (Heartbeat interval in seconds. The value must be less than or equal to 180)\n        \"auto_subscribe\": true | false (True means that after the login is successful, the server automatically subscribes to all the bound devices; if false, you need to select the devices to be subscribed to through the following \"User subscribes to device messages\" API. The default value is true. Recommend to set to false, then subscribe the devices as needed to save costs)\n    }\n}\nCloud ⇒ Browser. The cloud responds to the browser with the following JSON string.\n{\n    \"cmd\": \"login_res\",\n    \"data\":\n    {\n        \"success\": true | false （True for successful login, false for failed login）\n    }\n}\n2. User subscribes to device messages\nUsers can receive device-related messages only if they have subscribed to the bound device messages. This API only applies to scenarios where the login parameter auto_subscribe is set to false.\nBrowser ⇒ Cloud. The browser sends the following JSON string to the cloud so as to subscribe device messages.\n{\n    \"cmd\": \"subscribe_req\",\n    \"data\":\n    [\n        {\"did\": <str> },（did of the first device to be subscribed to）\n        {\"did\": <str> },（did of the second device to be subscribed to）\n        ……\n    ]\n}\nCloud ⇒ Browser. The cloud sends the following JSON string to the browser to return the results.\n{\n    \"cmd\": \"subscribe_res\",\n    \"data\":\n    {\n        \"success\":\n        [\n            {\n                \"did\": <str>,（corresponding to the first device did）\n                \"error_code\": 0,（0 for success）\n                \"msg\": <str>（description）\n            },\n            {\n                \"did\": <str>,（corresponding to the second device did）\n                \"error_code\": 0,（0 for success）\n                \"msg\": <str>（description）\n            },\n            ……\n         ],\n         “failed”:\n         [\n            {\n                \"did\": <str>,（corresponding to the first device did）\n                \"error_code\": <int>,（error code of failed subscription）\n                \"msg\": <str>（description）\n            },\n            {\n                \"did\": <str>,（corresponding to the second device did）\n                \"error_code\": <int>,（error code of failed subscription）\n                \"msg\": <str>（description）\n            },\n            ……\n         ]\n    }\n}\n3. Get notified when device goes offline or comes online\nWhen the device goes online or offline, the cloud will send a notification to the browser.\nCloud ⇒ Browser. The cloud sends the following JSON string to the browser to notify the browser that the device goes online or offline.\n{\n    \"cmd\": \"s2c_online_status\",\n    \"data\":\n    {\n        \"did\": <str>,（did of the device goes offline or comes online）\n        \"passcode\": <str>,（passcode of the device goes offline or comes online）\n        \"mac\": <str>,（mac of the device goes offline or comes online）\n        \"online\": true | false （true for online，false for offline）\n    }\n}\n4. device state change notification for binding/unbinding\nAfter the device is bound or unbound by the user, the cloud sends this message to notify the browser.\nCloud ⇒ Browser. The cloud sends the following JSON string to the browser to notify that a binding or unbinding event has occurred.\n{\n    \"cmd\": \"s2c_binding_changed\",\n    \"data\":\n    {\n        \"did\": <str>, (device did)\n        \"bind\": true | false (true for binding, false for unbinding)\n    }\n}\n5. Data exchange between browser and cloud (data transparent transmission)\nThe browser can exchange with the cloud any data that conforms to the protocol. Be sure to refer to the API documentation for full details about the protocol format.\nPlease note that when the user logs in with the parameter \"p0_type\" set to \"custom\", data can only be exchanged with the cloud in this way.\nBrowser ⇒ Cloud. The browser sends the following JSON string to the cloud.\n{\n    \"cmd\": \"c2s_raw\",\n    \"data\":\n    {\n        \"did\": <str>, （target device did）\n        \"raw\": [<byte>, <byte>, ...] (The contents of custom business logic instructions, which are transmitted in byte arrays. The range of each byte must be 0~255. The content must begin with [0, 0, 0, 3, varLen(1~4B), 0, 0, 144])\n    }\n\n}\nIf you want the cloud to forward data to the device, the raw value needs to add the following protocol prefix and then concatenate the data sent to the device, i.e., [0, 0, 0, 3, varLen(1 ~ 4B), 0, 0, 144] + Data sent to the device, where varLen is a variable length, and represents the number of bytes with 1~4 bytes (B) after the variable length field until the end of the packet. If the length is less than 128B, directly with one byte (B) to indicate the length. For the encoding and decoding method with the length of 128B or more, refer to the definition of the Remaining Length of the MQTT V3.1 protocol. cmd can be 0x90/0x93/0x94 and so on.\nCloud ⇒ Browser. After the cloud receives the data uploaded by the device, the cloud forwards the following JSON string to the browser. The data is passed in the raw field. Note that even if the value of the login parameter \"p0_type\" is set to \"attrs_v4\", the data command reported by the device with the “business instruction via transparent transmission” or the operation command related to central control will also be sent to the browser with this command.\n{\n    \"cmd\": \"s2c_raw\",\n    \"data\":\n    {\n        \"did\": <str>,（source device did）\n        \"raw\": [<byte>, <byte>, ...] (The contents of custom business logic instructions, which are transmitted in byte array. The range of each byte must be 0~255)\n    }\n}\nIf the data is reported by the device, the raw value will have a prefix, i.e., [0, 0, 0, 3, varLen(1~4B), 0, 0, 145] + device data, where varLen is a variable length. For its definition, please refer to above. cmd can be 0x91/0x93/0x94 and so on.\n6. Standard data point operations (read, write, notification, ACK)\nWhen the user logs in with the parameter \"p0_type\" set to \"attrs_v4\", the cloud will interact with the browser in the way of the standard data point protocol.\nBrowser ⇒ Cloud. The browser sends the following JSON string to the cloud to read the current state of the target device. It is not allowed to use this instruction when the value of the parameter \"p0_type\" is set to \"custom\".\n{\n    \"cmd\": \"c2s_read\",\n    \"req_sn\": <int>, (Optional, if there is a value, indicates that it is a business instruction with ACK by transparent transmission [0x0093], if not, it is a business instruction without ACK by transparent transmission[0x0090])\n    \"data\":\n    {\n        \"did\": <str>,（target device did）\n        \"names\": [<str>, <str>, …] （optional for data points with variable length: Pass in the names of the data points to be read, omit to read all data points; For read operation of data points with fixed length, ignore this parameter）\n    }\n}\nBrowser ⇒ Cloud. The browser sends the following JSON string to the cloud to control the target device (changing the state of the target device). It is not allowed to use this command when the value of login parameter \"p0_type\" is set to \"custom\".\n{\n    \"cmd\": \"c2s_write\",\n    \"req_sn\": <int>, (Optional, if there is a value, indicates that it is a business instruction with ACK by transparent transmission [0x0093], if not, it is a business instruction without ACK by transparent transmission[0x0090])\n    \"data\":\n    {\n        \"did\": <str>,（target device did）\n        \"attrs\":\n        {\n            \"name1\": <value1>, (\"name1\" refers to the name of the data point, and <value1> refers to the value of the data point, which can be true/false (Boolean), Unicode-encoded string like \\u62bd (enumeration), number (numeric), byte array [23,2,3] (extension type))\n            \"name2\": <value2>,\n            ...\n        }\n    }\n}\nCloud ⇒ Browser. After the device receives the read command or the state changes, it will actively send the current state to the cloud, and the cloud forwards the following JSON string to the browser. When the login parameter \"p0_type\" is set to \"custom\", this instruction will not be received.\n{\n    \"cmd\": \"s2c_noti\",\n    \"req_sn\": <int>, (Optional. If the device sends a business instruction with ACK via transparent transmission [0x0093], this field is required. Then the browser must reply with c2s_ack and the value of this field. res_sn and req_sn parameters cannot coexist at the same time)\n    \"res_sn\": <int>, (Optional. If the c2s_read or c2s_write request command sent by the browser has the req_sn parameter, the corresponding response command s2c_noti contains the res_sn field and its value is consistent with req_sn. res_sn and req_sn parameters cannot coexist at the same time)\n    \"data\":\n    {\n        \"did\": <str>,（source device did）         \n        \"attrs\":\n        {\n            \"name1\": <value1>, (\"name1\" refers to the name of the data point, and <value1> refers to the value of the data point, which can be true/false (Boolean), Unicode-encoded string like \\u62bd (enumeration), number (numeric), byte array [23,2,3] (extension type))\n            \"name2\": <value2>,\n             ...          \n        }\n    }\n}\nCloud ⇒ Browser. After the browser sends a read or write command with req_sn [0x0093], it may receive ACK 0x0094 for the transparent transmission command from the device, and the cloud forwards the following JSON string to the browser. This instruction is not used when the value of login parameter \"p0_type\" is set to \"custom\".\n{\n    \"cmd\": \"s2c_ack\",\n    \"res_sn\": <int>, (corresponding to the req_sn value of the browser read or write instruction)\n    \"did\": <str>(device did)\n\n}\nBrowser ⇒ Cloud. After the browser receives the s2c_noti message with req_sn [0x0093], the browser is required to send the following JSON string [0x0094] to the cloud. It is not allowed to use this command when the value of login parameter \"p0_type\" is set to \"custom\".\n{\n    \"cmd\": \"c2s_ack\",\n    \"res_sn\": <int>, (corresponding to the req_sn value of s2c_noti instruction received by the browser)\n    \"did\": <str>(target device did)\n\n}\n7. Heartbeat\nAfter a Web Socket connection is established between the browser and the cloud, the heartbeat needs to be periodically sent to the cloud within the time interval specified by the login parameter \"heartbeat_interval\". The cloud will reply to the heartbeat after receiving it.\nBrowser ⇒ Cloud. The browser sends the following JSON string to the cloud.\n{\n    \"cmd\": \"ping\"\n}\nCloud ⇒ Browser. The cloud responds to the browser with the following JSON string.\n{\n    \"cmd\": \"pong\"\n}\n8. Invalid message notification\nWhen the browser sends an invalid message to the cloud or the data reported by the device is invalid, the cloud sends this message to inform the browser.\nCloud ⇒ Browser. The cloud sends the following JSON string to the browser to notify that there is an invalid message.\n{\n    \"cmd\": \"s2c_invalid_msg\",\n    \"data\":\n    {\n        \"error_code\": <int> (error code)\n        \"msg\": <str> (description)\n    }\n}\n"},{"title":"Enterprise Application Development","url":"/en-us/cloud/ent_dev.html","content":"Overview\nEnterprise applications refer to the specific business management functionality by using the obtained data from those devices connected to Gizwits cloud in order to satisfy enterprises’ operation and management needs for devices and device users. Usually, in the process of enterprise application development, not only does it need to retrieve the data of the connected devices through the Gizwits cloud platform, but it also needs to control the devices and carry out statistical analysis of the device data using the enterprise APIs, which allows you to focus on the overall business applications.  \nSNoti service\nThe SNoti service is a real-time device message transmission service. This service can push enterprises’ device data to enterprise application systems in real time, which helps your organization to achieve business requirements based on the device data.\nSNoti service capabilities\n\nBased on message publish-subscribe model\n40-50ms of average device data transmission time \nSupports simultaneous requests from multiple clients\nSupports SSL transmission\nDevice messages are cached for 3 days by default, which can be customized on your behalf\nProvides monitoring and early warning of device messages\n\nEnterprise API\nThe Enterprise API is based on the operation and management requirements of the enterprise connected to the Gizwits cloud platform. Using the data generated by the enterprise in the Gizwits cloud platform, it provides companies with device management, data analytics, and other functions at the enterprise level and with a holistic viewpoint, which allows you to focus on business management system itself and reduce unnecessary development costs and time.\nUser cases\nEV Charger SaaS Platform\nThe EV charger SaaS platform provides charging station operators with finding electric stations, booking, charging, and payment for electric vehicle owners. The operator manages charging stations, faults, orders, billing rules and settlement through an operation management platform powered by the EV charger SaaS platform for its daily business in a closed loop, which greatly improves the operational efficiency.The EV chargers is connected to Gizwits, and the EV charger SaaS platform needs to obtain the data of the chargers in real time. Based on these data, it can calculate the charge and whether there is a fault. These device data are collected by the Gizwits PaaS platform and sent to the EV charger SaaS platform in real time through the SNoti service.The EV charger SaaS platform can also perform statistical analysis through the enterprise open API, such as the location query, communication log, and fault query of the charging stations.\nUsage-based Rental Management System\nThe business of the usage-based rental management system is similar to that of the EV charger SaaS platform, which covers the car rental, bicycle rental. The operators need to build a usage-based rental management system to fulfill the necessary functions such as order, settlement and payment. \nWhen cars and bicycles are connected to Gizwits, the operators do not need to invest in the device connection, they can access the SNoti service through related protocols to obtain device data for business development. \nDevelopment Process\nSNoti service access\n1. Access request\n\nThe SNoti service is usually open to enterprise developers. If you need real-time data ingested into Gizwits PaaS platform for secondary development, please apply to Gizwits.\nSNoti services are generally used together with enterprise API services, so enterprise developers also need to apply for enterprise API services.\n\n2. Learn about the protocol\nFor details, see SNoti service protocol.\n3. Get access parameters\nLog into the developer center and obtain the account and secret key for the enterprise to access the SNoti service and the enterprise API. Choose \"Company Information\" as shown below.\n\nChoose your organization on the left, and then click \"API configuration\" to get Eid, Esecret. You can also set the IP white list here. If you do not set the IP white list, the messaging service will fail to authenticate.\n\nIf it is in the development environment, the enterprise developers need to get the external network IP address corresponding to the development environment through some tools, which can be obtained through ip.taobao.com, and the identified IP address is supposed to be copied to the white list in the above figure. Only one IP address can be set in each line. For a production environment, the system allows multiple source IP addresses to be set to access the message service.\n4. On-demand implementation of the client\nAccording to the Demo Code, the enterprise can start the development of the client functions based on its own requirements. The Demo Code can be used as a prototype to implement the business logic after capturing the device data, such as: \n\nParse JSON messages pushed by SNoti service\nPublish the captured message in real time to the queue to which the enterprise application belongs and perform asynchronous operations;\nThe data can also be written into the database directly after it is parsed. However, a data cleaning mechanism on a periodic basis needs to be established. \n\n5. Simulate a real device to push data through a virtual device\nIf the enterprise does not have any real device connected to Gizwits yet, it can use the virtual device to simulate it.\n\nStart Demo Code, provided that it has been modified as the correct product_key, auth_id and auth_secret\nDefine data points under the product\nAfter the approval, you can start the virtual device and simulate the data, click \"Push\"\nDemo Code will print device state pushed by SNoti service in real time\n\nUsing Enterprise API\n1. Apply for enterprise API service\nEnterprise developers log into the developer center and choose “Add services”, as shown below.\n\nClick on the enterprise API in the red box above and jump to the next step.\n\n2. Get parameters\nLog into developer center and choose \"Company Information\" as shown below.\n\nSelect the organization for which you have permissions on the left, and then click \"API configuration\" to get Eid, Esecret, and also set IP white list here.\n\n3. Learn about the protocol\nAfter the approval of using enterprise API, the enterprise can make calls according to the enterprise API protocol.\nEnterprise API can be found here.\n"},{"title":"Enterprise API","url":"/en-us/cloud/enterprise_api.html","content":"Overview\nThe Enterprise API is an open API service for those enterprise who has already connected to Gizwits cloud platform and want to go further to bring device data into some vertical industry in order to unlock its business insights. Using the data generated by the enterprise in the Gizwits cloud platform, it provides companies with device management, data analytics, and other functions at the enterprise level and with a holistic viewpoint, which allows you to focus on business management system itself and reduce unnecessary development costs and time.\nAPIs\nBased on the services powered by Gizwits, Enterprise API accomplishes following functions:\n\nAuthorization: Get a token for enterprise developers. \n\n\n\n\nAPI List\nDescription\n\n\n\n\npost_v1_products_product_key_access_token\nGet required access permissions that the caller has on Enterprise API\n\n\n\n\nProduct Management: Get product data points.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_v1_products_product_key_datapoint\nGet data point information for a given product\n\n\n\n\nUser Management: Search for registered users and binding users etc.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_v1_products_product_key_users_search\nSearch for registered user information \n\n\nget_v1_users_search\nSearch for binding user information\n\n\n\n\nDevice Management: Get device did, device details, device enumeration, device online and offline records, communication logs, historical data in 2 days by default and control remote devices etc.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_v1_products_product_key_devices\nGet device did\n\n\nget_v1_products_product_key_device_detail\nGet device details\n\n\nget_v1_products_product_key_devices_search\nEnumerate devices\n\n\nget_v1_products_product_key_devices_did_data\nGet KV value of a given device in 2 days by default \n\n\nget_v1_products_product_key_devices_did_online\nGet device online and offline records\n\n\nget_v1_products_product_key_devices_did_cmd\nGet device raw instructions of a given device in 2 days by default\n\n\npost_v1_products_product_key_devices_did_control\nControl a device remotely \n\n\n\n\nDevice Grouping: Create a device group, list all devices of a device group, delete a device group, update a device group and list all MACs under a given device group etc.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_v1_products_product_key_device_groups\nGet the device group tree structure of a given product\n\n\npost_v1_products_product_key_device_groups\nCreate a device group\n\n\ndelete_v1_products_product_key_device_groups_gid\nDelete a device group\n\n\nget_v1_products_product_key_device_groups_gid\nList all MACs under a given device group\n\n\nput_v1_products_product_key_device_groups_gid\nUpdate a device group\n\n\n\n\nBinding Management: Bind and unbind devices.\n\n\n\n\nAPI List\nDescription\n\n\n\n\npost_v1_products_product_key_devices_bindings\nBind devices\n\n\ndelete_v1_products_product_key_devices_bindings\nUnbind devices\n\n\n\n\nDevice Reporting: Provides device activation reports, geographical distribution, overview, activation details, activity details, device faults, and device alarm reports.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_v1_products_product_key_devices_report_activation\nGet device activation statistics report\n\n\nget_v1_products_product_key_devices_locations\nGet device geographical distribution\n\n\nget_v1_products_product_key_summary\nThe number of recent activations and active devices\n\n\nget_v1_products_product_key_incr_devices\nCustom query for activated device details\n\n\nget_v1_products_product_key_active_devices\nCustom query for active device details\n\n\nget_v1_products_product_key_devices_report_liveness_history\nQuery historical reports of active devices by day, week, and month\n\n\nget_v1_products_product_key_devices_report_rt\nQuery device status report\n\n\nget_v1_products_product_key_fault_report_devices\nGet faulty device report\n\n\nget_v1_products_product_key_alert_report_devices\nGet alarm device report\n\n\nget_v1_products_product_key_fault_report_events\nGet device fault report\n\n\nget_v1_products_product_key_fault_alert_events\nGet device alarm report\n\n\n\n\nUser Reporting：Provides new user report, active enterprise user report, geographical distribution of users, and total number of users.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_v1_products_product_key_users_report_new\nThis refers to the new users who has bound the product with its PK\n\n\nget_v1_users_liveness_total\nActive enterprise users\n\n\nget_v1_users_location\nUser geographical distribution\n\n\nget_v1_products_product_key_users_report_total\nThe total number of users\n\n\n\nSpecification\n1. Request methods\nThe APIs defined in this document is based on the HTTP/HTTPS protocol. Please note the request methods marked in the protocol which perform different actions through GET, PUT, and DELETE.\n2. Request URL\nThe variables included in each API URL with the ${ } need to be substituted altogether for the corresponding variables. For example, ${product_key} indicates that the product_key value needs to be assigned to the API URL, ${token value} indicates that it needs to be replaced by the token obtained through the authorization API, and ${did} indicates that it needs to be replaced with the specific did value.\n3. Request parameters\nThe types of HTTP request parameters are generally categorized into three types, the names of which are Header, URL path and Body. Header indicates that the parameter is in the HTTP request header; the URL path indicates that the parameter is passed in the URL path; Body indicates that it is in the request body, and usually accepts data in JSON format.\n4. HTTP request header\nThose APIs of device management and device reporting in this document should be accessed with the token at the request header to verify whether the caller has the permission on it. The token value is obtained by the authorization API.\nThe request header requires the following format.\nContent-Type: application/json\nAuthorization: token ${token value}\nNote: The ${} should be excluded from the ${token value}, just add the token value next to the token. For example: Authorization: token efbekskdklllsF\n5. HTTP response header\nIf the action is successful, the service sends back a response which looks like this:\nX-RateLimit-Limit: 60     //Request limit \nX-RateLimit-Remaining: 56 //Remaining visits\nX-RateLimit-Reset: 1372700873 //Request frequency reset time, TS type\n6. Token lifecycle\nThe Token value is valid for 7 days. The expired_at field returned by the authorization API is the expiration timestamp. If the current timestamp > expired_at timestamp, you need to re-acquire the token using \"Get an access token\".\n7. Request quota\nEnterprise API allows you to make 3600 requests in one hour by default. The request will fail if it exceeds the request limit. After one hour, the API call is resumed. For details, see the system error code 5013 in the error code table.\nOnline debugger\nWe provide Enterprise API debugging tools. The corresponding debug link is given in each API description.\nThe following example uses user management to illustrate the use of API debugging tools:\n\nClick user management to enter the API debugging page\nThere is a red exclamation mark on the right side of the API. After clicking it, a dialog box pops up prompting for the required header information.\nThe API needs to enter the X-Gizwits-Application-Id, get the AppID according to the previous instructions and fill it in, click \"Authorize\" to authorize\nThe page is automatically refreshed and the exclamation mark turns blue, indicating that the required header information has been filled in (filled does not necessarily indicate that the value is correct. If the value is incorrect, the corresponding result will be returned in the response)\nEnter the parameter value in the input box (click the Example Value yellow box to the right of the parameter to enter the sample JSON quickly)\nClick the \"Try\" button to complete the API request\nThe request completes, displaying the equivalent curl statement of local call, request URL, response body, response code, and response header\n\nAuthorization\nGet an access token\nDebug console\nRequest method and URL\nPOST\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/access_token\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\nenterprise_id\nstring\nYes\nbody\nEnterprise ID\n\n\nenterprise_secret\nstring\nYes\nbody\nEnterprise secret\n\n\nproduct_secret\nstring\nYes\nbody\nProduct secret\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntoken\nstring\nUser token\n\n\nexpire_at\ninteger\nToken expiration time (timestamp)\n\n\n\nExample response\n{\n  \"token\": \"89d753a234ef42cd90f75da7489e78a4\",\n  \"expired_at\": 1517897923\n}\nProduct Management\nGet product data points\nDebug console\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/datapoint\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nname\nstring\nProduct name\n\n\nentities\nArray\n[EntitiyList]\n\n\nprotocolType\nstring\nFixed value: standard\n\n\nproduct_key\nstring\nProduct key\n\n\npacketVersion\nstring\nFixed value: 0x00000004\n\n\nui\ninline_model_7\nMobile client UI definition \n\n\nEntitiyList\n——————\n——————\n\n\nid\ninteger\nFixed value: 0\n\n\nname\nstring\nFixed value: entity0\n\n\ndisplay_name\nstring\nFixed value: Gizwits development kit\n\n\nattrs\nArray\n[AttrItem]\n\n\ninline_model_7\n——————\n——————\n\n\nobject\ninline_model_1\n\n\n\nsections\nArray\nUI section list:[SectionItem]\n\n\nAttrItem\n——————\n——————\n\n\nid\ninteger\nData point order\n\n\nname\nstring\nData point name\n\n\ndisplay_name\nstring\nData point display name\n\n\ndesc\nstring\nFixed value: …..\n\n\ntype\nstring\nRead/write type, W: Read/write, R: Read only, N: Alarm, E: Fault\n\n\ndata_type\nstring\nData type, bool: Boolean type; 'uint8', 'uint16', 'uint32': numeric type; enum: enumeration type; binary: extended type]\n\n\nuint_spec\ninline_model_4\nThis field is available when data_type is uint8/uint16/uint32 \n\n\nenum\nArray\nThis field is available when data_type is enum\n\n\nposition\ninline_model_5\nByte and Bit position description\n\n\ninline_model_1\n——————\n——————\n\n\nversion\ninteger\nFixed value: 4\n\n\nshowEditButton\nboolean\nFixed value: false\n\n\nSectionItem\n——————\n——————\n\n\nelements\nArray\n[ElementItem]\n\n\ninline_model_4\n——————\n——————\n\n\nmin\ninteger\nMinimum value\n\n\nmax\ninteger\nMaximum value\n\n\nratio\nnumber\nRatio k\n\n\naddition\ninteger\nIncrement\n\n\ninline_model_5\n——————\n——————\n\n\nbit_offset\ninteger\nBit index, fixed to 0 if it’s a variable length protocol\n\n\nlen\ninteger\nlength\n\n\nunit\nstring\nUnit, 'bit’, ‘byte’\n\n\nbyte_offset\ninteger\nByte index, fixed to 0 if it’s a variable length protocol\n\n\nElementItem\n——————\n——————\n\n\ntitle\nstring\nData point display name\n\n\nkey\nstring\nentity0.{Data point name}\n\n\ntype\nstring\n‘QBooleanElement’, ‘QFloatElement’, ‘QRadioElement’, ‘QMultilineElement’, ‘QLabelElement’\n\n\nkeyboardType\nstring\nKeyboard type, fixed value: ,\"NumbersAndPunctuation\"\n\n\nmaxLength\ninteger\nThis field is only available for type QMultilineElement, the maximum length, which is 2 times the defined length of the data point.\n\n\nitems\nArray\nThis field is only available for type QRadioElement, enumeration value list\n\n\nboolValue\nboolean\nThis field is only available for type QBooleanElement, fixed value: false\n\n\nbind\nstring\nThis field is only available for type QFloatElement, fixed value: floatValue:float\n\n\nmaximumValue\nnumber\nThis field is only available for type QFloatElement, the maximum value\n\n\nminimumValue\nnumber\nThis field is only available for type QFloatElement, the minimum value\n\n\nvalue\ninteger\nThis field is only available for type QFloatElement. fixed value: 0\n\n\nobject\ninline_model_6\n\n\n\ninline_model_6\n——————\n——————\n\n\naction\nstring\nFixed value: entity0\n\n\nbind\nArray[string]\nFixed value: entity0.{data point name}\n\n\nperm\nstring\nRead/Write type: W: Read/Write, R: Read Only, N: Alarm, E: Fault\n\n\nunit_spec\ninline_model_2\nThis field is only available for type QFloatElement\n\n\ninline_model_2\n——————\n——————\n\n\nmax\ninteger\nThe maximum value\n\n\nstep\ninteger\nStep value\n\n\nmin\ninteger\nThe minimum value\n\n\n\nExample response\n{\n  \"name\": \"微信宠物屋\",\n  \"entities\": [\n    {\n      \"id\": 0,\n      \"display_name\": \"机智云开发套件\",\n      \"attrs\": [\n        {\n          \"display_name\": \"开关\",\n          \"name\": \"switch\",\n          \"data_type\": \"bool\",\n          \"position\": {\n            \"bit_offset\": 0,\n            \"len\": 1,\n            \"unit\": \"bit\",\n            \"byte_offset\": 0\n          },\n          \"type\": \"status_writable\",\n          \"id\": 0,\n          \"desc\": \".....\"\n        }\n      ],\n      \"name\": \"entity0\"\n    }\n  ],\n  \"protocolType\": \"standard\",\n  \"product_key\": \"4244bf2d79694a259232431b6f2ef46a\",\n  \"packetVersion\": \"0x00000004\",\n  \"ui\": {\n    \"object\": {\n      \"version\": 4,\n      \"showEditButton\": false\n    },\n    \"sections\": [\n      {\n        \"elements\": [\n          {\n            \"boolValue\": false,\n            \"object\": {\n              \"action\": \"entity0\",\n              \"bind\": [\n                \"entity0.switch\"\n              ],\n              \"perm\": \"W\"\n            },\n            \"type\": \"QBooleanElement\",\n            \"key\": \"entity0.switch\",\n            \"title\": \"开关\"\n          }\n        ]\n      }\n    ]\n  }\n}\nUser Management\nSearch for registered users\nThis API is used to search for registered user information. \nDebug console\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/users/search\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Enterprise-ID\nstring\nYes\nheader\nenterprise id\n\n\nX-Gizwits-Enterprise-Secret\nstring\nNo\nheader\nenterprise secret\n\n\nproduct_key\nstring\nYes\nquery\nProduct key\n\n\nappid\nstring\nNo\nquery\nApplication ID\n\n\nusername\nstring\nNo\nquery\nUser name\n\n\nphone\nstring\nNo\nquery\nMobile phone number\n\n\nemail\nstring\nNo\nquery\nEmail address\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned records, 20 by default \n\n\nskip\ninteger\nNo\nquery\nThe number of skipped records, 0 by default\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nThe total number of records\n\n\nlimit\ninteger\nThe number of records returned\n\n\nskip\ninteger\nThe number of skipped records\n\n\nprevious\nstring\nPrevious page request address\n\n\nnext\nstring\nNext page request address\n\n\nuid\nstring\nUser ID\n\n\nusername\nstring\nUser name\n\n\nphone\nstring\nMobile phone number\n\n\nemail\nstring\nEmail address\n\n\nbirthday\nstring\nBirthday date\n\n\nis_anonymous\nboolean\nWhether it is an anonymous user\n\n\ngender\nstring\nGender\n\n\naddress\nstring\nAddress\n\n\nremark\nstring\nNotes\n\n\ncreated_at\ninteger\nCreation time\n\n\nupdated_at\ninteger\nUpdate time\n\n\n\nExample response\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 20,\n    \"limit\": 20,\n    \"next\":null\n  },\n  \"objects\": [\n    {\n      \"username\": null,\n      \"remark\": null,\n      \"uid\": \"25a5324c807842348f63ade277eb413a\",\n      \"is_anonymous\": true,\n      \"gender\": null,\n      \"created_at\": 1513135417,\n      \"updated_at\": 1513135417,\n      \"phone\": null,\n      \"birthday\": null,\n      \"address\": null,\n      \"email\": null\n    }\n  ]\n}\nSearch for binding users\nDebug console\nThis API is used to search for binding user information.\n\nOnly returns the device's owner permissions when searching by device did, true: has ownership, false: does not have ownership\n\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/users/search\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nGroup ID\n\n\ntype\nstring\nNo\nquery\nType\n\n\nval\nstring\nNo\nquery\nQuery condition value\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned records \n\n\nskip\ninteger\nNo\nquery\nThe number of skipped records\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nThe total number of records\n\n\nlimit\ninteger\nThe number of returned records \n\n\nskip\ninteger\nThe number of skipped records\n\n\nprevious\nstring\nPrevious page request address\n\n\nnext\nstring\nNext page request address\n\n\nuid\nstring\nUser ID\n\n\nusername\nstring\nUser name\n\n\nphone\nstring\nMobile phone number\n\n\nemail\nstring\nEmail address\n\n\nbirthday\nstring\nBirthday date\n\n\naddress\nstring\nAddress\n\n\nremark\nstring\nNotes\n\n\ncreated_at\ninteger\nCreation time\n\n\nis_anonymous\nboolean\nWhether it is an anonymous user\n\n\nauth_src\nobject\nThird-party authentication information\n\n\nis_owner\nboolean\nOnly returns the device's ownership when searching by device did, true: has ownership, false: does not have ownership\n\n\n\nExample response\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 30,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"username\": null,\n      \"remark\": null,\n      \"uid\": \"2ac80784a695a5f88f63ade277eb413a\",\n      \"is_anonymous\": true,\n      \"gender\": null,\n      \"created_at\": 1513135417,\n      \"auth_src\": null,\n      \"phone\": null,\n      \"birthday\": null,\n      \"address\": null,\n      \"email\": null,\n      \"name\": null\n    }\n  ]\n}\nDevice Management\nGet device did\nDebug console\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\nmac\nstring\nYes\nquery\nMAC address\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ndid\nstring\nDevice ID\n\n\n\nExample response\n{\n  \"did\": \"cBYkSjoE2xspYMhaUHdk5k\",\n  \"passcode\": \"123456\"\n}\nGet device details\nDebug console\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/device_detail\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\nmac\nstring\nYes\nquery\nMAC address\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nproduct_key\nstring\nProduct key\n\n\nmac\nstring\nMAC address\n\n\ndid\nstring\nDevice ID\n\n\nis_online\nboolean\nWhether the device is online, True means online, False means offline\n\n\nis_disabled\nboolean\nWhether the device is logged off, True means logged off, False means not logged off\n\n\ntype\nstring\nDevice type\n\n\n\nExample response\n{\n  \"did\": \"dE2xjocBhaUHkYkSspYM5k\",\n  \"is_disabled\": false,\n  \"product_key\": \"6f2e214bf2d79649232431b94a25f46a\",\n  \"mac\": \"virtual:site\",\n  \"is_online\": false,\n  \"type\": \"normal\"\n}\nEnumerate devices\nDebug console\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/search\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nDevice group ID\n\n\ncountry\nstrin\ng    No\nquery\nCountry\n\n\nregion\nstring\nNo\nquery\nProvince\n\n\ncity\nstring\nNo\nquery\nCity\n\n\nis_online\ninteger\nNo\nquery\nWhether the device is online, 1 means online, 0 means offline\n\n\nis_faulty\ninteger\nNo\nquery\nWhether a fault exists, 1 means yes, 0 means no\n\n\nis_alert\ninteger\nNo\nquery\nWhether an alarm exists, 1 means yes, 0 means no\n\n\nshow_disabled\ninteger\nNo\nquery\n1 means to display logout devices, and 0 means to filter out logout devices\n\n\nliveness_start\nstring\nNo\nquery\nMost recently active timestamp\n\n\ntype\nstring\nNo\nquery\nIts value can be did, mac, uid\n\n\nval\nstring\nNo\nquery\nQuery condition value\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned records \n\n\nskip\ninteger\nNo\nquery\nThe number of skipped records\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nThe total number of records\n\n\nlimit\ninteger\nlogout \n\n\nskip\ninteger\nlogout \n\n\nprevious\nstring\nPrevious page request address\n\n\nnext\nstring\nNext page request address\n\n\ndid\nstring\nDevice ID\n\n\nmac\nstring\nMAC address\n\n\nis_online\ninteger\nWhether the device is online\n\n\ncountry\nstring\nCountry\n\n\nregion\nstring\nProvince\n\n\ncity\nstring\nCity\n\n\nlongitude\nstring\nLongitude\n\n\nlatitude\ninteger\nLatitude\n\n\nis_faulty\ninteger\nWhether a fault happens\n\n\nis_alert\ninteger\nWhether an alarm happens\n\n\nonline_latest\ninteger\nThe device most recently online time\n\n\ncreated_at\ninteger\nDevice creation time\n\n\nmcu_hard_version\nstring\nMCU hardware version\n\n\nmcu_soft_version\nstring\nMCU software version\n\n\nwifi_hard_version\nstring\nWi-Fi hardware version\n\n\nwifi_soft_version\nstring\nWi-Fi software version\n\n\n\nExample response\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 3,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"city\": \"Guangzhou\",\n      \"mcu_hard_version\": null,\n      \"mcu_soft_version\": null,\n      \"did\": \"kYkSE2xspYjocBhaUHdM5k\",\n      \"country\": \"China\",\n      \"region\": \"Guangdong\",\n      \"mac\": \"virtual:site\",\n      \"longitude\": 113.280637,\n      \"wifi_hard_version\": null,\n      \"online_latest\": 1517296665,\n      \"wifi_soft_version\": null,\n      \"is_online\": false,\n      \"latitude\": 23.125178,\n      \"is_alert\": false,\n      \"created_at\": 1505789918,\n      \"is_faulty\": false\n    }\n  ]\n}\nDevice remote control\nDebug console\nRaw instructions (raw):\nThe default format is a decimal array. The binary_coding parameter can be set as hex and base64.\nIf you want to send a payload of binary 011000010110001001100011, after every byte of the binary string is converted to a decimal, you will get an array: [97,98,99];\nIf you want to send a payload of hexadecimal 616263, after every byte of the binary string is converted to a decimal, you will get an array: [97,98,99].\n{\n  \"raw\": [97,98,99]\n}\nData point (attrs):\nDevice products must have defined data points. If you want to set the value of the extended field binary to hexadecimal 1234567, you need to pad the extended field to the given length:\nThe default type of the extended field is hex16, and base64 can be used to set the binary_coding parameter as well.\n{\n  \"attrs\": {\n    \"binary\": \"1234567000\"\n  }\n}\nRequest method and URL\nPOST\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/{did}/control\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ndid\nstring\nYes\npath\nDevice ID\n\n\nraw\nArray[integer]\nYes\nbody\nRaw instruction method\n\n\nattrs\nobject\nYes\nbody\nData point method\n\n\n\nResponse parameters\nNo\nGet device online and offline records\nDebug console\nThis API is used to query online and offline records for any two days in the last 7 days.\nTime & Sorting:\n\nIf start_ts and end_ts fields are not filled, it is to query the communication log records within the past two days in the default way.\nThe interval between start_ts and end_ts must be within two days\nIt support sorting with the sort field, it is descending order by default. Pass in asc for ascending order, desc for descending order\n\nThe offline reason of the device (reason)\n\nmqtt_disconnect: The device actively disconnected from mqtt\nno_heartbeat: m2m did not receive any device heartbeat during the KeepAlive period\nTcp_closed: The device actively terminated tcp connections\nssl_closed: The device actively terminated the ssl connection\noffline_force: The device goes online again and the original connection is terminated \noffline_reset: The device is logged out and disconnected\noffline_exception: Abnormal disconnection\noffline_sending_density_overflow: The client sent the message too often and disconnected\noffline_sending_data_size_overflow: The client sent too much traffic and disconnected\n\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/{did}/online\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ndid\nstring\nYes\npath\nDevice did\n\n\nstart_ts\ninteger\nNo\nquery\nStart timestamp\n\n\nend_ts\ninteger\nNo\nquery\nEnd timestamp\n\n\nsort\nsort\nNo\nquery\nIts value can be desc or asc\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned records \n\n\nskip\ninteger\nNo\nquery\nThe number of skipped records\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nThe total number of records\n\n\nlimit\ninteger\nThe number of returned records \n\n\nskip\ninteger\nThe number of skipped records\n\n\nprevious\nstring\nPrevious page request address\n\n\nnext\nstring\nNext page request address\n\n\ntimestamp\ninteger\nDevice online/offline instruction received time\n\n\ntype\nstring\nDevice log types, such as: dev_online/dev_offline, etc.\n\n\npayload\nstring\nDevice raw log\n\n\nKeepAlive\ninteger\nHeartbeat interval specified by the device (in seconds)\n\n\nduration\ninteger\nOnline duration of the device (unit: seconds)\n\n\ncount\ninteger\nThe number of heartbeats sent when online\n\n\nmax\ninteger\nMaximum interval\n\n\nmin\ninteger\nMinimum interval\n\n\navg\ninteger\nAverage interval\n\n\nlast\ninteger\nThe time span between the last time the heartbeat was received and the offline time\n\n\nreason\nstring\nOffline reason\n\n\n\nExample response\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 5,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"timestamp\": 1517384124.229,\n      \"type\": \"dev_online\",\n      \"payload\": {\n        \"keep_alive\": 130\n      }\n    },\n    {\n      \"timestamp\": 1517298056.201,\n      \"type\": \"dev_offline\",\n      \"payload\": {\n        \"duration\": 1391,\n        \"heartbeat\": {\n          \"count\": 21,\n          \"max\": 60,\n          \"avg\": 60,\n          \"last\": 130,\n          \"min\": 60\n        },\n        \"reason\": \"no_heartbeat\"\n      }\n    }\n  ]\n}\nGet device communication log\nDebug console\nThis API is used to query device communication log for any two days in the last 7 days (raw data).\nTime & Sorting:\n\nIf start_ts and end_ts fields are not filled, it is to query the communication log records within the past two days in the default way.\nThe interval between start_ts and end_ts must be within two days\nIt support sorting with the sort field, it is descending order by default. Pass in asc for ascending order, desc for descending order\n\npayload：\n\npayload is base64-encoded for binary.\n\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/{did}/cmd\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ndid\nstring\nYes\npath\nDevice did\n\n\nstart_ts\ninteger\nNo\nquery\nStart timestamp\n\n\nend_ts\ninteger\nNo\nquery\nEnd timestamp\n\n\nsort\nsort\nNo\nquery\nIts value can be desc or asc\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned records \n\n\nskip\ninteger\nNo\nquery\nThe number of skipped records\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nThe total number of records\n\n\nlimit\ninteger\nThe number of returned records \n\n\nskip\ninteger\nThe number of skipped records\n\n\nprevious\nstring\nPrevious page request address\n\n\nnext\nstring\nNext page request address\n\n\ntimestamp\ninteger\nDevice online/offline instruction received time\n\n\ntype\nstring\nDevice log types, such as: dev2app/app2dev, etc.\n\n\npayload\nstring\nDevice raw log\n\n\n\nExample response\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 6,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"timestamp\": 1517384252.294,\n      \"type\": \"app2dev\",\n      \"payload\": \"0000000309000090010101000010\"\n    },\n    {\n      \"timestamp\": 1517384243.044,\n      \"type\": \"dev2app\",\n      \"payload\": \"000000030b0000910401000010000000\"\n    }\n  ]\n}\nGet device history data\nDebug console\nThis API is used to query device communication log for any two days in the last 7 days (JSON format).\nTime & Sorting:\n\nIf start_ts and end_ts fields are not filled, it is to query the communication log records within the past two days in the default way.\nThe interval between start_ts and end_ts must be within two days\nIt support sorting with the sort field, it is descending order by default. Pass in asc for ascending order, desc for descending order\n\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/{did}/data\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ndid\nstring\nYes\npath\nDevice did\n\n\nstart_ts\ninteger\nNo\nquery\nStart timestamp\n\n\nend_ts\ninteger\nNo\nquery\nEnd timestamp\n\n\nsort\nsort\nNo\nquery\nIts value can be desc or asc\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned records \n\n\nskip\ninteger\nNo\nquery\nThe number of skipped records\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nThe total number of records\n\n\nlimit\ninteger\nThe number of returned records \n\n\nskip\ninteger\nThe number of skipped records\n\n\nprevious\nstring\nPrevious page request address\n\n\nnext\nstring\nNext page request address\n\n\nts\ninteger\nDevice instruction received time\n\n\nattrs\nobjects\nData points\n\n\n\nExample response\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 3,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"ts\": 1517384243,\n      \"attrs\": {\n        \"alert_full\": 0,\n        \"alert_shutdown\": 0,\n        \"mode\": \"制冷\",\n        \"fan_swing\": 0,\n        \"switch\": 1,\n        \"fan_speed\": \"低风\",\n        \"fault_roomtemp\": 0,\n        \"room_temp\": -10,\n        \"set_temp\": 16,\n        \"off_timing\": 0,\n        \"on_timing\": 0\n      }\n    }\n  ]\n}\nDevice grouping\nGet the device group tree structure\nDebug console\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\n\nExample response\n{\n  \"c8e4b5634b047dc495be4a05a39d02a3\": \"\"\n}\nCreate a device group\nDebug console\n\nThe parent_gid is an optional parameter. It means to create a device child group if it’s passed in.\nA product can have only one root device group.\n\nRequest method and URL\nPOST\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\nparent_gid\nstring\nNo\nbody\nDevice child group ID\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\n\nExample response\n{\n  \"gid\": \"c8e4b5634b047dc495be4a05a39d02a3\"\n}\nDelete a device group\nDebug console\nTo delete a device group, you need to clear all devices and device child groups in the device group at first.\nRequest method and URL\nDELETE\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups/{gid}\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nYes\npath\nDevice group ID\n\n\n\nResponse parameters\nNo\nList all MACs in a device group\nDebug console\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups/{gid}\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nYes\npath\nDevice group ID\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nmacs\nArray[string]\nMAC list\n\n\n\nExample response\n{\n  \"macs\": [\n    \"virtual:site\"\n  ]\n}\nUpdate a device group\nDebug console\n\naction: \"assign\" | \"unassign\"\nmacs: MAC list, up to 1000 MACs at a time\nreassign: It’s valid when the action is \"assign\". When reassign is true, the MAC will be moved to the current group if it is already under some device group; if the reassign is false, the move will fail if the MAC is already under some device group.\n\nRequest method and URL\nPUT\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups/{gid}\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nYes\npath\nDevice group ID\n\n\naction\nstring\nYes\nbody\nDevice group assignment type: assign,unassign\n\n\nreassign\nboolean\nYes\nbody\n\n\n\nmacs\nArray[string]\nYes\nbody\nMAC list\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nfailed\nArray[string]\nThe MAC list of failure update\n\n\nsuccess\nArray[string]\nThe MAC list of successful update\n\n\n\nExample response\n{\n  \"failed\": [],\n  \"success\": [\n    \"virtual:site\"\n  ]\n}\nBinding Management\nBind devices\nDebug console\nRequest method and URL\nPOST\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/bindings\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\nuid\nstring\nYes\nbody\nUser ID\n\n\nappid\nstring\nYes\nbody\nApplication ID\n\n\ndids\nstring\nYes\nbody\ndid list\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nsuccess\nArray[string]\nMAC list of successful binding\n\n\nfailed\nArray[string]\nMAC list of failure binding\n\n\n\nExample response\n{\n  \"failed\": [],\n  \"success\": [\n    \"jaUHdkYkSocBhE2xspYM5k\"\n  ]\n}\nUnbind devices\nDebug console\nRequest method and URL\nDELETE\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/bindings\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\nuid\nstring\nYes\nbody\nUser ID\n\n\nappid\nstring\nYes\nbody\nApplication ID\n\n\ndids\nstring\nYes\nbody\ndid list\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nsuccess\nArray[string]\nMAC list of successful binding\n\n\nfailed\nArray[string]\nMAC list of failure binding\n\n\n\nExample response\n{\n  \"failed\": [],\n  \"success\": [\n    \"jaUHdkYkSocBhE2xspYM5k\"\n  ]\n}\nDevice Reporting\nGet device geographical distribution\nDebug console\nThis API is used to get device geographical distribution report.\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/locations\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nDevice group ID\n\n\nis_online\ninteger\nNo\nquery\nWhether the device is online\n\n\nis_faulty\ninteger\nNo\nquery\nWhether the device is faulty\n\n\nis_alert\ninteger\nNo\nquery\nWhether the device raised an alarm\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\ntotal\ninteger\nThe total number of devices\n\n\nlocation\nobject\nDevice location information\n\n\n\nExample response\n{\n  \"gid\": null,\n  \"total\": 4,\n  \"location\": {\n    \"China\": {\n      \"count\": 3,\n      \"Guangdong\": {\n        \"count\": 3,\n        \"Guangzhou\": 3\n      }\n    }\n  }\n}\nDevice overview\nThis API can only be used in domestic environments\nDebug console\nUsed to get the latest new activation and active device report\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/locations\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nonline\ninteger\nThe number of online devices \n\n\ntotal\ninteger\nThe cumulative number of online devices\n\n\nactive\ninline_model\nActive devices\n\n\nyesterday\ninteger\nThe number of active devices yesterday\n\n\n7_day\ninteger\nThe number of active devices in the last 7 days\n\n\nnew\ninline_model\nNewly activated devices\n\n\ntoday\ninteger\nThe number of newly activated devices today\n\n\nyesterday\ninteger\nThe number of newly activated devices yesterday \n\n\n7_day\ninteger\nThe number of newly activated devices in the last 7 days \n\n\n30_day\ninteger\nThe number of newly activated devices in the last 30 days\n\n\n\nExample response\n{\n  \"active\": {\n    \"7_day\": 0,\n    \"yesterday\": 0\n  },\n  \"new\": {\n    \"7_day\": 0,\n    \"30_day\": 0,\n    \"yesterday\": 0,\n    \"today\": 0\n  },\n  \"total\": 3,\n  \"online\": 0\n}\nDevice activation details\nThis API can only be used in domestic environments\nDebug console\nUsed to get device activation details report.\nQuery by date\n\nThe format of start,end is year-month-day. For example: 2016-08-01,\nNote: The response returned by Bluetooth devices fills in the device_sn field\n\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/incr_devices\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\nstart\nstring\nNo\nquery\nStart date\n\n\nend\nstring\nNo\nquery\nEnd date\n\n\ncountry\nstring\nNo\nquery\nCountry\n\n\nregion\nstring\nNo\nquery\nProvince\n\n\ncity\nstring\nNo\nquery\nCity\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nThe total number of records\n\n\nlimit\ninteger\nThe number of returned records \n\n\nskip\ninteger\nThe number of skipped records\n\n\nprevious\nstring\nPrevious page request address\n\n\nnext\nstring\nNext page request address\n\n\nreport_date\nstring\nReport date\n\n\nproduct_key\nstring\nProduct key\n\n\nmac\nstring\nMAC address\n\n\ndevice_sn\nstring\nSerial number of the Bluetooth device\n\n\ncountry\nstring\nCountry\n\n\nregion\nstring\nProvince\n\n\ncity\nstring\nCity\n\n\ncreated_at\nstring\nDevice creation time\n\n\n\nExample response\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 4,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"city\": \"Guangzhou\",\n      \"country\": \"China\",\n      \"region\": \"Guangdong\",\n      \"report_date\": \"2017-12-07\",\n      \"product_key\": \"4bd8778c5aa4602e5c9a5a208a1fdcc3\",\n      \"mac\": \"virtual:site\",\n      \"created_at\": \"2017-12-07 10:12:45\"\n    }\n  ]\n}\nActive device details\nThis API can only be used in domestic environments\nDebug console\nUsed to get active device details report\nQuery by date\n\nThe format of start,end is year-month-day. For example: 2016-08-01,\nNote: The response returned by Bluetooth devices fills in the device_sn field\n\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/active_devices\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\nstart\nstring\nNo\nquery\nStart date\n\n\nend\nstring\nNo\nquery\nEnd date\n\n\ncountry\nstring\nNo\nquery\nCountry\n\n\nregion\nstring\nNo\nquery\nProvince\n\n\ncity\nstring\nNo\nquery\nCity\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nThe total number of records\n\n\nlimit\ninteger\nThe number of returned records \n\n\nskip\ninteger\nThe number of skipped records\n\n\nprevious\nstring\nPrevious page request address\n\n\nnext\nstring\nNext page request address\n\n\nreport_date\nstring\nReport date\n\n\nproduct_key\nstring\nProduct key\n\n\nmac\nstring\nMAC address\n\n\ndevice_sn\nstring\nSerial number of the Bluetooth device\n\n\ncountry\nstring\nCountry\n\n\nregion\nstring\nProvince\n\n\ncity\nstring\nCity\n\n\ncreated_at\nstring\nDevice creation time\n\n\n\nExample response\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 19,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"city\": \"Guangzhou\",\n      \"country\": \"China\",\n      \"region\": \"Guangdong\",\n      \"report_date\": \"2017-12-28\",\n      \"product_key\": \"ea202c9a5bd8708a145a4678c5afdcc3\",\n      \"mac\": \"virtual:site\",\n      \"created_at\": \"2017-12-28 18:45:33\"\n    }\n  ]\n}\nQuery historical reports of active devices\nThis API can only be used in domestic environments\nDebug console\nActive devices: Devices with data reported within one day\nResult report time range\n\nThe daily report can be queried up to 30 days.\nThe weekly report can be queried up to 53 weeks.\nMonthly report can be queried up to 12 months.\n\nQuery by date\n\nWhen the cycle parameter is set with date, the format of start,end is year-month-day, example:2016-08-01,\nWhen the cycle parameter is set with week, the format of start,end is year-week, example:2016-51\nWhen the cycle parameter is set with month, the format of start,end is year-month, example:2016-12\n\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/report/liveness/history\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nDevice group ID\n\n\ncycle\nstring\nNo\nquery\nThe reference period, date, week, month\n\n\nstart\nstring\nYes\nquery\nStart date\n\n\nend\nstring\nYes\nquery\nEnd date\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\ncycle\nstring\nThe reference period, date, week, month\n\n\nstart\nstring\nStart date\n\n\nend\nstring\nEnd date\n\n\ndate\nstring\nDate\n\n\ncount\ninteger\nCount number\n\n\nlocation\nobject\nLocation information\n\n\n\nExample response\n{\n  \"start\": \"2017-12\",\n  \"gid\": null,\n  \"end\": \"2017-12\",\n  \"data\": [\n    {\n      \"count\": 2,\n      \"location\": {\n        \"China\": {\n          \"count\": 1,\n          \"Guangdong\": {\n            \"count\": 1,\n            \"Guangzhou\": {\n              \"count\": 1\n            }\n          }\n        }\n      },\n      \"month\": \"2017-12\"\n    }\n  ],\n  \"cycle\": \"month\"\n}\nQuery device status report\nDebug console\nThis API is used to get device status report.\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/report/devices/report/rt\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nDevice group ID\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\nactivated\ninteger\nThe activated devices number\n\n\nfaulty\ninteger\nThe faults number\n\n\nalert\ninteger\nThe alarms number\n\n\nlocation\nobject\nThe device geographical distribution\n\n\n\nExample response\n{\n  \"count\": {\n    \"faulty\": 0,\n    \"activated\": 4,\n    \"alert\": 1\n  },\n  \"gid\": null,\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"activated\": 2,\n        \"alert\": 1\n      },\n      \"Guangdong\": {\n        \"count\": {\n          \"faulty\": 1,\n          \"activated\": 1,\n          \"alert\": 1\n        },\n        \"Guangzhou\": {\n          \"count\": {\n            \"activated\": 3\n          }\n        }\n      }\n    }\n  }\n}\nGet faulty device report\nThis API can only be used in domestic environments\nDebug console\nGet faulty device report\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/fault/report/devices\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nDevice group ID\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\ntotal\ninteger\nThe total number of faulty deices \n\n\nresolved\ninteger\nThe number of devices with all issues resolved \n\n\nunresolved\ninteger\nThe number of devices with issues unresolved\n\n\nlocation\nobject\nThe faulty device geographical distribution\n\n\n\nExample response\n{\n  \"gid\": null,\n  \"count\": {\n    \"total\": 2,\n    \"resolved\": 1,\n    \"unresolved\": 1\n  },\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"total\": 2,\n        \"resolved\": 1,\n        \"unresolved\": 1\n      },\n      \"Guangdong\": {\n        \"count\": {\n          \"total\": 2,\n          \"resolved\": 1,\n          \"unresolved\": 1\n        },\n        \"Guangzhou\": {\n          \"count\": {\n            \"total\": 2,\n            \"resolved\": 1,\n            \"unresolved\": 1\n          }\n        }\n      }\n    }\n  }\n}\nGet alarm device report\nThis API can only be used in domestic environments\nDebug console\nUsed to get alarm device report.\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/alert/report/devices\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nDevice group ID\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\ntotal\ninteger\nThe total number of alarm devices \n\n\nresolved\ninteger\nThe number of devices with all alarms cleared \n\n\nunresolved\ninteger\nThe number of devices with alarms not cleared\n\n\nlocation\nobject\nThe alarm device geographical distribution\n\n\n\nExample response\n{\n  \"gid\": null,\n  \"count\": {\n    \"total\": 2,\n    \"resolved\": 1,\n    \"unresolved\": 1\n  },\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"total\": 2,\n        \"resolved\": 1,\n        \"unresolved\": 1\n      },\n      \"Guangdong\": {\n        \"count\": {\n          \"total\": 2,\n          \"resolved\": 1,\n          \"unresolved\": 1\n        },\n        \"Guangzhou\": {\n          \"count\": {\n            \"total\": 2,\n            \"resolved\": 1,\n            \"unresolved\": 1\n          }\n        }\n      }\n    }\n  }\n}\nGet device fault report\nThis API can only be used in domestic environments\nDebug console\nThis API is used to get device fault report\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/fault/report/events\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nDevice group ID\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\ndetail\nobject\nData point statistics of faults\n\n\nlocation\nobject\nGeographical distribution of faults\n\n\ntotal\ninteger\nThe total number of faulty devices\n\n\nresolved\ninteger\nThe number of resolved issues\n\n\nunresolved\ninteger\nThe number of unresolved issues\n\n\n\nExample response\n{\n  \"count\": {\n    \"resolved\": 1,\n    \"total\": 1,\n    \"unresolved\": 0\n  },\n  \"gid\": null,\n  \"detail\": {\n    \"fault_roomtemp\": {\n      \"resolved\": 1,\n      \"total\": 1,\n      \"unresolved\": 0\n    }\n  },\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"resolved\": 1,\n        \"total\": 1,\n        \"unresolved\": 0\n      },\n      \"detail\": {\n        \"fault_roomtemp\": {\n          \"resolved\": 1,\n          \"total\": 1,\n          \"unresolved\": 0\n        }\n      }\n    }\n  }\n}\nGet device alarm report\nThis API is used to get device alarm report\nThis API can only be used in domestic environments\nDebug console\nRequest method and URL\nGET  \nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/alert/report/devices\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nDevice group ID\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\ndetail\nobject\nData point statistics of alarms\n\n\nlocation\nobject\nGeographical distribution of alarms\n\n\ntotal\ninteger\nThe total number of alarm devices\n\n\nresolved\ninteger\nThe number of cleared alarms\n\n\nunresolved\ninteger\nThe number of alarms not cleared\n\n\n\nExample response\n{\n  \"count\": {\n    \"resolved\": 1,\n    \"total\": 1,\n    \"unresolved\": 0\n  },\n  \"gid\": null,\n  \"detail\": {\n    \"alert_full\": {\n      \"resolved\": 1,\n      \"total\": 1,\n      \"unresolved\": 0\n    }\n  },\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"resolved\": 1,\n        \"total\": 1,\n        \"unresolved\": 0\n      },\n      \"detail\": {\n        \"alert_full\": {\n          \"resolved\": 1,\n          \"total\": 1,\n          \"unresolved\": 0\n        }\n      }\n    }\n  }\n}\nUser Reporting\nGet new users report\nThis API can only be used in domestic environments\nDebug console\nThis refers to the new users who has bound the product with the PK\nQuery by date\n\nWhen the cycle parameter is set with date, the format of start,end is year-month-day, example:2016-08-01,\nWhen the cycle parameter is set with week, the format of start,end is year-week, example:2016-51\nWhen the cycle parameter is set with month, the format of start,end is year-month, example:2016-12\n\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/users/report/new\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nYes\nquery\nDevice group ID\n\n\ncycle\nstring\nNo\nquery\nThe reference period, date, week, month\n\n\nstart\nstring\nYes\nquery\nStart date or start week or start month\n\n\nend\nstring\nYes\nquery\nEnd date or end week or end month\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ndid\nstring\nDevice group ID\n\n\ncycle\nstring\nThe reference period, date, week, month\n\n\nstart\nstring\nStart date\n\n\ndata\nstring\nDate\n\n\ncount\nstring\nCount number\n\n\n\nExample response\n{\n  \"start\": \"2017-12\",\n  \"gid\": null,\n  \"end\": \"2017-12\",\n  \"data\": [\n    {\n      \"count\": 3,\n      \"month\": \"2017-12\"\n    }\n  ],\n  \"cycle\": \"month\"\n}\nGet active enterprise users\nDebug console\nThis API is used to get active enterprise users\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/users/liveness_total\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Enterprise-ID\nstring\nYes\nheader\nenterprise id\n\n\nX-Gizwits-Enterprise-Secret\nstring\nYes\nheader\nenterprise secret\n\n\nproduct_secret\nstring\nYes\nquery\nProduct key\n\n\nappid\nstring\nNo\nquery\nApplication ID\n\n\nstart_date\nstring\nYes\nquery\nStart date, like 2015-01-02\n\n\nend_date\nstring\nYes\nquery\nEnd date, like 2015-01-03\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ndate\nstring\nDate\n\n\ncount\ninteger\nCount number\n\n\n\nExample response\n{\n  \"data\": [\n    {\n      \"count\": 2,\n      \"date\": \"2017-12-13\"\n    }\n  ]\n}\nGet user geographical distribution\nDebug console\nThis API is used to get enterprise user geographical distribution\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/users/location\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Enterprise-ID\nstring\nYes\nheader\nenterprise id\n\n\nX-Gizwits-Enterprise-Secret\nstring\nYes\nheader\nenterprise secret\n\n\nproduct_secret\nstring\nYes\nquery\nProduct key\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ncount\ninteger\nCount number\n\n\n\nExample response\n{\n  \"China\": {\n    \"count\": 18,\n    \"Beijing\": {\n      \"count\": 14,\n      \"Beijing\": {\n        \"count\": 14\n      }\n    },\n    \"Guangdong\": {\n      \"count\": 4,\n      \"Guangzhou\": {\n        \"count\": 4\n      }\n    }\n  }\n}\nGet the total number of users\nThis API is used to query the total number of users who has bound the product with the given PK in the user table \nDebug console\nRequest method and URL\nGET\nhttp://enterpriseapi.gizwits.com/v1/products/{product_key}/users/report/total\nRequest parameters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nproduct_key\nstring\nYes\npath\nProduct key\n\n\ngid\nstring\nNo\nquery\nDevice group ID\n\n\n\nResponse parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ngid\nstring\nDevice group ID\n\n\ntotal\ninteger\nThe total number of users\n\n\n\nExample response\n{\n  \"gid\": null,\n  \"total\": 31,\n}\nError codes\n\n\n\nStatus Code\nSystem Error Code\nDescription\nHow to fix\n\n\n\n\n400\n5001\nbody json invalid\nCheck the JSON string\n\n\n400\n5002\nform invalid\nThe input is incorrect\n\n\n404\n5003\nenterprise id not exist\nEid does not exist, check whether it has been requested or incorrect input\n\n\n400\n5004\nenterprise secret error\nEsecret check failed, check if it is correct\n\n\n400\n5005\nproduct secret error\nProduct Secret check failed, check if it is correct\n\n\n400\n5006\nproduct exist devicegroups\n\n\n\n404\n5007\nassociation not exist\nNeed to open enterprise API service first\n\n\n400\n5008\nassociation existed\nEid is not associated with the corresponding product key, please contact customer service\n\n\n400\n5009\ntoken invalid\nPlease pass in the token or check the token field format\n\n\n400\n5010\ntoken not match product_key\n\n\n\n400\n5011\ntoken has expired\nPlease obtain the token again\n\n\n400\n5012\nip not in white list\nAdd IP to access white list of enterprise data for IP\n\n\n403\n5013\nAPI call rate limit execeed quota\nWait for a while before using this API again\n\n\n400\n5014\nReport has not been generated!\n\n\n\n404\n5015\nProduct key not exist!\nCheck whether the product key is correct\n\n\n404\n5016\nAppid not exist!\n\n\n\n404\n5016\nAppid not exist!\n\n\n\n404\n5017\nUid not exist!\n\n\n\n403\n5018\nproduct operation not allowed\n\n\n\n404\n5019\norganization does not exist\n\n\n\n400\n5020\ncan not delete published product!\n\n\n\n400\n5021\nenterprise is exist\n\n\n\n404\n5022\nenterprise does not exist\n\n\n\n403\n5023\nenterprise is creating\n\n\n\n403\n5024\napi deny to visit!\n\n\n\n404\n5025\nproduct does not exist\n\n\n\n403\n5201\ndevice group not belong to this product\n\n\n\n404\n5202\nparent group not exist\n\n\n\n400\n5203\nalready has one root group\n\n\n\n400\n5204\ngroup has subgroup\n\n\n\n400\n5205\ngroup has device item\n\n\n\n404\n5206\ngroup not exist\n\n\n\n400\n5207\nproduct key not in pre assignment!\n\n\n\n400\n5208\ncreate assign device in progress!\n\n\n\n404\n5301\ndevice not exist    Check the device ID\n\n\n\n403\n5302\ndevice not belong to this product    Please bind the device to the product first\n\n\n\n400\n5303\ndevice not bound\n\n\n\n400\n5304\ndevice is disabled\nActivate the device\n\n\n400\n5305\ndevice offline!\nGet the device online\n\n\n400\n5401\nattr invalid!\nCheck data point information\n\n\n404\n5402\ndatapoint data not found!\nDefine data points first and try again\n\n\n400\n5403\nsend command failed!\nPlease try it again\n\n\n403\n5404\nremote control not allowed!\nRemote control operation needs to be opened in the backend\n\n\n404\n5405\nattrs not exist!\n\n\n\n500\n5406\nDatapoints malformed\n\n\n\n500\n5407\ngenerate meta failed\n\n\n\n400\n5408\nraw data error!\n\n\n\n500\n5409\ncall innerapi failed!\n\n\n\n404\n5501\nfirmware does not exist\n\n\n\n400\n5502\nfirmware version has created\n\n\n\n403\n5503\nfirmware operation not allowed\n\n\n\n500\n5601\nkairosdb query error!\n\n\n\n403\n5701\nThis eid has no permission to reset pwd.\n\n\n\n403\n5702\nThis eid has no permission to reset pwd for this appid.\n\n\n\n400\n5703\nCannot reset pwd for anonymous user\n\n\n\n400\n5801\nthe pks has not associate with enterprise!\n\n\n\n400\n5901\nx-service secret key invalid!\n\n\n\n\n"},{"title":"Overview","url":"/en-us/overview/overview.html","content":"Gizwits Platform Overview\n1. Introduction\nThe Gizwits platform is a one-stop intelligent hardware development and cloud services platform for individuals and enterprise developers that has been built by Gizwits company with many years of deeply rooting in the industries, as well as actionable insights. The platform provides capabilities ranging from products definition, device-side development and debugging, application development, production testing, cloud-side development, operations management, and data services etc., which cover full lifecycle services from intelligent hardware provision to operation management.\nThe Gizwits platform provides developers with self-service smart hardware development tools and open cloud services. With self-service tools for dummies, comprehensive SDKs and API service capabilities, the platform lowers the technical barrier for IoT hardware development, reduces R&D costs, accelerates products launch speed, and helps developers promote the intellectualization of products to better connect and serve the end consumers.\n\n2. Architecture\n\n3. Gizwits Advantages\n\nHigh availability\nSLA 99.99%\nEB-level massive data support\nFlexible and scalable architecture\n\n\nFast connection\nFast connection within only a half day\nProvide SDKs for each activity in the development process\nProvide automatic code generation tools\nProvide ECE capability to automatically adapt private protocols through cloud configuration scripts\nProvide holistic solutions for industries\n\n\nProfessional services\nProfessional tools support for dummies\nProfessional support from our solution architecture team\nProfessional operation and maintenance support\n\n\nDeep industry expertise\n10000+ enterprise customers\n80W + global IoT developers\n\n\nSecurity\nComply with the X.509 certificate standard\nEncrypted cloud storage for enterprise data  \nEncryption for key business data \nPenetration test by professional security companies\nComply with the ISO27000 family of security management standards\n\n\nMulti-tier cloud data services\nMessage Proxy Service: Subscribe to enterprise device data on demand\nEnterprise API: Provides device control, device management, device location service and device data service etc.\nD3 Engine: A flexible and powerful data orchestration engine\n\n\nOpenness\nThe world's most open IoT self-development platform\nIntegrate with Amazon Echo, WeChat, JD, Nest, Apple HomeKit, Suning Cloud and other major platforms\n\n\nInternationalization\nGlobal coverage: Built independent data centers and cloud platforms in China, Europe, America, and Southeast Asia to cover the devices and users in most countries and regions of the world for customers\nSmart connection: Devices adapt their connections with the nearest cloud servers for acquiring the same service\n\n\n\n4. Gizwites Global Server Deployment\n1.The network response times in Guangzhou, Shenzhen, Guangxi, Hunan, and Fujian cities/regions are all less than 20ms (0.02 seconds); the network response times in other cities/regions of China are generally less than 40ms (0.04 seconds); the network response times in Singapore, Malaysia, Indonesia are less than 20ms (0.02 seconds); other cities in Asia are less than 70ms (0.07 seconds).\n\n2.The response time in the Middle East is less than 70ms (0.07 seconds); the average response time in Oceania is about 98ms; the average response time in Africa is about 150ms (0.15 seconds); the overall situation remains good.\n\n3.The overall network response time in Europe and other regions is less than 40ms (0.04 seconds).\n\n4.The overall network response time in North America and other regions is less than 40 ms (0.04 seconds); the average response time in cities/regions of South America is 146 ms (0.146 seconds); the overall situation remains good.\n\n(PS: Due to network instability, there are small deviations of response time.)\nQuick Start\nFive Minutes to Understand Gizwits\n\nFive minutes to understand Gizwits\nDefinition of termsFast Connection Wizard\n\n\nApplication Development(App, Wechat)\nGizwits provides the APP SDKs, open source frameworks, and WeChat SDK to facilitate the quick building of mobile applications. You only need to implement business functions according to the tool guides without considering the underlying functions.\n1. App development preparation and guidance\nApp development preparation and guidance\n2. App code automatic generation service introduction\nApp code automatic generation service introduction\n3. App open source frameworks\n\niOS open source framework description (including source code)\niOS push notification\niOS third-party authentication and themes\nRapid application development examples for iOS open source framework\nAndroid open source framework description (including source code)\nAndroid push notification\nAndroid third-party authentication and themes\nRapid application development examples for Android open source framework\nAPICloud open source framework guidlines (including source code)\n\n4. App SDKs\nApp SDKs help developers rapidly complete App development. You only need to focus on the App UI and UE design, while relatively complex protocols and error handling can be ignored.\n\nAndroid SDK access\nIOS SDK access\nAPICloud SDK User Guide\n\n5. More guidelines for App development\n\nTransparent transmission mode of data\nVideo tutorial for open source frameworks\n\n6. Wechat Application Development\n\nLearn about WeChat application development\nWeChat application development tutorial\n\nDevice Connectivity\n1. Connecting your devices to Gizwits cloud quickly\nIn order to let developers quickly understand the process of our device connection, we provide two fast connection tutorials for MCU and SOC solutions based on the open-source suite Gokit. Both tutorials use the smart lighting as a case study.\nNote: It is not necessary to use Gokit suite for device connection\n\nFast connection tutorial for MCU solution\nFast connection tutorial for SOC solution \n\n2. GAgent communication module usage\nThe main role of GAgent is data forwarding. It is a data exchange bridge among devices, Gizwits cloud, and applications (APP).\nIn order to enable different communication modules to connect to Gizwits cloud, we provide multiple burning methods and logging methods for those modules to ensure that the GAgent firmware runs normally in the modules.\nNote: Please follow the following steps when performing the module burning operation; otherwise, uncontrollable errors will occur.\n\nGAgent details\nBurning instructions for HF-LPB100 serial port \nBurning instructions for HF-LPT120 serial port\nBurning instructions for MXCHIP serial port\nBurning instructions for ESP8266 serial port\nBurning instructions for Guanghetong G510 module\nLog retrieve tutorial for debugging communication modules\n\n3. MCU code automatic generation service\nIn order to reduce the barrier for development, shorten the development cycle, and reduce the investment in development resources, Gizwits has launched an automatic code generation service. The cloud generates the device-side code for the corresponding product based on the defined product data points.\n\nIntroduction and tutorial for the automatic code generation tool \nPorting instructions for MCU SDK common version\nPorting the code automatically generated by Gizwits using STM32CubeMX\nOptimization instructions for 8051 platform by tailoring code \n\n4. Gokit open source suite\nIn order to enable developers to experience the Gizwits service faster, we provide the open source suite Gokit for developers to learn and reference, so that developers can connect their own products to Gizwits cloud quickly.\n\nGokit2 User Guide\nIntroduction to Gokit3 series development suite\nGokit3 hardware manual\nGokit3(S) user manual\nIntroduction to Gokit3(S) development suite \nGokit3 (S) development environment setup\nDetailed annotation for GoKit-SoC program\nDetailed annotation for GoKit-MCU program\n\n5. Connecting ArduinoUnoWIFI to Gizwits cloud\n\nHow to connect ArduinoUNOWIFI to Gizwits cloud\nHow to burn ESP8266 firmware into ArduinoUNOWiFi\nSDK API introduction for ArduinoUNOWiFi \nMaking a smart lamp using ArduinoUNO WiFi\n\n6. More guidelines for device connection\n\nDevelopment tutorial for ECE demo \nGizwits serial port tool tutorial \n\nCloud API\nIf you have completed device connection and App development, and want to obtain data from the Gizwits PaaS platform to build a business management system or access services provided by Gizwits, the following documents should be noticed:\n\n1). Understanding enterprise application development\n2). Understanding enterprise APIs\n3). SNoti API (V2.1.3)\n4). Gizwits Open API (new)\n5). Websocket API guide\n6). API tutorial\nUse openapi (postman) to control virtual devices\nUse Websocket webpage to control devices\nAggregation API tutorial\nDevice interaction API tutorial\nDemo tutorial for Snoti real-time synchronization service \n\n\n\nUser Manual\n\nProduct transfer from a personal account to an enterprise account\nOTA tutorial\nProduction testing tool tutorial\nD3 engine tutorial\nECE fog computing tutorial\nAmazon Echo integration tutorial\nReal-time big data guidelines\nGlobal deployment solutions\n\n"},{"title":"Quick start of Android App development","url":"/en-us/quickstart/AndroidAppFrame.html","content":"Overview\nThis article mainly walks you through how to use the Gizwits Android App open source framework (hereinafter referred as Framework) for rapid App development and testing. Before reading this document, please go through App development preparation and guidance.\nDeploy and debug the Framework in 10 minutes\n1. Download the Framework\nThe Framework development environment: Eclipse\nThe Framework code repository:\nhttps://git.oschina.net/dantang/GizOpenSource_AppKit_Android\n\n2. Import project to Eclipse\nThe following error may occur during the import process.\n\nIn this case, you need to change the target version in project.properties to the Android SDK version corresponding to eclipse.\n\n3. The Framework directory structure\nSet the Package Presentation to Hierarchical as shown below.\n\nAt this point, you can clearly see the directory structure of the entire project. As shown in the figure, the Framework separates each module as a Package to work independently for ensuring maximum decoupling between Packages. During the development, if you want to remove a function, such as a third-party authentication, you can directly delete the \"ThirdAccountModule\" package directly and it will not affect other packages.\n\n4. Modify the UIConfig.json\nAs shown in the above figure, the UIConfig.json file under the assets directory is a global configuration file. Here you can set the configuration information of the project.\n\napp_id: Gizwits app id\napp_secret: Gizwits app secret\nproduct_key: Gizwits product key  \nwifi_type_select: Whether the Wi-Fi module selection function is enabled\ntencent_app_id:qq authentication app id \nwechat_app_id: Wechat authentication app id\nwechat_app_secret: Wechat authentication app secret \npush_type: Push notification type [0: Off, 1: Jiguang, 2: Baidu]\nbpush_app_key: Baidu push notification app key\nopenAPI_URL: Domain name and port, in the format of “api.gizwits.com:80”. Defaults to 80 if unspecified.\nsite_URL: Domain name and port, in the format: \"site.gizwits.com:80\". Defaults to 80 if unspecified.\npush_URL: Push notification service domain name and port, in the format: \"push.gizwits.com:80\". Defaults to 80 if unspecified.\nbuttonColor: Button color\nbuttonTextColor: Button text color\nnavigationBarColor: Navigation bar color\nnavigationBarTextColor: Navigation bar text color\nconfigProgressViewColor: Configuration progress view color\naddDeviceTitle: Navigation bar text of Adding device page\nqq: QQ login button on the login page [true: display, false: hidden]\nwechat: Wechat login button on the login page [true: display, flase: hide]\nanonymousLogin: Skip button on the login page [true: display, flase: hide]\n\nFind the Product Key, App ID and App Secret on Gizwits Platform Console, and fill in the corresponding fields in the json file, as shown below:\n\n5. App deployment\nAfter typing the Product Key, App ID, and App Secret correctly, the project can be deployed and executed.\n\n\n6. Register a new user\n\n7. Log in the App\nAfter the successful registration, the use will automatically log in and navigate to My Devices page.\n\n8. Start the virtual device and display its QR code\nChoose the \"Virtual Device\" of the corresponding product in left navigation pane of the developer center.\nVirtual Device: The Gizwits Platform automatically generates a simulation device that simulates the behavior of reporting data by real devices. Developers can use the virtual device provided by Gizwits for App development when the development of physical devices has not been completed yet.\n\n\n9. Scan QR code to bind the device\nChoose the menu in the upper right corner and click Scan QR code to bind device.\n\n\nAfter scanning successfully, it will navigate to the \"My Devices\" page. At this time, the \"virtual device\" that was just scanned will appear on the page.\n\n10. Click on \"Smart Lamp\" to access the device control page\n\nAfter navigating to the control page, you will find that it is a blank page. In order to develop App quickly, the Gizwits open source framework has encapsulated user login, device discovery, device connection, and other functions into various standard modules, leaving only control pages for you to build on your own demand, which saves your time. The next section will illustrate how to develop a simple and attractive control page quickly.\nRapid development of device control pages\n1. Code preview\nOpen DeviceModule -> GosDeviceController. You can see that the entire control page is very simple, in which only one UILabel displays the device MAC address.\n\n2. UI design\nAccording to the created product \"Smart Lamp\", the expected UI effect is as follows:\n\nClick the lamp icon on the left page, then the App issues an instruction to control the light switch. The two icons are swapped for each other when tapped.\n3. Page layout\n3.1 Import pictures\n\nCopy the switch pictures that swap the states of the smart lamp to drawable directory, as shown in the following figure:\n\n3.2 Add a Button control\n1) Open the layout file \"activity_gos_device_control.xml\" corresponding to the control page.\n\n2) Add a Button control\nAs shown in the figure, remove the extra controls from the control page and add a Button control.\n\n3) Use the selector to control the Button background\nCreate a new selector file in the drawable folder, as shown in the figure:\n\nAdd the background switch code in btn_light_onoff_selector.xml:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <!-- background image for the button's selected state -->\n    <item android:drawable=\"@drawable/light_on\" android:state_selected=\"true\"/>\n    <!-- background image for the button's unseleted state -->\n    <item android:drawable=\"@drawable/light_off\"/>\n\n</selector>\n4) Set the background of the Button control to btn_light_onoff_selector, the code is as follows:\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    android:orientation=\"vertical\" >\n\n    <Button\n        android:id=\"@+id/btn_light_onoff\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" \n        android:background=\"@drawable/btn_light_onoff_selector\"/>\n\n</LinearLayout>\nAt this point the entire page layout is ready.\n4. Implementation of the control page\n4.1 Create the control page\nThe figure below shows the data point created for the product in the Gizwits cloud.\n\nThe reference code for the entire GosDeviceControlActivity is as follows:\npackage com.gizwits.opensource.appkit.ControlModule;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport com.gizwits.gizwifisdk.api.GizWifiDevice;\nimport com.gizwits.gizwifisdk.enumration.GizWifiErrorCode;\nimport com.gizwits.gizwifisdk.listener.GizWifiDeviceListener;\nimport com.gizwits.opensource.appkit.CommonModule.GosBaseActivity;\nimport com.gizwits.opensource.appkit.R;\nimport android.app.ActionBar;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\n\npublic class GosDeviceControlActivity extends GosBaseActivity {\n    /** Smart lamp */\n    private GizWifiDevice device;\n    /** Navigation bar */\n    ActionBar actionBar;\n    /** The data point name created in the Gizwits cloud */\n    public static final String LIGHT_SWITCH = \"switch\";\n    /** The smart lamp switch Button */\n    private Button btnLightSwitch;\n    /** Device listener */\n    private GizWifiDeviceListener deviceListener = new GizWifiDeviceListener() {\n        // Callback for receiving data\n        public void didReceiveData(GizWifiErrorCode result, GizWifiDevice device,\n                ConcurrentHashMap<String, Object> dataMap, int sn) {\n            // the defined device data points with boolean, numeric, or enumration data\n            if (dataMap.get(\"data\") != null) {\n                ConcurrentHashMap<String, Object> map = (ConcurrentHashMap<String, Object>) dataMap.get(\"data\");                \n                // Get the value reported from the device in the map by the name.\n                if (map.get(LIGHT_SWITCH) != null) {\n                    boolean status = (Boolean) map.get(LIGHT_SWITCH);                    \n                    // Change the button icon according to the value reported by the device\n                    btnLightSwitch.setSelected(status);\n                }\n            }\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_gos_device_control);\n        initDevice();\n        // Set ActionBar\n        setActionBar(true, true, device.getProductName());\n        initView();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // Exit the control page and take an unsubscribe action on the device\n        device.setSubscribe(false);\n    }\n\n    /**\n     * Description:Initialize the control\n     */\n    private void initView() {\n        btnLightSwitch = (Button) findViewById(R.id.btn_light_onoff);\n        btnLightSwitch.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                controlLight();\n            }\n        });\n    }\n\n    /**\n     * Description:Initialize the device\n     */\n    private void initDevice() {\n        Intent intent = getIntent();\n        device = (GizWifiDevice) intent.getParcelableExtra(\"GizWifiDevice\");\n        device.setListener(deviceListener);\n        Log.i(\"Apptest\", device.getDid());\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n        case android.R.id.home:\n            this.finish();\n            break;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    /**\n     * Description::Control the smart lamp\n     */\n    private void controlLight() {\n        if (btnLightSwitch.isSelected()) {\n            // issue a command\n            sendCommand(false);\n            // change the Button state\n            btnLightSwitch.setSelected(false);\n        } else {\n            sendCommand(true);\n            btnLightSwitch.setSelected(true);\n        }\n    }\n\n    /**\n     * Description:the method that issues a command\n     * \n     * @param onOff\n     *            true for turning on the lamp, false for turning off the lamp\n     */\n    private void sendCommand(boolean onOff) {\n        int sn = 5;\n        ConcurrentHashMap<String, Object> command = new ConcurrentHashMap<String, Object>();\n        // The key in the map is the data point name created in the Gizwits cloud, and the value is the data to be transmitted.\n        command.put(LIGHT_SWITCH, onOff);\n        // call the write method to issue a command\n        device.write(command, sn);\n    }\n}\n4.2 Deployment and debugging\nAfter completing the above code, you can deploy it to your phone for testing.\nThe App issues a command\nAfter the App is deployed on the mobile phone, it goes to the control page as shown below:\n\nClick the light icon in the App, the App will issue a command, and the light icon changes its state from off to on.\n\nAt this point, you can see the command sent by the App in the communication log of the cloud virtual device, as shown in the following figure:\n\nThe device reports data\nAs shown in the figure of the virtual device, change the value of the switch to “0” and click the Push button below. At this time, you can see that there is a record in the communication log “The virtual device reports data”, indicating that the device successfully reports the data.\n\nAt this time, the light icon on the control page of the App immediately changes its state to off, indicating that the App successfully received the reported data from the device.\n\nSee Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of iOS SDK 2.0 integration\nGuide of Android SDK 2.0 integration\nGuide of APICloud SDK\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process for third-party authentication platform \n\n"},{"title":"App development preparation and guidance","url":"/en-us/quickstart/AppDevPrepare.html","content":"Overview\nThis article mainly introduces the functions of the Gizwits Cloud access SDK for devices and Gizwits App open source framework, as well as the preparatory work for the early stage. Developers can choose the convenient way for App development according to their own project requirement.\nGizwits App Development Resources\nGizwits now offers three App development methods (integrating SDK, using App open source framework, and using App code auto-generator), which facilitate rapid App development according to the different needs of developers. The following are recommended development methods with corresponding requirements.\n1. Gizwits cloud access SDK for devices\nThe Gizwits cloud access SDK for devices (hereinafter referred to as SDK) encapsulates the communication process between the mobile phones (including PAD and other devices) and the devices, as well as between the mobile phones and Gizwits cloud. The process includes network access configuration, device discovery, connectivity, control, heartbeat, status reporting, and alarm notification. Using the SDK, you can quickly complete App development and only need to focus on the App UI and UE design. Relatively complex protocols and error handling can be ignored.\nThis method is applicable to the App that needs to do complex business logic processing, or needs to integrate the SDK to accomplish remote control after the App development has been completed.\nGizwits currently offers three SDKs: the native SDK for iOS, the native SDK for Android, and the APICloud SDK for cross-platform. Developers can choose anyone according to the needs of the project. The APICloud SDK can be used to develop once with HTML5 technology and can be adapted to both iOS and Android platforms.\n\nNative SDK for iOS platform\nIntegration guide of native SDK for iOS Platform\nNative SDK Android platform\nIntegration guide of native SDK for Android platform \nAPICloud SDK for cross-platform\nIntegration guide of APICloud SDK for cross Platform\n\n\n2. Gizwits App open source framework\nIn order to further ease the challenges associated with App development, Gizwits launched the App open source framework in which the following functions have been modularly integrated:\nThis method is applicable to the APP that needs to do simple business logic processing.\n\nUser module: user registration, user login, password recovery, third party authentication (WeChat, QQ)\nNetwork access configuration for device (Arilink+SoftAP)\nDevice discovery and list\nPush notification: supports Jiguang Push, Baidu Push\nCustom skin\n\nThe App open source framework makes each module an independent package. If you want to know the implementation code and flow of one of the modules, directly refer to the framework code.\n\nGuide of App open source framework for iOS\nQuick start guide based on App open source framework for iOS\nGuide of App open source framework for Android\nQuick start guide based on App open source framework for Android\nGuide of APICloud open source framework\nVideo tutorials of App open source framework\n\n3. Gizwits App code auto-generator\nThis method is applicable to the project that needs its own product App to debug, or requires a complete App code for reference.\nIn order to lower the barrier for the development of smart hardware App and reduce the investment in development resources, Gizwits has further developed the App open source code that implements the complete functions based on the \"App Open Source Framework\". After creating corresponding data points on the product project, Gizwits cloud generates an App reference code of the corresponding product according to the defined data points.\nThe automatically generated App code modularly integrates the necessary functions of a smart hardware App, mainly including:\n\nUser module: user registration, password recovery, third party anthentication (Wechat, QQ)\nNetwork access configuration (Arilink+SoftAP)\nDevice discovery and list\nDevice control\nPush notification: After the device raises the alarm, the alarm information is pushed to the App. The main push platforms we use are Jiguang Push and Baidu Push.\n\nAfter developers download the source code, they only need to optimize the UI and design the control logic and device control interface. The control page of the source code implements the standard flow of device control using Gizwits SDK. During the secondary development of the App, you only need to package and install to complete the control App of your own product.\nIntroduction and tutorial for App code auto-generator.\n4.Other App development tutorials\n\niOS push notification guide\niOS third-party authentication and re-skin tutorial\nAndroid push notification guide\nAndroid third-party authentication and re-skin tutorial\nExplanation of SDK data transparent transmission\n\nNote: The above methods are all based on open source frameworks.\nGet ready\n1. Create a product and define data points\n\n\n2. Create Android and iOS applications for your product\nIn the left navigation pane, click \"Application Configuration\" under “Services” to add Android and iOS applications respectively.\n\n\n3. The meaning and role of App ID and App Secret\nApp ID: application identification code, when the developer needs to develop applications for a smart product (including iOS, Android, Web applications, etc.), an App ID is automatically generated after an application is created in the Gizwits developer center and associates with the device. This App ID is required during application development. All users registered in the App are bound under this App ID.\nApp Secret: App ID verification secret.\nAs shown in the figure below, it is the role that App ID plays in the process of developing App.\n\n4. See Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of iOS SDK 2.0 integration\nGuide of Android SDK 2.0 integration\nGuide of APICloud SDK\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process of third-party authentication platform \n\n"},{"title":"Glossary","url":"/en-us/quickstart/glossary.html","content":"This document defines and explains the terms related to Gizwits. If you encounter some terms that are not well understood during the development, you can refer to this document.\nTerm definitions of cloud side\n1. ProductKey\nDefinition: product identification code, a 32 characters long string that is automatically generated by the developer after creating a new product in Gizwits cloud. It is a unique code in the database of Gizwits cloud. After the developer writes the ProductKey to the device master MCU, the Gizwits identifies the device through this code and automatically completes the registration.\nExplanation: The premise for the device to access Gizwits cloud is that it needs the cloud to identify this device. Productkey is an important parameter for the device to access Gizwits. The basic meaning of this parameter is: a device identification code. For example, a company produces air conditioners, water heaters, which are two different types of devices. Thus both of them require the Productkey parameter in order to connect to Gizwits Cloud. This parameter, which can be viewed on the Gizwits official website, will be used during the development on MCU. See the following figure:\n\nThe role of Productkey in the development:\n\n2. Product Secret\nDefinition: product secret key. When the Productkey is generated, the cloud generates a corresponding Product Secret. This parameter is a key confidential parameter and should not be disclosed to third parties. This parameter is used when binding remote devices (generally for GPRS access schema).\n3. DID\nDefinition: device code. When a device is connected to Gizwits for the first time, Gizwits automatically registers this device based on its ProductKey and Wi-Fi module MAC address. DID which is used to associate with users and perform subsequent operations, should be unique across the entire network.\n\n4. AppID\nDefinition: application identification code. When you need to develop an application (including iOS, Android, Web application, etc.) for a smart device, an AppID is automatically generated in Gizwits cloud and associated with the device. This AppID is required for application development.\nExplanation: When creating a product in the cloud, you need to add an application under the product. To build an App on both Android and iOS requires creating separate applications. AppID is mainly used when developing APP, and all users registered in the App are associated with this Appid. See Gizwits official website.\n\n\n5. App Secret\nDefinition: application secret key. An App Secret will be generated when the AppID is created in the cloud. This parameter is required when registering a mobile phone user on the APP side using SDK to obtain the SMS verification code.\n6. Micro Cycle\nDefinition: establishing connections between smart devices and mobile phones, smart devices and smart devices via the same router to achieve WLAN communication (status check or control), which is called a Micro Cycle.\n7. Macro Cycle\nDefinition: Smart devices access the Internet via routers to accomplish remote monitoring and control by users, which is called a Macro Cycle.\n\nTerm definitions of device side\n1. Gagent\nDefinition: The full name is Gizwits Agent, which runs on Wi-Fi modules, and through which devices access the Gizwits server. Currently, it is compatible with mainstream Wi-Fi modules of China. Developers can also implement their own custom modules to access Gizwits using the GAgent secondary development package provided by Gizwits.\nExplanation: Gagent is an application program that runs on the Wi-Fi module. Gagent's main role is to make Wi-Fi modules connect to the Gizwits server and achieve TCP/UDP communication with the cloud. Therefore, after integrating the Wi-Fi module on the control board of the developer's product, only the implementation of serial communication between the control board and the Wi-Fi module is needed to connect to the Gizwits server directly without processing the underlying network transmission, as is showed in the picture: \n\n2. PassCode\nDefinition: Device Pass Code, used to verify the user's binding/control permission. When the user initiates a device binding, the device pass code can be obtained by users with legal means to bind the device and perform operations such as device status check and control during the valid period. GAgent generates a random number as a device pass when it is first run. It is generated and stored in non-volatile memory. When the device goes online, it needs to be reported to the server.\n\n3. Onboarding\nDefinition: network access configuration, the process of connecting a Wi-Fi-based IoT device to a router is called Onboarding. When the new device is used for the first time, it needs to know the router's SSID and password to connect to the Internet via the router. Since most IoT devices do not have their own screens and keyboards, it is necessary to send the router's SSID and password to the device through a smart phone. The network access SDK for Wi-Fi devices provided by Gizwits has such built-in configuration function.\n\n4. Station mode\nStation mode (referred to as STA), is similar to a wireless terminal. STA itself does not accept wireless access and it can connect to the AP. Wireless network adapter is working in this mode generally.\n5. AP mode\nAP mode: Access Point, provides wireless access service, allowing other wireless devices to access, and providing data access. Wireless routers / bridges work in this mode generally. APs are allowed to connect to each other.\n6. AirLink\nDefinition: collectively, the features of UDP broadcast messages that allow you to configure the network access for devices, such as SmartConfig and SmartLink, are called AirLink. It provides the standard onboarding operation procedures with a good user experience, which is compatible with configuration protocols from multiple Wi-Fi module manufacturers. The network access SDK for Wi-Fi devices provided by Gizwits has built-in AirLink function. \n7. SoftAP\nDefinition: Because each Smart Config protocol from different Wi-Fi module manufacturers is not fully mature and neither does it support 5G router signal. Gizwits has provided AirLink configuration mode and also supports SoftAP mode to configure devices to access routers. When a device enters the SoftAP configuration mode, the device itself becomes an AP, and the smart phone can directly connect to the device. Then the SSID and password of the router are input on the mobile phone and sent to the device which will automatically switch to the normal mode and try to connect to the router. \n"},{"title":"Quick start of iOS App development","url":"/en-us/quickstart/iOSAPPFrame.html","content":"Overview\nThis article mainly walks you through how to use the Gizwits iOS App open source framework (hereinafter referred as Framework) for rapid App development and testing. Before reading this document, please go through App development preparation and guidance.\nDeploy and debug the Framework in 10 minutes\n1. Download the Framework\nThe Framework development environment: XCode\nThe Framework code repository:\nhttps://git.oschina.net/dantang/GizOpenSource_AppKit_iOS\n\n2. Import project to XCode\nThe downloaded Framework is shown in the figure below. Double click on the red box to open.\n\nThe Framework directory is as follows:\n\n3. The Framework directory structure\nThe overall directory structure of the Framework is shown in the following figure. The open source code is stored under the path “GOpenSourceModules”. According to the functional decomposition of the Framework, it is divided into five major modules with loose coupling between modules. All modules can be removed arbitrarily according to your own needs except the common module “CommonModule”. For example, if push notification is not required, you can delete \"PushModule\" straightway and comment out related properties and methods used in other classes. \n\n4. Modify the UIConfig.json\n\nAs shown in the above figure, the UIConfig.json file is a global configuration file. Here you can set the configuration information of the project.\n\napp_id: Gizwits app id\napp_secret: Gizwits app secret\nproduct_key: Gizwits product key  \nwifi_type_select: Whether the Wi-Fi module selection function is enabled\ntencent_app_id:qq authentication app id \nwechat_app_id: Wechat authentication app id\nwechat_app_secret: Wechat authentication app secret \npush_type: Push notification type [0: Off, 1: Jiguang, 2: Baidu]\nJpush_app_key: Jiguang push notification app key\nbpush_app_key: Baidu push notification app key\nopenAPIDomain: Domain name and port, in the format of “api.gizwits.com:80”. The default port is 80.\nsiteDomain domain name and port, in the format: \"site.gizwits.com:80\". The default port is 80.\npushDomain: Push notification service domain name and port, in the format: \"push.gizwits.com:80\". The default port is 80.\nbuttonColor: Button color\nbuttonTextColor: Button text color\nnavigationBarColor: Navigation bar color\nnavigationBarTextColor: Navigation bar text color\nconfigProgressViewColor: Configuration progress view color\nstatusBarStyle: Status bar looks like [0: default black style, 1: white style]\naddDeviceTitle: Navigation bar text of Adding device page\nqq: QQ login button on the login page [true: display, false: hidden]\nwechat: Wechat login button on the login page [true: display, flase: hide]\nanonymousLogin: Skip button on the login page [true: display, flase: hide]\n\nFind the Product Key (for example, the figure in \"1. Create Product and Define Data Points\"), App ID (for example, the second figure in \"2. Create Android and iOS App for the product\") and App Secret on Gizwits Platform Console, and fill in the corresponding fields in the JSON file, as shown below:\n\n5. UI customization\nIf you want to change the App UI page to a user-defined UI page instead of the page provided by the framework, you can replace \"GosDeviceController\" in the following figure to a custom UI page through removing the red box on the right side of the figure and complete the following two steps:\n1) Initialize the custom UI page\n2) Navigate from deviceListController (device list page) to your custom UI page\n\n6. App deployment\nAfter typing the Product Key, App ID, and App Secret correctly, the project can be deployed and executed.\n\n\n7. Register a new user\n\n8. Log in the App\nAfter the successful registration, the use will automatically log in and navigate to My Devices page.\n\n9. Start the virtual device and display its QR code\nChoose the \"Virtual Devices\" of the corresponding product in left navigation pane of the developer center.\nVirtual Device: The Gizwits Platform automatically generates a simulation device that simulates the behavior of reporting data by real devices. Developers can use the virtual device provided by Gizwits for App development when the development of physical devices has not been completed yet.\n\n\n10. Scan QR code to bind the device\nChoose the menu in the upper left corner and click Scan QR code to bind device.\n\n\nAfter scanning successfully, it will navigate to the \"My Devices\" page. At this time, the \"virtual device\" that was just scanned will appear on the page.\n\n11. Click on \"Smart Lamp\" to access the device control page\n\nAfter navigating to the control page, you will find that it is a blank page. In order to develop App quickly, the Gizwits open source framework has encapsulated user login, device discovery, device connection, and other functions into various standard modules, leaving only control pages for you to build on your own demand, which saves your time. The next section will illustrate how to develop a simple and attractive control page quickly.\nRapid development of device control pages\n1. Code preview\nOpen DeviceModule -> GosDeviceController. You can see that the entire control page is very simple, in which only one UILabel displays the device MAC address.\n\n2. UI design\nAccording to the created product \"Smart Lamp\", the expected UI effect is as follows:\n\nClick the lamp icon on the left page, then the App issues an instruction to control the light switch. The two icons are swapped for each other when tapped.\n3. Page layout\n3.1 Import pictures\n\nCopy the switch pictures that swap the states of the smart lamp to CommonModule/Images directory, as shown in the following figure:\n\n3.2 Add a Button control\n1) Open the controller's xib file - GosDeviceController.xib, delete the Label control, and remove all related code from the GosDeviceController.m file\n\n2) Add a Button control\nAs shown, drag a Button control to the center of the xib, set the Button's State Config property to Default, the Image property to light_off.png. When the Button's State Config property value is selected, the Image property value will be light_on.png.\n\n3) Reference the xib Button in GosDeviceController.m file\n\nAt this point the entire page layout is ready.\n4. Control logic development\n4.1 Define Data Point Macros\nDefine the macro according to the name of the data point: DataPointSwitch\n\n\n4.2 Implement control logic\nImplementing the control logic requires the following three steps:\n1) Specify the device delegate\n2) Implement the device agreement\n3) Issue control instructions\n\n// Control logic of the button\n- (void)switchBtnDidClick:(UIButton *)btn\n{\n    If (btn.isSelected)\n    {\n        // turn off the lamp\n        Btn.selected = NO;\n        // Send the control instruction to the device\n        [self.device write:@{DataPointSwitch:@NO} withSN:5];\n    }\n    Else\n    {\n        // turn on the lamp\n        Btn.selected = YES;\n        // Send the control instruction to the device\n        [self.device write:@{DataPointSwitch:@YES} withSN:5];\n    }\n}\n4.3 Received data handling\nAs shown in the figure, the callback logic is implemented in the device delegate method to swap the switch pictures of the Button.\n\n// Received a device status callback\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)dataMap withSN:(NSNumber *)sn\n{\n    NSDictionary *data = dataMap[@\"data\"];\n    If (data != nil && data.count != 0)\n    {\n        NSNumber *switchNum = data[DataPointSwitch];\n        self.switchBtn.selected = switchNum.boolValue;\n    }\n}\n4.4 Unsubscribe action\nWhen going back from the control page to the device list page, you need to do an unsubscribe action. Otherwise, unforeseen errors will occur.\n- (void) dealloc\n{\n    [self.device setSubscribe:NO];\n}\n4.5 Deployment and Test\nAfter completing the above code, you can deploy to a mobile phone to test.\n1) Issue a command\nAs shown in the figure, after the APP is deployed to the mobile phone, it goes to the control page.\n\nClick the icon of the lamp in the App and it will issue a command. At this time, the icon of the App will change to the on-state.\n\nAt this point, you can see the App command in the virtual device communication log in Gizwits Platform, as shown in the following figure:\n\n2) The device actively reports data\nAs shown in the figure, in the virtual device, change the value of the switch to “0” and click on the push button below. At this point, you can see that there is a record “The virtual device reporting data” in the communication log, indicating that the device reported the data successfully. .\n\nAt this time, the button of the lamp on the control page of the App change immediately to the off-state, indicating that the App successfully received the reported data from the device.\n\nSee Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of iOS SDK 2.0 integration\nGuide of Android SDK 2.0 integration\nGuide of APICloud SDK\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process of third-party authentication platform \n\n"},{"title":"Five Minutes to Understand Gizwits","url":"/en-us/quickstart/readme.html","content":"Overview\nThis article mainly introduces the process of self-service access to Gizwits, and helps you to quickly understand the principle of access to the Gizwits platform through the provided practical case study \"Gizwits Debugging App controls a virtual device in cloud\". Even if you have not yet developed any device, you can also get started rapidly.\nGizwits Access Process\n\n1. Register as a developer of Gizwits\nBefore using the Gizwits platform services, you need to register a Gizwits developer account first. Click here to register\nGizwits offers individual developer account and enterprise developer account, as shown in the figure below. If you are a enterprise user, please be sure to apply for a enterprise developer account (which provides more services).\n\n2. Create a product\nAs shown in the figure, click \"Create a new product\" in the developer center, enter the product name and select the corresponding access method to complete the creation of the \"new product.\" The created product needs to define the product data points. The data points refers to the functional abstraction that the product has, which are represented by different data types. For example, the simplest device “switch” has the following functions: On and Off, which can be abstracted as one data point with boolean type. 0 means On, 1 means Off.\nData points are an important attribute of a product. Therefore, the first step for product intellectualization is to clarify product functions and create corresponding data points on the platform to describe its functions. Subsequently, the MCU protocol for embedded development will be generated automatically based on the created data points. According to the automatically generated protocol, developers can complete the development of smart devices.\nStep 1: Click \"Create a new product\"\n\nStep 2: Type the product name and select an access method\n\nStep 3: Create data points\n\nClick \"New data point\" to add switch on/off data point.\n\nFor further information of this step, please click here for reference.\nStep 4: Download the automatically generated protocol by the cloud\nAs shown in the figure, click \"Development wizard\" in the developer center to find the MCU development resources to view the protocol automatically generated by the cloud based on the defined data points.\n\n3. Device and Application Development\nDevice connection\n\nDevelopers or R&D personnel of enterprises simply embed the communication module burnt in with Gizwits connection protocol GAgent on the smart device that is being developed, so that devices can be connected to Gizwits cloud and intelligentized. The communication modules include Wi-Fi, GPRS and other mainstream networking types. Other connection solutions are also available, such as BLE, GSM, CDMA, Zigbee, and LoRa.\nThe case study of this article focuses on Wi-Fi devices. To speed up R&D, it is recommended to use Gizwits certified modules, models, and GAgent. Click here for reference.\nApplication connection\nDevelopers or R&D personnel of enterprises simply integrate the App SDK provided by Gizwits into the mobile applications being developed, which then can connect to the Gizwits platform to control smart devices.\nThe case study of this article focuses on how to use Gizwits debugging APP to control devices. If you need to quickly develop an App,  it is recommended to use the App open source framework provided by Gizwits for rapid development. Click here for iOS open source framework. Click here for Android open source framework.\n4. Debugging products\nAfter product creation in the Developer Center, you can launch smart product development with the help of related technical documents in Gizwits Documentation Center. \nDuring debugging, the device will be connected to the Gizwits sandbox server (test server), which provides the developer with a complete testing environment and some functions of Gizwits. After the product development is completed, it is required to apply for roll out, and the completed product will be redeployed to the production server.\n5. Applying for roll out\nWhen the development is completed for devices, it is required to roll out the product. The product will be deployed on the servers of the official production environment of Gizwits, and an independent cloud operating environment will be allocated for your device for free, ensuring that your devices is available 24 hours a day for end users. At the same time, after the products are officially released, you will enjoy more free value-added services frome Gizwits, including statistical analysis of smart devices, open platform display, and various meticulous technical support services.\n\n6. Mass production\nAfter rolling out product, the manufacturers and Gizwits sign the “GDCS Agreement” to formally mass-manufacture the product and connect them. The mass-manufactured products will be monitored by Gizwits technicians for 24 hours to ensure the stable operation.\nGetting Started\nGizwits Self-service Development Platform provides a complete suite of simulation development tools, including virtual devices and debugging Apps. Regardless of whether you have already completed a smart device, you can understand the principle of Gizwits access through virtual devices and debugging Apps when you use Gizwits for the first time, which allows you to experience intuitive services of Gizwits access.\nThe virtual device is a smart hardware simulator that can be automatically generated by Gizwits cloud. It can simulate the smart device to be developed or being developed to perform device control by cloud and App, and data reporting.\n\nIn the course of development, if the formal smart hardware product has not yet been fully completed, developers or R&D personnel of enterprises can use the \"virtual device\" to debug and verify its functions together with formal controlling Apps so as to accelerate R&D and reduce costs.\nGizwits debugging App is the world's first-in-class debugging tool for IoT devices. Its functions can be customized according to the actual needs of smart hardware products. It can automatically generate responsive control pages with user registration, login, and logout processes, and complete the basic operations such as configuration of network access, device searching, device binding, device login, device control, remote control, status update and local/remote switching etc. for smart devices, as well as debugging.\nDuring development, if the formal controlling App of the product is not yet fully developed, developers or R&D personnel of enterprises can easily use the \"debugging App\" to debug and verify the formal product functions, so as to accelerate the development and reduce costs.\nIn the following, we use the actual case study \"Gizwits debugging App to control cloud-based virtual device\", to get you familiar with the Gizwits connection service and complete the process of getting started. The detailed steps are as follows:\n1. Install Gizwits debugging App\nClick here to download and install the Gizwits debugging App.\n\n2. Start the virtual device\nStep 1: Go to the developer center, click on the selection bar in the upper left corner and select \"Gizwits lab\":\n\nStep 2: Select a smart hardware product(a virtual device)\nWe recommend that novices choose those in \"products under development\" to simulate the real development process. You can choose any one in the section of \"products under development\" for practice.\n\nWe select \"Gizwits Smart Light 2nd Generation\" and click \"Online device debugging\" in the red box to jump to the next page \"Virtual device\".\nStep 3: Start the virtual device\n\nClick \"Start virtual device\" in the red box to navigate to online debugging page for the virtual device, you will see three functional areas of \"Debug tips\", \"Simulating device data reporting\", \"Communication log\":\n\nThe button \"Show QR Code\" in the \"Debug tips\" is used to bind the virtual device to the Gizwits debugging App.\n\n\"Simulating device data reporting\" is used to report data by the virtual device in the developer center.\n\n\"Communication log\" is used to display \"Accept data sent by App\" and \"data reporting from virtual devices\"\n\n\n\n3. Use Gizwits debugging App to bind virtual devices\nThe following is the steps of binding the virtual device with the Gizwits debugging App. Please keep your network available during the operation:\n\nStep 1: Click \"Show QR Code\" in the red box of \"Debug tips\" to display the virtual device QR Code\n\nStep 2: Login in Gizwits debugging App and bind the device\n\nAfter using debugging App to scan the virtual device QR Code and binding the selected virtual device successfully, \"Gizwits Smart Light 2nd Generation\" will be showed in the \"bound devices\" of \"My Devices\" on the debugging App.\nStep 3: Control the virtual device using Gizwits debugging App\n\nClick \"Gizwits Smart Light 2nd Generation\" in the red box to navigate to the debugging page of the virtual device. Take the \"switch on/off\" function as an example, set the \"switch on/off\" field of the smart light with 1.\n\nAt this point, you can see that the \"switch on/off\" field of the virtual device in the cloud is enabled and displayed as \"1\". Meanwhile, \"Communicating log\" displays \"Accept data sent by App\" and automatically print the corresponding communication log.\n(Note: Other operations can be performed following the above steps, you can try each of them one by one!)\n4. Virtual devices reporting data to the debugging App\n\nSet the \"Adjustment mode\" of the virtual device in the cloud with \"Color temperature mode\" option, and click the \"push\" button. The virtual device will report the data to the Gizwits debugging App. You can see that the \"Adjustment mode\" field on the Gizwits Debugging App has changed to \"Color temperature mode\". At the same time, \"Virtual devices reporting data\" will be displayed on the \"Communication log\" for the virtual device in the cloud, and the communication log will be printed automatically.\nGizwits Debugging App automatically updates its UI after receiving the data pushed by the virtual device.\n\n(Note: Other operations can be performed following the above steps, you can try each of them one by one!)\nOK, congratulations! You have quickly understood and experienced the connection service of Gizwits through the virtual device and Gizwits Debugging App. Now get started!\nTo learn about the fast device connection to the Gizwits cloud, please click here\nTo learn more about the rapid App development process, please click here\nTo apply for Gizwits open source development kit GoKit, please click here\nTo join our developer community and interact with 10,000 developers, please click here\n"},{"title":"APICloud开源框架使用指南","url":"/zh-cn/AppDev/APICloudFrame.html","content":"APICloud开源框架是使用机智云SDK开发的APP模板，实现了SDK的加载、初始化、用户注册、登陆、设备配置、设备发现、设备连接等基本的功能。APP开发者可以基于框架实现具体产品的控制界面就可以生成一个完整的APP。目前提供iOS、Android和APICloud三个版本的开源框架，APICloud版的主要优势是一套代码适配iOS和Android两个平台。\n本文档主要目的是告诉开发者如何利用开源框架来快速开发一个完整的APP，当然，也可以将源码作为参考，重新开发一套APP。\nAPICloud开源框架工程源码链接：https://github.com/gizwits/GizOpenSourceAppKit_APICloud\nAPICloud Gokit App是使用开源框架工程的源码范例，源码链接：https://github.com/gizwits/gokit_demo_in_apicloud\n框架目录结构说明\nAPICloud开发类似于Web前端开发，也是通过CSS + html + Javascript来完成的，目录也是基于此结构来区分的，如下图：\n\n 具体到每个文件的功能描述如下：\n\n快速集成指南\n在APICloud中每一个应用都有一个唯一的id标识，开源框架中并没有该id，需要重新创建一个APICloud项目，获取项目id，才能运行框架源码。\n创建一个空白项目\n右击《我的APP项目》栏下的空白部分，点击新建APICloud项目；或者点击菜单栏的导航按钮，点击《新建APP项目》，进入项目创建页面。\n\n选择《空白应用》，点击《完成》，此时，APICloud也同步生成了一个空白项目。\n\n进入APICloud的开发控制台：http://www.apicloud.com/console，可以看到创建成功的APP项目\n\n移植框架代码\n上面生成的空白源码目录如下，将红框部分的文件删除。\n\n下图是框架的源码，将红框部分的文件复制到上图空白源码部分，则新创建的源码除了config.xml之外都与框架相同了。\n\n设置config.xml文件\nconfig.xml是APICloud提供的配置文件，在每个项目中都会存在一个config.xml，上面提供了项目的id，也就是项目在APICloud平台的唯一标识，开发者个人的账号信息，以及一些界面的设置、项目所使用到的第三方模块的引入。若想了解详细内容可查看：http://docs.apicloud.com/Dev-Guide/app-config-manual。\n下图是框架的config.xml文件内容，将红框部分的内容，替换为新建项目生成的对应值，然后将新建项目的config.xml文件替换为该config.xml文件\n\n如果项目中使用QQ登陆，需要前往腾讯开发者中心申请应用，并获取apiKey值，urlScheme的value值就是填写 tencent+apiKey的字符串值； apikey的value值直接填写QQ的apikey值即可。\n将项目的改动提交到APICloud云端，如下：\n\n引入GizWifiSDK\n将源码移植与Config.xml的改动提交到云端后，APICloud会根据源码使用到的模块自动导入相应\n的模块，机智云SDK需要手动导入。\n\n搜索并导入GizWifiSDK\n\n设置源码中产品和应用的参数\n此时的源码还需要设置安卓和iOS应用的appid和appsecret，并且设置在机智云官网创建的产品的ProductKey。\n在机智云官网获取产品的ProductKey和ProductSecret。\n\n获取安卓和iOS的AppID和AppSecret\n\n进入框架的index.html页面：\n\n将红框中的代码修改为下图红框所示：\n\nyour_ios_appid: 替换成在机智云创建的iOS应用的AppID\nyour_android_appid：替换成在机智云创建的安卓应用的AppID\nyour_ios_appsecret：同上，替换成iOS应用的AppSecret\nyour_android_appid：同上，替换成安卓应用的AppSecret\nyour_productKey：替换成在机智云创建的产品的ProductKey.\n同时在deviceList.html文件中设置一下产品的ProductKey，让APP只获取该ProductKey的设备\n\n将红框部分改为如下图：\n\n部署APP\n完成上面的所有步骤后，运行APP\n\n\nAPICloud真机调试说明\nAPICloud真机调试的方法较多，包括云编译、USB真机调试、WiFi真机调试等等，其中最方便快捷的是WiFi真机调试。下面将以APCIoud Studio工具为例，说明如何使用WiFi真机同步。\n编译自定义Loader\nAPICloud的所有第三方模块都保存在云端，如果编译调试的方式与原生APP相同，每次真机调试都要重新编译代码，将会耗费较长时间和资源。所以，APICloud推出了自定义Loader的编译调试方法。\n每个APP项目对应一个自定义Loader，即当APP所需的第三方模块都在云端设置后，并且本地的代码也已经编辑，需要真机调试效果，即可编译自定义Loader，Loader中将根据你选择的模块和设置进行编译。\n自定义Loader在真机调试中的优点是：若在调试过程中修改了代码不需要重新编译自定义Loader，只需要重新WiFi真机同步即可，在真机同步中APICloud会将改动的部分同步在自定义Loader中。\n自定义Loader编译方式，选择需要调试的项目，右击如下图所示：\n\n编译成功，会弹出如下页面，扫描即可安装相应的自定义Loader\n\n安装自定义Loader\n扫描安装自定义Loader如下所示：\n\n\n点击红色框内的白圆圈进入以下界面，通过该界面设置数据进行WiFi同步。\n\n注意：自定义Loader也可通过以下方式获取：\n\n设置WiFi同步参数\n在APICloud Studio中查看同步参数\n\n选择《查看WiFi真机同步服务器地址》\n\n在安装的自定义Loader设置该参数，点击《连接》，连接成功后，界面的圆圈变为绿色。\n\n\nWiFi同步测试\n完成自定义Loader和WiFi同步参数后，即可进入WiFi同步测试。\n在APICloud Studio选择《WiFi真机同步》\n\nAPP进入以下界面，同步完成后，即成功同步APP，接下来就可以测试APP了\n\n\n"},{"title":"Android开源框架使用指南（含源码）","url":"/zh-cn/AppDev/Android开源框架使用指南.html","content":"简介\n本文档为机智云物联网开源基础App套件使用说明，旨在为机智云物联网开发者提供一个快速开发模板，可在此工程基础上进行快速开发或参考相关代码进行开发。\nAndroid开源框架工程源码链接：\nEclipse 版本:https://git.oschina.net/dantang/GizOpenSource_AppKit_Android\nAndroid Studio版本：https://github.com/gizwits/GOpenSource_AppKit_Android_AS\nAndroid Gokit App是使用开源框架工程的源码范例，源码链接：\nhttps://git.oschina.net/dantang/GoKit_Demo_Android\n也可在下载中心下载Android Gokit App：\n\n目录结构说明\n\nA.     Libs: 包括 GizWifiSDK 在内的的第三方库目录**\nassets: 包含 UIConfig.json 配置文件\nB.     GizOpenSource: 组成模块\nGizOpenSourceModules：组成模块\nGosApplication.java // SDK 在此启动\nCommonModule // 公共方法类、资源文件读取类 \nConfigModule // 设备配置模块，包含 AirLink 及 SoftAP\nUserModule // 用户模块，包含 用户登录、用户注册、找回密码\nDeviceModule // 设备模块，包含 设备列表\nControlModule // 控制模块，包含 控制示例\nSettingsModule // 设置模块，包含 设置菜单 及其 包含的子菜单项（关于等）\nPushModule // 推送模块，包含 百度和极光的推送SDK 集成封装\nThirdAccountModule // 第三方登录模块， 包含 第三方登录（QQ、微信等）\nview // 自定义控件\nutils // 工具类\nwxapi // 微信集成包\nzxing // 扫描二维码\n\n\n\n快速集成指南\n默认程序入口在 UserModule 中的 GosUserLoginActivity。\nA.     设定初始化参数\n在工程的 GosApplication.java 文件中填写机智云AppID及AppSecret，如果使用第三方登录或推送，需要填写相应的从其他资源平台申请的参数；如果使用推送需要打开当前需要使用推送的类型的初始化，如果都为注释状态则表示当前不使用第三方推送，同时只支持一种第三方推送，不可打开多个第三方推送宏定义的注释。可配置的参数有：\napp_id：机智云 app id\napp_secret：机智云 app secret\nproduct_key：机智云 product key\nwifi_type_select：默认配置模块wifi模组选择功能是否开启\ntencent_app_id：qq登录 app id\nwechat_app_id：微信登录 app id\nwechat_app_secret：微信登录 app secret\npush_type：推送类型 【0：关闭，1：极光，2：百度】\nbpush_app_key：百度推送 app key\nopenAPI_URL：openAPI 域名及端口，格式：“api.gizwits.com:80”，不写端口默认80\nsite_URL：site 域名及端口，格式：“site.gizwits.com:80”，不写端口默认80\npush_URL：推送绑定服务器 域名及端口，格式：“push.gizwits.com:80”，不写端口默认80\nbuttonColor：按钮颜色\nbuttonTextColor：按钮文字颜色\nnavigationBarColor：导航栏颜色\nnavigationBarTextColor：导航栏文字颜色\nconfigProgressViewColor：配置中界面 progress view 颜色\naddDeviceTitle：添加设备界面 导航栏标题文字\nqq：是否打开QQ登录【true：打开】\nwechat：是否打开微信登录【true：打开】\nanonymousLogin：是否打开匿名登录【true：打开】\n\n需要注意:\n1.极光推送的appid需要在AndroidManifest.xml 中填写见243行。\n2.微信登录需要进行在腾讯api中设置自己的md5值否则无法正常运行\n3.tencent_app_id需要在AndroidManifest.xml中89行填写\nB.     加载控制界面\n1）框架工程内提供的代码已经可以在不修改任何代码的前提下，进行到控制界面的跳转操作，开发者只需要关心操作界面的逻辑即可，如果需要在设备列表界面中点击某设备后，跳转到自己创建的控制器视图中，请在 GosDeviceListActivity.java  文件中修改相应跳转参数。请按照图示修改跳转视图的类定义，如果使用默认提供的空白界面（GosDeviceControlActivity）来进行编写控制界面，可略过此步骤。\n\n2） 在控制界面中注册设备的监听，并实现回调，如图：\n\n用于接收SDK上报的设备状态变化通知，将接收到的上报数据解析并更新界面。\n3）控制界面中对当前设备设置监听，例如：device.setListener(gizWifiDeviceListener);                                                                             \n4）实现控制命令下发，需要调用SDK中GizWifiDevice类实例的接口方法：device.write(concurrentHashMap ,0);     具体参数解释，请参考SDK使用文档。                                                                                                  \n5）退出控制界面时，需要取消当前设备订阅，调用SDK中GizWifiDevice类实例的接口方法，将参数设为False：    device.setSubscribe(false);\nC.     设置界面增加菜单项及点击处理\n如果需要在设置界面进行列表项的增加或修改，需要在activity_gos_settings.xml中添加相应控件，并在模块（SettingsModule）中的GosSettingsActivity.java文件中添加相应事件。\n常见问题\nA.     支持Android版本？\n目前支持Android 4.0及更高版本系统。\n B.     关于修改版本号\n在工程的AndroidManifest.xml 文件下，修改versionNmae即可更改SettingsModule模块下，关于界面的版本号显示。示例：\n\nC.     关于推送与包名（以下使用集成极光推送示例）\n在新建工程下，替换框架内模块使用时。需要将AndroidManifest.xml 文件package与申请推送时所填包名相对应，并修改集成推送时相应位置。示例：\n\n与申请推送应用保持一致，示例：\n\n修改集成推送的相应位置：\n在工程的AndroidManifest.xml文件中修改\n1)    \n<permission android:name=”您应用的包名.permission.JPUSH_MESSAGE” android:protectionLevel=”signature” />\n（详见开源APP套件的AndroidManifest.xml文件第13行）\n2)\n<uses-permission android:name=”您应用的包名.permission.JPUSH_MESSAGE” />\n（详见开源APP套件的AndroidManifest.xml文件第17行）\n3)       \nDaemonService下<category android:name=”您应用的包名” />\n（详见开源APP套件的AndroidManifest.xml文件第159行）\n4)  \nPushPeceiver下<category android:name=”您应用的包名” />\n（详见开源APP套件的AndroidManifest.xml文件第170行）\n5)        \nPushActivity下<category android:name=”您应用的包名” />\n（详见开源APP套件的AndroidManifest.xml文件第193行）\n6)       \nJPushReceiver下<category android:name=”您应用的包名” />\n（详见开源APP套件的AndroidManifest.xml文件第224行）\n7)      \n<meta-data android:name=”JPUSH_APPKEY” android:value=”Your AppKey” />\n（详见开源APP套件的AndroidManifest.xml文件第240行）\n重要提示\n查阅《APP代码自动生成服务介绍》，可了解自动生成的APP代码模块具备哪些功能\n查阅《APP开源框架》，可了解\n\niOS开源框架使用指南\n\niOS App消息推送集成指南\n\niOS App集成第三方登录与换肤指南\n\niOS App快速开发实例\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送集成指南\nAndroid App集成第三方登录与换肤指南\nAPICloud开源框架使用指南\n\n查阅《APP开发SDK》，可随心开发IoT APP（很多细节设计，均可在里面找到应用案例）\n\niOS SDK 2.0集成指南\nAndroid SDK 2.0集成指南\nAPICloud SDK使用指南\nSDK数据透传方法解析\nSDK调试日志抓取教程\nSDK错误码表\n\n更多应用开发\n\n应用开发FAQ\n设备分享功能使用流程\n第三方登录平台申请流程\n\n"},{"title":"Android App消息推送集成指南","url":"/zh-cn/AppDev/Android消息推送.html","content":"概述\n机智云APP开源框架集成了百度推送与极光推送功能，只需修改部分代码即可快速使用。本文档就如何基于机智云APP开源框架快速集成消息推送功能，如需了解开源框架，请参考快速入门的文档。\n快速集成极光推送\n1.申请极光AppKey与Master Secret\n开发者需要根据框架包名在极光官网上创建应用并填写相应信息，如下所示：\n1).查看框架包名\n\n2).在极光平台创建应用\n\n3).查看对应的AppKey和Master Secret\n\n2.在云端绑定第三方推送\n2.1.申请开通D3 Engine\n1.查看D3 Engine\n\n2.开通服务\n\n开通D3 Engine需要机智云审核通过，点击开通服务后需要联系机智云FAE协助审核开通。\n2.2.云端绑定极光推送\n通过审核后，可以在服务一栏看到D3 Engine，依次点击“配置”->” 编辑推送平台”\n\n将在极光申请的对应信息填写到下图所示的位置，并点击绑定。\n\n下图所示表示成功绑定了极光推送\n\n2.3.利用D3 Engine创建推送规则\n\n点击项目列表->新建项目，下面将演示创建一个设备上线后给APP推送消息的规则。\n\n拖动“设备数据”框到右边空白处，并双击该栏目。\n\n将触发方式设为“设备上线”，点击确定。\n\n双击“APP推送”，并设置推送的内容。\n\n点击“保存”，保存推送规则\n\n\n下图表示成功保存推送规则\n\n3.修改UIConfig.json代码\n1、填写机智云app_id与product_key并修改push_type\n\n\n4.修改AndroidManifest.xml\n将图3中的APP KEY填写到AndroidManifest.xml中的对应的代码中。\n\n5.启动虚拟设备\n\n6.部署APP运行\n通过以上步骤，该APP已具备了极光推送功能，部署到手机上后，申请帐号并登录，通过扫码即可绑定云端的虚拟设备。\n\n7.测试推送功能\n关闭虚拟设备后，再次开启，即可看到手机收到了推送消息。\n\n快速集成百度推送\n1.申请百度API KEY\n根据框架包名在百度官网上创建应用并填写相应信息，如下图：\n\n\n查看对应的API KEY和SECRET KEY\n\n2.在云端绑定第三方登录\n2.1.申请开通D3 Engine\n该步骤可以参考《快速集成极光推送》的2.1部分。\n2.2.云端绑定百度推送\n\n将百度申请的对应信息填写到下图所示的位置，并点击绑定。\n\n下图表示成功绑定了百度推送。\n\n2.3.利用D3 Engine创建推送规则\n该步骤可以参考《快速集成极光推送》的2.3部分\n3.修改UIConfig.json代码\n填写app_id、app_secret、product_key，修改push_type为2，并将图24对应的key填入到对应的位置\n\n4.启动虚拟设备\n该步骤可以参考这里。\n5.部署APP运行\n通过以上步骤，该APP已具备了百度推送功能，部署到手机上后，申请帐号并登录，通过扫码即可绑定云端的虚拟设备。\n\n6.测试推送功能\n关闭虚拟设备后，再次开启，即可看到手机收到了推送消息。\n\n常见问题FAQ\n1、开发者一定要开通D3 Engine才能使用消息推送吗？\n解答：是的，目前D3 Engine只针对于企业开发者用户。所以，只有企业开发者才能申请开通使用。\n2、使用极光推送按照以上步骤完成代码修改，但是却无法收到推送消息。\n解答：可按照以下步骤进行排查\ni.    APP包名是否已修改，默认包名为“com.gizwits.opensource.appkit”。如果包名已被修改，则需要在AndroidManifest.xml中修改对应位置的信息。可参考极光文档：\nhttp://docs.jiguang.cn/jpush/client/Android/android_guide/\n修改了相应信息后，需要测试利用极光平台给APP单独推送消息是否成功，只有极光单推成功才能收到机智云推送消息。\nii.    极光单推成功，但是APP还是无法收到消息。\n第一、    确认云端成功绑定了极光的App Key和Master Secret\n\n第二、    确认云端成功创建了规则。\n\n第三、    以上两步都确认无误后，还是无法收到消息，则查看如下代码：\n\n查看下JPushInterface.setAlias方法回调的Result值是否为0，不为0则表示设置极光别名失败，需要重新调用该方法设置别名。\n\n查看didChannelIDBind回调接口中Result的值是否为GIZ_SDK_SUCCESS，根据提示的代码重新调试代码。\n"},{"title":"Android App集成第三方登录与换肤指南","url":"/zh-cn/AppDev/Android第三方登录与换肤.html","content":"查看iOS第三方登录与换肤指南\n查看第三方登录平台申请流程\n概述\n本文主要是介绍了如何通过开源框架快速支持QQ和微信登录，并介绍了如何实现app快速换肤\nQQ登录接入\nAPP要支持QQ登录，需要先到腾讯开放平台创建一个应用，获取应用的APPID，并设置到开源框架中即可。\n获取APP ID 并绑定应用\n查看QQ开放平台应用申请教程获取APP ID和绑定机智云应用\n修改UIConfig.json文件\n将在腾讯开发平台申请到的APPID填写到开源框架的配置文件UIConfig.json中\n\n正确填写“tencent_app_id”后部署运行，即可使用QQ登录了。\n微信登录接入\nAPP要实现微信登录，必须前往微信开放平台申请一个应用，获取应用的APPID和APPSecret并且配置到开源框架中即可。\n获取APPID和APPSecret\n查看微信开放平台应用申请教程获取APPID和APPSecret\n修改UIConfig.json文件\n将在微信开发平台申请到的APPID和APPSecret填写到开源框架的配置文件UIConfig.json中，如下图\n\n正确填写“wechat_app_id”和\"wechat_app_secret\"后部署运行，即可使用微信登录了。\nAPP快速换肤\n开源框架已集成了皮肤定制功能。通过修改UIConfig.json文件即可实现快速换肤。\n\n如图红框内所示，为自定义皮肤代码修改区，各含义如下：\nbuttonColor：按钮颜色\nbuttonTextColor：按钮文字颜色\nnavigationBarColor：导航栏颜色\nnavigationBarTextColor：导航栏文字颜色\nconfigProgressViewColor：配置中界面 progress view 颜色\n通过修改对应的颜色值即可实现快速换肤，参考如下示例：\n1.肤色一\n\"buttonColor\":\"6ebe37\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\"6ebe37\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\n实际效果图：\n \n2.    肤色二\n\"buttonColor\":\"ff8a44\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\"ff8a44\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\n实际效果图：\n \n3.    肤色三\n\"buttonColor\":\" 16b599\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\" 16b599\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\n实际效果图：\n\n"},{"title":"SDK数据透传方法解析","url":"/zh-cn/AppDev/SDK数据透传方法解析.html","content":"概述\n本文主要介绍如何使用机智云设备接入SDK来进行APP与设备之间的数据透传。在APP和MCU之间，有两种数据透传方式：\n\n利用“扩展类型”数据点进行透传\n不定义数据点直接进行数据透传，即纯透传\n\n扩展类型数据点透传\n1.定义数据点\n\n在机智云产品管理中的数据点中定义一个拓展类型的数据点，如上图所示：\n定义数据长度为60个byte（透传情况下，数据长度暂时支持900字节内数据传输）。\n2.设备上报数据协议说明\n设备MCU按照数据点的定义格式上报透传数据，在完成新产品的定义后，每个新产品都有相应的串口通信协议文档，文档下载路径如下图所示：\n\n在串口通信协议文档文档的4.9部分则有MCU上报数据的格式，如下图：\n \n图中的dev_status(60B)即为需要透传的数据。\n3.SDK回调接口说明\nAPP端接收到MCU上报数据的回调接口：didReceiveData，判断result为GizWifiErrorCode.GIZ_SDK_SUCCESS，则接收到的数据可能为普通数据点或者扩展数据点。\n4.APP接收数据代码示例\nAndriod接收到MCU上报拓展数据类型代码示例：\nfinal protected static char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n\n// 将16进制的byte转为string，比如byte值为{0x62,0x63}，那么将转为“6263”\npublic static String bytesToHex(byte[] bytes) {\n        char[] hexChars = new char[bytes.length * 3];\n        for (int j = 0; j < bytes.length; j++) {\n            int v = bytes[j] & 0xFF;\n            hexChars[j * 3] = hexArray[v >>> 4];\n            hexChars[j * 3 + 1] = hexArray[v & 0x0F];\n            hexChars[j * 3 + 2] = ' ';\n        }\n        return new String(hexChars);\n}\n\n@Override\nprotected void didReceiveData(GizWifiErrorCode result, GizWifiDevice device,\n            ConcurrentHashMap<String, Object> dataMap, int sn) {\n\n    if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n    // 普通数据点类型，有布尔型、整形和枚举型数据，该种类型一般为可读写\n        if (dataMap.get(\"data\") != null) {\n            ConcurrentHashMap<String, Object> map = (ConcurrentHashMap<String, Object>) dataMap.get(\"data\");\n            // 扩展数据点，key为\"kuozhan\"\n            byte[] bytes = (byte[]) map.get(\"kuozhan\");\n            String string = bytesToHex(bytes);\n            Toast.makeText(this, string, Toast.LENGTH_SHORT).show();\n        }\n    }\n}\n\niOS接收到MCU上报拓展数据类型代码示例：\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)dataMap withSN:(NSNumber *)sn\n{\n    if (result.code == GIZ_SDK_SUCCESS)\n    {\n        NSLog(@\"接收到数据\");\n        NSDictionary *data = dataMap[@\"data\"];\n        NSString *kuozhan = data[@\"kuozhan\"];\n\n        NSLog(@\"dataMap = %@\", dataMap);\n        NSLog(@\"kuozhan = %@\", kuozhan);\n\n    }\n}\n\n5.设备上报数据案例\n案例：根据数据点上报格式上报数据：\nFF FF 00 42 05 00 00 00 04 01 02 03 04 05 06 07 08 09 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78\n注意定义的扩展数据类型为60个字节，因此上报数据的时候也一定要保证上报命令中“设备状态”字节数为60个字节，否则APP端将不会收到数据。多余的数据可以进行补零操作。\nAPP端接收到的dataMap字典中有一个\"kuozhan\"的key，对应的值即为透传的数据。\ndataMap = {\n    alerts={\n    };\n    data ={\n        kuozhan = <01020304 05060708 09000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000>;\n    };\n    faults={\n    };\n}\n\n6.APP下发数据代码示例\nAPP在GizWifiDevice类的write接口中，按照数据点定义发送扩展数据。\nAndriod下发拓展数据类型命令代码示例：\nbyte[] input1 = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 };\n// byte[] input2 = { 11, 22, 33, 44, 55, 66, 77, 88, 99};\nConcurrentHashMap<String, Object> dataMap = new ConcurrentHashMap<String, Object>();\ndataMap.put(\"kuozhan\", input1);\ndevice.write(dataMap, 0);\n\niOS下发拓展数据类型命令代码示例：\nchar input1[7] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};\n// char input2[7] = {11, 22, 33, 44, 55, 66, 77};\n    NSData* data = [NSData dataWithBytes:input1 length:sizeof(input1)];\n    NSDictionary *request = @{@\"kuozhan\": data};\n    [self.device write:request withSN:44];\n\n上述代码中，input1与input2的透传结果是不一样的，input1中定义的是十六进制的数值，input2中则是十进制的数值。如果使用input1中0x11的值下发给设备，那么设备将收到0x11的十六进制值，如果使用input2中11的值下发给设备，那么设备收到将是0x0b（十进制11对应十六进制b）。使用input1下发设备，MCU收到的数据为：\nFF FF 00 43 03 45 00 00 01 01 11 22 33 44 55 66 77 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 69\n无数据点透传\n1.设备上报数据协议说明\nMCU上报数据的格式如下表所示，包长度(len)是指从命令开始一直到校验和的字节长度(包括命令和校验和)。dev_status是需要透传数据，可以设置任意长度，但是暂时支持900B内传输。\n\n如设备上报指令：FF FF 00 0D 05 00 00 00 06 11 22 33 44 55 66 77 F4  ；那么透传的数据为11 22 33 44 55 66 77\n2.SDK回调接口说明\nAPP端接收到MCU上报数据的回调接口： didReceiveData，判断result为GizWifiErrorCode.GIZ_SDK_SUCCESS，则表示接收到数据成功，回传参数的dataMap 中的“binary”字段的值为透传数据。\n3.APP接收数据代码示例\nAndriod接收MCU无数据点上报代码示例：\n@Override\nprotected void didReceiveData(GizWifiErrorCode result, GizWifiDevice device,ConcurrentHashMap<String, Object> dataMap, int sn) {\n    if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n        // 透传数据，无数据点定义，适合开发者自行定义协议自行解析\n        if (dataMap.get(\"binary\") != null) {\n        byte[] binary = (byte[]) dataMap.get(\"binary\");\n        Log.i(\"info\", \"Binary data:\" + bytesToHex(binary));\n            // 收到后面需要自行解析\n        }\n    }\n}\n\niOS接收MCU无数据点上报代码示例：\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)dataMap withSN:(NSNumber *)sn\n{\n    if (result.code == GIZ_SDK_SUCCESS)\n    {\n        NSLog(@\"接收到数据\");\n        NSLog(@\"dataMap = %@\", dataMap);\n\n        NSString *binary = dataMap[@\"binary\"];\n        // 后面需要自行对binary数据进行解析\n    }\n}\n\n如MCU上报：FF FF 00 0D 05 00 00 00 06 11 22 33 44 55 66 77 F4\n则APP将打印： Binary data:11 22 33 44 55 66 77\n4.APP下发数据代码示例\nAPP在GizWifiDevice类的write接口中，发送的json格式为：{\"binary\": \"xxxxxx\"}；MCU接收的数据格式如下：\n \nAndriod下发无数据点透传数据代码示例：\nbyte[] input1 = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 };\nConcurrentHashMap<String, Object> dataMap = new ConcurrentHashMap<String, Object>();\ndataMap.put(\"binary\", input1);\ndevice.write(dataMap, 0);\n\niOS下发无数据点透传数据代码示例：\nchar input1[7] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};\n// char input2[7] = {11, 22, 33, 44, 55, 66, 77};    \nNSData* data = [NSData dataWithBytes:input1 length:sizeof(input1)];\nNSDictionary *request = @{@\"binary\": data};    \n[self.device write:request withSN:0];\n\nMCU接收到的APP下发数据格式（即以上bytes数组下发后，MCU接收到的数据）：\nFF FF 00 0D 03 16 00 00 05 11 22 33 44 55 66 77 07\n"},{"title":"SDK调试日志抓取教程","url":"/zh-cn/AppDev/SDK调试日志抓取教程.html","content":"概述\n本文档介绍了如何获取SDK的调试日志。\n当在使用机智云SDK进行调试的时候，如果出现一些不可控的错误，可以按照如下步骤获取相应的日志信息提供给机智云技术团队分析定位问题。\n如何获取手机APP SDK日志\n1.获取安卓SDK日志\n以下步骤以三星Galaxy Note3 Lite 4G为例\n步骤一、\n在安卓手机上集成我们的SDK，并参考机智云官网上集成文档之初始化流程：http://docs.gizwits.com/hc/kb/article/175453/ 正确启动我们的SDK后，SDK默认将所有日志信息输出到调试终端和日志文件中。如果手机有SD卡，则日志文件会保存在SD卡上，如果没有SD卡，就只保存在应用程序路径下。\n步骤二、\n用USB数据线将手机连接上电脑，并在我的电脑中打开手机SD卡目录\n  \n步骤三、找到GizWifiSDK文件并双击打开即可看到你开发的应用的包名，如果你同时在该手机上开发多个应用，则该目录下将会有多个包名文件夹。 \n步骤四、根据出现问题的应用，找到该应用对应的包名的文件夹，并将此文件夹里面的全部内容提供给机智云FAE即可。\n \n2.获取iOS SDK日志\n获取iOS SDK日志要区分两种情况，iOS10以下的系统和iOS10系统\n1）iOS10以下系统的日志获取\n步骤一、\n在iOS手机上集成我们的SDK，并参考机智云官网上集成文档之初始化流程：http://docs.gizwits.com/hc/kb/article/175851/ 正确启动我们的SDK后，SDK默认将所有日志信息输出到调试终端和日志文件中。\n步骤二、\n下载并安装同步助手：http://zs.tongbu.com/mac/ （其中包括了mac版和win版）\n步骤三、\n用USB数据线将手机连接到电脑上，打开同步助手，按下图操作，并将最终拷贝的文件夹交给机智云FAE即可。\n \n2）iOS10系统的日志获取\n步骤一、\n在项目的info.plist中添加一个key值：Application supports iTunes file sharing，value值为YES,如下图所示：\n \n步骤二、\n将APP运行到手机上\n步骤三、\n在iTurns的文件共享中获取日志\n   用USB数据线将手机连接到电脑上，打开iTurns，找到项目下的日志文件导出即可，如下图：\n  \n  \n"},{"title":"iOS App集成第三方登录与换肤指南","url":"/zh-cn/AppDev/iOS第三方登陆与换肤.html","content":"查看Android第三方登录与换肤指南\n查看第三方登录平台申请流程\n概述\n本文主要是介绍了如何通过开源框架快速支持QQ和微信登录，并介绍了如何实现app快速换肤\nQQ登录接入\nAPP要支持QQ登录，需要先到腾讯开放平台创建一个应用，获取应用的APPID，并设置到开源框架中即可。\n获取APP ID 并绑定应用\n查看QQ开放平台应用申请教程获取APP ID和绑定机智云应用\n开源框架配置\n配置腾讯APP ID\n将在腾讯开发平台申请到的APPID填写到开源框架的配置文件UIConfig.json中\n\n配置URL Schemes\n选择QQ登陆跳转到QQ授权登陆界面，登陆成功后需要跳转回我们的APP，此时需要给QQ SDK一个跳转路径，这个路径就是通过URL Schemes来设置的。\n   选择Targets -> Info 选择URL Types可以看到如下界面\n\n红框部分中必须修改的有两个部分：URL Schemes和Identifier。\nURL Schemes的修改规则是：tencent + 腾讯的APP ID。\nIdentifier一般采用反转域名来保证名字的唯一性，也可如图填写程序的Bundle Identify。\n微信登陆接入\nAPP要实现微信登陆，必须前往微信开放平台申请一个应用，获取应用的APPID和APPSecret并且配置到开源框架中即可。\n获取APPID和APPSecret\n查看微信开放平台应用申请教程获取APPID和APPSecret\n开源框架配置\n配置微信APP ID\n将在微信开发平台申请到的APPID和APPSecret填写到开源框架的配置文件UIConfig.json中，如下图\n\n配置URL Schemes\n选择微信登陆跳转到微信授权登陆界面，登陆成功后需要跳转回我们的APP，此时需要给微信SDK一个跳转路径，通过URL Schemes来设置这个路径。\n选择Targets -> Info 选择URL Types可以看到如下界面。\n\n红框部分中必须修改的有两个部分：URL Schemes和Identifier。\nURL Schemes的修改规则是：微信的APP ID。\nIdentifier一般采用反转域名来保证名字的唯一性，也可如图填写程序的Bundle Identify。\nAPP快速换肤\n开源框架已集成了皮肤定制功能。通过修改UIConfig.json文件即可实现快速换肤。\n\n如图红框内所示，为自定义皮肤代码修改区，各含义如下\nbuttonColor：按钮颜色\nbuttonTextColor：按钮文字颜色\nnavigationBarColor：导航栏颜色\nnavigationBarTextColor：导航栏文字颜色\nconfigProgressViewColor：配置中界面 progress view 颜色\nstatusBarStyle：状态栏颜色\n\n通过修改对应的颜色值即可实现快速换肤，参考如下示例：\n1. 肤色一\n\"buttonColor\":\"6ebe37\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\"6ebe37\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\n\" statusBarStyle \"：1\n\n实际效果图：\n\n2. 肤色二\n\"buttonColor\":\"ff8a44\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\"ff8a44\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\n\" statusBarStyle \"：1\n\n实际效果图：\n\n3. 肤色三\n\"buttonColor\":\" 16b599\",\n\"buttonTextColor\":\"ffffff\",\n\"navigationBarColor\":\" 16b599\",\n\"navigationBarTextColor\":\"ffffff\",\n\"configProgressViewColor\":\"000000\",\n\" statusBarStyle \"：0\n\n实际效果图：\n\n重要提示\n查阅《APP代码自动生成服务介绍》，可了解自动生成的APP代码模块具备哪些功能\n查阅《APP开源框架》，可了解\n\niOS开源框架使用指南\n\niOS App消息推送集成指南\n\niOS App集成第三方登录与换肤指南\n\niOS App快速开发实例\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送集成指南\nAndroid App集成第三方登录与换肤指南\nAPICloud开源框架使用指南\n\n查阅《APP开发SDK》，可随心开发IoT APP（很多细节设计，均可在里面找到应用案例）\n\niOS SDK 2.0集成指南\nAndroid SDK 2.0集成指南\nAPICloud SDK使用指南\nSDK数据透传方法解析\nSDK调试日志抓取教程\nSDK错误码表\n\n更多应用开发\n\n应用开发FAQ\n设备分享功能使用流程\n第三方登录平台申请流程\n\n"},{"title":"SDK错误码表","url":"/zh-cn/AppDev/sdk_error.html","content":"概述\n本文为主要列出了调用机智云SDK的时候，SDK回调返回的错误码信息\n错误码定义\n\n\n\n枚举ID\n枚举定义\n描述\n\n\n\n\n0\nGIZ_SDK_SUCCESS\nClient 发出的请求执行成功\n\n\n8001\nGIZ_SDK_PARAM_FORM_INVALID\nClient 发给 Daemon 的 json 格式错误\n\n\n8002\nGIZ_SDK_CLIENT_NOT_AUTHEN\nClient与Daemon之间如果没有通过握手认证，任何数据交互都无效\n\n\n8003\nGIZ_SDK_CLIENT_VERSION_INVALID\nClient 版本号无效\n\n\n8004\nGIZ_SDK_UDP_PORT_BIND_FAILED\nudp 端口绑定失败\n\n\n8005\nGIZ_SDK_DAEMON_EXCEPTION\nDaemon 系统错误\n\n\n8006\nGIZ_SDK_PARAM_INVALID\nClient 发出的数据请求，Json 格式正确，但参数无效；APP 传入参数无效\n\n\n8007\nGIZ_SDK_APPID_LENGTH_ERROR\nappid 长度错误\n\n\n8008\nGIZ_SDK_LOG_PATH_INVALID\n日志路径无效\n\n\n8009\nGIZ_SDK_LOG_LEVEL_INVALID\n日志级别无效\n\n\n8020\nGIZ_SDK_NO_AVAILABLE_DEVICE\n批量设置设备域名信息时没有可用设备\n\n\n8021\nGIZ_SDK_DEVICE_CONFIG_SEND_FAILED\n设备配置信息发送失败\n\n\n8022\nGIZ_SDK_DEVICE_CONFIG_IS_RUNNING\n设备正在配置\n\n\n8023\nGIZ_SDK_DEVICE_CONFIG_TIMEOUT\n设备配置超时\n\n\n8024\nGIZ_SDK_DEVICE_DID_INVALID\n设备 did 无效\n\n\n8025\nGIZ_SDK_DEVICE_MAC_INVALID\n设备 mac 无效\n\n\n8026\nGIZ_SDK_SUBDEVICE_DID_INVALID\n子设备 did 无效\n\n\n8027\nGIZ_SDK_DEVICE_PASSCODE_INVALID\n设备 passcode 无效\n\n\n8028\nGIZ_SDK_DEVICE_NOT_CENTERCONTROL\n不是中控设备\n\n\n8029\nGIZ_SDK_DEVICE_NOT_SUBSCRIBED\n设备未订阅\n\n\n8030\nGIZ_SDK_DEVICE_NO_RESPONSE\n设备未响应\n\n\n8031\nGIZ_SDK_DEVICE_NOT_READY\n设备未就绪\n\n\n8032\nGIZ_SDK_DEVICE_NOT_BINDED\n设备未绑定\n\n\n8033\nGIZ_SDK_DEVICE_CONTROL_WITH_INVALID_COMMAND\n设备控制指令中包含无效指令\n\n\n8034\nGIZ_SDK_DEVICE_CONTROL_FAILED\n设备控制指令执行失败\n\n\n8035\nGIZ_SDK_DEVICE_GET_STATUS_FAILED\n设备状态查询失败\n\n\n8036\nGIZ_SDK_DEVICE_CONTROL_VALUE_TYPE_ERROR\n设备控制指令参数类型错误\n\n\n8037\nGIZ_SDK_DEVICE_CONTROL_VALUE_OUT_OF_RANGE\n设备控制指令参数值不在有效范围内\n\n\n8038\nGIZ_SDK_DEVICE_CONTROL_NOT_WRITABLE_COMMAND\n设备控制指令中包含不可写指令\n\n\n8039\nGIZ_SDK_BIND_DEVICE_FAILED\n设备绑定失败\n\n\n8040\nGIZ_SDK_UNBIND_DEVICE_FAILED\n设备解绑失败\n\n\n8041\nGIZ_SDK_DNS_FAILED\n域名解析失败\n\n\n8042\nGIZ_SDK_M2M_CONNECTION_SUCCESS\nm2m 连接成功\n\n\n8043\nGIZ_SDK_SET_SOCKET_NON_BLOCK_FAILED\nsocket 设置非阻塞失败\n\n\n8044\nGIZ_SDK_CONNECTION_TIMEOUT\n连接超时\n\n\n8045\nGIZ_SDK_CONNECTION_REFUSED\n连接被拒绝\n\n\n8046\nGIZ_SDK_CONNECTION_ERROR\n连接错误\n\n\n8047\nGIZ_SDK_CONNECTION_CLOSED\n连接被关闭\n\n\n8048\nGIZ_SDK_SSL_HANDSHAKE_FAILED\nssl 握手失败\n\n\n8049\nGIZ_SDK_DEVICE_LOGIN_VERIFY_FAILED\n设备登录验证失败\n\n\n8050\nGIZ_SDK_INTERNET_NOT_REACHABLE\n当前外网不可达\n\n\n8095\nGIZ_SDK_HTTP_SERVER_NOT_SUPPORT_API\nHTTP 服务不支持此 API\n\n\n8096\nGIZ_SDK_HTTP_ANSWER_FORMAT_ERROR\nopenapi 应答格式错\n\n\n8097\nGIZ_SDK_HTTP_ANSWER_PARAM_ERROR\nhttp 应答参数错误\n\n\n8098\nGIZ_SDK_HTTP_SERVER_NO_ANSWER\nhttp 服务无响应\n\n\n8099\nGIZ_SDK_HTTP_REQUEST_FAILED\nhttp 请求失败，比如返回 404 等\n\n\n8101\nGIZ_SDK_MEMORY_MALLOC_FAILED\nDaemon 内存分配失败\n\n\n8102\nGIZ_SDK_THREAD_CREATE_FAILED\nDaemon 内部线程创建失败\n\n\n8150\nGIZ_SDK_USER_ID_INVALID\n用户 ID 无效\n\n\n8151\nGIZ_SDK_TOKEN_INVALID\n用户 token 无效\n\n\n8152\nGIZ_SDK_GROUP_ID_INVALID\n组 ID 无效\n\n\n8153\nGIZ_SDK_GROUPNAME_INVALID\n组名称无效\n\n\n8154\nGIZ_SDK_GROUP_PRODUCTKEY_INVALID\n组类型无效\n\n\n8155\nGIZ_SDK_GROUP_FAILED_DELETE_DEVICE\n组设备删除失败\n\n\n8156\nGIZ_SDK_GROUP_FAILED_ADD_DEVICE\n组设备添加失败\n\n\n8157\nGIZ_SDK_GROUP_GET_DEVICE_FAILED\n组设备获取失败\n\n\n8201\nGIZ_SDK_DATAPOINT_NOT_DOWNLOAD\n配置文件还未下载\n\n\n8202\nGIZ_SDK_DATAPOINT_SERVICE_UNAVAILABLE\n配置文件服务不可用\n\n\n8203\nGIZ_SDK_DATAPOINT_PARSE_FAILED\n配置文件解析失败\n\n\n8300\nGIZ_SDK_SDK_NOT_INITIALIZED\nSDK 未初始化\n\n\n8301\nGIZ_SDK_APK_CONTEXT_IS_NULL\nContext 无效，无法启动\n\n\n8302\nGIZ_SDK_APK_PERMISSION_NOT_SET\napp 权限不足\n\n\n8303\nGIZ_SDK_CHMOD_DAEMON_REFUSED\n无法修改 daemon 的执行权限\n\n\n8304\nGIZ_SDK_EXEC_DAEMON_FAILED\ndaemon 程序执行失败\n\n\n8305\nGIZ_SDK_EXEC_CATCH_EXCEPTION\n尝试运行 daemon 时发生异常\n\n\n8306\nGIZ_SDK_APPID_IS_EMPTY\nAPPID 为空\n\n\n8307\nGIZ_SDK_UNSUPPORTED_API\n不支持的 API\n\n\n8308\nGIZ_SDK_REQUEST_TIMEOUT\nClient 如果等不到 Daemon 的回复，就向 APP 返回操作超时\n\n\n8309\nGIZ_SDK_DAEMON_VERSION_INVALID\nDaemon 版本号无效\n\n\n8310\nGIZ_SDK_PHONE_NOT_CONNECT_TO_SOFTAP_SSID\n手机没有连接软 AP 热点\n\n\n8311\nGIZ_SDK_DEVICE_CONFIG_SSID_NOT_MATCHED\n手机热点和要配置的路由 ssid 不匹配\n\n\n8312\nGIZ_SDK_NOT_IN_SOFTAPMODE\n设备不在 softap 模式\n\n\n8313\nGIZ_SDK_CONFIG_NO_AVAILABLE_WIFI\n设备配置时无可用 wifi\n\n\n8314\nGIZ_SDK_RAW_DATA_TRANSMIT\n设备上报透传数据的标识\n\n\n8315\nGIZ_SDK_PRODUCT_IS_DOWNLOADING\n正在下载设备的产品定义\n\n\n8316\nGIZ_SDK_START_SUCCESS\nSDK 启动成功\n\n\n10003\nGIZ_SITE_PRODUCTKEY_INVALID\n产品标识码无效\n\n\n10010\nGIZ_SITE_DATAPOINTS_NOT_DEFINED\n数据点未定义\n\n\n10011\nGIZ_SITE_DATAPOINTS_NOT_MALFORME\n数据点异常\n\n\n\n"},{"title":"第三方登录平台申请流程","url":"/zh-cn/AppDev/third-party.html","content":"一、 国内平台\n微信\nAPP要实现微信登陆，必须前往微信开放平台申请一个应用，获取应用的AppID和AppSecret并且配置到开源框架中即可。\n注册开发者账号\n已有开发者账号可以直接跳过此步骤\n点击进入微信开放平台\n\n点击《注册》进入以下界面，填写开发者基本信息\n\n点击 下一步，微信开放平台将会往你的注册邮箱发送一份激活邮件\n\n点击激活链接，跳转到完善资料界面，填写资料，点击完成即成功创建了微信开放平台开发者账号。\n\n创建应用\n注册成功后登陆微信开放平台，选中 管理中心 跳转到应用创建界面\n\n点击 创建移动应用 按钮，进入以下界面，填写应用的基本信息。\n\n填写完成，点击 下一步，进入《填写平台信息界面》\n\n选择需要的应用平台（一般iOS和Android都要），iOS应用需要填写Bundle ID，安卓应用需要填写应用签名和应用包名，\n\n\n填写完毕后，点击 提交审核，提交审核成功，7天内微信会给出审核结果。审核通过后，应用的APPID和APPKey就可以使用了。\n获取 AppID 和 AppSecret\n审核通过后在移动应用列表点击 查看\n\n打开应用详情后可以看到AppID和AppSecret\n\n配置开源框架\n点击查看iOS SDK 配置微信登录教程\n点击查看Android SDK 配置微信登录教程\n腾讯QQ\nAPP要支持QQ登录，需要先到腾讯开放平台创建一个应用，获取应用的APPID，并设置到开源框架中即可。\n注册开发者账号\n点击进入腾讯开放平台\n\n点击 登录 ，填写账号密码登录\n\n登录成功后跳转到注册界面，开发者可根据自己的需要选择个人或者公司类型。\n\n下图是选择个人注册的跳转界面，需填写完整的资料，并完成邮箱验证，即成功创建腾讯开发者账号。\n\n创建应用\n进入腾讯开放平台，点击 应用接入\n\n安卓应用\n选择 移动应用 安卓，点击 创建应用\n \n完善应用信息，并提交审核\n\niOS应用\n选择 移动应用 iOS，点击 创建应用\n\n完善应用信息，并提交审核\n\n获取 APP ID 和 APP KEY\n安卓应用\n审核通过后，即可获取下图的APP ID 和 APP KEY来创建QQ登录登录。\n\niOS应用\n审核通过后，即可获取下图的APP ID 和 APP KEY来创建QQ登录登录。\n\n绑定应用\n登录机智云开发者中心，选中需要绑定第三方登录的产品\n\n进入产品设置界面，选择需要关联QQ登录的应用，如下图：\n\n点击 关联第三方登录 进入关联界面，填写从腾讯开放平台申请到的APPID，并点击确定，即完成了机智云应用于QQ应用的绑定。\n\n配置开源框架\n点击查看ios SDK配置QQ登录教程\n点击查看Android SDK配置QQ登录教程\n新浪微博\nAPP要支持新浪微博登录，需要先到微博开放平台创建一个应用，通过新浪sdk获得token和uid后，调用OpenAPI创建用户。\n注册开发者账号\n点击进入微博开放平台\n\n点击 登录 ，填写账号密码登录\n\n登录成功点击 编辑开发者信息 完善开发者信息和完成身份认证。\n\n开发者可根据自己的需要选择个人或者公司类型\n\n完成身份认证\n\n创建应用\n进入微博开放平台，点击 微连接 >> 移动应用\n\n点击 立即接入\n\n选择需要的应用平台（一般iOS和Android都需要）\n\n填写应用信息后提交审核。iOS应用需要填写Apple ID和Bundle ID，安卓应用需要填写一套签名信息和下载地址。\n\n获取 AppID 和 AppSecret\n点击应用信息，如下图所示位置查看AppID 和 AppSecret\n\n调用接口\n开发者根据微博提供的 SDK 完成微博登录，通过返回的 user_id 和 access_token 调用机智云OpenAPI的创建用户接口完成登录。\n百度\nAPP要支持百度登录，需要先到百度开发者中心创建一个应用，通过？？？？？？获得token和uid后，调用OpenAPI创建用户。\n注册开发者账号\n点击进入百度开放平台\n\n登录成功后完善开发者信息，开发者可根据自己的需要选择个人或者公司类型。并完成邮箱验证，即成功创建百度开发者账号\n\n创建应用\n完成邮箱验证后，通过邮箱链接进入百度开发者中心，然后点击去创建应用。\n\n进入开发者服务管理，点击创建工程\n\n填写应用名称\n\n获取 API Key 和 Secret Key\n点击基本信息，如下图所示位置查看API Key 和 Secret Key\n\n调用接口\n开发者根据百度提供的 SDK 完成百度登录后获取 access_token ，然后通过百度的 REST API 获取 UID，再调用机智云OpenAPI的创建用户接口完成登录。\n二、国外平台\nFacebook\nAPP要支持Facebook登录，需要先到腾讯开放平台创建一个应用，获取应用的APPID，并设置到开源框架中即可。\n登录developers\n点击进入Facebook for developers,登录Facebook账号\n\n创建应用\n完成身份认证后创建应用\n新用户创建界面，点击 创建应用\n\n老用户创建应用，点击 添加新应用\n\n填写应用名称和联系邮箱，点击 创建应用编号\n\n创建成功后自动打开应用详情，选择 设置 >> 基本，点击 添加平台\n\n选择需要的应用平台（一般iOS和Android都需要）\n\n填写应用信息，\n\n获取 App ID 和 App Secret\n点击控制面板即可查看 App ID，点击下图显示按钮查看 App Secret\n\n调用接口\n开发者根据 Facebook 提供的sdk完成第三方登录，通过返回的user_id和access_token调用机智云OpenAPI的创建用户接口完成登录。\nTwitter\nAPP要支持 Twitter 登录，需要先到Twitter Developers创建一个应用，获取应用的APPID。\n登录Developers\n打开Twitter Developers，点击 My apps\n\n如果还没有注册Twitter账号的，需要先注册账号，已经注册账号的，请直接登录：\n\n创建应用\n点击Create New App\n\n填写APP名称、说明和网站地址\n\n注:1）现在Twitter创建新的应用时，必须将的手机号添加到Twitter账号上。2）使用在iOS和Android应用中使用twitter登录必需填写CallBack URL。\n获取 API KEY 和 API Secret\n点击Keys and Access Tokens，将得到下图中的API KEY 和 API Secret。\n\n绑定并应用\n登录机智云开发者中心，选中需要绑定第三方登录的产品\n\n进入产品设置界面，选择需要关联QQ登录的应用，如下图：\n\n点击 关联第三方登录 进入关联界面，填写从Twitter Developers申请到的API KEY 和 API Secret，并点击确定，即完成了机智云应用于twitter应用的绑定。\n\n调用接口\n开发者根据 Twitter 提供的sdk完成第三方登录，通过返回的user_id和access_token调用机智云OpenAPI的创建用户接口完成登录。\nGoogle+\n登录APIs\n打开Google APIs，如果还没有注册google账号的，需要先注册账号，已经注册账号的，请直接登录：\n\n创建应用\n登录成功后点击 选择项目\n\n弹出选择项目弹窗，点击 +号 创建项目\n\n填写项目名称，同意服务条款并点击创建按钮\n\n在新创建的项目下，点击 凭据 >> OAuth 同意屏幕，将APP名称填入“向使用者展示的产品名称”，和填写其他app的信息。\n\n返回 凭据 标签，点击 创建凭据 >> OAuth 客户端ID\n\n填写应用软件包ID(bundle id)，可选择填写App Store ID 和团队ID\n\n获取Client ID\n点击 凭据 标签，即可在下图所示位置查看客户端ID（Client ID）\n\n调用接口\n开发者根据google提供的sdk完成第三方登录，通过返回的user_id和access_token调用机智云OpenAPI的创建用户接口完成登录。\n注：接口中token入参数需要Bearer开头，以空格连接。格式：Bearer access_token\nAmazon\nAPP要支持 Amazon 登录，需要先到 Login with Amazon 创建一个应用，获取应用的APPID。\n登录Developers Center\n打开Amazon Developers Center 的Login with Amazon，点击 Sign Up\n\n如果还没有注册Twitter账号的，需要先注册账号，已经注册账号的，请直接登录：\n\n创建应用\n点击Register new application创建新应用\n\n填写应用名称、说明和网站地址\n\n添加所需要的应用平台（一般iOS和Android都需要，Android）\n\n填写应用基本信\n\n获取 APP ID 和 API Key\n在应用信息中即可看到APP ID\n\nAPI Key需要在iOS或Android设置中点击API Key Value查看\n\n调用接口\n开发者根据Amazon提供的sdk完成第三方登录，通过返回的user_id和access_token调用机智云OpenAPI的创建用户接口完成登录。\n注：接口中token入参数需要Bearer开头，以空格连接。格式：Bearer access_token\n"},{"title":"应用开发FAQ","url":"/zh-cn/AppDev/应用开发FAQ.html","content":"1、概述\n本文列举了开发者在使用机智云app、开源框架、app自动生成或者进行SDK集成的时候所遇到的一些问题以及解答方案。\n2、FAQ\nQ：配置失败，设备配不上网，App显示配置超时\nA： 设备配网涉及到App以及设备端，以下列出会导致该问题发生的情况或解决方案。\n\n1、使用机智云app进行配置（机智云app下载地址：https://download.gizwits.com/zh-cn/p/98/99）。\n2、配置时确认将要配置的网络和手机所链接的网络是否为同一个，确认路由器SSID和密码是否输入正确，确认配置时所选用的模组型号正确。\n3、将要配置的路由器不能是5G频段的wifi，不能有链接登陆限制、不可开启ap隔离，尝试更换wifi路由器，或用手机热点作为路由器，不建议使用公共或进行了端口限制的路由器进行配置。\n4、判断设备是否进入了相应的配置模式，通过模组的debug口的输出日志，查看模组是否进入配网模式（抓取日志链接：http://docs.gizwits.com/zh-cn/deviceDev/%E9%80%9A%E8%AE%AF%E6%A8%A1%E7%BB%84%E8%B0%83%E8%AF%95%E6%97%A5%E5%BF%97%E6%8A%93%E5%8F%96%E6%95%99%E7%A8%8B.html\n\nQ：App配置成功了，但是设备没有显示\nA：使用开源框架、App自动生成所编译出来的App，确认App工程目录中的assets/UIConfig.json，product key是否与自己设备一致。\nQ：使用开源框架或自动生成出来的App，注册账号显示“未知错误”\nA：那是因为注册的时候采用了弱密码导致的，注册需要采用强密码注册，密码由大写，小写，数字和特殊符号组成，四个条件至少满足三个即可\nQ：为什么在机智云App上注册的账户，不能在开源框架或自动生成出来的App登陆，登陆显示账号密码错误\nA：那是因为机智云App和开源框架还有自动生成的app不具备同一个appid，用户系统也不同，如需要在各自的App上登陆，同时也要在该App上注册用户。\nQ：机智云App显示“未知设备\\不支持该设备\\下载配置文件失败”是什么？怎么处理？\nA：IOE Demo加载了设备列表以后，会自动下载设备的配置文件，SDK通过该配置文件进行JSON和二进制数据的解析，这样才能正确的控制设备和获取设备状态。如果IOE Demo因为网络问题未下载到对应设备的配置文件，或者云端无法找到该设备的配置文件，就会出现该句提示，或者提示“下载配置文件失败”。\nQ：开源App要怎样改动才能控制我的设备？\nA：关键步骤有三步，推荐采用自动生成App，可以省略前两步：\n\n1、修改源码的ProductKey和AppID与自己的设备一致。\n2、修改源码的数据点标识名与自己的设备一致。\n3、根据自己的设备功能修改UI。\n\nQ：Demo App如何下载？是通用的吗？\nA：Demo App可通过机智云下载中心下载或者是在手机应用商店搜索“机智云”。因为Demo App做了界面空间和通讯协议自适应，所以机智云平台上的所有产品用的都是同一个Demo App，不需要另外下载。\nQ：微信开发要用个人公众号还是企业公众号？\nA：微信公众号分为服务号、订阅号、企业号。设备功能目前是微信服务号的一个插件功能，开通设备功能前需要先申请开通服务号。未认证的服务号也可以开通设备功能，但对接入设备的数量有严格限制。因此， 未认证的服务号开通设备功能后，需要尽快通过服务号认证，以提高接入设备限额。因为服务号目前不向个人开放申请，个人开发者可以使用测试账号来完成开发调试。详情可参考微信官方说明\nQ：机智云怎样判断当前模块和终端是局域网还是广域网，要理论 \nA：手机SDK里面是这样判断的：SDK每隔1秒会在局域网发出广播包，模组如果在局域网的话，收到了广播包就会给SDK回复passcode，这时候SDK就能通过passcode来登录设备了。如果SDK收不到回复，就会判断设备列表里面的设备是远程的，会通过广域网查询设备状态。\n"},{"title":"开源框架视频教程","url":"/zh-cn/AppDev/开源框架视频教程.html","content":"教程概述\n开源框架是机智云的出品，包含Wi-Fi类智能硬件app通用功能的一套源码。只要使用机智云协议的产品，开发者可以直接用该框架的源码实现快速开发配套app，从而满足app开发周期短、成本低的要求。\n本教程将给大家介绍如何使用机智云开源框架，开发属于自己产品的app，按由易到难、从基础功能到高级功能，分为以下几个章节进行讲解：\n\n如何创建机智云产品\n如何使用核心模块开发设备控制功能\n如何在开源框架基础上定制app开发\n如何使用微信登录\n如何使用QQ登录\n如何使用百度推送\n如何使用极光推送\n\n微信和QQ登录、百度和极光推送功能属于高级功能。在我们的开源框架代码中，默认是不开启这些高级功能的。如果只想要一个简单的设备控制功能app，只学习前三个章节就可以了。想要使用高级功能，可以继续关注后面的章节。\n开源框架教程1-1\n视频标题\n开发者中心产品及设备应用创建（App开发前传）\n视频简介\n我们在app开发之前，需要学会在机智云开发者中心创建新产品。首先选择产品分类和方案，为产品添加数据点，最后为产品创建应用。为了帮助大家更好地理解整个创建过程，我们在视频里穿插着介绍了开源框架、数据点、数据点模板、Product key、Product Secret、App ID、App Secret等用法。\n观看链接\nhttps://v.qq.com/x/page/p0344jspddv.html\n开源框架教程1-2\n视频标题\n使用开源框架快速开发一个功能简单的iOS App\n视频简介\n延续开源框架教程1-1，本教程在开源框架代码基础上做一个控制gokit红灯开关的iOS App。下载代码后进行APP定制，在控制页面的布局文件中创建点击事件，将pruductkey烧写进Gokit的MCU固件中，最后为大家实操展示APP控制Gokit亮灯。为了帮助大家更好地理解整个创建过程，我们在视频里穿插着介绍了开源框架代码模块、代码功能、指令添加、iOS app、设备配置等用法。\n观看链接\nhttps://v.qq.com/x/page/b0350blmgcf.html\n开源框架教程1-3\n视频标题\n使用开源框架快速开发一个功能简单的Android App\n视频简介\n延续开源框架教程1-1，本教程在开源框架代码基础上做一个控制gokit红灯开关的Android App。下载代码后进行APP定制，在设备控制页面的布局文件中创建点击事件，将pruductkey烧写进Gokit的MCU固件中，最后为大家实操展示APP控制Gokit亮灯。为了帮助大家更好地理解整个创建过程，我们在视频里穿插着介绍了开源框架代码模块、代码功能、指令添加、Android app、设备配置等用法。\n观看链接\nhttps://v.qq.com/x/page/p03512if92n.html\n\n机智的小伙伴们，赶紧按着教程复习一遍。如果您喜欢我们或者对我们还有什么建议，可以在机智云论坛大声说出你们的想法。我们会提供更好更全的视频教学内容。\n更多视频，敬请期待！\n（不定期更新）\n"},{"title":"云端应用FAQ","url":"/zh-cn/Cloud/CloudFAQ.html","content":"1、概述\n本文列举了开发者在使用机智云的开发者平台和api，或者进行web开发，后台开发的时候所遇到的一些问题以及解答方案。\n2、FAQ\nQ：项目下的设备日志数据在云端可以保存多久\nA：  在云端的设备日志以及历史日志，可以保存7天。\nQ：请问下一个product key最多可以添加多少个数据点\nA：目前服务器端对这个没有限制，测试反馈添加了200个数据点，都是可以正常工作的。\nQ：请问product key可以进行修改么”\nA：项目创建以后，pk是不能被修改的。想换pk，可以把数据点导出成模板，然后重新创建一个新的项目再将模板导入进去。\nQ：请问OpenApi和Web Socket Api提供SSL的通讯支持吗\nA：支持的\nQ：设备已经断开连接，为什么云端与APP仍然显示设备在线一段时间？\nA：设备有可能是掉电、死机、断网等各种意外造成的异常断开，TCP keepalive默认值是2分钟左右\nQ： 什么情况设备日志会出现再上线？\nA：在设备与云端的两个心跳时间间隔内出现模组重新连接云端，云端日志就会显示再上线。在手动调试过程，或者网络不好的情况下比较容易出现。\nQ：如何确认OTA是否成功？\nA：OTA后，将模组重新上电，查看模组的软件版本号，若是OTA的版本号，则说明OTA成功。云端显示OTA失败，只要查看版本号是新的，都表明成功。\nQ：调用云端openapi，修改用户信息的接口，返回9999的错误是怎么回事？ \nA：修改用户信息的接口，返回9999是因为你修改的信息和原来的信息是一样的，所以返回改错误\nQ：在做OTA升级GAgent的时候，出现“不是同一个系列的固件”的提示\nA：是因为填写的硬件版本号不一致导致的，先查看要升级的GAgent硬件版本号是多少，再重新填写到固件验证的信息上。\nQ：OTA升级设备WiFi固件出现无法升级，但重新上电有恢复正常，又开始OTA升级现象\nA：OTA升级的时候，设备每重启一次都会去检查该固件的版本是否需要进行升级。如果该设备是符合升级的条件，即使第一次升级失败，重启设备后都会重新去执行一次升级的，一直到设备升级成功。\nQ：用网页去获取设备数据可以用什么接口，OpenApi，WebSocketApi，Snoti这三种有什么区别。\nA：这三种Api都可以做到，区别不同就是，OpenApi是HTTP请求，是异步执行的（且涉及用户管理方面、分享，分组等接口），WebSocketApi是单个设备实时监控，Snoti可以做到多个设备实时监控\n"},{"title":"SNoti API","url":"/zh-cn/Cloud/NotificationAPI.html","content":"v2.1.9\n目的\n企业客户可通过SNoti提供的安全数据传输通道，实时的接收设备的数据，用于设备信息归类整理，设备状态统计，设备监控等；也可以通过远程控制功能，实时发送业务指令控制在线设备。\n客户端示例（开源社区版本）\n用户可根据需要，适当选择以下任意一种开发语言的客户端版本，基于此做二次开发，或者作为参考。\n1.Java版客户端\n  代码仓库：https://github.com/Bestfeel/noti-netty-client\n2.Ruby版客户端\n  代码仓库：https://github.com/AbelLai/gizwits_sac_rb\n3.Python版客户端\n  代码仓库：https://github.com/wangzhenandy/snoti_client_python\n4.Java版Demo（基础版）\n  代码仓库：https://github.com/gizwits/noti-java-demo/tree/v2.0.0\n5.Java版Demo（Netty框架版）\n  代码仓库：https://github.com/gizwits/noti-java-demo/tree/v2.0.0-netty\nSNoti申请流程\n1.企业开发者登陆开发者中心，选择添加服务，如下图\n\n2.点击上图箭头指向的SNoti服务，进入下一步，申请开通服务\n\n3.成功添加SNoti服务后，在服务页面点击“新建授权”创建，该 auth_id 拥有获取该产品下所有设备消息和控制设备的权限；\n\n关键术语\n1.auth_id & auth_secret: 产品授权ID和密钥，一款产品可创建多个auth_id，一个auth_id对应唯一的一款产品；SNoti客户端登陆时，会验证auth_id和auth_secret的正确性；\n2.subkey：消息分发机制，以ProductKey + subkey作为唯一主键，不同主键之间，消息互不影响（即同一个ProductKey使用不同的subkey，可产生消息副本）；subkey(subscription key)为自定义字符串，大小写敏感，长度为 1 到 32 个字符，可包含数字，字母和下划线（即[a-zA-Z0-9]）；\n3.产品的12种消息类型（event_type）分别为：\n\ndevice.online：设备上线消息\ndevice.offline：设备下线消息\ndevice.status.raw：设备上报自定义透传业务指令\ndevice.status.kv：设备上报数据点业务指令\ndevice.attr_fault：设备故障事件\ndevice.attr_alert：设备报警事件\ndatapoints.changed：数据点编辑事件\ncenter_control.sub_device_added: 中控添加子设备事件\ncenter_control.sub_device_deleted: 中控删除子设备事件\ndevice.bind：设备绑定消息\ndevice.unbind: 设备解绑消息\ndevice.reset：设备重置消息\ndevice.file.download：设备文件下载消息\ndevice.app2dev.raw: 控制设备自定义透传业务指令\ndevice.app2dev.kv: 控制设备数据点业务指令\n\n过程描述\n事件通过 SSL 接口推送。通讯过程如下：\n1.客户端以 Client 的身份与本接口（Gizwits Platform）建立 SSL 连接。客户端无需提供证书，只需要信任服务器证书即可；\n2.客户端发送登录指令完成验证；\n3.服务端推送消息到客户端。推送工作方式：\n\n相同 product_key + subkey 的多个客户端登录连接，消息轮流推送到各客户端；\n相同 product_key，不同 subkey 的客户端都能接收该 product 下设备的指定类型的消息副本，客户端之间不会相互干扰；\n当某客户端未返回的 ack 消息数达到该客户端登录设置的 prefetch_count 值后，消息将不在继续推送给该客户端，但会发送到其他客户端；\n未返回 ack 的消息，服务端会一直等待不会重发，只有在该客户端断开的情况下，未 ack 的消息会重新发送到连接的客户端；\n当所有客户端都断开连接后，后续设备的消息会保存在服务端，等待客户端下次接收。\n\n4.客户端实时接受事件消息，并向服务器 ack 事件消息；\n5.当客户端在一定时间范围内没有向服务器发送任何消息，需要发 ping 心跳请求，服务器回复 pong 心跳响应。\n6.客户端可发送远程控制指令，来控制设备。SNoti服务会在客户端登录时，缓存每一个product_key对应的M2M信息，用于给设备发送控制指令。特别注意的是，当产品正式发布后，需要重启SNoti客户端，以更新M2M的信息。\n接口协议\n\n域名：snoti.gizwits.com\nSSL 服务端口：2017\n\n消息内容为二进制数据，UTF-8 编码。请注意每个消息后都必须添加\"\\n\"作为消息结尾符。\n1.  连接与登陆\n客户端和 Gizwits Platform 建立 SSL 连接后，客户端发送以下字符串内容作身份验证(登陆Gizwits Platform)：\n{\n\"cmd\": \"login_req\",\n\"prefetch_count\":<uint> (0 < prefetch_count <= 32767, 表示推送没有 ACK 的消息\n的最大个数，可不填，默认值是 50)\n\"data\": [{\n“product_key\": <key string>,\n\"auth_id\": <auth_id string>,\n\"auth_secret\": <auth_secret string>,\n\"subkey\": <subkey string>,\n\"events\":[<event string>,...] (可一个或多个 event)\n},...] (可一个或多个 product)\n}\\n\n\n请求字段说明：\n\n\n\n字段\n是否必须\n描述\n\n\n\n\ncmd\n必须\n登录类型，必须为login_req\n\n\nprefetch_count\n非必须\n默认值为50\n\n\ndata.product_key\n必须\n产品ID\n\n\ndata.auth_id\n必须\n产品授权ID\n\n\ndata.auth_secret\n必须\n产品授权密匙\n\n\ndata.subkey\n必须\nsubscription key，为客户端自定义标识，大小写敏感，长度为 1 到 32 个字符，可包含数字，字母和下划线\n\n\ndata.events\n必须\n客户端接收消息类型，使用逗号隔开的字符串列表，目前支持类型 为device.attr_fault;device.attr_alert;device.online;device.offline   device.status.raw;device.status.kv;datapoints.changed   center_control.sub_device_added;center_control.sub_device_deleted   device.bind;device.unbind;device.reset;device.file.download\n\n\n\nGizwits Platform 回复：\n{\n\"cmd\": \"login_res\",\n\"data\": {\n\"result\": true | false,\n\"msg\": \"ok\" | <error msg>\n}\n}\\n\n\n如 result 为 false 表示登陆失败，该连接会被关闭。\n2.  心跳\n客户端和 Gizwits Platform 建立 SSL 连接后，需定期向 Gizwits Platform 发送数据以保持连接的有效性，如 5 分钟内没有向 Gizwits Platform 发送任何数据，应向 Gizwits Platform 发送以下的心跳数据：\n{\n\"cmd\": \"ping\"\n}\\n\n\nGizwits Platform 回复：\n{\n\"cmd\": \"pong\"\n}\\n\n\n如没有及时收到 Gizwits Platform 的回复，可以认为与 Gizwits Platform 的连接已关闭，需重连。\n3.  控制设备\n客户端和 Gizwits Platform 建立 SSL 连接后，客户端可发送以下字符串内容，控制设备：\n{\n\"cmd\": \"remote_control_req\",\n\"msg_id\": <msg id string>,\n\"data\": [{\n“cmd\": \"write_attrs\" | \"write\" | \"write_v1\",\n\"data\": {\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"product_key\": <product_key string>,\n\"attrs\": {\n\"name1\": <value1>,(\"name1\"指数据点的标识名(name)，<value1>指数据点的值。值可以为true/false(bool)，Unicode编码的字符串如\\u62bd(enum)，数字或byte数组(如 [23,2,3]，用于扩展类型))\n\"name2\": <value2>,\n… …\n}(Only used with cmd \"write_attrs\")\nOR\n\"raw\": [<byte>, <byte>, <byte>, … ...](Only used with cmd \"write\" or \"write_v1\")\n}\n},...] (可一个或多个控制指令)\n}\\n\n\n请求字段说明：\n\n\n\n字段\n是否必须\n描述\n\n\n\n\ncmd\n必须\n控制设备，必须为 remote_control_req\n\n\nmsg_id\n可选\n可用于标识本消息，将会在回复指令中返回\n\n\ndata\n必须\n控制指令，数组类型\n\n\ndata.cmd\n必须\nV4 产品数据点协议格式，填写write_attrs；V4 产品自定义协议格式，填写 write；V1 产品协议格式，填写 write_v1\n\n\ndata.source\n必须\n固定填写 noti\n\n\ndata.data.did\n必须\n设备 ID\n\n\ndata.data.mac\n必须\n设备 Mac 地址,长度为 12 的字符串，大小写敏感\n\n\ndata.data.product_key\n必须\n设备所属产品的标识码\n\n\ndata.data.attrs / data.data.raw\n必须\nV4 产品数据点协议格式，选择data.data.attrs；V4 产品自定义协议格式（参考通用数据点协议之透传业务指令），选择data.data.raw；V1 产品协议格式，选择 data.data.raw\n\n\n\n当设备为NB-IoT设备时，使用如下指令：\n{\n\"cmd\": \"remote_control_nb_req\",\n\"msg_id\": <msg id string>,\n\"source\": \"huawei\",\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"product_key\": <product_key string>,\n\"attrs\": {\n\"name1\": <value1>,(\"name1\"指数据点的标识名(name)，<value1>指数据点的值。值可以为true/false(bool)，Unicode编码的字符串如\\u62bd(enum)，数字或byte数组(如 [23,2,3]，用于扩展类型))\n\"name2\": <value2>,\n… …\n}\n}\\n\n\n请求字段说明：\n\n\n\n字段\n是否必须\n描述\n\n\n\n\nsource\n必须\nNB-IoT设备的来源，目前仅支持电信IoT平台\n\n\n\nGizwits Platform 回复：\n{\n\"cmd\": \"remote_control_res”,\n\"msg_id\": <msg id string>,\n“result\": {\n\"succeed\": [\"did1\", \"did2\", … …]\n\"failed\": [\n{\"did3\": <reason str>}\n{\"did4\": <reason str>}\n… …\n]\n}\n}\\n\n\n其中msg_id的内容为请求消息中msg_id字段的内容，如请求消息中不存在该字段，回复消息中将不会出现该字段。\n如协议自身引起的错误，Gizwits Platform 回复 错误响应消息，该消息格式参见下文。\n4.  推送事件\n数据点编辑事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于 ACK)\n\"event_type\": \"datapoints_changed\",\n\"product_key\": <product_key string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\n\n设备上线事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于 ACK)\n\"event_type\": \"device_online\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>，\n\"ip\": <ip string>,\n\"latitude\": <latitude float; Only for NB device>,\n\"longitude\": <longitude float; Only for NB device>,\n\"country\": <country string>,\n\"region\": <region string>,\n\"city\": <city string>\n}\\n\n\n设备下线事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于 ACK)\n\"event_type\": \"device_offline\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\n\n故障与报警事件\n当有故障与报警事件发生，Gizwits Platform 会向客户端推送以下消息：\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于 ACK)\n\"event_type\": \"attr_fault\" | \"attr_alert\",\n\"event_id\": <uuid string>, (同一设备的同一故障或报警的发生事件与恢复事件共享同一事件 id)\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>,\n\"data\": {\n\"attr_name\": <故障或报警数据点标识名>,\n\"attr_displayname\": <故障或报警数据点显示名称>\n\"value\": 0 | 1 (0 表示从故障恢复或报警取消，1 表示发生了故障或报警)\n}\n}\\n\n\n设备状态事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于 ACK)\n\"event_type\": \"device_status_raw\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>,\n\"data\": <base64 encoding string> (设备状态原始数据 base64 编码字符串)\n}\\n\n\n如该产品支持数据点解释(机智云通用数据点协议或自定义数据点协议)，则消息格式为message format:\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于 ACK)\n\"event_type\": \"device_status_kv\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>,\n\"data\": {\n<key1 string>: <value1>,\n<key2 string>: <value2>,\n...\n}\n}\n\n中控添加子设备事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于ACK)\n\"event_type\": \"sub_device_added\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"child_product_key\": <product_key string>,\n\"child_did\": <did string>,\n\"child_mac\": <mac string>,\n\"child_passcode\": <str, AES encrypted, see below>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\n\n其中child_passcode采用AES加密，\nAES补码方式为pcks7padding\nAES key为中控passcode的md5值（16 bytes）\nAES mode为AES.MODE_ECB\n中控删除子设备事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于ACK)\n\"event_type\": “sub_device_deleted”,\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n            \"child_product_key\": <product_key string>,\n\"child_did\": <did string>,\n\"child_mac\": <mac string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\n\n设备绑定/解绑事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于ACK)\n\"event_type\": \"device_bind\" | \"device_unbind\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"app_id\": <app_id string>,\n\"uid\": <uid string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\n\n设备重置事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于ACK)\n\"event_type\": \"device_reset\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\n\n设备大文件下载通知事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于ACK)\n\"event_type\": \"device_file_download\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"download_url\": <download_url string>,\n\"created_at\"：<timestamp in seconds, float>\n}\\n\n\n设备控制事件\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于 ACK)\n\"event_type\": \"app2dev_raw\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>,\n\"source:\": \"client\"|\"open_api\"|\"scheduler\"|\"enterprise_api\"|\"gateway\"\n\"appid\": <appid string>, (missing if source=\"enterprise_api\"|\"gateway\" or v1.0 devices)\n\"uid\": <uid string>, (missing if source=\"enterprise_api\"|\"gateway\" or v1.0 devices)\n\"enterprise_id\": <enterprise_id string>, (only for source=\"enterprise_api\")\n\"data\": <base64 encoding string> (设备状态原始数据 base64 编码字符串)\n}\\n\n\n如该产品支持数据点解释(机智云通用数据点协议或自定义数据点协议)，则消息格式为message format:\n{\n\"cmd\": \"event_push\",\n\"delivery_id\": <delivery_id>，(用于 ACK)\n\"event_type\": \"app2dev_kv\",\n\"product_key\": <product_key string>,\n\"did\": <did string>,\n\"mac\": <mac string>,\n\"group_id\": <group_id string>,\n\"created_at\"：<timestamp in seconds, float>,\n\"source: \"client\"|\"open_api\"|\"scheduler\"|\"enterprise_api\"|\"gateway\" \n\"appid\": <appid string>, (missing if source=\"enterprise_api\"|\"gateway\" or v1.0 devices)\n\"uid\": <uid string>, (missing if source=\"enterprise_api\"|\"gateway\" or v1.0 devices)\n\"enterprise_id\": <enterprise_id string>, (only for source=\"enterprise_api\")\n\"data\": {\n<key1 string>: <value1>,\n<key2 string>: <value2>,\n...\n}\n}\\n\n\n事件 ACK\n客户端每收到一事件消息都需要回复以下 ACK 消息：\n{\n\"cmd\": \"event_ack\",\n\"delivery_id\": <delivery_id> (按原数据类型填写)\n}\\n\n\n如 Gizwits Platform 没有收到客户端的回复，该事件会重复推送直至收到 ACK 或过期为止。一般情况下事件按发生时间顺序推送，当prefetch_count > 1 时，有可能因某事件没有 ACK而导致重发而表现为事件没有按时间顺序到达，例如先收到故障恢复或报警取消的事件，所以客户端开发者在处理时应比较 event_id 和 created_at 的值。\n5.  错误响应\n当客户端发送的消息 Gizwits Platform 不能识别时，Gizwits Platform 返回以下的消息：\n{\n\"cmd\": \"invalid_msg\"\n“error_code”: <code int>\n\"msg\": <msg string>\n}\\n\n\n客户端开发者应检查客户端发出的消息内容是否正确（注意：如果客户端没有在消息结尾添加\"\\n\"，服务器端会认为还没有收到完整的消息而继续等待更多的消息内容）。\nsubkey管理\n用户使用过程中，需要关注当前使用到的subkey有哪些，并且对不再使用的subkey，要尽快清理，避免不必要的资源浪费。subkey的获取和删除，采用Http API的方式请求。\n\n域名：snoti.gizwits.com\nHttp API端口：2018\n\n1. 获取subkey\nhttp://swagger.gizwits.com/doc/index/snoti_api_operator#!/product/get_v1_products_product_key_subkey\n2. 删除subkey\nhttp://swagger.gizwits.com/doc/index/snoti_api_operator#!/product/delete_v1_products_product_key_subkey\nFAQ\n1. SNoti客户端接收的设备数据，需要遵循怎样的格式？\na.未使用数据点协议的设备，协议命令字为0x0091、0x0093、0x0094均可透传到SNoti；\nb.使用通用数据点协议的设备，协议命令字在满足0x0091、0x0093、0x0094外，业务指令的首位命令字需要满足以下之一：\n\n0x04，业务指令需满足数据点格式定义\n0x06，业务指令透传\n\n2. SNoti客户端控制设备时，发送的Raw指令，对应机智云协议的哪一部分？\nRaw指令指的是，协议命令字0x0090之后的所有指令，不包括0x0090。值得注意的是，当使用通用数据点透传指令时，Raw指令以0x05开头。\n3. 设备离线后，SNoti客户端控制设备，当设备再次上线，是否可以接收到控制指令？\n不可以。\n4. Raw指令的[0-255]是什么意思？必须是十进制？如果是负数，怎么处理？\n协议中一个字节（1B）能表示的整数范围是：无符号整数0~255或带符号整数-128~127。在SNoti协议中，使用无符号整数表示单个字节内容。部分程序语言将带符号正数转换无符号整数方法：result = bytes & 0xff。\n5. 中控项目是否可以使用SNoti？\na. SNoti不区分产品类型是否为中控产品，只需要对产品申请auth_id即可；\nb. 需要接收中控网关的数据，就使用中控网关产品对应的auth_id；\nc. 需要接收子设备的数据，就使用子设备产品对应的auth_id。\n6. 相同product_key下不同subkey的客户端都能接收到来自SNoti的消息推送吗？\n是的，不同的subkey就会创建不同的队列，彼此数据独立。所以当有数据需要向客户端推送的时候，所有不同subkey的客户端都可以接收到该推送消息，前提是该subkey的客户端在登陆时有设置该推送事件的监听。  \n7. subkey最多可以创建多少个？\n最多5个。\n"},{"title":"Gizwits Open API","url":"/zh-cn/Cloud/OpenAPI.html","content":"新版文档可查看：Open API新版文档\n概述\n使用机智云提供的Open API（Http / WebSocket），可以快速开发网页或微信应用等基于html的轻应用，用于管理和控制智能设备。\n机智云 Open API 主要帮助开发者通过 HTTP 的方式维护用户、用户与设备之间的绑定关系，以及获取设备数据、发送控制指令给设备。\n访问地址\nhttp://api.gizwits.com\n协议约定\n请求方式\n本文档所定义接口基于HTTP/HTTPS协议进行传输，需要注意协议中标注的请求方式，通过GET、PUT、DELETE等进行不同的操作。\n请求参数\nHTTP请求参数的类型一般分为三种。Header表示该参数是在HTTP请求头中；URL表示是通过url传参；Body表示是Request Body，通常Body中都是JSON格式\nHTTP头部请求说明\n调用 API 需要获取 appid，product_key 和 token。appid 和 product_key 可以在产品信息页面获取到，token 通过用户注册和登录获取到。\n下文中的参数统一用 {appid} 来表示，请将你自己的 appid 整个替换掉 {appid} （包括大括号）。\nX-Gizwits-Application-Id\n所有接口都需要设置该头部, 该头部信息的值通过在开发者中心的应用管理中创建应用获得\nX-Gizwits-User-token\nApp用户token值， 生存周期为1个星期有效，调用获取token接口返回的expired_at为失效日期时间戳。若现在时间戳 > expired_at时间戳，则需要重新获取token, 获取token接口请见“App用户token申请”\nApp Token申请\n获取 App Token\n业务功能描述\n该接口提供获取访问token访问权限的功能\n接口地址\nhttp://api.gizwits.com/app/request_token\n请求方式\nPOST\n说明\n\n请使用 https 调用本接口\nsignature 的算法: signature = MD5(appid+appsecret) 32位小写\n\n请求报文\nHeader\nX-Gizwits-Application-Id: {appid}\nX-Gizwits-Application-Auth: {signature}\n\n应答报文\n{\n    \"token\": \"XxXXXxxxx\",\n    \"expired_at\": 123333333\n}\n\n用户管理\n创建用户\n1、创建匿名用户\n如果您想让您的用户不需要显示注册和登录就能使用机智云的功能，就可以通过匿名注册的方式来为该用户创建一个匿名用户。phone_id 可以是手机的唯一识别码。\n或者您已经有了自己的用户系统，不希望用户再次注册一次机智云帐号，您也可以使用该接口，为您的每一个用户创建一个对应的机智云匿名帐号。这时，phone_id 可以是用户在您的系统中的唯一识别码。如在与微信应用做对接时，phone_id 可以设置成微信用户的 openid。\n接口地址\nhttp://api.gizwits.com/app/users\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nphone_id\nstring\n是\nbody\nphone_id 可以是手机的唯一识别码\n\n\n\n应答报文\n    { \n        \"uid\": \"akkdlfeiow\", \n        \"token\": \"akdlfkad\",\n        \"expire_at\": 13894002020\n    }\n\n2、使用用户名和密码创建用户\n接口地址\nhttp://api.gizwits.com/app/users\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nusername\nstring\n是\nbody\n用户名\n\n\n\npassword\nstring\n是\nbody\n密码\n\n\n\n应答报文\n    { \n                \"uid\": \"akkdlfeiow\", \n                \"token\": \"akdlfkad\",\n                \"expire_at\": 13894002020\n    }\n\n3、使用邮箱创建用户\n业务功能描述\n用户通过邮箱注册机智云帐号，注册成功后会收到一封邮件通知。\n接口地址\nhttp://api.gizwits.com/app/users\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nemail\nstring\n是\nbody\n用户邮箱\n\n\n\npassword\nstring\n是\nbody\n密码\n\n\n\n应答报文\n        { \n                \"uid\": \"akkdlfeiow\", \n                \"token\": \"akdlfkad\",\n                \"expire_at\": 13894002020\n        }\n\n4、使用手机号创建用户\n业务功能描述\n如果希望用户使用手机号注册机智云帐号，机智云提供短信验证码接口，您需要先调用获取验证码接口获取验证码，然后再进行注册。\n接口地址\nhttp://api.gizwits.com/app/users\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nphone\nstring\n是\nbody\n手机号码\n\n\n\npassword\nstring\n是\nbody\n密码\n\n\n\ncode\nstring\n是\nbody\n验证码\n\n\n\n应答报文\n        { \n            \"uid\": \"akkdlfeiow\", \n            \"token\": \"akdlfkad\",\n            \"expire_at\": 13894002020\n        }\n\n使用第三方账号（百度/新浪/QQ）创建用户\n业务功能描述\n机智云目前支持使用百度、新浪和QQ创建用户，但是需要您在客户端实现 OAuth 授权，获得用户的 uid 和 token，机智云会验证 uid 和 token 的合法性，验证通过就会创建一个机智云帐号。\n关于 QQ 登录\n使用 QQ 登录，需要提供您的机智云 APP ID 和 QQ 应用 APP ID 发送给我们的客服，我们客服将会在后台将二者进行关联。\n手机客户端使用 QQ SDK 获取到用户的 openid 和 access_token，将 openid 和 access_token 作为 uid 和 token POST 到该接口:\n{\n    \"authData\": {\n        \"src\": \"qq\",\n        \"uid\": opendid,\n        \"token\": access_token\n    }\n}\n接口地址\nhttp://api.gizwits.com/app/users\n请求方式\nPOST\n请求报文\nHeader\n    X-Gizwits-Application-Id: {appid}\n\nBody\n    {   \n                \"authData\": {\n                    \"src\": \"baidu|sina|qq\",\n                    \"uid\": \"2346677\",\n                    \"token\":\"pnktnjyb996sj4p156gjtp4im\"\n                }\n            }\n\n应答报文\n        { \n            \"uid\": \"akkdlfeiow\", \n            \"token\": \"akdlfkad\",\n            \"expire_at\": 13894002020\n        }\n\n匿名用户设置用户名和密码\n业务功能描述\n假设您的机智云应用帮用户创建了一个匿名用户，他不需要注册就可以体验您的应用，并且绑定了设备，他体验满意之后，希望有一个自己的机智云帐号，但是又不想重复绑定设备。这时您可以调用该接口，为匿名用户设置用户名和密码，这样他就不再是一个匿名用户了。\n接口地址\nhttp://api.gizwits.com/app/users\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nusername\nstring\n是\nbody\n用户名\n\n\n\npassword\nstring\n是\nbody\n密码\n\n\n\n应答报文\n{\n    \"updatedAt\": \"2011-11-07T21:25:10.623Z\",\n}\n\n匿名用户设置手机号和密码\n业务描述\n与匿名用户设置用户名和密码类似，该接口可以为匿名用户设置手机号和密码，但是需要先调用一次获取短信验证码的接口。\n接口地址\nhttp://api.gizwits.com/app/users\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nphone\nstring\n是\nbody\n手机号码\n\n\n\npassword\nstring\n是\nbody\n密码\n\n\n\ncode\nstring\n是\nbody\n验证码\n\n\n\n应答报文\n{\n    \"updatedAt\": \"2011-11-07T21:25:10.623Z\",\n}\n\n修改用户信息\n业务功能描述\n该接口分别提供修改用户密码、修改用户邮箱、修改用户手机的功能\n接口地址\nhttp://api.gizwits.com/app/users\n请求方式\nPUT\n修改密码Example\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nold_pwd\nstring\n是\nbody\n旧密码\n\n\n\nnew_pwd\nstring\n是\nbody\n新密码\n\n\n\n应答报文\n{\n    \"updatedAt\": \"2011-11-07T21:25:10.623Z\",\n}\n\n修改 email Example\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nemail\nstring\n是\nbody\n邮箱地址\n\n\n\n应答报文\n{\n    \"updatedAt\": \"2011-11-07T21:25:10.623Z\",\n}\n\n修改手机号 Example\n修改手机号需要先调用一次获取短信验证码的接口，给新手机号发送一条短信验证码。\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nphone\nstring\n是\nbody\n手机号码\n\n\n\ncode\nstring\n是\nbody\n验证码\n\n\n\n应答报文\n{\n    \"updatedAt\": \"2011-11-07T21:25:10.623Z\",\n}\n\n用户登录\n可以使用用户名/邮箱/手机号登录，一律填写到 username 字段。\n接口地址\napi.gizwits.com/app/login\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nusername\nstring\n是\nbody\n用户名\n\n\n\npassword\nstring\n是\nbody\n密码\n\n\n\n应答报文\n{ \n                \"uid\": \"akkdlfeiow\", \n                \"token\": \"akdlfkad\",\n                \"expire_at\": 13894002020\n}\n\n验证码\n获取图片验证码\n业务功能描述\n该接口提供获取图片验证码\n请求地址\nhttp://api.gizwits.com/app/verify/codes\n请求方式\nPOST\n请求内容\n获取图片验证码\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\ncaptcha_url\nstring\n是\nbody\n\n\n\n\ncaptcha_id\nstring\n是\nbody\n\n\n\n\n应答报文\nResponse 201\n发送手机短信验证码\n业务功能描述\n发送手机短信验证码\n请求地址\nhttp://api.gizwits.com/app/verify/codes\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\ncaptcha_url\nstring\n是\nbody\n\n\n\n\ncaptcha_id\nstring\n是\nbody\n\n\n\n\nphone\nstring\n是\nbody\n\n\n\n\n应答报文\nResponse 201\n校验短信验证码\n业务功能描述\n该接口校验短信验证码功能\n请求方式\nPUT\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nsms_code\nstring\n是\nbody\n\n\n\n\nphone\nstring\n是\nbody\n\n\n\n\n应答报文\nResponse 200\n重置密码\n邮箱重置密码\n业务功能描述\n请求成功后用户会收到一封重置密码的邮件, 用户根据邮件的链接进行密码重置。\n接口地址\nhttp://api.gizwits.com/app/reset_password\n请求方式\n POST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nemail\nstring\n是\nbody\n\n\n\n\n应答报文\nResponse 200 (application/json)\n使用手机号重置密码\n业务功能描述\n使用手机号重置密码需要先调用一次获取短信验证码的接口。\n接口地址\nhttp://api.gizwits.com/app/reset_password\n请求方式\n POST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nphone\nstring\n是\nbody\n手机号码\n\n\n\ncode\nstring\n是\nbody\n验证码\n\n\n\nnew_pwd\nstring\n是\nbody\n新密码\n\n\n\n应答报文\nResponse 200 (application/json)\n绑定管理\n绑定设备\n业务功能描述\nX-Gizwits-Timestamp 与服务器相差不能超过 5 分钟\nX-Gizwits-Signature = MD5(product_secret + X-Gizwits-Timestamp).lower()\n接口地址\n http://api.gizwits.com/app/bind_mac\n请求方式\n POST\n请求报文\n1、 Header\n    X-Gizwits-Application-Id: {appid}\n    X-Gizwits-User-token: {token}\n    X-Gizwits-Timestamp: {req_ts}\n    X-Gizwits-Signature: {sig}\n\n2、 Body\n    {\n        \"product_key\": \"xxx\",\n        \"mac\": \"xxx\",\n        \"remark\": \"xxx\",\n        \"dev_alias\": \"xxx\"\n    }\n\n应答报文\nResponse 201 (application/json)\n获取绑定列表\n业务功能描述\n该接口提供绑定列表\n接口地址\n http://api.gizwits.com/app/bindings\n请求方式\n GET\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nlimit\nString\n是\nurl\n\n\n\n\nskip\nString\n是\nurl\n\n\n\n\nlimit & skip参数说明\nlimit 和 skip 表示分页参数。limit 为一次性返回的最多条数，skip 为跳过多少条数据。\n如每页 10 条数据，获取第一页数据：limit=10, skip=0；获取第二页数据：limit=10, skip=10.\n应答报文\n            {\n                \"devices\": [{\n                    \"product_key\": \"akdlfkad\",\n                    \"did\": \"abcada\",\n                    \"mac\": \"1122334455667788\",\n                    \"is_online\": false,\n                    \"passcode\": \"123456\",\n                    \"host\": \"m2m.gizwits.com\",\n                    \"port\": 3128,\n                    \"remark\": \"\",\n                    \"is_disabled\": false,\n                    \"type\": \"normal\",\n                    \"dev_alias\": \"dev1\"\n                },{\n                    \"product_key\": \"akdlfkad\",\n                    \"did\": \"abcada\",\n                    \"mac\": \"1122334455667788\",\n                    \"is_online\": false,\n                    \"passcode\": \"123456\",\n                    \"host\": \"m2m.gizwits.com\",\n                    \"port\": 3128,\n                    \"remark\": \"\",\n                    \"is_disabled\": false,\n                    \"type\": \"center_control\",\n                    \"dev_alias\": \"dev2\"\n                }]\n            }\n\n修改绑定信息\n业务功能描述\n修改绑定信息\n接口地址\n http://api.gizwits.com/app/bindings/{did}\n请求方式\n PUT\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\ndid\nString\n是\nurl\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nremark\nString\n是\nbody\n\n\n\n\ndev_alias\nString\n是\nbody\n\n\n\n\n应答报文\n    {\n        \"remark\": \"string\",\n        \"dev_alias\": \"string\"\n    }\n\n解除绑定\n业务功能描述\n提供解除绑定功能\n接口地址\n http://api.gizwits.com/app/bindings\n请求方式\n DELETE\n请求报文\nHeader\nX-Gizwits-Application-Id: {appid}\nX-Gizwits-User-token: {token}\nBody\n    {\n                \"devices\": [{\n                    \"did\": \"gdGn7PzAYf4VrhnVag5x8D\"\n                }]\n    }\n\n应答报文\n{\n    \"success\": ['abc', 'add'],\n    \"failed\": ['adad', 'ee']\n}\n\n设备管理\n设备加密注册\n业务描述\n提供设备加密注册功能，当设备使用加密注册接口进行注册后，设备将生成唯一did，且该did无法调用普通的设备注销接口注销，如进行重复加密注册操作，生成的did不会发生变化。\n设备使用加密注册接口注册生成唯一did后，设备之前生成的did会自动被注销。\n设备调用加密注册接口成功后，设备将无法调用非加密的设备注册接口，设备provison接口，以及设备注销接口。\n接口地址\n   http://api.gizwits.com/dev/{product_key}/device\n请求方式\n   POST \n请求报文\nHeader\nContent-Type：application/x-www-form-urlencoded\n body：\n data={data}\n data内容为mac={mac}&passcode={passcode}&type={type}&extra={extra}经过AES加密后的密文。\ndata内容说明：\n\n\n\n内容\n说明\n\n\n\n\nMAC\n设备mac地址\n\n\npasscode\n设备passcode\n\n\ntype\n设备type，当前只可以取noraml或center_control\n\n\nextra\n16进制格式字符串，长度8bit：1.当最后一位字符转换成二进制的末尾一位为1，则默认设备type为center_control,如果为0，则默认type为normal 2当最后一位字符转换成二进制的倒数第二位为1，则默认使用了代码自动生成，如果为0，则默认未使用代码自动生成.\n\n\n\nAES加密方法说明：\nAES 补码方式为 pcks7padding\nAES key 为 product_secret 转为 16 进制（128 bit）\nAES mode 为 AES.MODE_ECB\n应答报文\n\n\n\n响应编码\n返回内容\n说明\n\n\n\n\n201\nadfkkgkljsdfd\n返回结果为did={did}经过AES加密后的密文\n\n\n\n远程控制设备\n接口地址\n http://api.gizwits.com/app/control/{did}\n请求方式\nPOST\n详情描述\n远程控制设备可以通过两种方式，一种是设置数据点，一种是发送原始控制指令。\n推荐使用设置数据点的方式，通过这种方式控制设备，系统内部自动会生成原始控制指令发送给设备，使用起来更简单。\n\n参数列表\ndid (required, string, did)\n\n\n\n设置数据点 [POST]\n\n只能设置可写类型的数据点\nbool 类型的数据点设置为 true/false\nenum 类型的数据点设置为枚举的字符串\nuint8/uint16/uint32 类型的数据点设置为数字\nbinary 类型的数据设置为 hex 类型字符串，如发送一串十六进制数据 0x01, 0x02, 0x03, 就写成 \"010203\";\n如果 binary 类型本身为字符串，如 \"hello world!\"，需将字符串每个字符的 ASCII 转成十六进制再发送，本例为 \"68656c6c6f20776f726c6421\";\n注意 binary 类型定义了多少长度，就需要发多少长度的数据。\n\n请求报文\nHeader\nX-Gizwits-Application-Id: {appid}\nX-Gizwits-User-token: {token}\nBody\n{\n    \"attrs\": {\n      \"temp\": 10\n    }\n}\n\n应答报文\n{}\n\n发送原始控制指令\n请求报文\nHeader\nX-Gizwits-Application-Id: {appid}\nX-Gizwits-User-token: {token}Body\n{\n    \"raw\": [<byte>, <byte>, ...]\n}\n\n应答报文\n{}\n\n设备日志查询\n业务功能描述\n该接口提供设备通信日志,上下线日志查询\n请求地址\nhttp://api.gizwits.com/app/devices/{did}/raw_data\n请求方式\nGET\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\ndid\nString\n是\nurl\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\ntype\nString\n是\nurl\ncmd通信日志查询,online上下线日志查询\n\n\n\nstart_time\nInteger\n是\nurl\n查询起始时间戳,单位秒\n大于此时间戳的数据将会被查询到\n\n\nend_time\nInteger\n是\nurl\n查询终止时间戳,单位秒\n小于等于此时间戳的数据会被查询到\n\n\nskip\nInteger\n否\nurl\n跳过条目数,默认0\nskip+limit需要小于等于5000\n\n\nlimit\nInteger\n否\nurl\n返回条目数,默认20\n需要小于等于1000\n\n\nsort\nString\n否\nurl\n数据按生成时间排序规则 desc降序 asc升序,默认降序\n\n\n\n时间戳补充说明\n\n终止时间戳必须大于起始时间戳\n终止时间戳与起始时间戳之差必须小于48小时\n终止时间戳需要小于等于当前时间点\n\n应答报文\n{\n      \"meta\": {\n            \"start_time\": 0,\n            \"end_time\": 0,\n            \"type\": \"string\",\n            \"did\": \"string\",\n            \"skip\": 0,\n            \"limit\": 0,\n            \"sort\": \"desc\"|\"asc\",\n            \"total\": 0\n      },\n      \"objects\": [\n        {\n              \"type\": \"string\",\n              \"ip\": \"string\",\n              \"timestamp\": 0,\n              \"payload_bin\": \"string\"\n        }\n      ]\n}\n\n返回数据objects补充说明\n\n查询类型为通信日志时,返回数据的type字段为 app2dev(app到设备的通信), dev2app(设备到app的通信)\n查询类型为上下线日志时,返回数据的type字段为 dev_online(上线), dev_re_online(完成离线流程前再次登陆), dev_offline(离线)\n\n定时功能\n定时任务\n业务详情描述\n定时任务分为一次性定时任务和可重复执行定时任务。一次性定时任务在设定好的日期和时间执行；可重复执行定时任务可以设置按星期重复，如每周一执行，工作日执行等，在重复的星期的设定时间执行。\n执行日期通过 date 参数进行设置，格式为：\"2015-01-01\"。\n执行时间通过 time 参数进行设置，格式为：\"10:10\", 注意：该时间为 UTC 时间！\n重复类型通过 repeat 参数进行设置，不重复设置为 \"none\"；重复设置为 \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\" 的组合，组合之间用逗号分隔，如每周一和周二重复为 \"mon,tue\"。\n一次定时任务可以给多个已绑定的设备发送控制指令，只有设定的所有控制指令都发送成功，本次定时任务才算执行成功。任务内容通过 task 设定，为一个列表，列表内的内容为每个具体的任务。具体的任务需要提供设备 did, product_key 和要设置的数据点键值对 attrs。如：\n    {\n      \"did\": \"did1\",\n      \"product_key\": \"xxx\",\n      \"attrs\": {\n        \"attr1\": val,\n        \"attr2\": val\n      }\n    }\n\n对于执行失败的定时任务，可以设置重复次数和重复策略。重复次数的范围为 0 ～ 60 次。置重复策略分为全部重试和部分重试。全部重试，将在重试的时候发送所有设定的控制指令；部分重试，只对还未发送成功指令进行发送。\n重复次数通过 retry_count 来设置。\n重复策略通过 retry_task 来设置，全部重试为 \"all\"，部分重试为 \"failed\"。\n创建定时任务\n业务功能描述\n该接口提供定时任务创建功能\n请求地址\nhttp://api.gizwits.com/app/scheduler\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nlimit\nString\n是\nurl\n\n\n\n\nskip\nString\n是\nurl\n\n跳过条数\n\n\n\n\nrequest body         {\n           \"date\": \"2015-01-01\",\n           \"time\": \"12:00\",\n           \"repeat\": \"none\",\n           \"task\": [\n             {\n               \"did\": \"did1\",\n               \"product_key\": \"xxx\",\n               \"attrs\": {\n                 \"attr1\": val,\n                 \"attr2\": val\n               }\n             },\n             {\n               \"did\": \"did2\",\n               \"product_key\": \"xxx\",\n               \"attrs\": {\n                 \"attr1\": val,\n                 \"attr2\": val\n               }\n             }\n           ],\n           \"retry_count\": 3,\n           \"retry_task\": \"all\"\n         }\n\n\n\n应答报文\n            {\n              \"id\": \"adkle\"\n            }\n\n获取定时任务\n业务功能描述\n该接口提供定时任务获取功能\n请求地址\nhttp://api.gizwits.com/app/scheduler\n请求方式\nGET\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nlimit\nString\n是\nurl\n\n\n\n\nskip\nString\n是\nurl\n\n\n\n\n应答报文\n            [\n              {\n                \"id\": \"abckaldkl\",\n                \"created_at\": \"2015-01-01T12:00:00\",\n                \"date\": \"2015-01-01\",\n                \"time\": \"12:00\",\n                \"repeat\": \"none\",\n                \"task\": [\n                  {\n                    \"did\": \"did1\",\n                    \"product_key\": \"xxx\",\n                    \"attrs\": {\n                      \"attr1\": 1,\n                      \"attr2\": 1\n                    }\n                  },\n                  {\n                    \"did\": \"did2\",\n                    \"product_key\": \"xxx\",\n                    \"attrs\": {\n                      \"attr1\": 1,\n                      \"attr2\": 2\n                    }\n                  }\n                ],\n                \"retry_count\": 3,\n                \"retry_task\": \"all\"\n              },\n              {\n                \"id\": \"abckaldkl\",\n                \"created_at\": \"2015-01-01T12:00:00\",\n                \"date\": \"2015-01-01\",\n                \"time\": \"12:00\",\n                \"repeat\": \"none\",\n                \"task\": [\n                  {\n                    \"did\": \"did1\",\n                    \"product_key\": \"xxx\",\n                    \"attrs\": {\n                      \"attr1\": \"val\",\n                      \"attr2\": \"val\"\n                    }\n                  },\n                  {\n                    \"did\": \"did2\",\n                    \"product_key\": \"xxx\",\n                    \"attrs\": {\n                      \"attr1\": \"val\",\n                      \"attr2\": \"val\"\n                    }\n                  }\n                ],\n                \"retry_count\": 3,\n                \"retry_task\": \"all\"\n              }\n            ]\n\n删除定时任务\n业务功能描述\n该接口提供定时任务删除功能\n请求地址\nhttp://api.gizwits.com/app/scheduler/{id}\n请求方式\nDELETE\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nid\nString\n是\nurl\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\n应答报文\nResponse 200 (application/json)\n获取设备定时任务\n请求地址\nhttp://api.gizwits.com/app/devices/{did}/scheduler\n请求方式\nGET\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\ndid\nString\n是\nurl\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nlimit\nString\n是\nurl\ndefault:20\n\n\n\nskip\nString\n是\nurl\ndefault:0\n\n\n\n应答报文\n            [\n              {\n                \"attrs\": {\"attr\": 1},\n                \"date\": \"2016-11-07\",\n                \"time\": \"12:00\",\n                \"repeat\": \"none\",\n                \"days\": [\n                  0\n                ],\n                \"start_date\": \"2016-11-07\",\n                \"end_date\": \"2016-11-07\",\n                \"enabled\": true,\n                \"remark\": \"\",\n                \"id\": \"\",\n                \"created_at\": \"2016-11-07\"\n              }\n            ]\n\n创建设备定时任务\n业务功能描述\n该接口提供设备定时任务创建功能\n请求地址\nhttp://api.gizwits.com/app/devices/{did}/scheduler\n请求方式\nPOST\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\ndid\nString\n是\nurl\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nBody request\n            {\n              \"attrs\": {},\n              \"date\": \"2016-11-07\",\n              \"time\": \"12:00\",\n              \"repeat\": \"none\",\n              \"days\": [\n                0\n              ],\n              \"start_date\": \"2016-11-07\",\n              \"end_date\": \"2016-11-07\",\n              \"enabled\": true,\n              \"remark\": \"\"\n            }\n\n应答报文\n            {\n              \"id\": \"adkle\"\n            }\n\n修改设备定时任务\n业务功能描述\n该接口提供设备定时任务修改功能\n请求地址\nhttp://api.gizwits.com/app/devices/{did}/scheduler\n请求方式\nPUT\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\ndid\nString\n是\nurl\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\nBody request\n            {\n              \"attrs\": {},\n              \"date\": \"2016-11-07\",\n              \"time\": \"12:00\",\n              \"repeat\": \"none\",\n              \"days\": [\n                0\n              ],\n              \"start_date\": \"2016-11-07\",\n              \"end_date\": \"2016-11-07\",\n              \"enabled\": true,\n              \"remark\": \"\"\n            }\n\n应答报文\n            {\n              \"id\": \"adkle\"\n            }\n\n删除设备定时任务\n业务功能描述\n该接口提供设备定时任务删除功能\n请求地址\nhttp://api.gizwits.com/app/devices/{did}/scheduler/{id}\n请求方式\nDELETE\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\ndid\nString\n是\nurl\n\n\n\n\nid\nString\n是\nurl\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\n应答报文\nResponse 200 (application/json)\n定时任务执行日志\n业务功能描述\n该接口提供定时任务执行日志功能\n请求地址\nhttp://api.gizwits.com/app/scheduler/{id}/logs\n请求方式\nGET\n请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n备注\n\n\n\n\nid\nString\n是\nurl\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n\n\n\nX-Gizwits-User-token\nString\n是\nheader\n\n\n\n\n应答报文\n            {\n              \"datetime\": \"2015-01-02T12:00:00\",\n              \"status\": \"succeed|failed\",\n              \"detail\": {\n                \"did1\": true,\n                \"did2\": false\n              }\n            }\n\n接口错误\n错误信息格式\n{\n      \"error_code\": \"9015\",\n      \"error_message\": \"form invalid!\",\n      \"detail\": \"\"\n}\n\n错误信息表\n\n\n\nstatus\ncode\nmessage\n\n\n\n\n400\n9001\nmac already registered!\n\n\n400\n9002\nproduct_key invalid\n\n\n400\n9003\nappid invalid\n\n\n400\n9004\ntoken invalid\n\n\n400\n9005\nuser not exist\n\n\n400\n9006\ntoken expired\n\n\n400\n9007\nm2m_id invalid\n\n\n500\n9008\nserver error\n\n\n400\n9009\ncode expired\n\n\n400\n9010\ncode invalid\n\n\n400\n9011\nsandbox scale quota exhausted!\n\n\n400\n9012\nproduction scale quota exhausted!\n\n\n400\n9013\nproduct has no request scale!\n\n\n404\n9014\ndevice not found!\n\n\n400\n9015\nform invalid!\n\n\n400\n9016\ndid or passcode invalid!\n\n\n401\n9017\ndevice not bound!\n\n\n400\n9018\nphone unavailable!\n\n\n400\n9019\nusername unavailable!\n\n\n400\n9020\nusername or password error!\n\n\n400\n9021\nsend command failed!\n\n\n400\n9022\nemail unavailable!\n\n\n400\n9023\ndevice is disabled!\n\n\n400\n9024\nfail to notify m2m!\n\n\n400\n9025\nattr invalid!\n\n\n400\n9026\nuser invalid!\n\n\n404\n9027\nfirmware not found!\n\n\n404\n9028\nJD product info not found!\n\n\n400\n9029\ndatapoint data not found!\n\n\n404\n9030\nscheduler not found!\n\n\n400\n9031\nqq oauth key invalid!\n\n\n400\n9032\nota upgrade service OK, but in idle or disable!\n\n\n400\n9033\nbt firmware unverified, except verify device!\n\n\n404\n9034\nbt firmware is OK, but nothing to upgrade!\n\n\n500\n9035\nSave kairosdb error!\n\n\n400\n9036\nevent not defined!\n\n\n400\n9037\nsend sms failed!\n\n\n400\n9038\nX-Gizwits-Application-Auth invalid!\n\n\n403\n9039\nNot allowed to call deprecated API!\n\n\n400\n9040\nbad qrcode content!\n\n\n429\n9041\nrequest was throttled\n\n\n400\n9042\ndevice offline!\n\n\n400\n9043\nX-Gizwits-Timestamp invalid!\n\n\n400\n9044\nX-Gizwits-Signature invalid!\n\n\n400\n9045\nAPI deprecated!\n\n\n400\n9046\nRegister already in progress!\n\n\n400\n9047\ndevice encrypt disabled!\n\n\n400\n9048\ndevice encrypt enabled, does not support this api!\n\n\nxxx\n9999\nreserved\n\n\n\n"},{"title":"机智云设备分享功能使用流程","url":"/zh-cn/Cloud/SharingSDK.html","content":"1.概述\n用户绑定设备后，可以通过设备分享的方式让其他人使用设备。设备分享提供了更好的设备权限管理，在多用户使用同一个设备时提供了更安全、更便捷的设备绑定方式。设备绑定权限分为四种：\nOwner：设备的主账号，可以分享设备；\nGuest：设备的分享账号，可以接受分享邀请，不能再分享设备给其他人；\nSpecial：最早绑定设备但还未分享设备的账号，分享设备后即成为设备的主账号；\nNormal：其他已绑定了设备的账号，不能分享设备，也不能成为设备的主账号；\n只有最早绑定设备的账号或设备的主账号才能分享设备。一旦设备有了主账号，其他人就无法再绑定了。主账号可以查看设备的当前已绑定用户，可以解绑其他用户。在设备没有主账号时，其他用户仍然可以绑定这个设备。\n\n注：使用设备分享功能之前，需要在开发者中心-产品基础信息内打开该功能，打开之后将无法关闭\n\n\n2.设备分享功能的应用场景\n产品设计流程如下：\n\n2.1.应用场景1:一个设备对一个用户\n一个设备只能被一个用户绑定和控制，就是说用户只要Special /Owner身份，而没有Normal/ Guest身份。代码设置流程图如下：\n\n（注意：因为该应用场景是一个设备对应一个用户，Special身份调用账号分享功能成为Owner身份的时候，调用sharingDevice接口上guestUser参数直接在代码上写死一个该appid注册的账号就成，不需要到UI上的。）\n2.2.应用场景2:一个设备对多个用户\n该场景是常用场景，一个设备可以被多个用户绑定，当Special用户成为Owner身份,其它用户要绑定该设备，只能Owner用户通过调用设备分享功能分享给其它的用户，然后其它用户才能远程控制该设备。就是说用户可以是Special /Owner身份，也可以是Normal/ Guest身份。代码设计流程图如下：\n（1）创建分享邀请\n\n（2）接收分享邀请\n\n3.硬件设计部分\n3.1.可绑定模式功能介绍\n在wifi模组请求设备信息的时候，mcu回复的命令中包含了一个绑定超时的字段，该字段值为0时，表示该设备随时可以在局域网内被绑定。大于0时，需要协议中《4.12MCU通知WiFi模组进入可绑定模式》的命令来配合使用。\n\n\n3.2.APP设备分享功能要结合硬件绑定超时功能的原因\n分析：在局域网内，当用户使用了设备分享功能成为Owner身份，其它用户在该局域网内调用发现设备接口还是可以发现设备和控制设备，只是不能绑定设备而已。\n在大循环情况下，先前绑定过该设备的用户，Owner身份用户除外，调用获取绑定设备列表，是发现不了该设备的，只能通过Owner身份用户将设备分享出来给其它用户控制。\n3.3.重置WiFi模组功能\n当设备reset模组后，模组会清除先前配置的ssid和密码、did，passcode等信息，还将先前跟该设备绑定过的绑定关系全部清除掉。\n\n3.4.APP设备分享功能需要硬件做重置WiFi模组功能的原因\n分析：当该设备已经被其他用户设置为Owner或者Special身份后，且不能确认是设置了那个用户。此时，设备reset模组后，会把先前跟该设备绑定过的用户全部清除，以及先前的用户Owner或者Special身份也会清除掉。客户重新再配置和绑定该设备就成为Special身份，然后再分享设备，该用户就重新成为Owner身份了。\n4.APP开发部分\n4.1.Android sdk 接口部分\n4.1.1账号分享\n账号分享时，对方账号可以是手机号、邮箱、普通用户名或者匿名账号，但必须是已经在机智云注册过的用户。如果该用户已经是这个设备的Guest账号或者已经绑定了这个设备，分享邀请会创建失败。账号分享邀请的有效期为24小时，即对方必须在24小时内作出响应，否则账号邀请会过期失效。\n（注意：如果产品用的是应用场景1，一个设备对一个用户，guestUser参数填死一个已注册的用户就成，该接口不需要在做UI交互，具体流程请查看2.1.应用场景1。）\n账号分享时要指定账号类型，匿名账号的guestUser参数填匿名账号的uid。账号分享创建成功时，回调参数中会返回sharingID，但不会返回QRCodeImage。下面仅以手机号分享举例：\n【示例代码】\n // 设置设备分享监听\nGizDeviceSharing.setListener(mListener);\n// 在设备列表中找到可以分享的设备\n// 通过手机号分享设备\nGizDeviceSharing.sharingDevice(\"your_token\", \"your_device_id\", GizDeviceSharingWay.GizDeviceSharingByNormal, \"guest_phone_number\", GizUserAccountType.GizUserPhone);\nGizDeviceSharingListener mListener = new GizDeviceSharingListener() {\n    // 实现设备分享的回调\n    @Override\n    public void didSharingDevice(GizWifiErrorCode result, String deviceID, int sharingID, Bitmap QRCodeImage) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 分享成功\n        } else {\n            // 分享失败\n        }\n    }\n};\n4.1.2.二维码分享\n二维码分享时，二维码有效期为15分钟，即对方必须在15分钟内扫描生成的二维码并作出响应，否则二维码邀请会过期失效。二维码分享邀请创建成功时，回调参数中会返回sharingID，同时还会返回对应的二维码图片QRCodeImage，App直接加载图片即可。\n  【示例代码】\n // 设置设备分享监听\nGizDeviceSharing.setListener(mListener);\n// 在设备列表中找到可以分享的设备\n// 二维码分享设备\nGizDeviceSharing.sharingDevice(\"your_token\", \"your_device_id\", GizDeviceSharingWay.GizDeviceSharingByQRCode, null, null);\nGizDeviceSharingListener mListener = new GizDeviceSharingListener() {\n    // 实现设备分享的回调\n    @Override\n    public void didSharingDevice(GizWifiErrorCode result, String deviceID, int sharingID, Bitmap QRCodeImage) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 分享成功\n        } else {\n            // 分享失败\n        }\n    }\n};\n4.1.3.接受分享邀请\nGuest账号可以查询发给自己的设备分享邀请，只有Guest账号可以接受分享邀请。\n接受账号分享邀请\nGuest查询到的分享邀请如果是还未接受的状态，可以接受或者拒绝邀请。\n【示例代码】\n// 设置设备分享监听\nGizDeviceSharing.setListener(mListener);\n// 查询发给自己的分享邀请列表\nGizDeviceSharing.getDeviceSharingInfos(\"your_token\", GizDeviceSharingType.GizDeviceSharingToMe, \"your_device_id\");\nGizDeviceSharingListener mListener = new GizDeviceSharingListener() {\n    // 实现获取分享邀请列表的回调    \n    @Override\n    public void didGetDeviceSharingInfos(GizWifiErrorCode result, String deviceID, List<GizDeviceSharingInfo> deviceSharingInfos) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n\n            // 获取成功。找到deviceSharingInfos中状态为未接受的分享邀请，your_sharing_id为要接受的分享邀请\n            int your_sharing_id = -1;\n            for (int i = 0; i < deviceSharingInfos.size(); i++) {\n                GizDeviceSharingInfo mDeviceSharing = deviceSharingInfos.get(i);\n                if (mDeviceSharing.getStatus() == GizDeviceSharingStatus.GizDeviceSharingNotAccepted) {\n                    your_sharing_id = mDeviceSharing.getId();\n                    break;\n                }\n            }\n\n            // 接受邀请\n            if (your_sharing_id != -1) {\n                GizDeviceSharing.acceptDeviceSharing(\"your_token\", your_sharing_id, true);\n            }\n\n        } else {\n            // 获取失败\n        }\n    }\n\n    // 实现接受分享邀请的回调    \n    @Override\n    public void didAcceptDeviceSharing(GizWifiErrorCode result, int sharingID) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 接受成功\n        } else {\n            // 接受失败\n        }\n    }\n};\n4.2.IOS sdk 接口部分\n4.2.1.账号分享\n账号分享时，对方账号可以是手机号、邮箱、普通用户名或者匿名账号，但必须是已经在机智云注册过的用户。如果该用户已经是这个设备的Guest账号或者已经绑定了这个设备，分享邀请会创建失败。账号分享邀请的有效期为24小时，即对方必须在24小时内作出响应，否则账号邀请会过期失效。\n（注意：如果产品用的是应用场景1，一个设备对一个用户，guestUser参数填死一个已注册的用户就成，该接口不需要在做UI交互，具体流程请查看2.1.应用场景1。）\n账号分享时要指定账号类型，匿名账号的guestUser参数填匿名账号的uid。账号分享创建成功时，回调参数中会返回sharingID，但不会返回QRCodeImage。下面仅以手机号分享举例：\n【示例代码】\n// 设置设备分享委托\n[GizDeviceSharing setDelegate:self];\n// 在设备列表中找到可以分享的设备\n// 通过手机号分享设备\n[GizDeviceSharing sharingDevice:@\"your_token\" deviceID: @\"your_device_id\" sharingWay:GizDeviceSharingByNormal guestUser:@\"guest_phone_number\" guestUserType:GizUserPhone]; \n// 实现回调\n- (void)didSharingDevice:(NSError*)result deviceID:(NSString*)deviceID sharingID:(NSInteger)sharingID QRCodeImage:(UIImage*)QRCodeImage {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 分享邀请创建成功\n    } else {\n        // 创建失败\n    }\n}\n4.2.2. 二维码分享\n二维码分享时，二维码有效期为15分钟，即对方必须在15分钟内扫描生成的二维码并作出响应，否则二维码邀请会过期失效。二维码分享邀请创建成功时，回调参数中会返回sharingID，同时还会返回对应的二维码图片QRCodeImage，App直接加载图片即可。\n【示例代码】\n// 设置设备分享委托\n[GizDeviceSharing setDelegate:self];\n// 在设备列表中找到可以分享的设备\n// 二维码分享设备\n[GizDeviceSharing sharingDevice:@\"your_token\" deviceID: @\"your_device_id\" sharingWay:GizDeviceSharingByQRCode guestUser:nil guestUserType:GizUserOther]; \n// 实现回调\n- (void)didSharingDevice:(NSError*)result deviceID:(NSString*)deviceID sharingID:(NSInteger)sharingID QRCodeImage:(UIImage*)QRCodeImage {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 分享邀请创建成功\n    } else {\n        // 创建失败\n    }\n}\n4.2.3 接受分享邀请\nGuest账号可以查询发给自己的设备分享邀请，只有Guest账号可以接受分享邀请。\n接受账号分享邀请\nGuest查询到的分享邀请如果是还未接受的状态，可以接受或者拒绝邀请。\n【示例代码】\n// 设置设备分享委托\n[GizDeviceSharing setDelegate:self];\n// 查询发给自己的分享邀请列表\n[GizDeviceSharing getDeviceSharingInfos:@\"your_token\" sharingType: GizDeviceSharingToMe deviceID: @\"your_device_id\"];\n// 实现获取分享邀请列表的回调\n- (void)didGetDeviceSharingInfos:(NSError*)result deviceID:(NSString*)deviceID deviceSharingInfos:(NSArray*)deviceSharingInfos {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 获取成功。找到deviceSharingInfos中状态为未接受的分享邀请，your_sharing_id为要接受的分享邀请\n        NSInteger your_sharing_id = -1;\n        for (int i = 0; i < deviceSharingInfos.count; i++) {\n            GizDeviceSharingInfo* mDeviceSharing = [deviceSharingInfos objectAtIndex:i];\n            if (mDeviceSharing.status == GizDeviceSharingNotAccepted) {\n                your_sharing_id = mDeviceSharing.id;\n                break;\n            }\n        }\n\n        // 接受邀请\n        if (your_sharing_id != -1) {\n            [GizDeviceSharing acceptDeviceSharing:@\"your_token\" sharingID:your_sharing_id accept:YES];\n        }\n    } else {\n        // 获取失败\n    }\n}\n// 实现接受分享邀请的回调    \n- (void)didAcceptDeviceSharing:(NSError*)result sharingID:(NSInteger)sharingID {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 接受成功\n    } else {\n        // 接受失败\n    }\n}\n5.参考文档\nAndroid sdk使用指南文档:http://docs.gizwits.com/zh-cn/AppDev/AndroidSDKA2.html\nIOS sdk使用指南文档:http://docs.gizwits.com/zh-cn/AppDev/iOSSDKA2.html\n"},{"title":"Websocket API 指南","url":"/zh-cn/Cloud/WebsocketAPI.html","content":"v1.0.7\nDemo\nhttps://github.com/gizwits/gizwits-wechat-js-sdk\n通讯模型\n浏览器（Javascript）可以通过Web Socket API与机智云云端直接通讯。浏览器（Javascript）通过 Web Socket API，可以控制设备和实时接收设备上报的数据。\n\n通讯流程\n浏览器（Javascript）通过Web Socket API与云端通讯主要包括以下的通讯过程。\n\n用户登陆：用户通过从Http API获得的uid和token登陆云端。\n接收设备上线下线消息：只有绑定设备后才能控制设备。\n发送和接收设备业务逻辑数据：\n心跳：浏览器（Javascript）定期向云端发送心跳，云端回复心跳响应。\n\n约定\n1. 协议阅读说明\n● <str>表示字符串占位符，<int>表示整型数据占位符。\n2. 云端Web Socket服务地址\nws://<host>:<ws_port>/ws/app/v1 (非加密连接)\nwss://<host>:<wss_port>/ws/app/v1 (加密连接)\n其中的<host>为绑定设备列表中的host字段的值，<ws_port>为绑定设备列表中的ws_port字段的值，<wss_port>为绑定设备列表中的wss_port字段的值，请参考获取绑定设备列表HTTP API。\n3. 注意事项\n\n在与云端进行Web Socket交互前，用户必须已注册并已绑定了设备。\n与云端交互的数据均为JSON字符串,以UTF-8的方式编码。可以通过JSON.stringify(json)把Javascript对象转化为字符串再发送给云端，或通过var res = JSON.parse(evt.data)把接收到的字符串数据转化成Javascript对象。\nWeb Socket的测试程序请使用http://<m2m_host>:8080/app (​<m2m_host>为绑定设备列表中的host字段的值)， 也可以查看这个网页的源代码作为示例代码参考。\n\n通讯协议\n1. 用户登陆\n浏览器（Javascript）必须登陆后才能和云端作进一步的交互。\n浏览器 ⇒ 云端。浏览器向云端发送以下的JSON字符串。\n{\n    \"cmd\": \"login_req\",\n    \"data\":\n    {\n        \"appid\": <str>,\n        \"uid\": <str>,\n        \"token\": <str>,\n        \"p0_type\": \"attrs_v4\"|\"custom\", (\"attrs_v4\" 指通过标准数据点协议的方式和云端交互，见下文“标准数据点操作”部分。\"custom\"表示使用自定义业务逻辑协议的方式与云端交互，见下文“浏览器与云端的数据交互”部分。)\n        \"heartbeat_interval\": <int>, (心跳的时间间隔，单位为秒，值必须小于等于180)\n        \"auto_subscribe\": true | false (true表示登陆成功后，服务器自动订阅所有已绑定设备；false则需要通过下面的“用户定阅设备消息”协议选择订阅设备，默认值为true。推荐设为false，然后按需定阅设备以节省开销)\n    }\n}\n\n\n云端 ⇒ 浏览器。云端向浏览器回复以下的JSON字符串。\n\n\n{\n    \"cmd\": \"login_res\",\n    \"data\":\n    {\n        \"success\": true | false （true为登陆成功，false登陆失败）\n    }\n}\n\n2. 用户定阅设备消息\n用户只有订阅了已绑定的设备消息，才可以接收与设备相关的消息。本指令只适用于登陆参数auto_subscribe: false的场景。\n浏览器 ⇒ 云端。浏览器向云端发送以下的JSON字符串定阅设备消息。\n{\n    \"cmd\": \"subscribe_req\",\n    \"data\":\n    [\n        {\"did\": <str> },（需要定阅的设备did1）\n        {\"did\": <str> },（需要定阅的设备did2）\n        ……\n    ]\n}\n\n云端 ⇒ 浏览器。云端向浏览器发送以下的JSON字符串返回定阅结果。\n{\n    \"cmd\": \"subscribe_res\",\n    \"data\":\n    {\n        \"success\":\n        [\n            {\n                \"did\": <str>,（对应请求的设备did1）\n                \"error_code\": 0,（0表示成功）\n                \"msg\": <str>（描述文本）\n            },\n            {\n                \"did\": <str>,（对应请求的设备did2）\n                \"error_code\": 0,（0表示成功）\n                \"msg\": <str>（描述文本）\n            },\n            ……\n         ],\n         “failed”:\n         [\n            {\n                \"did\": <str>,（对应请求的设备did1）\n                \"error_code\": <int>,（订阅失败的错误码）\n                \"msg\": <str>（描述文本）\n            },\n            {\n                \"did\": <str>,（对应请求的设备did2）\n                \"error_code\": <int>,（订阅失败的错误码）\n                \"msg\": <str>（描述文本）\n            },\n            ……\n         ]\n    }\n}\n\n3. 设备上线下线通知\n当设备上线或下线时，云端会主动发送通知到浏览器。\n云端 ⇒ 浏览器。云端向浏览器发送以下的JSON字符串通知设备上线或下线。\n{\n    \"cmd\": \"s2c_online_status\",\n    \"data\":\n    {\n        \"did\": <str>,（上下线设备的did）\n        \"passcode\": <str>,（上下线设备的passcode）\n        \"mac\": <str>,（上下线设备的mac）\n        \"online\": true | false （true表示设备上线，false表示设备下线）\n    }\n}\n\n\n4. 设备绑定解绑状态变更通知\n当设备被用户绑定或者解绑后,云端会下发此消息通知浏览器。\n云端 ⇒ 浏览器。云端向浏览器发送以下的JSON字符串通知有绑定或解绑事件发生。\n{\n    \"cmd\": \"s2c_binding_changed\",\n    ￼\"data\":\n    {\n        \"did\": <str>, (设备的did)\n        \"bind\": true | false (true表示绑定,false表示解绑)\n￼    }\n}\n￼\n\n5. 浏览器与云端的数据交互（数据透传）\n浏览器可以和云端交互任意符合协议的数据。协议的格式为请参考其它协议文档。\n当用户在登 陆时参数\"p0_type\"的值等于\"custom\"时，只能以这种方式和云端交互数据。\n浏览器 ⇒ 云端。浏览器向云端发送以下的JSON字符串。\n{\n    \"cmd\": \"c2s_raw\",\n    \"data\":\n    {\n        \"did\": <str>, （目标设备的did）\n        \"raw\": [<byte>, <byte>, ...] （自定义业务逻辑指令的内容，以byte数组方式传送，每个byte的范围必须为 0~255。该内容必须要以[0, 0, 0, 3, varLen(1~4B), 0, 0, 144]开头）\n    }\n\n}\n\n若想云端往设备转发数据，raw的值需要加上以下的协议前缀再接上发往设备的数据，即[0, 0, 0, 3, varLen(1 ~ 4B), 0, 0, 144] + 发往设备的数据，其中的varLen为可变长度，由1 ~ 4个字节(B)表示本可变长度字段后一直到数据包结尾的字节数 ，如长度小于128B，直接用一个字节(B)表示长度即可，长度大于等于128B的编码解码方式请参考MQTT V3.1协议的可变长度（Remaining Length）定义。cmd为0x90/0x93/0x94等。  \n云端 ⇒ 浏览器。当云端收到设备上传的数据后，云端向浏览器转发以下的JSON字符串，数据放在raw字段中。注意，即使是登陆参数​\"p0_type\"​的值等于​\"attrs_v4\"​时，设备以“透传业务指令”上报的数据指令或中控相关的操作指令也会以本指令发往浏览器。\n{\n    \"cmd\": \"s2c_raw\",\n    \"data\":\n    {\n        \"did\": <str>,（数据来源设备的did）\n        \"raw\": [<byte>, <byte>, ...]（自定义业务逻辑指令的内容，以byte数组方式传送，每个byte的范围必须为 0~255）\n    }\n}\n\n若该数据为设备上报的数据，raw的值会带上一个协议前缀，即[0, 0, 0, 3, varLen(1~4B), 0, 0, 145] + 设备数据，其中的varLen为可变长度，定义请参考上文。 cmd为0x91/0x93/0x94等。\n6. 标准数据点操作（读、写、通知、ACK)\n当用户在登陆时参数\"p0_type\"的值等于\"attrs_v4\"时，云端会以标准数据点协议的方式和浏览器交互。   \n浏览器 ⇒ 云端。浏览器向云端发送以下的JSON字符串，读取目标设备当前的状态。陆参数\"p0_type\"​的值等于​\"custom\"​时不允许使用本指令。\n{\n    \"cmd\": \"c2s_read\",\n    \"req_sn\": <int>, (可选参数,若有值下发指令为带ACK的业务透传指令 [0x0093],若无则为不带ACK的业务\n￼透传指令 [0x0090])\n    \"data\":\n    {\n        \"did\": <str>,（目标设备的did）\n        \"names\": [<str>, <str>, …] （变长数据点可选参数：传入需要读取的数据点名称，参数省略表示读取全部数据点；定长数据点读操作忽略该参数）\n    }\n}\n\n浏览器 ⇒ 云端。浏览器向云端发送以下的JSON字符串，控制目标设备（更改目标设备的状态）。登陆参数​\"p0_type\"​的值等于​\"custom\"​时不允许使用本指令。\n{\n    \"cmd\": \"c2s_write\",\n    \"req_sn\": <int>, (可选参数,若有值下发指令为带ACK的业务透传指令 [0x0093],若无则为不带ACK的业务\n透传指令 [0x0090])\n    \"data\":\n    {\n        \"did\": <str>,（目标设备的did）\n        \"attrs\":\n        {\n            \"name1\": <value1>, (“name1”指数据点的标识名(name)，<value1>指数据点的值。值可以为true/false(布尔型)，Unicode编码的字符串如\\u62bd(枚举型)，数字（数值型），byte数组[23,2,3]（扩展类型)\n            \"name2\": <value2>,\n            ...\n        }\n    }\n}\n\n云端 ⇒ 浏览器。设备收到读取指令或状态发生变化后，会主动发送当前状态到云端，云端向浏览器转发以下的JSON字符串。 登陆参数​\"p0_type\"​的值等于​\"custom\"​时不会收到本指令。\n{\n    \"cmd\": \"s2c_noti\",\n    \"req_sn\": <int>, (非必须参数,若设备发送带ACK透传业务指令 [0x0093],则包含本字段,浏览器须带上本\n字段的值回复c2s_ack。res_sn与req_sn参数不能同时并存)\n    \"res_sn\": <int>, (非必须参数,若浏览器发送的c2s_read或c2s_write请求指令带有req_sn参数,则对应响应\n指令s2c_noti包含res_sn字段且值与req_sn一致。res_sn与req_sn参数不能同时并存)\n    \"data\":\n    {\n        \"did\": <str>,（数据来源设备的did）         \n        \"attrs\":\n        {\n            \"name1\": <value1>, (“name1”指数据点的标识名(name)，<value1>指数据点的值。值可以为true/false(布尔型)，Unicode编码的字符串如\\u62bd(枚举型)，数字（数值型），byte数组[23,2,3]（扩展类型)\n            \"name2\": <value2>,\n             ...          \n        }\n    }\n}\n\n云端 ⇒ 浏览器。浏览器发送带有req_sn的读取或写指令后 [0x0093],可能会收到设备对透传指 令的ACK 0x0094,云端向浏览器 转发以下的JSON字符串。登陆参数​\"p0_type\"​的值等于​\"custom\"​时不使用本指令。\n{\n    ￼\"cmd\": \"s2c_ack\",\n    \"res_sn\": <int>, (对应浏览器读取或写指令的req_sn)\n    ￼\"did\": <str>(设备did)\n￼\n}\n\n浏览器 ⇒ 云端。浏览器收到带有req_sn的s2c_noti消息后 [0x0093],需要浏览器向云端发送以下 的JSON字符串[0x0094]。登陆参数​\"p0_type\"​的值等于​\"custom\"​时不允许使用本指令。\n{\n    ￼\"cmd\": \"c2s_ack\",\n    \"res_sn\": <int>, (对应浏览器接收到s2c_noti指令的req_sn)\n    ￼\"did\": <str>(目标设备did)\n￼\n}\n\n7. 心跳\n浏览器和云端建立Web Socket连接后，需要在登陆参数\"heartbeat_interval\"指定的时间间隔内，定期向云端发送心跳。云端收到后会回复心跳。\n浏览器 ⇒ 云端。浏览器向云端发送以下的JSON字符串。\n{\n    \"cmd\": \"ping\"\n}\n\n云端 ⇒ 浏览器。云端向浏览器回复以下的JSON字符串。\n{\n    \"cmd\": \"pong\"\n}\n\n8. 非法消息通知\n当浏览器向云端发送的消息不合法或收到设备上报的数据不合法时,云端会下发此消息通知浏览器。\n云端 ⇒ 浏览器。云端向浏览器发送以下的JSON字符串通知有非法消息。\n{\n    \"cmd\": \"s2c_invalid_msg\",\n    \"data\":\n    {\n        \"error_code\": <int> ​(错误码)\n        \"msg\": <str> ​(描述文本)\n    }\n}\n\n"},{"title":"企业应用开发","url":"/zh-cn/Cloud/ent_dev.html","content":"概述\n企业应用是指企业将设备接入机智云后，企业需要获取设备数据用于实现企业特定的业务管理功能，以实现企业对设备、设备消费者的运营管理需要。通常企业应用在开发过程中，不仅需要通过机智云平台获取接入设备的数据，也需要通过企业API去控制设备、进行设备数据的统计分析。让企业集中精力关注企业应用的整体业务。\nSNoti服务\nSNoti服务是一个实时设备消息传输服务，该服务可以实时将企业的设备数据推送到企业应用系统，企业应用系统基于设备数据实现业务需求。\nSNoti服务的能力\n\n基于消息发布/订阅模型\n设备数据传输平均时长40-50ms\n支持多客户端同时请求\n支持SSL传输\n设备消息默认缓存3天，并可按企业需求定制\n提供设备消息的监控预警\n\n企业API\n企业API是从接入机智云平台的企业的运营管理的需求出发，基于企业接入到机智云平台所产生的数据，为企业提供企业视角全局的设备管理、数据分析等功能，让企业更关注业务管理系统本身，减少不必要的开发成本与时间。\n案例介绍\n充电桩SaaS平台\n充电桩SaaS平台是充电桩运营商为电动车主提供了寻找电桩、预约、充电、支付等功能，运营商通过运营管理平台对充电桩、故障、订单、计费规则、订单管理、结算等管理功能。充电桩运营商通过充电桩SaaS平台可以完整闭环的管理日常业务，大大提高运营效率。\n 充电桩设备接入了机智云，充电桩SaaS平台需要实时获得充电桩的数据，根据这些数据才能计算充电费用，是否有故障等。这些设备数据正是由机智云PaaS平台负责采集，并通过SNoti服务实时推送给充电桩SaaS平台。\n 充电桩SaaS平台还可以通过企业API开放的接口进行统计分析，如设备的位置服务查询，设备通信数据查询，充电桩故障数查询等功能\n分时租赁系统\n分时租赁平台的业务其实与充电桩SaaS平台类似，对于分时租赁的运营管理方，如运营汽车租赁、自行车租赁的企业。这些企业需要建设一套分时租赁管理平台，实现订单、结算、支付等必要功能。\n汽车、自行车接入到机智云，企业就无需在设备的物联接入进行投入，企业只需通过接入协议接入SNoti服务即可获取设备数据进行业务开发。\n开发流程\nSNoti服务接入\n1、提出申请\n\nSNoti服务通常是向企业开发者开放，如果企业需要实时获取接入到机智云PaaS平台的数据进行二次开发，则向机智云提出申请\nSNoti服务一般会与企业API服务共同使用，所以企业开发者也要同步申请企业API服务\n\n2、理解协议\n具体协议请点击 SNoti服务接口协议\n3、获取参数\n登录开发者中心，获取机智云为企业分配的访问SNoti服务与企业API的账号与秘钥。选择“企业信息”，如下图\n\n选择左侧组织，然后再点击“API配置”，即可获取Eid,Esecret，也可以在此设置IP白名单，若不设置IP白名单，消息代服务将会鉴权失败。\n\n如果是在开发环境，企业开发者需要通过一些工具获取开发环境对应的外网IP，可以通过ip.taobao.com获取，将识别出的IP地址复制到上图IP白名单，一行只能设置一个IP地址，对于生产环境，系统允许设置多个源IP地址访问消息服务。\n4、按需实现客户端\n企业根据Demo Code，根据自己的需求实现客户端功能开发，可以以Demo Code为原型，实现接收到设备数据后的业务逻辑。如：\n\n解析SNoti服务推送的JSON报文\n实时将获取的消息Publish到企业应用所属的队列中，进行异步操作；\n也可直接解析后，将数据写入数据库；但需要建立数据的定期清理策略\n\n5、通过虚拟设备模拟真实设备推送数据\n企业如果还没有真实设备接入到机智云，可以使用虚拟设备模拟一遍。\n\n启动Demo Code，前提是已经修改为正确的product_key,auth_id与auth_secret\n\n在该产品下并定义了数据点\n\n审批通过后即可启动虚拟设备，并模拟数据，点击”推送“\n\nDemo Code会实时打印SNoti服务推送的设备状态数据\n\n\n使用企业API\n1、申请企业API服务\n企业开发者登陆开发者中心，选择添加服务，如下图\n\n点击上图红色框中的企业API，进入下一步\n\n2、获取参数\n登陆开发者中心，选择“企业信息”，如下图\n\n选择左侧有权限可管理的组织，然后点击“API配置”，即可获取Eid,Esecret，也可以在此设置IP白名单\n\n3、理解协议\n企业API申请后，企业就可以通过理解企业API协议进行接口调用\n点击 企业API\n"},{"title":"Arduino开发指南（IoT）","url":"/zh-cn/GCP/Arduino.html","content":"Arduino开发指南\nArduino是一款便捷灵活、方便上手的开源电子原型平台，包含硬件（各种型号开发板）和软件（arduino IDE）,它适合爱好者，艺术家，和设计师的快速开发，把你的灵感快速实现。机智云Arduino中文论坛\n作为国内第一个智能硬件自助开发(PaaS)及云服务(SaaS)平台和Arduino战略合作伙伴,机智云率先开发出了基于Arduino的物联网开源套件 Gokit 和 Arduino代码自动生成工具，帮助创客快速实现智能化产品开发。\nGokit_Arduino开源套件\nGizWits Open Kit（缩写：GoKit），是机智云推出的一款开源WiFi智能硬件开发板，内置了温/湿度传感器、红外控测器、电机马达、全彩LED灯等常用传感器和元器件，配有一个WiFi时间模块和一颗MCU，并预留了扩展接口和开关键，可根据开发者的实际需求搭配使用。另外增加了OLED扩展接口，你可以为GoKit配上一块显示屏。\nWiFi模块方面，目前已经有二十几家国内厂商为机智云做了兼容。而且，现在所有开发者都可以拿到开发库自行开发适配。\n借助机智云的 Gokit套件，开发者可快速开发新产品。\nGoKit背后是一个完整的产品体系\n\n这个体系包含设备、APP、M2M服务、业务服务、以及云对接等各种环节,详细说来,还有很多很多,如果您有兴趣,可以参考我们的论坛 club.gizwits.com。\nGoKit在系统中的位置\nGoKit在系统逻辑上,位于右下角的MCU的位置,即：GoKit代表智能硬件。\n\n历代Gokit\n现有的Gokit版本\n\nGokit 2 标准板（STM32）:基于STM32平台，可更快的实现量产时的代码移植和复用。支持数据通过Wifi上传至到云平台\nGokit 2 创客板（arduino）:基于Arduino平台，简单、易入门，能够通过串口接收到MCU或传感器的数据。支持数据通过Wifi上传至到云平台\nGokit 3S（SOC）:支持MCU、SoC、BLE、语音、模式切换等特性，支持代码自动生成工具，节省空间和成本。\n支持GPRS数据透传。\nGokit 3V（语音板）:支持语音通信。\n\nGoKit 能给您带来什么？\n\n如果您是一个产品经理\n如果您是一个产品经理,您肯定希望快速的完成两件事情,一是做出产品的原型,实现产品初步功能;二是将产品量产,并找到销售渠道;\n第一件事情可以这样玩 GoKit:\n在我们的网页上,参照 GoKit 的模版,用图形化的方式定义您的产品功能;\n下载系统为您的产品生成的 DemoAPP,即可完成对您的产品原型;\n第二件事情可以这样玩 GoKit:\n使用系统按照您的产品定义生成的协议和源码,参考 GoKit 的工程,完成快速产品开发(1-2 天);\n使用 GizWits 提供的开源 APP(含 UI、UE 设计),参考您的产品定义,快速完成 APP 开发(1-2 天);\n通过 GizWits 的合作伙伴,找到合适的生产商,进行产品测试和生产;\n利用 GizWits 提供的 N 种宣传和渠道机会,将您的产品一夜成名;\n\n如果您是一个APP开发者\n如果您是一个APP开发者,您可能不太熟悉硬件的处理和云端处理，您可以使用GoKit提供的丰富资源,进行APP的开发：\n您可以根据 GoKit 的电机控制功能,开发出电动窗帘的 APP；\n您也可以根据温湿度传感器,开发出家庭的温湿度检测的 APP；\n您也可以自定义 LED 的颜色和亮度,来开发出更多功能的 APP；\n当然,如果您愿意,也可以和GizWits的合作伙伴一起,针对您想实现的产品定制GoKit,合作完成一款优秀的产品。 \n\n如果您是一个嵌入式开发者\n如果您是一个嵌入式开发者,您可能不太了解APP开发以及云端处理,您可以这样玩GoKit：\n在我们的网页上,参照 GoKit 的模版,用图形化的方式定义您的产品功能;\n参考系统生成的协议和源码,以及 GoKit 工程,二次开发 GoKit 并烧写 MCU;\n下载系统为您的产品生成的DemoAPP,即可完成对您的产品发现、控制、远程控制;\n如果您愿意,也可以研究您的产品是如何被APP发现的、如何连接云端的,因为这些基本上都开源; \n\n如果您就想讲一个故事\n如果您有一个非常好的想法,能讲一个很好的故事,这个故事可以为您找到投资,可以这样玩GoKit：\n您可以参照产品经理的做法快速做出产品原型;\n然后利用 GizWits提供的N 种活动机会,以及 N 种投资、孵化渠道,用 GoKit 原型生动的讲述您的故事;\n故事被认可后,您可以利用GizWits提供的N个生产合作伙伴实现您的故事;\n\n\n联网说明\n为方便硬件快速联网，机智云自研串口通信协议GAgent，兼容市面上70多种GRPS、WiFi模块， Arduino爱好者只需购买支持接入机智云的模组，烧写相应的GAgent固件，即可让Arduino设备具备联网能力。\n什么是GAent? GAent是机智云开发用于快速搭建物联网框架的固件，主要的作用是数据转发，是设备数据、机智云、应用端（APP）的数据交互桥梁。目前机智云提供由机智云移植的WiFi模组对应固件有：汉枫LPB100、乐鑫8266、汉枫LPT120、高通4004 、RealTek 8711AM 、庆科3162等。以上设备只需刷入GAgent，即可快速接入机智云。可应用在智能家居 \\ 智能家电 \\ 智慧公寓 \\ 智慧安防 \\ 物联网M2M \\ 单品类解决方案（净水器、空气净化器、照明、卫浴、厨电等） \\ 商用租赁 \\ 智能充电桩 \\ 工业控制 \\ 农业大棚 \\ 资产管理等领域 。\n\nGAgent模组固件烧写教程：\n\n汉枫 LPB100串口烧写说明\n乐鑫 ESP8266串口烧写说明\n汉枫 LPT120串口烧写说明\n庆科 3162串口烧写说明\n广和通 G510串口烧写说明\n串口工具使用文档\n日志抓取教程文档  \n\nArduino代码自动生成\n机智云官方提供Arduino UNO WIFI和Arduino UNO R3的代码自动生成。用户只需完成所需的逻辑功能即可。\n代码生成分为两个步骤:1.设置数据点  \n\n数据点的设置  \n\n2.使用MCU代码自动生成工具生成目标代码  \n\n具体移植步骤，巨细  \n\n其他信息：\n\nArduino Uno WIFI接入机智云介绍\nArduino Uno WIFI之ESP8266固件烧写教程\nArduino Uno WIFISDK之API介绍\nArduino Uno WIFI智能小夜灯\n\nArduino应用案例\n开源项目\n\n小夜灯  \n智能家居应用模型One\n智能药盒    \n智能婴儿摇篮\n智能灯\n智能温控器\n智能鞋柜\n智能家居云控制套件\n智能健康计\n智能插座\n智慧宿舍\n智能仓鼠管家（语音版）\n无线工业粉尘监测仪\n\n商用项目\n部分商用项目：\n\n伊莱特智能电饭煲\n全球客服 A.O.史密斯\n华商三优电动车智能充电应用平台\n西默智能路由器\n艾沃净水机：连接微信，智慧饮水\n戴勒姆Care2Share\n酷蛙智能净水器\n诸葛小明床头灯，语音控制 wifi音响自动感应\n新科微信操控空调\n希澈智能声波牙刷\n巴比立方智能果蔬种植机\n幸福森林空气净化器\nC1智能鱼缸温控器\nOnread智能插座\n无源智能墙壁开关\n\n关于机智云\n机智云，Giz(mo)Wits（设备智慧）是广州机智云物联网科技有限公司旗下品牌，全球领先的物联网开发和云服务商，全栈物联网平台服务领导者，国内第一个智能硬件自助开发(PaaS)及云服务(SaaS)平台\n公司拥有完整的技术研发团队、安全团队和人工智能团队，为有志于进军物联网开发者和企业提供安全、可靠的一站式物联网开发工具和云端运维服务，涵盖终端管理、连接管理、应用支持和业务分析等主要功能，已服务车联网、新能源、工业互联、医疗健康、消费类电子产品等众多行业。\n模块化开发工具\n以下是机智云提供的模块化开发工具：\n\n标准GAgent串口通讯协议\nMCU代码自动生成工具 \nAPP代码自动生成工具\n自动化产测工具\nOTA固件升级\n国际版应用邮件模板\n产品互联（Echo接入等）\nSnoti服务\n企业API、OPEN API\nRTDB实时大数据统计\n\n解决方案\n以下是机智云提供的解决方案：\n\n信息家电/大家电智能化/小家电智能化/\n厨电信息化解决方案\n智能净水器/智能空气净化器/\n汽车电子/车联网/智能充电桩\n公寓/楼宇/家居/酒店智能化解决方案\n安防 / 消防\n电机控制\n智能电网\n医疗/保健/卫生\n\n机智云客户：\n\n官方技术交流群\n\nG1机智云物联网云服务 104975951\nG2机智云物联网云服务 491509598\nG3机智云物联网云服务 287087942\nG4机智云-STM32 iot开发 289447077\nG5-APP代码自动生成公测 599735135\nG6机智云-Arduino iot开发 378683984\n\n联系我们\n\n地址: 广州天河区天平架陶庄路5号众创空间8-9层 研发中心\n电话: 020-6224-0080\n邮箱: service@gizwits.com\nNewYork   646.201.9357\n\n\n"},{"title":"STM32开发指南（IoT）","url":"/zh-cn/GCP/STM32.html","content":"概述\nSTM32是ST(意法半导体)推出的基于ARM® Cortex® M 处理器内核的 32位闪存微控制器产品，融高性能、实时性、数字信号处理、低功耗、低电压于一身，同时保持高集成度和开发简易的特点。拥有业内最强大的产品阵容，基于工业标准的处理器，大量的软硬件开发工具，让STM32单片机成为各类中小项目和完整平台解决方案的理想选择。\n作为国内第一个智能硬件自助开发(PaaS)及云服务(SaaS)平台和意法半导体战略合作伙伴,机智云率先开发出了基于STM32的物联网开源套件 Gokit 和STM32代码自动生成工具，帮助物联网智能硬件开发者快速打造产品原型。STM32论坛\n应用范围:\n智能家居 \\ 智能家电 \\ 智慧公寓 \\ 智慧安防 \\ 物联网M2M \\ 单品类解决方案（净水器、空气净化器、照明、卫浴、厨电等） \\ 商用租赁 \\ 智能充电桩 \\ 工业控制 \\ 农业大棚 \\ 资产管理 。\n基于STM32的开源套件Gokit\nGizWits Open Kit（缩写：GoKit），是机智云推出的一款开源WiFi智能硬件开发板，内置了温/湿度传感器、红外控测器、电机马达、全彩LED灯等常用传感器和元器件，配有一个WiFi时间模块和一颗MCU，并预留了扩展接口和开关键，可根据开发者的实际需求搭配使用。另外增加了OLED扩展接口，你可以为GoKit配上一块显示屏。\nWiFi模块方面，目前已经有二十几家国内厂商为机智云做了兼容。而且，现在所有开发者都可以拿到开发库自行开发适配。\n借助机智云的 Gokit套件，开发者可快速开发新产品。\nGoKit背后是一个完整的产品体系\n\n这个体系包含设备、APP、M2M服务、业务服务、以及云对接等各种环节,详细说来,还有很多很多,如果您有兴趣,可以参考我们的论坛 club.gizwits.com。\nGoKit在系统中的位置\nGoKit在系统逻辑上,位于右下角的MCU的位置,即：GoKit代表智能硬件。\n\n历代Gokit\n现有的Gokit版本：\n\nGokit 2 标准板（STM32）:基于STM32平台，可更快的实现量产时的代码移植和复用。支持数据通过Wifi上传至到云平台\nGokit 2 创客板（arduino）:基于Arduino平台，简单、易入门，能够通过串口接收到MCU或传感器的数据。支持数据通过Wifi上传至到云平台\nGokit 3S（SOC）:支持MCU、SoC、BLE、语音、模式切换等特性，支持代码自动生成工具，节省空间和成本。\n支持GPRS数据透传。\nGokit 3V（语音板）:支持语音通信。\n\nGoKit 能给您带来什么？\n\n如果您是一个产品经理\n如果您是一个产品经理,您肯定希望快速的完成两件事情,一是做出产品的原型,实现产品初步功能;二是将产品量产,并找到销售渠道;\n第一件事情可以这样玩 GoKit:\n在我们的网页上,参照 GoKit 的模版,用图形化的方式定义您的产品功能;\n下载系统为您的产品生成的 DemoAPP,即可完成对您的产品原型;\n第二件事情可以这样玩 GoKit:\n使用系统按照您的产品定义生成的协议和源码,参考 GoKit 的工程,完成快速产品开发(1-2 天);\n使用 GizWits 提供的开源 APP(含 UI、UE 设计),参考您的产品定义,快速完成 APP 开发(1-2 天);\n通过 GizWits 的合作伙伴,找到合适的生产商,进行产品测试和生产;\n利用 GizWits 提供的 N 种宣传和渠道机会,将您的产品一夜成名;\n\n如果您是一个APP开发者\n如果您是一个APP开发者,您可能不太熟悉硬件的处理和云端处理，您可以使用GoKit提供的丰富资源,进行APP的开发：\n您可以根据 GoKit 的电机控制功能,开发出电动窗帘的 APP；\n您也可以根据温湿度传感器,开发出家庭的温湿度检测的 APP；\n您也可以自定义 LED 的颜色和亮度,来开发出更多功能的 APP；\n当然,如果您愿意,也可以和GizWits的合作伙伴一起,针对您想实现的产品定制GoKit,合作完成一款优秀的产品。\n\n如果您是一个嵌入式开发者\n如果您是一个嵌入式开发者,您可能不太了解APP开发以及云端处理,您可以这样玩GoKit：\n在我们的网页上,参照 GoKit 的模版,用图形化的方式定义您的产品功能;\n参考系统生成的协议和源码,以及 GoKit 工程,二次开发 GoKit 并烧写 MCU;\n下载系统为您的产品生成的DemoAPP,即可完成对您的产品发现、控制、远程控制;\n如果您愿意,也可以研究您的产品是如何被APP发现的、如何连接云端的,因为这些基本上都开源;\n\n如果您就想讲一个故事\n如果您有一个非常好的想法,能讲一个很好的故事,这个故事可以为您找到投资,可以这样玩GoKit：\n您可以参照产品经理的做法快速做出产品原型;\n然后利用 GizWits提供的N 种活动机会,以及 N 种投资、孵化渠道,用 GoKit 原型生动的讲述您的故事;\n故事被认可后,您可以利用GizWits提供的N个生产合作伙伴实现您的故事;\n\n\n联网说明\n智能设备之所以智能，一个重要的原因在于其具备联网能力，常见的智能设备多是由单片机/微处理器/微控制器等构成的嵌入式系统，主流的联网方式是嵌入GPRS、WIFI、蓝牙等无线通信模块。\n机智云提供了一款兼容国内主流Wi-Fi模块、GSM模块的模组系统——GAgent。可以提供上层应用（手机APP等控制端、云端）到产品设备的双向数据通讯，此外，还提供对设备的配置入网、发现绑定、程序升级等功能。\n产品开发者使用GAgent后，只需要关心产品的业务逻辑开发，不用关心数据的通讯功能开发，大大降低了开发的难度。\n目前机智云提供由机智云移植的WiFi模组对应固件有：汉枫LPB100、乐鑫8266、汉枫LPT120、高通4004 、RealTek 8711AM 、庆科3162、广和通G510等。购买机智云支持的无线通信模组后，烧录GAgent固件，模组对MCU就是串口透传，开发者无需任何二次开发，只需按照官方给出的参考设计搭建最小系统，连接到MCU的串口即可。\n部分模组固件烧写教程：\n\n汉枫 LPB100串口烧写说明\n乐鑫 ESP8266串口烧写说明\n汉枫 LPT120串口烧写说明\n庆科 3162串口烧写说明\n广和通 G510串口烧写说明\n串口工具使用文档\n日志抓取教程文档\n\n\nSTM32代码自动生成\n为了降低开发者的开发门槛，缩短开发周期，降低开发资源投入，机智云推出了代码自动生成服务。云端会根据产品定义的数据点生成对应产品的设备端代码。使用自动生成的代码开发产品，就不必再处理协议相关的部分了，开发者可以将节省出来的精力集中在产品的核心功能开发上\n自动生成的代码实现了机智云通信协议的解析与封包、传感器数据与通信数据的转换逻辑，并封装成了简单的API，且提供了多种平台的实例代码。当设备收到云端或APP端的数据后，程序会将数据转换成对应的事件并通知到应用层，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，就可以完成产品的开发。\n\n代码自动生成工具文档：\n\nMCU（STM32）代码自动生成工具介绍\n\nMCU和SOC方案\n自动生成服务支持的硬件方案有：独立MCU方案、SOC方案。\n\n独立MCU方案支持的硬件平台有：stm32f103c8x、STM32F407X、STM32F429X、STM32767X、Arduinounowifi、ArduinounoR3、通用平台（即“其他平台”）；\nSOC方案支持的硬件平台有：ESP8266平台\n\n快速入门：\n\n独立MCU方案\nSOC 方案\n\nMCU方案与SOC方案区别\nMCU方案：模组负责与云端信息的交互，通过串口与主控板（即MCU）进行通信，需要在MCU上进行协议解析与外设控制的开发。\nSoC方案：节省一颗MCU芯片，利用模组内部资源完成传感器操作和产品逻辑。\nMCU方案中除了支持STM32平台，还可以将我们生成好的通用平台版代码移植到符合条件的任意平台，从而实现机智云所提供的各种功能。移植参考：DEV SDK Common版移植说明（通用平台）\nSTM32开发应用\n常见案例\n\nSTM32 NucleoL496ZG智能灯案例\nSTM32L432 Nucleo-32案例-3分钟打造手机APP远程空气质量监测应用\n史上最详细UCOS-II移植教程，基于Gokit STM32F103C8T6\n亲测WS2812 RGB彩灯MCU和SOC方案实现\n用 ESP8266 做一个网络插座 (SOC方案)\n 基于ESP8266 SOC 车库照明系统\n\n开源项目\n\n智能家居应用模型One\n智能药盒\n智能婴儿摇篮\n智能灯\n智能温控器\n智能鞋柜\n智能家居云控制套件\n智能健康计\n智能插座\n智慧宿舍\n智能仓鼠管家（语音版）\n无线工业粉尘监测仪\n\n商用项目\n部分商用项目：\n\n伊莱特智能电饭煲\n全球客服 A.O.史密斯\n华商三优电动车智能充电应用平台\n西默智能路由器\n艾沃净水机：连接微信，智慧饮水\n戴勒姆Care2Share\n酷蛙智能净水器\n诸葛小明床头灯，语音控制 wifi音响自动感应\n新科微信操控空调\n希澈智能声波牙刷\n巴比立方智能果蔬种植机\n幸福森林空气净化器\nC1智能鱼缸温控器\nOnread智能插座\n无源智能墙壁开关\n\n常见问题\n\nSTM32如何快速接入机智云\n\n5分钟了解机智云\n\n机智云支持哪些WiFi模块、GSM模块？\n\n汉枫 HF-LPB100、HF-LPB120、LPT120\n乐鑫/安信可    esp-8266\nRealtek8711am、联盛德TLN13SP01、广州致远AW54101WFX、高通QCA4004\nTI    CC3200、NXP QFN-1、上海移远M26\n广和通G510、 中兴ME3610 、中兴ME3630\n\n\nGAgent for 汉枫LPB100、乐鑫ESP8266固件下载地址\n\nHF-LPB100串口烧写说明\n\nHF-LPT120串口烧写说明\n\n在哪可以购买已烧写好GAgent固件的汉枫模块\n\n了解更多STM32信息：http://www.stmcu.com.cn/\n\n\n关于机智云\n机智云，Giz(mo)Wits（设备智慧）是广州机智云物联网科技有限公司旗下品牌，全球领先的物联网开发和云服务商，全栈物联网平台服务领导者，国内第一个智能硬件自助开发(PaaS)及云服务(SaaS)平台\n公司拥有完整的技术研发团队、安全团队和人工智能团队，为有志于进军物联网开发者和企业提供安全、可靠的一站式物联网开发工具和云端运维服务，涵盖终端管理、连接管理、应用支持和业务分析等主要功能，已服务车联网、新能源、工业互联、医疗健康、消费类电子产品等众多行业。\n模块化开发工具\n以下是机智云提供的模块化开发工具：\n\n标准GAgent串口通讯协议\nMCU代码自动生成工具\nAPP代码自动生成工具\n自动化产测工具\nOTA固件升级\n国际版应用邮件模板\n产品互联（Echo接入等）\nSnoti服务\n企业API、OPEN API\nRTDB实时大数据统计\n\n解决方案\n以下是机智云提供的解决方案：\n\n信息家电/大家电智能化/小家电智能化/\n厨电信息化解决方案\n智能净水器/智能空气净化器/\n汽车电子/车联网/智能充电桩\n公寓/楼宇/家居/酒店智能化解决方案\n安防 / 消防\n电机控制\n智能电网\n医疗/保健/卫生\n\n官方技术交流群\n\nG1机智云物联网云服务 104975951\nG2机智云物联网云服务 491509598\nG3机智云物联网云服务 287087942\nG4机智云-STM32 iot开发 289447077\nG5-APP代码自动生成公测 599735135\nG6机智云-Arduino iot开发 378683984\n\n联系我们\n\n地址: 广州天河区天平架陶庄路5号众创空间8-9层 研发中心\n电话: 020-6224-0080\n邮箱: service@gizwits.com\nNewYork   646.201.9357\n\n\n"},{"title":"D3 Engine使用教程","url":"/zh-cn/UserManual/D3.html","content":"D3 Engine简介\n申请条件\n机智云企业开发者，购买了GDCS服务包的企业客户。\n 功能介绍\nD3 Engine，全称 Dynamic Data Director Engine。\nD3 Engine是机智云为开发者提供的傻瓜式的数据处理、开发引擎。D3 可以灵活定义数据的输入，能将设备、用户数据与外部第三方数据进行有机整合，还可以支持脚本解析与自定义数据输入，满足不同开发者的数据处理需要。主要特点如下：\n1）多样的数据源：支持自定义多种数据源，第三方公共数据甚至您的ERP系统的数据输入。\n2）强大的规则处理：基于决策树算法支持灵活多重条件组合。\n3）灵活的输出：除了App推送、邮件、短信等服务，还可以支持回调服务以及存储服务；存储服务通过数据平台的计算与开放API服务对各类应用提供数据服务，降低各类应用的开发成本以及面对海量数据的性能处理风险\nD3 Engine申请流程\n申请条件：企业开发者\n申请成功后：可以免费使用推送100条／天，如需更多，请致电 020-62240080 咨询\n第一步：登录机智云【开发者中心】，打开需要申请开通D3 Engine的产品(仅限企业开发者)，如有疑问可发邮件至club@gizwits.com邮箱；\n第二步：点击【添加服务】，进入到【添加服务】页面，找到【D3 Engine】；\n\n第三步：打开D3 Engine，点击【开通服务】按钮，等待机智云审核；\n\n第四步：待审核通过后，在服务列表即可看到D3 Engine；点击【D3 Engine】即可开始体验。\n\nD3 Engine使用说明\n1.项目列表\n进入D3 Engine，默认进入此产品的项目列表页面。\n\n项目列表为空时，页面显示如上图。\n【新建项目】：点击后跳转至新建项目页面。\n【APP推送配置】：点击后跳转至APP推送配置页面。\n\n项目列表不为空时，页面显示如上图。本页面显示该产品所创建的所有项目(不包含通过调用接口创建的项目)。显示字段为项目ID、项目名称、动作类型、备注、是否开启等。\n【新建项目】：点击此按钮跳转至新建项目页面，可为该产品创建新项目；\n【编辑】：点击后进入当前项目页面可进行修改；\n【删除】：点击此按钮可将当前项目删除。\n【是否开启】：项目是否开启按钮。项目创建成功后默认开启。点击关闭后该项目将不会被触发。\n2.配置\n进入D3 Engine，默认进入此产品的【项目列表】页面，点击【配置】进入APP推送配置页面。\n\n当前产品无绑定的应用时，页面显示如上图。\n【应用配置】：点击后跳转至应用配置页面，可创建新应用。\n\n当前产品有绑定的应用时，页面显示如上图，列出该产品绑定的所有应用。\niOS和Android类型支持配置推送，微信暂不支持。\n【编辑推送平台】：点击后跳转至APP绑定第三方推送的配置界面。\n3.编辑推送平台\n此页面可以为APP绑定百度推送或者极光推送。\n应用平台：创建应用时所选的类型iOS、Android、微信(暂不支持配置推送)\n推送平台：目前仅支持百度推送和极光推送两种方式\n推送Key和Secret：从百度推送或极光推送平台申请的Key和Secret\n证书类型：生产和开发两种证书类型。iOS应用须选择证书类型(且应根据所选证书类型上传对应证书至百度或极光推送平台上)，Android应用无需证书\n\n输入百度推送API Key、Secret Key或者极光推送App Key、Master Key绑定成功后效果如下图：\n\n再次点击编辑推送平台，可进行解绑及修改操作。\n4.新建/编辑项目\n【返回】：点击此按钮，返回至项目列表页；\n【保存】：点击对当前所编辑的项目进行保存(无法保存时会有出错提示)；\n【左侧节点】：项目组成部分，不同类型的节点，使用拖拽的方式拖至中间空白区域。分为三类：输入、处理方法、触发动作；\n【中间区域】：项目编辑区域，可拖拽页面左侧节点至此部分进行项目创建和修改等操作；\n【右下角三个图标】：可对页面进行缩小、恢复默认及放大的操作(仅针对项目编辑区域有效)；\n\n5.输入节点\n设备数据\n使用接入机智云的设备的数据作为输入。当有报警或故障数据点时，设备报警或设备故障选项才会显示。\n\n自定义数据\n使用自定义的JSON格式的数据作为输入。\n\n\nSchema：描述JSON字符串内部包含的字段结构。可以使用以下工具生成:http://jsonschema.net/#/\n数据标识名：用于引用此请求返回的JSON标识。\n更新间隔：不小于5s，请求的缓存过期时间。D3会将自定义数据缓存起来，每经过一个更新间隔会重新获取数据。\n6.处理方法节点\n逻辑规则\n添加一个逻辑条件。比较参数可以是数据点值也可以是自定义的变量值。\n\n四则运算\n添加一个由四则运算表达式指定的中间变量。此处只能针对数值类型的数据点进行四则表达式运算。变量标识请不要使用中文。\n\n7.触发动作节点\nAPP推送\n规则触发成功时，与设备绑定的APP用户将收到一条推送消息。\n此处可以编辑推送消息的标题、推送内容(可从参数中选择自动替换的变量)、选择推送应用及消息类型，可以自定义推送的时间段。\n\n\nHTTP请求\n规则触发成功时，向指定的API发送一个请求。在此节点中输入要请求API的详细参数。\n\n邮件\n规则触发成功时，指定的邮箱将收到一封推送邮件。此节点定义邮件主题、邮件内容及收件人信息。\n\n短信推送\n规则触发成功时，与设备绑定的APP用户的手机号码将收到一条短信消息。Apikey和短信模板ID可以从云片获取，此处会进行校验。展开属性可自定义消息接收时间。\n\n\n控制设备\n规则触发成功时，该设备改变自己的状态。控制内容中以JSON格式填入，支持Raw和KV两种格式。\n\n8.举例说明\n产品名称：空气净化器\n数据点：\n空气质量（air_quality）    枚举型    优秀,良好,一般,污染\n温度（temperture）    数值型    -128~128\n消耗品1（consumable1）    数值型    0~100\n消耗品2（consumable2）    数值型    0~100\n例1：设备上线时，推送消息给app用户同时推送邮件给xxxx@126.com邮箱\n第一步：打开【空气净化器】产品的新建项目页面。\n第二步：拖动【设备数据】节点到项目编辑区域。\n\n第三步：双击【设备数据】节点进行编辑，点击【确定】即保存。\n\n第四步：拖动【APP推送】节点到项目编辑区域。\n\n第五步：双击【APP推送】节点进行编辑(定义推送标题、内容、时间段等参数，可参考触发动作节点APP推送节点说明)，点击【确定】即保存。\n第六步：拖动【邮件】节点到项目编辑区域，并双击进行编辑(定义推送人、推送内容、推送标题等参数，可参考触发动作节点邮件推送节点说明)，点击【确定】即保存\n第七步：将三个节点连结起来。\n\n第八步：点击右上角【保存】按钮，项目创建成功。\n例2：空气质量等于一般且消耗品1和消耗品2的平均值小于30时，推送消息给app用户\n第一步：拖动【设备数据】节点到项目编辑区域。\n\n第二步：双击进行编辑，选择设备上报状态，点击【确定】即保存。\n\n第三步：拖动【逻辑规则】节点到项目编辑区域。\n第四步：双击【逻辑规则】节点进行编辑，点击【确定】即保存。\n进入【逻辑规则】编辑框，比较参数1选择数据点值(空气质量)，比较符号选择等于，比较参数2选择值且从下拉列表中选择具体值(一般)，点击【确定】保存。\n\n第五步：拖动【四则运算】节点到项目编辑区域\n第六步：双击【四则运算】节点进行编辑，点击【确定】即保存\n此步骤定义一个中间变量Avg = (消耗品1+消耗品2)/2\n【算述表达式】中公式输入步骤：点击运算符中的左括号(，从【参数】下拉列中选择“消耗品1”点击添加，点击运算符中的+，从【参数】下拉列表中选择“消耗品2”点击添加，点击运算符中的右括号)，点击运算符中的除号/，输入数字2\n在【变量标识】中给变量起个名称(例如Avg)\n\n第七步：再拖动一个【逻辑运算】节点到项目编辑区域，并双击进行编辑，点击【确定】即保存。\n进入【逻辑规则】编辑框，比较参数1选择上一步定义的中间变量(Avg)，中间比较符号选择小于，比较参数2选择值且输入数字(30)，点击【确定】保存。\n\n第八步：拖动【APP推送】节点到项目编辑区域，并双击进行编辑，点击【确定】保存。【APP推送】节点设置请参考触发动作节点_APP推送节点说明。\n第九步：将五个节点连接起来。\n\n第十步：点击右上角【保存】按钮，项目创建成功。\n"},{"title":"聚合API使用教程","url":"/zh-cn/UserManual/DataAPI.html","content":"1.概述\n该接口可以对设备上报的数值型数据点数据进行聚合，可以按小时/天/周/月对数据点数据进行求和/平均值/最大值/最小值进行聚合。一次可以获取多个数据点的聚合数据。\n要使用该接口，必须先请求开通该接口。请求通过的之后上报的数据才会进行聚合运算。\n使用例子，如：智能水表的用水量数据点，可以统计分析每户每个月的用水量、每个星期的用水量和每天的用水量。从而，形成一个月报表、周报表和天报表。 \n2.Open API的高级数据接口使用流程\nOpen API的高级数据接口，就是获取设备聚合数据。\n当客户已开通open API聚合接口使用权限后，就可以调用该接口进行设备上报的数值型数据点数据进行聚合分析，可以按小时/天/周/月对数据点数据进行求和/平均值/最大值/最小值进行聚合。\n2.1创建用户\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/用户管理/post_app_users\n如下图为创建匿名登录\n\n2.2.登录用户\n匿名创建接口和匿名登录接口一样。\n2.3.绑定设备\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/绑定管理/post_app_bind_mac\n\n2.4.上报设备数据\n使用机智云提供的xpg工具，通过模拟mcu上报当前设备的数据。\n工具的使用方法如下：\nhttp://docs.gizwits.com/zh-cn/deviceDev/串口工具使用文档.html\n\n2.5.数据聚合查询\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/高级数据接口\n\n查询后的结果：\n\n3.企业API的设备数据聚合查询流程\n设备数据聚合查询只是对单台设备进行数据聚合查询，该接口提供查询某个时间周期内某个WiFi设备数据型数据点的聚合运算，包括求和、平均、最大、最小。\n注意：企业API使用先向机智云技术申请开通企业API，以及要在API配置处添加IP白名单。\n3.1.申请开通企业API\n申请开通企业API的流程：\nhttp://docs.gizwits.com/zh-cn/Cloud/ent_dev.html\n3.2.添加IP白名单\n\nIP为你当前服务器的外部IP。\n\n3.3.申请开通企业API聚合接口使用\n联系机智云技术人员，向他们申请开通企业API聚合接口的使用权限。\n3.4.获取token\n请求URL: \nhttp://enterpriseapi.gizwits.com/v1/products/447c947fff3245a18dfc709371c34e69/access_token\nBody参数填写：\n{\n  \"enterprise_id\": \"string\",\n  \"enterprise_secret\": \" string \",\n  \"product_secret\": \" string \"\n}\n\n注意：不能在swagger上面直接请求，因为swagger服务的IP没有在你们的IP白名单内，如果你暂时还没有搭建好后台服务器，可以借用chrome浏览器插件postman来进行请求。\n3.5.上报设备状态\n\n3.6.调用单台设备数据聚合查询接口\n请求URL:\nhttp://enterpriseapi.gizwits.com/v1/products/cdfb1e7f2d31474ca10396de88491372/devices/Zb248887fhMVZ2V2Jhz2xfq/agg_data?start_ts=1485151200000&end_ts=1485153000000&attrs=t1%2Ct2%2Ct3%2Ct4&aggregator=avg&unit=HOURS\nURL的Params值有：\nproduct_key\ndid\nstart_ts\nend_ts\nattrs\naggregator\nunit\nHeaders参数：\nAuthorize   token “填token”\nContent-Type    application/json\n\n注意：${token值}是不包括${}号，只需将从获取token接口获得token值放到token之后。例如：Authorization: token efbekskdklllsF\n4.相关支持\n聚合接口是面向企业开发者使用的，如果要申请开通，请通过官网的联系方式联系我们。\n网站地址：http://www.gizwits.com/about-us\n官方二维码：\n\n"},{"title":"使用Google Home音箱控制GoKit","url":"/zh-cn/UserManual/Google_Home_GoKit.html","content":"1.概述\n\n本教程说明了用户使用Gokit除App和微信两种控制方式外第三种控制方式使用说明：Google Home音箱控制。\n\nGoogle Home音箱：Google Home音箱是一款结合Google Assistant语音助理的音箱，我们可以通过这位助理获得大多数的帮助，比如计时器、播放音乐或者回答简单的问题，同时也可以控制我们的智能家居。\n\nGoogle Assistant：Google Assistant是一款语音助手，它并不是一种单独的程序，这款新的技术会和谷歌不同的设备以及操作系统机密结合，旨在让用户通过“流畅”的语音和设备相互沟通。它也能够使用在第三方的应用和服务中，例如流媒体音乐服务、打车服务等。\nAction and Google：Action是在Google Assistant上建立应用程序，你的程序可以让用户通过Google Home，支持Google的安卓手机，iphone去唤Action的名字，然后与你的程序进行交互。\n\n机智云在Google Assistant上发布了一款用来控制Gokit的Action，名字为“Gokit”\n\n\n\n\n\nAction名称\n可控制的功能\n\n\n\n\nGoKit\nGokit上的RGB灯的开关与红绿蓝三种颜色\n\n\nGoKit\nGokit上的电机的开关\n\n\n\n2.准备工作\n硬件：\n\nGokit2 或 Gokit3（可以到官方商城购买，链接：https://59680395.taobao.com/）\nGoogleHome音箱、支持Google的Android6.0+手机、美国地区账号的iphone （中国大陆的用户需要VPN或可以翻墙的路由器）\n\n软件：\n\n机智云Gokit APP\n\n\n\n\nIOS\nAndroid\n\n\n\n\n\n\n\n\n\n\nGoogle Home App （版本为1.26.93937以上） 或  Google App （版本为7.7以上）\n\n\n\nAndroid客户端（需在Google Play Store进行下载）\nIOS客户端（需要在美国地区注册的账号登陆App Store进行下载）\n账号：\n\n机智云账号（在机智云Gokit APP里通过手机注册）\nGoogle账号\n\n3.机智云Gokit配置绑定\n\n打开机智云Gokit app，通过手机注册，并登陆，跳转到“我的设备”页面，并点击“暂无设备，请添加”。\n\n\n\n选择你Gokit上wifi模组的类型，并选择你要配置的网络，输入wi-fi密码，点击“下一步”，长按Gokit上key2，使RGB亮绿灯，则点击“下一步”。\n\n\n\n进入“设备链接网络”的页面，稍等片刻之后，连接成功并跳转到“我的设备”页面，在“发现新设备”一栏中，有一个未绑定的设备，“微信宠物屋”可以通过设置别名来修改，“ACCF2378C44A”为该设备的MAC，点击该设备。\n注：若配置超时则检查路由器是否是在2.4GHz的频段下，路由器是否能连入外网，若配置成功却没有发现到新设备，请检查你Gokit的MCU程序中的product key，是否为出厂自带的product key。\n\n\n\n进入该设备的控制页面，当点击开启红色灯，Gokit的灯能够成功点亮，则说明配置成功了，点击返回到“我的设备”，发现该设备已经在“已绑定设备”一栏，则说明Gokit绑定成功。\n\n\n4.Google Home音箱配置和Action账号关联\n4.1配置Google Home音箱入网\n4.1.1 用Google Home App来配置Google Home音箱（Android系统手机）\n\n给音响插上电源，让Google Home处于白色呼吸灯状态（若不是呼吸灯状态，请长按背后的禁麦克风按钮至橙圈完整）打开Google Home App，登陆账号，进入到Home 页面，点击右上角设备的按钮，跳转到“Devices”页面，这个页面会发现到你的google home，点击SET UP进入下一个界面\nps：若Google Home并未处于呼吸灯状态，此页面将不会发现Google Home设备，请长按背后的禁麦克风按钮至重置\n\n\n\n进入Google Home setup 页面，点击CONTINUE，等待手机自动链接Google Home的Ap热点。\n\n\n\n稍等片刻之后，手机连上了GoogleHome3232.k的热点，点击PLAY TEST SOUND，音箱发出声响即处于正常配网流程\n\n\n\n如果听见音响发出声响则点击I HEARD IT，如果没有则点击TRY AGAIN，进入下一界面选择你音箱的名字，点击CONTINUE。\n\n\n\n在这个页面选择你要将Google Home配置到哪个网路，这里可以选择通过手机获取密码，或者手动输入密码，输好密码之后，点击\"CONTINUE\"，然后显示配置成功的提示\n\n\n\n配置一些Google Home的基本参数以及使用向导之后，回到Home主界面，就可以看到自己的Google Home设备了\n\n\n4.1.2 用Google Home App来配置Google Home音箱（IOS系统手机）\n\n采用蓝牙的方式配网，具体请参考该链接（https://support.google.com/googlehome/answer/7029485?hl=en&ref_topic=7196250&co=GENIE.Platform%3DiOS&oco=0）\n\n4.2        唤醒Action和账户关联\n4.2.1 用Google Home唤醒Action\n\n保持Google Home处于麦克风打开状态，对Google Home说\"Ok,Google.Talk to gokit\"，之后DISCOVER页面会弹出GOKIT的用户条款还有账户链接，滑动到账户链接，点击\"LINK\"进入账户关联页面\n\n\n4.2.2 用手机唤醒Action\n\n进入Google页面，长按Home键，弹出Google Assistantd的对话框，在对话框文字或者语音输入\"Talk to gokit\"，就会弹出Link Gokit to Google的一个对话框，点击进入账户关联页面\n\n\n4.2.3 账户关联\n\n进入账户关联页面，登陆刚刚通过GOKIT App注册的机智云账号，然后点击yes，之后回到Home页面之后，就可以开始说控制指令了\n\n\n5.附录\n5.1        “GoKit”Action控制语音指令与结果返回语音\n\n控制例句示范：Ok Google,talk to gokit and turn on the light\nOk Google ->用于唤醒Google Home （用手机控制不需要此句，Ok Google的唤醒词也可用Hey Google）\ntalk to gokit ->用于唤醒Action\nturn on the light->控制命令语句\n\n\n\n\n用户控制语音指令\nGoogle Home音箱回复语音\n实际操作效果\n\n\n\n\nOk Google,talk to gokit\nWelcome to gokit.I will now receive commands for your device.If you need more help,say help\n唤醒Google Home并进入会话模式\n\n\nOk Google,talk to gokit and help\nYou can say turn on the light or motor to control the sensor on gokit\n音箱回复帮助指令，提示用户更多信息，并保持会话模式\n\n\nOk Google,talk to gokit and turn on the light\nthe light is on\nGokit上的RGB灯亮\n\n\nOk Google,talk to gokit and turn off the light\nthe light is off\nGokit上的RGB灯灭\n\n\nOk Google,talk to gokit and turn the light    to red\nthe light is red\nGokit上的RGB变红\n\n\nOk Google,talk to gokit and turn the light    to green\nthe light is green\nGokit上的RGB变绿\n\n\nOk Google,talk to gokit and turn the light to blue\nthe light is blue\nGokit上的RGB变蓝\n\n\nOk Google,talk to gokit and turn on the motor\nthe motor is on\nGokit上的电机开始转动\n\n\nOk Google,talk to gokit and shut down the motor\nthe motor is off\nGokit上的电机停止转动\n\n\n\n"},{"title":"设备联动API使用教程","url":"/zh-cn/UserManual/LinkageAPI.html","content":"1.概述\n   单品WiFi设备之间联动关系，通过创建设备间联动规则，当设备触发规则后，由云端给要联动的设备推送控制指令。例如：客户有一个智能灯和一个智能空调，可以根据云端提供设备联动功能，创建一个规则，当打开智能灯后，就把智能空调打开。关系图如下\n \n（注意：创建两个产品联动关系的时候，两个产品一定要关联同一个appid，不然，请求的时候就会报appid不存在问题。）\n2.设备联动流程\n条件：原设备和联动设备必须绑定在同一个用户下，然后再在该用户下设定设备联动的规则才能进行设备间的联动功能。\n如下就是设备联动的流程图：\n\n3.设备联动规则\n3.1.获取可用变量\n功能描述：获取可以在创建规则时使用的、跟appid关联的pk下的所有数据点标识名以及设备和产品相关变量。\n1.请求URL:  http://api.gizwits.com/app/rules/params?product_key=pk1,pk2 \n2.请求方式:    GET\n3.请求Header:\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nString\n是\nparams\n多个pk用“,”隔开，参数为空时默认选中与appid绑定的所有pk，填入与appid无绑定的pk时该pk无效\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n机智云APPID\n\n\nX-Gizwits-User-Token\nString\n是\nheader\n用户token\n\n\n\n3.2.创建规则\n功能描述：创建一个设备联动规则。\n1.请求URL: http://api.gizwits.com/app/rules\n2.请求方式:POST\n3.请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n可选值\n描述\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n机智云APPID\n\n\nX-Gizwits-User-Token\nString\n是\nheader\n\n用户token\n\n\nproduct_key\nString\n是\nbody\n\n产品识别码\n\n\ndid\nString\n是\nbody\n\n设备号\n\n\nname\nString\n否\nbody\n\n产品名称\n\n\nremark\nString\n否\nbody\n\n设备别名\n\n\ninterval\nInteger\n否\nbody\n\n最小触发间隔(单位:秒)，每当设置了此值的规则触发后，必须要经过时长等于此值的间隔时间后才可以再次触发\n\n\nevent\nString\n是\nbody\nonline/offline/alert/fault/data/extern\n触发方式，无此参数或为空时默认值为data\n\n\nevent_attr\nObject\n否\nbody\n\n当event为alert或fault需要的参数\n\n\ninput\nArray\n否\nbody\n\n数组中每一个对象代表一个设备的数据,不需要使用设备数据时可忽略此参数\n\n\ncondition\nArray\n否\nbody\n\n数组中的每一个数组代表一组条件,无此参数或为空时,表示直接触发\n\n\noutput\nArray\n是\nbody\n\n数组中每一个数组代表一组触发动作,至少要有一个\n\n\n\n参数补充说明\na.event\n表示该规则的触发方式,以下是可选值的意义:\n    online  - 设备上线\n    offline - 设备下线\n    alert   - 设备某个报警数据点发生报警\n    fault   - 设备某个故障数据点发生故障\n    data    - 设备上报状态\n    extern  - 外部调用触发API\n无此参数或为空时默认值为data\nb.event_attr\n当触发方式为alert(报警)/fault(故障)时, 发生这个报警/故障的数据点,以及报警/故障的发生/恢复,由该参数指定:\n\"event_attr\": {\n    \"attr_name\": \"datapoint_alert\", ---- 发生这个报警/故障的数据点\n    \"value\": \"1\"                    ---- 报警/故障的发生/取消, 值为1时表示发生, 值为0时表示取消\n}\n注: 这里提到的报警/故障的\"发生\"指的是－设备上一次上报的报警/故障数据点的值为0, 这一次上报的为1, 那么报警/故障发生\n    这里提到的报警/故障的\"恢复\"指的是－设备上一次上报的报警/故障数据点的值为1, 这一次上报的为0, 那么报警/故障恢复\n    其他情况均不属于\"发生\"和\"恢复\"\nc.did \n当触发方式为online/offline/alert/fault/data时, 产生这个触发方式的设备由该参数指定, 以下把指定的这个设备称为主设备\nd.input \n指定规则中需要用到的设备数据,数组中每一个对象代表一个设备的数据,不需要使用设备数据时可忽略此参数:\n[{\n    \"product_key\": \"pk1\", ---- 设备所属Product key\n    \"did\": \"did1\",        ---- 设备did\n    \"prefix\": \"device1\"   ---- 用于在条件及输出中引用这个设备的数据点值的前缀, 如设置了这个参数为device1时, 则device1.datapoint1表示引用这个设备的标识名为datapoint1的数据点\n}]\ne.condition \n指定触发规则需要满足的条件, 云端处理时将逐组检查数组内的条件, 任意一组条件满足时触发输出\n[\n    [{\n        \"left\": \"device1.datapoint1\", ---- 左比较参数, 参数的值类型需要和右比较参数一致\n        \"opt\": \"==\",                  ---- 比较运算符, 可选值有: >, >=, <, <=, ==, != (注:只有数值类型才能比较大小)\n        \"right\": \"1\"                  ---- 右比较参数, 参数的值类型需要和左比较参数一致, 使用常数时注意,\"1\"代表数字1,\"'1'\"或\"\\\"1\\\"\"才是字符串\"1\"\n    }],\n    [{                                ---- 每个数组表示一组条件，当这个组里的所有条件都满足时，这一组条件满足\n        \"left\": \"device1.datapoint1\",\n        \"opt\": \"==\",\n        \"right\": \"1\"\n    },{\n        \"left\": \"device2.datapoint2\",\n        \"opt\": \">\",\n        \"right\": \"25\"\n    }]\n]\nf.output \n指定当条件满足时, 需要做的事情，可认为云端同时执行各组动作，各组之间互不影响\n•    控制设备 \n向设备发送控制指令\n•    [\n•        [{                            ---- 每个数组表示一组输出动作，按顺序执行，前面的动作执行失败时，后面不会执行\n•            \"type\": \"devctrl\",        ---- output的类型, devctrl表示控制设备\n•            \"did\": \"did1\",            ---- 指定被控制的设备的did\n•            \"attrs\": {                 ---- key-value形式\n•                \"datapoint1\": 1,      ---- 设置datapoint1值为1\n•                \"datapoint2\": 25,\n•                \"datapoint3\": \"黄色\"\n•            }\n•        },{\n•            \"type\": \"delay\",          ---- output的类型, delay表示延时\n•            \"delay\": 5                ---- 延时时长, 单位:秒\n•        },{\n•            \"type\": \"devctrl\",\n•            \"did\": \"did3\",\n•            \"raw\": \"1111111100000111\" ---- raw形式\n•        }],\n•        [{\n•            \"type\": \"devctrl\",\n•            \"did\": \"did2\",\n•            \"attrs\": {\n•                \"datapoint1\": 1,\n•                \"datapoint2\": 25,\n•                \"datapoint3\": \"黄色\"\n•            }\n•        }]\n•    ]\ng.Body示例\n{\n    \"product_key\": \"pk1\",\n    \"did\": \"did1\",\n    \"name\": \"name1\",\n    \"remark\": \"remark1\",\n    \"event\": \"data\",\n    \"event_attr\": {\n        \"attr_name\": \"datapoint_alert\",\n        \"value\": \"1\"\n    },\n    \"input\": [\n        {\n            \"product_key\": \"pk1\",\n            \"did\": \"did1\",\n            \"prefix\": \"device1\"\n        },\n        {\n            \"product_key\": \"pk2\",\n            \"did\": \"did2\",\n            \"prefix\": \"device2\"\n        }\n    ],\n    \"condition\": [\n        [{\n            \"left\": \"device1.datapoint1\", ---- 布尔型\n            \"opt\": \"==\",\n            \"right\": \"1\"\n        }],\n        [{\n            \"left\": \"device2.datapoint2\", ---- 数值型\n            \"opt\": \">\",\n            \"right\": \"25\"\n        }],\n        [{\n            \"left\": \"device2.datapoint3\", ---- 枚举型\n            \"opt\": \"!=\",\n            \"right\": \"'黄色'\"\n        },{\n            \"left\": \"device2.datapoint4\", ---- 扩展型\n            \"opt\": \"==\",\n            \"right\": \"0xFF00\"\n        }]\n    ],\n    \"output\": [\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"did1\", \n            \"attrs\": {\n                \"datapoint1\": 1,\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        },{\n            \"type\": \"delay\",\n            \"delay\": 5\n        },{\n            \"type\": \"devctrl\",\n            \"did\": \"did3\",\n            \"raw\": \"1111111100000111\"\n        }],\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"did2\",\n            \"attrs\": {\n                \"datapoint1\": 1,\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        }]\n    ]\n}\n5.示例规则\n如：含义打开原设备Power_Switch数据点，就联动把要联动设备的数据点OnOff也打开。\n{\n    \"product_key\": \"9005ab8399bb4338b6131a0522b3a57c\",\n    \"did\": \"7qSv5w62GK36NkUWFQu8AP\",\n    \"name\": \"\",\n    \"remark\": \"\",\n    \"event\": \"data\",\n      \"input\": [\n        {\n            \"product_key\":\"9005ab8399bb4338b6131a0522b3a57c\",\n            \"did\":\"7qSv5w62GK36NkUWFQu8AP\",\n            \"prefix\":\"device1\"\n        },\n        {\n            \"product_key\":\"98b133ecaa314d9d8224cd8cbc935c06\",\n            \"did\":\"qkDCqFiW3s4mbXWAqpFUnW\",\n            \"prefix\":\"device2\"\n        }\n    ],\n    \"condition\": [\n         [{\n            \"left\": \"device1.Power_Switch\", \n            \"opt\": \"==\",\n            \"right\": \"1\"\n        }]\n    ],\n    \"output\": [\n        [{\n            \"type\":\"devctrl\",\n            \"did\":\"qkDCqFiW3s4mbXWAqpFUnW\", \n            \"attrs\":{\n                \"OnOff\":1\n            }\n        }]\n    ]\n}\n3.3.获取用户规则\n功能描述：获取某个用户创建的所有规则\n1.请求UR:  http://api.gizwits.com/app/rules\n2.请求方式:GET\n3.请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nHeader\n机智云APPID\n\n\nX-Gizwits-User-Token\nString\n是\nHeader\n用户token\n\n\n\n3.4.修改规则\n功能描述：根据rule_id，修改该rule_id下的规则\n1.请求URL:http://api.gizwits.com/app/rules/{rule_id}\n2.请求方式:PUT\n3.请求报文\n\n\n\n参数\n类型\n必填\n参数类型\n可选值\n描述\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nheader\n\n机智云APPID\n\n\nX-Gizwits-User-Token\nString\n是\nheader\n\n用户token\n\n\nproduct_key\nString\n是\nbody\n\n产品识别码\n\n\ndid\nString\n是\nbody\n\n设备号\n\n\nname\nString\n否\nbody\n\n产品名称\n\n\nremark\nString\n否\nbody\n\n设备别名\n\n\ninterval\nInteger\n否\nbody\n\n最小触发间隔(单位:秒)，每当设置了此值的规则触发后，必须要经过时长等于此值的间隔时间后才可以再次触发\n\n\nevent\nString\n是\nbody\nonline/offline/alert/fault/data/extern\n触发方式，无此参数或为空时默认值为data\n\n\nevent_attr\nObject\n否\nbody\n\n当event为alert或fault需要的参数\n\n\ninput\nArray\n否\nbody\n\n数组中每一个对象代表一个设备的数据,不需要使用设备数据时可忽略此参数\n\n\ncondition\nArray\n否\nbody\n\n数组中的每一个数组代表一组条件,无此参数或为空时,表示直接触发\n\n\noutput\nArray\n是\nbody\n\n数组中每一个数组代表一组触发动作,至少要有一个\n\n\n\n4.示例规则格式\n{\n    \"product_key\": \"pk1\",\n    \"did\": \"did1\",\n    \"name\": \"name1\",\n    \"remark\": \"remark1\",\n    \"event\": \"data\",\n    \"event_attr\": {\n        \"attr_name\": \"datapoint_alert\",\n        \"value\": \"1\"\n    },\n    \"input\": [\n        {\n            \"product_key\": \"pk1\",\n            \"did\": \"did1\",\n            \"prefix\": \"device1\"\n        },\n        {\n            \"product_key\": \"pk2\",\n            \"did\": \"did2\",\n            \"prefix\": \"device2\"\n        }\n    ],\n    \"condition\": [\n        [{\n            \"left\": \"device1.datapoint1\",\n            \"opt\": \"==\",\n            \"right\": 1\n        }],\n        [{\n            \"left\": \"device2.datapoint2\",\n            \"opt\": \">\",\n            \"right\": 25\n        }],\n        [{\n            \"left\": \"device2.datapoint3\",\n            \"opt\": \"!=\",\n            \"right\": \"黄色\"\n        },{\n            \"left\": \"device2.datapoint4\",\n            \"opt\": \"==\",\n            \"right\": \"0xFF00\"\n        }]\n    ],\n    \"output\": [\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"did1\", \n            \"attrs\": {\n                \"datapoint1\": 1,\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        },{\n            \"type\": \"delay\",\n            \"delay\": 5\n        },{\n            \"type\": \"devctrl\",\n            \"did\": \"did3\",\n            \"raw\": \"1111111100000111\"\n        }],\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"did2\",\n            \"attrs\": {\n                \"datapoint1\": 1,\n                \"datapoint2\": 25,\n                \"datapoint3\": \"黄色\"\n            }\n        }]\n    ]\n}\n5.修改规则的实例，\n如下（规则含义为：把原设备的Power_Switch数据点打开，联动到把要联动的设备数据点OnOff打开，然后等待5s，再把要联动的设备数据点Lightness设置为25值）\n{\n    \"product_key\": \"9005ab8399bb4338b6131a0522b3a57c\",\n    \"did\": \"7qSv5w62GK36NkUWFQu8AP\",\n    \"name\": \"\",\n    \"remark\": \"\",\n    \"event\": \"data\",\n    \"input\": [\n        {\n            \"product_key\": \"9005ab8399bb4338b6131a0522b3a57c\",\n            \"did\": \"7qSv5w62GK36NkUWFQu8AP\",\n            \"prefix\": \"device1\"\n        },\n        {\n            \"product_key\": \"98b133ecaa314d9d8224cd8cbc935c06\",\n            \"did\": \"qkDCqFiW3s4mbXWAqpFUnW\",\n            \"prefix\": \"device2\"\n        }\n    ],\n    \"condition\": [\n        [{\n            \"left\": \"device1.Power_Switch\",\n            \"opt\": \"==\",\n            \"right\": \"1\"\n        }]\n    ],\n    \"output\": [\n        [{\n            \"type\": \"devctrl\",\n            \"did\": \"qkDCqFiW3s4mbXWAqpFUnW\", \n            \"attrs\": {\n                \"OnOff\": 1\n            }\n        },{\n            \"type\": \"delay\",\n            \"delay\": 5\n        },{\n            \"type\": \"devctrl\",\n            \"did\": \"qkDCqFiW3s4mbXWAqpFUnW\",\n             \"attrs\": {\n                \"Lightness\": 25\n            }\n        }]\n    ]\n}\n3.5.删除规则\n功能描述：根据rule_id，删除该rule_id下的规则\n1.请求URL: http://api.gizwits.com/app/rules/{rule_id}\n2.请求方式: DELETE\n3.请求报文:\n\n\n\n参数\n类型\n必填\n参数类型\n可选值\n描述\n\n\n\n\nX-Gizwits-Application-Id\nString\n是\nHeader\n\n机智云APPID\n\n\nX-Gizwits-User-Token\nString\n是\nHeader\n\n用户token\n\n\nrule_id\nInteger\n是\nurl\n\n规则号\n\n\n\n#4.参考资料\nOpen API文档:http://docs.gizwits.com/zh-cn/Cloud/openapi_apps.html\nswagger使用链接:swagger\n"},{"title":"MCU OTA教程（3.1）","url":"/zh-cn/UserManual/MCUOTA.html","content":"GAgent OTA教程\nMCU OTA教程（2.0）\nMCU OTA教程（3.0）\n源文档及源参考代码下载\n1.概述\nMCU OTA可以对MCU程序进行无线远程升级。本文以STM32F103C8T6实现OTA作为例子。原本MCU程序软件版本号是01，想升级到02，但是设备已经量产了不可能再去一个一个设备重新烧录新的程序，这时候就需要用到MCU OTA。\nSTM32F103C8T6 芯片（GOKIT2 代）Flash 空间划分出 4 个区域：Bootloader、FLAG、APP 分区、APPBAK 分区。\n\nBootloader:存储 Bootloader 固件，MCU 上电后首先运行该固件。\nFLAG:存储有关升级的相关标志位，Bootloader 和 APP 分区都需要操作该区域。\nAPP 分区:存储用户程序固件。\nAPPBAK 分区:临时存储云端下发的新固件，升级固件的一个过渡存储区。\n源代码中有BootLoader和APP 分区两部分。BootLoader稍作编译设置，不需要改动代码，就可以编译烧写到MCU中；APP 分区的OTA功能相关代码复制到mcu方案自动生成代码中，再编译烧写到MCU中，mcu程序就具有OTA功能。\n下文分别是BootLoader和APP 分区的详细移植步骤。\n2.Bootloader 分区部分\n2.1.Bootloader 程序流程\nBootloader 的主要职能是在有升级任务的时候将 APPBAK 分区里面的固件拷贝到 APP 区域。当然，这期间需要做很多的工作，比如升级失败的容错等等。具体的流程可以参考图示。需要注意的是，在校验 MD5 正确后开始搬运固件数据期间，MCU 出现故障（包括突然断电），MCU 应发生复位操作（FLAG 区域数据未破坏），复位后重新开始执行 Bootloader，从而避免 MCU 刷成板砖。\n\n2.2.Bootloader 编译设置\n按照 Bootloader 流程编写好代码，需要我们对 KEIL 工程做相应配置，需要注意的是编译的 Bootloader 固件大小不超过最大可允许的 11KB。Keil 编译器需要设置如下：\n2.2.1按照 FLASH 分区方案，设置 FLASH 固件下载地址，如下图所示：\n\n2.2.2Flash 烧写地址设置生效\n\n2.2.3设置ST-LINK 按块擦除 FLASH 区间和烧写程序\n\n\n\n3.APP 分区部分\n3.1.固件接收流程\n做好 BOOTLOADER 工作后，我们开始写 APP 分区的代码。APP 分区固件的编写要注意硬件版本号和软件版本号，软件版号作为升级迭代很重要的标志。APP 分区代码我们只需要在 GOKIT 微信宠物屋代码基础上增加大数据接受即接受云端新固件功能即可。需要注意的是，中断向量地址偏移的定义，这个地方需要我们尤其注意，我在开发过程中在这个地方排查了好长时间。STM32 标准库默认中断向量地址偏移为 0x0,但是我们 APP 分区实际的偏移是 0x3000。如果不修改，APP 分区也可以正常加载运行，但是不会相应中断。所以，我们需要根据实际 APP 分区下载的起始地址，对中断向量地址偏移做定义。按照协议规定，我们去实现大数据整个流程，具体如下：\n\n3.2.App 分区编译器设置\n同样，因为硬件 FLASH 空间限定，我们需要对 APP 分区的固件大小做严格的限制。本方案，针对 GOKIT 我们可允许的最大固件为 26KB。需要升级的新固件同样最大可支持 26KB。\n3.2.1.设置 FLASH 固件下载地址\n\n\n3.2.2.设置keil烧写方式为st-link\n\n3.2.3.通过编译优化等级控制APP 分区固件大小\n\n3.2.4.设置编译的时候生成.bin文件（OTA的时候需要选择把.bin文件上传到机智云）\n\n3.2.5.设置按区域擦除\n\n3.2.6.往工程目录添加hal_lash.c和gagent_md5.c，单击keil的build按钮展开工程目录，可以看到hal_flash.h和gagent_md5.h\n\n3.3.App 分区OTA功能代码移植\n3.3.1.中断向量偏移地址\n\n3.3.2.接下来是代码移植步骤，只需把图片内红框相应代码复制到开发者自动生成mcu代码，即可实现mcuOTA功能。\n\n\n\n\n\n\n\n\n\n3.3.3.编译和烧程序\n\n4.MCU OTA验证\n4.1.第一次用stlink烧录mcu代码后，mcu日志如图\n\n4.2.准备OTA，先让设备连上机智云。\n\n4.3.改mcu代码里面的软件版本号，要比原来的高，选择编译出来的.bin文件。（注意：如果图中有手动/静默，请选择静默，没有则忽略注意）\n\n4.4.OTA成功\n\n本文档主要写移植OTA功能移植过程，想要了解MCU OTA详细过程（例如mcu启动流程检查有无OTA任务，OTA flash分区等等），请看源文档。\n"},{"title":"MCU OTA教程（2.0）","url":"/zh-cn/UserManual/MCUOTA2.html","content":"GAgent OTA教程\n源文档及源参考代码下载\n1.概述\nMCU OTA可以对MCU程序进行无线远程升级。本文以STM32F103C8T6实现OTA作为例子。原本MCU程序软件版本号是01，想升级到02，但是设备已经量产了不可能再去一个一个设备重新烧录新的程序，这时候就需要用到MCU OTA。\nSTM32F103C8T6 芯片（GOKIT2 代）Flash 空间划分出 4 个区域：Bootloader、FLAG、APP 分区、APPBAK 分区。\n\nBootloader:存储 Bootloader 固件，MCU 上电后首先运行该固件。\nFLAG:存储有关升级的相关标志位，Bootloader 和 APP 分区都需要操作该区域。\nAPP 分区:存储用户程序固件。\nAPPBAK 分区:临时存储云端下发的新固件，升级固件的一个过渡存储区。\n源代码中有BootLoader和APP 分区两部分。BootLoader稍作编译设置，不需要改动代码，就可以编译烧写到MCU中；APP 分区的OTA功能相关代码复制到mcu方案自动生成代码中，再编译烧写到MCU中，mcu程序就具有OTA功能。\n下文分别是BootLoader和APP 分区的详细移植步骤。\n2.Bootloader 分区部分\n2.1.Bootloader 程序流程\nBootloader 的主要职能是在有升级任务的时候将 APPBAK 分区里面的固件拷贝到 APP 区域。当然，这期间需要做很多的工作，比如升级失败的容错等等。具体的流程可以参考图示。需要注意的是，在校验 MD5 正确后开始搬运固件数据期间，MCU 出现故障（包括突然断电），MCU 应发生复位操作（FLAG 区域数据未破坏），复位后重新开始执行 Bootloader，从而避免 MCU 刷成板砖。\n\n2.2.Bootloader 编译设置\n按照 Bootloader 流程编写好代码，需要我们对 KEIL 工程做相应配置，需要注意的是编译的 Bootloader 固件大小不超过最大可允许的 11KB。Keil 编译器需要设置如下：\n2.2.1按照 FLASH 分区方案，设置 FLASH 固件下载地址，如下图所示：\n\n2.2.2Flash 烧写地址设置生效\n\n2.2.3设置ST-LINK 按块擦除 FLASH 区间和烧写程序\n\n\n\n3.APP 分区部分\n3.1.固件接收流程\n做好 BOOTLOADER 工作后，我们开始写 APP 分区的代码。APP 分区固件的编写要注意硬件版本号和软件版本号，软件版号作为升级迭代很重要的标志。APP 分区代码我们只需要在 GOKIT 微信宠物屋代码基础上增加大数据接受即接受云端新固件功能即可。需要注意的是，中断向量地址偏移的定义，这个地方需要我们尤其注意，我在开发过程中在这个地方排查了好长时间。STM32 标准库默认中断向量地址偏移为 0x0,但是我们 APP 分区实际的偏移是 0x3000。如果不修改，APP 分区也可以正常加载运行，但是不会相应中断。所以，我们需要根据实际 APP 分区下载的起始地址，对中断向量地址偏移做定义。按照协议规定，我们去实现大数据整个流程，具体如下：\n\n3.2.App 分区编译器设置\n同样，因为硬件 FLASH 空间限定，我们需要对 APP 分区的固件大小做严格的限制。本方案，针对 GOKIT 我们可允许的最大固件为 26KB。需要升级的新固件同样最大可支持 26KB。\n3.2.1.设置 FLASH 固件下载地址\n\n\n3.2.2.设置keil烧写方式为st-link\n\n3.2.3.通过编译优化等级控制APP 分区固件大小\n\n3.2.4.设置编译的时候生成.bin文件（OTA的时候需要选择把.bin文件上传到机智云）\n\n3.2.5.设置按区域擦除\n\n3.2.6.往工程目录添加Flash.c和gagent_md5.c，单击keil的build按钮展开工程目录，可以看到Flash.h和gagent_md5.h\n\n3.3.App 分区OTA功能代码移植\n3.3.1.中断向量偏移地址\n\n3.3.2.接下来是代码移植步骤，只需把图片内红框相应代码复制到开发者自动生成mcu代码，即可实现mcuOTA功能。\n\n\n\n\n\n\n\n\n\n\n3.3.3.编译和烧程序\n\n4.MCU OTA验证\n4.1.第一次用stlink烧录mcu代码后，mcu日志如图\n\n4.2.准备OTA，先让设备连上机智云。\n\n4.3.改mcu代码里面的软件版本号，要比原来的高，选择编译出来的.bin文件。（注意：如果图中有手动/静默，请选择静默，没有则忽略注意）\n\n4.4.OTA成功\n\n本文档主要写移植OTA功能移植过程，想要了解MCU OTA详细过程（例如mcu启动流程检查有无OTA任务，OTA flash分区等等），请看源文档。\n"},{"title":"MCU OTA教程（3.0）","url":"/zh-cn/UserManual/MCUOTA3.0.html","content":"GAgent OTA教程\nMCU OTA教程（2.0）\n源文档及源参考代码下载\n1.概述\nMCU OTA可以对MCU程序进行无线远程升级。本文以STM32F103C8T6实现OTA作为例子。原本MCU程序软件版本号是01，想升级到02，但是设备已经量产了不可能再去一个一个设备重新烧录新的程序，这时候就需要用到MCU OTA。\nSTM32F103C8T6 芯片（GOKIT2 代）Flash 空间划分出 4 个区域：Bootloader、FLAG、APP 分区、APPBAK 分区。\n\nBootloader:存储 Bootloader 固件，MCU 上电后首先运行该固件。\nFLAG:存储有关升级的相关标志位，Bootloader 和 APP 分区都需要操作该区域。\nAPP 分区:存储用户程序固件。\nAPPBAK 分区:临时存储云端下发的新固件，升级固件的一个过渡存储区。\n源代码中有BootLoader和APP 分区两部分。BootLoader稍作编译设置，不需要改动代码，就可以编译烧写到MCU中；APP 分区的OTA功能相关代码复制到mcu方案自动生成代码中，再编译烧写到MCU中，mcu程序就具有OTA功能。\n下文分别是BootLoader和APP 分区的详细移植步骤。\n2.Bootloader 分区部分\n2.1.Bootloader 程序流程\nBootloader 的主要职能是在有升级任务的时候将 APPBAK 分区里面的固件拷贝到 APP 区域。当然，这期间需要做很多的工作，比如升级失败的容错等等。具体的流程可以参考图示。需要注意的是，在校验 MD5 正确后开始搬运固件数据期间，MCU 出现故障（包括突然断电），MCU 应发生复位操作（FLAG 区域数据未破坏），复位后重新开始执行 Bootloader，从而避免 MCU 刷成板砖。\n\n2.2.Bootloader 编译设置\n按照 Bootloader 流程编写好代码，需要我们对 KEIL 工程做相应配置，需要注意的是编译的 Bootloader 固件大小不超过最大可允许的 11KB。Keil 编译器需要设置如下：\n2.2.1按照 FLASH 分区方案，设置 FLASH 固件下载地址，如下图所示：\n\n2.2.2Flash 烧写地址设置生效\n\n2.2.3设置ST-LINK 按块擦除 FLASH 区间和烧写程序\n\n\n\n3.APP 分区部分\n3.1.固件接收流程\n做好 BOOTLOADER 工作后，我们开始写 APP 分区的代码。APP 分区固件的编写要注意硬件版本号和软件版本号，软件版号作为升级迭代很重要的标志。APP 分区代码我们只需要在 GOKIT 微信宠物屋代码基础上增加大数据接受即接受云端新固件功能即可。需要注意的是，中断向量地址偏移的定义，这个地方需要我们尤其注意，我在开发过程中在这个地方排查了好长时间。STM32 标准库默认中断向量地址偏移为 0x0,但是我们 APP 分区实际的偏移是 0x3000。如果不修改，APP 分区也可以正常加载运行，但是不会相应中断。所以，我们需要根据实际 APP 分区下载的起始地址，对中断向量地址偏移做定义。按照协议规定，我们去实现大数据整个流程，具体如下：\n\n3.2.App 分区编译器设置\n同样，因为硬件 FLASH 空间限定，我们需要对 APP 分区的固件大小做严格的限制。本方案，针对 GOKIT 我们可允许的最大固件为 26KB。需要升级的新固件同样最大可支持 26KB。\n3.2.1.设置 FLASH 固件下载地址\n\n\n3.2.2.设置keil烧写方式为st-link\n\n3.2.3.通过编译优化等级控制APP 分区固件大小\n\n3.2.4.设置编译的时候生成.bin文件（OTA的时候需要选择把.bin文件上传到机智云）\n\n3.2.5.设置按区域擦除\n\n3.2.6.往工程目录添加Flash.c和gagent_md5.c，单击keil的build按钮展开工程目录，可以看到Flash.h和gagent_md5.h\n\n3.3.App 分区OTA功能代码移植\n3.3.1.中断向量偏移地址\n\n3.3.2.接下来是代码移植步骤，只需把图片内红框相应代码复制到开发者自动生成mcu代码，即可实现mcuOTA功能。\n\n\n\n\n\n\n\n\n\n3.3.3.编译和烧程序\n\n4.MCU OTA验证\n4.1.第一次用stlink烧录mcu代码后，mcu日志如图\n\n4.2.准备OTA，先让设备连上机智云。\n\n4.3.改mcu代码里面的软件版本号，要比原来的高，选择编译出来的.bin文件。（注意：如果图中有手动/静默，请选择静默，没有则忽略注意）\n\n4.4.OTA成功\n\n本文档主要写移植OTA功能移植过程，想要了解MCU OTA详细过程（例如mcu启动流程检查有无OTA任务，OTA flash分区等等），请看源文档。\n"},{"title":"OTA使用教程","url":"/zh-cn/UserManual/OTA.html","content":"OTA功能概述\nOTA 英文全称是Over-the-Air Technology，即空间下载技术。当设备连上云端时会收到OTA升级通知，再通过HTTP完成固件升级。机智云的OTA服务主要提供以下功能：\n\nOTA通知服务，即离线升级。当设备的固件程序有新版本发布，OTA 通知服务会推送升级通知到设备。\nOTA透传服务，即在线升级。设备固件程序通过M2M 消息服务透传到设备端。\n支持一个产品同时有多个推送\n支持wifi/mcu升级\n支持定向升级。可指定设备mac地址、区域、旧固件版本进行推送。\n支持定时推送。可自定义推送周期及推送时段。\nOTA进度统计分析\n\nOTA升级流程\nWifi产品OTA服务是在开发者中心网站上实现的，由5部分组成：分别是添加固件、验证固件、添加规则、开始推送、推送完成（查询结果）。\n添加固件\n注：以下是GAgent固件OTA教程，要看MCU OTA教程请点击跳转\n如将设备的模组烧写的固件为：GAgent_00ESP826_04020019_16101715.bin，其中硬件版本号为：00ESP826，软件版本号为：04020019\n步骤一、进入【服务】固件升级（OTA）模块，点击【创建新固件】\n\n\n步骤二、下载GAgent OTA固件（MCU固件是开发者开发，若是MCU升级，可跳过该步骤。）\n\n\n备注：所有汉枫WiFi模组 OTA固件必须选择web版本，ESP 8266 WiFi模组OTA固件为“非combine文件”。如下图：\n\n\n\n步骤三、固件信息填写\n硬件版本号+软件版本号前 4 个字节 +固件类型完全匹配为一系列固件，软件版本号后4个字节区分固件版本，OTA升级需在同系列中进行。\n\n\n版本名称：自定义，由英文、数字及下划线组成\n固件类型：支持WiFi/MCU两种方式，选择wifi\n推送方式：支持V4V4.1两种方式。推送方式的选择可以参考页面“温馨提示”。\n注意：由于目前大部分设备所使用的固件支持v4.1推送方式，本文只讲解v4.1推送方式流程。\n选择固件：上传需要升级的固件，如：GAgent_00MX3162_04020004.bin（wifi为bin文件，mcu为bin/hex文件）\n硬件版本号：目标升级WIFI硬件版本（即上传的），必须为8个字节\n软件版本号：目标升级WIFI软件版本（即上传的），必须为8个字节\n\n\n\n\n步骤四、 点击完成，此时固件为未验证状态\n验证固件\n出于安全性考虑，未验证通过固件不可进行OTA推送。验证固件不区分OTA版本，流程一致。在大批量升级设备之前，需要选择单台设备进行升级，并自行验证升级后的设备稳定性。若无异常，固件变为已验证状态，表示可以进行批量OTA升级。\n验证固件流程如下：\n步骤一、再次确认已上传的bin文件及信息填写无误（未验证固件还可编辑）。\n步骤二、准备测试设备并让其连上云端,保证验证的设备在线。\n步骤三、进入未验证固件的固件详情页面，点击【验证固件】，出现如下界面：\n\n\n步骤四、在输入框填写在线测试设备的MAC地址，找到目标设备后进入固件升级倒计时\n\n步骤五、测试设备成功升级后，出现再次确认界面。此时，为了谨慎起见，请你对升级成功后的设备做一个稳定性验证，确保升级后的设备能正常工作。如无异常，请手动勾选确认框。\n\n添加规则\n通过添加不同的规则可以实现一个产品同时有多个推送请求，并可设置推送周期及时段，个性化定制推送服务。\n步骤一、在固件列表，点击已验证固件名称，进入【固件推送】页面，点击【添加规则】\n\n步骤二、设置推送条件：支持“指定地区”和“指定MAC”两种推送方式\n\n\n设置推送条件详解：\n指定地址：填入目标推送设备区域，如“广东省-广州市” 或者 指定MAC地址：填入目标推送设备地址，如有多个换行隔开\n指定旧固件版本：选择目标推送设备的旧固件版本\n目标设备：取条件1&2的交集，刷新后显示欲推送的目标设备数\n推送周期（UTC）：设置推送规则有效日期\n推送时段（UTC）：设置每日推送时段。\n备注（重要）:\n设备在推送周期内&推送时段内，且在线状态下，机智云将发送OTA推送通知。每日发送OTA推送通知次数为一次。设备收到通知后，主动下载OTA推送固件。\n设备重新上电，设备都将主动询问机智云是否有推送任务。若符合推送周期&推送时段&目标设备，等推送条件，设备主动下载OTA推送固件。\nUTC ：协调世界时（英：Coordinated Universal Time ，法：Temps Universel Coordonné），又称世界统一时间，世界标准时间，国际协调时间。推送页面中，机智云自动将UTC时间映射为本地（北京）推送时间。\n\n\n\n步骤三、点击【保存】，生成新的规则及唯一的request id\n\n开始推送\n步骤一、已成功添加规则，点击对应规则的【开始推送】按钮\n\n步骤二、勾选相关协议，再次确认。此时升级请求已推送，对应规则状态会改变。\n\n备注：目标设备栏，当前升级成功设备数/目标推送设备数\n\n\n步骤三、在线设备或离线设备上线后会自动执行OTA升级，升级到最新固件，并將状态上报给云端。\n推送完成\n步骤一、推送完成后，刷新界面，对应规则会变为“已完成”状态\n\n步骤二、查看明细\n点击【查看明细】链接，可查询单个设备升级详情，并可以导出当前所有设备升级情况\n\n"},{"title":"利用openapi（postman）控制虚拟设备","url":"/zh-cn/UserManual/UseOpenAPI.html","content":"概述\n本文档介绍了机智云云端提供api接口（openapi），应用端（PC）利用工具（postman）发送HTTP请求实现用户登陆，设备绑定，设备远程控制等功能。\n\n准备工作\n设备：开发者中心-个人项目-虚拟设备\n软件：postman\n其他：机智云开发者账号\n参考文档：openapi指南\n辅助工具链接：\nUnix时间戳\nMD5加密\n云端创建产品\n1.新建产品\n注册完成后，登陆至机智云开发者中心后台后，点击开发者中心后台右上角的“创建新产品”菜单，在跳转页面新建一个名为“Openapi”的产品，选择“Wi-Fi/移动网络方案”方式接入，并完成产品创建。如下图：\n\n\n2.新建云端数据点（产品功能点）\n2.1 数据点介绍\n数据点：即设备产品的功能的抽象，用于描述产品功能及其参数。创建数据点后，设备与云端通讯的数据格式即可确定，设备、机智云可以相互识别设备与机智云互联互通的数据。更多的解析和新建指引，可以在开发者中心数据点页面右上角“定义数据点教程”中查看找到帮助，以建立属于你自己产品的数据点，如下图：\n\n2.2 新建数据点\n然后以本次的项目“Openapi”为例，简单描述一下云端数据点和产品的功能点的关系，本次的项目“Openapi”，它需要实现的功能是远程开灯和关灯，那我们只需在云端建立一个“布尔值”的可写数据点即可完成这件事，如下图：\n\n添加数据点完成之后，点击下图的“应用”即可，完成整个产品的数据点的新建工作。\n\n2.3 新建应用配置\n以“openapi”的个人项目为例，点击服务-应用配置-添加新应用，如下图\n\n之后填入应用名称，名称自定义，平台这里我们选择Android平台，点击添加，如下图\n\n点击添加后会出现一个新应用，这里注意App id就是之后HTTP请求所用到的重要参数，如下图\n\n3. Postman安装和导入\n1)去官网下载最新的postman客户端：postman官网:https://www.getpostman.com\n2)下载完注册后是注册进入之后是collections是只有postman自带的echo。需要点击左上角import导入，或者按照文档中心的openapi文档。根据请求类型，来填url，header，body的key和value。\n\n3)下面我们选择导入已经收集好的请求，如下图：\n\nImport From Link填入：\nhttps://www.getpostman.com/collections/d6c5981977683526877f\n然后点击import，就会出现如下图所示的文件夹\n\n4. 使用Postman进行HTTP请求\n步骤流程：\n\n4.1 通过匿名登陆POST请求获取User_token\n首先我们使用匿名登陆的POST请求获得Token，Appid在3.2）步骤新建的应用配置可以获取到，在Headers的页面上填入Appid，在Body页面填入phone_id之后点击send发送请求，下面会弹出一个返回框，在body一栏，获取到User_token，则说明请求成功，如下图\n\n\n4.2 打开虚拟设备获取did和passcode\n之后我们回到个人项目-虚拟设备，点击启动虚拟设备，获取该虚拟设备的did和passcode如下图\n\n\n4.3 通过did+passcode的POST请求绑定设备\n我们这里选择用did+passcode的绑定方式的POST请求来绑定设备，在Headers填入之前获取的Appid和User_token，在Body填入从虚拟设备上获取的did和passcode，然后返回success则表示绑定成功，如下图\n\n\n4.4 通过MAC的POST请求绑定设备（注：第3步成功后，这步骤可跳过）\n我们这里选择用MAC的绑定方式的POST请求来绑定设备，在Headers填入之前获取的Appid和User_token，Timestamp为Unix时间戳（有效时间为五分钟），Signature的算法利用MD5加密的方法{MD5(product_secret+X-Gizwits-Timestamp).lower()}，Body填入product_key和设备的mac，点击send，发现设备在线则成功，如下图\n注：Timestamp和Signature获取的链接为：\nUnix时间戳\nMD5加密\n\n\n\n\n4.5 通过获取绑定设备列表GET请求来查看设备是否在在线\n点击获取绑定设备列表的GET请求，在Headers一栏填入Appid和User_token，点击send，然后返回一串JSON格式的信息，“is_online”的值是true表示设备在线，如下图\n\n4.6 通过远程控制设备的POST请求来控制设备\n点击远程控制设备的POST请求，先在Headers填入AppID和User_token，在Url后填入自己的设备ID（did），在body根据自己的数据点的标识名和要发送的数据的值按照JSON格式填入并点击send发送，返回为空则表示成功，如下图\n\n\n4.7 验证设备是否已被控制\n回到个人项目中，发现虚拟设备的值已改变，根据通讯日志，我们将标识名为Led_onoff的布尔型数据点修改成了true，如下图\n\n"},{"title":"APP绑定设备二维码生成教程","url":"/zh-cn/UserManual/UseQRCode.html","content":"概述\n机智云APP SDK中预留了一个扫描二维码绑定接口，APP可以通过扫描GPRS设备（WiFi设备也可）二位码直接绑定设备。本文主要介绍如何通过机智云接口生成设备对应的二维码。\n步骤过程\n1.进入二维码生成网址\n在浏览器打开 http://qrcode.gizwitsapi.com:1800/doc/\n2.输入授权码\n点击右上角 Authorize，在弹出对话框输入\"G\"，并点击 \"Authorize\" 按钮\n\n3.输入PK和MAC地址\n打开 \"创建二维码生成任务\" 接口\n\n输入 product_key，和要生成的 mac 序列\n\n4.生成二维码\n点击 \"Try it out!\"，创建生成任务，如果返回 201，说明二维码生成成功\n\n5.查询生成的二维码\n打开 \"查询所有二维码生成任务\" 接口\n\n输入 product_key，点击\"Try it out!\"，查询生成任务\n\n生成的任务包括文件下载URL的相对路径\n\n6.下载二维码\n在浏览器输入完整 URL（http://qrcode.gizwitsapi.com:1800/+上图中的URL）下载生成的二维码图片，本次下载的URL组合起来是：http://qrcode.gizwitsapi.com:1800/static/zipfiles/1474.zip\n\n下载好的二维码打包在zip文件中，如下图\n\n7.APP调用接口绑定设备\n下载解压后的二维码可以用机智云APP调试工具直接扫码后绑定设备。\n\n在APP开发中需要调用机智云APP SDK中通过二维码绑定设备的接口绑定设备，扫描二维码需要通过第三方框架(比如zxing)来实现，可以参考机智云开源框架代码来实现，SKD中具体绑定设备接口调用如下，以安卓为例：\n    //绑定接口\n    GizWifiSDK.sharedInstance().bindDeviceByQRCode(用户id,用户token,二维码内容);\n    //绑定回调接口\n    GizWifiSDKListener sdkListener=new GizWifiSDKListener() {\n        @Override\n        public void didBindDevice(GizWifiErrorCode result, String did) {\n            super.didBindDevice(result, did);\n        //绑定成功回调\n        }\n    }\n\n"},{"title":"Snoti 数据实时同步服务demo使用教程","url":"/zh-cn/UserManual/UseSNoti.html","content":"1.概述\n为企业提供 SSL 通讯 API，用于实时推送设备与产品相关的事件，以及控制对应的设备。\n（注意：使用snoti服务之前，要先开通snoti服务和添加白名单。）\n\n2.环境搭建\n2.1.下载eclipse和jdk\n下载链接:\nhttp://jingyan.baidu.com/article/bea41d435bc695b4c41be648.html\n2.2.安装jdk\n安装流程:\nhttp://jingyan.baidu.com/article/d7130635194f1513fcf47557.html\n2.3.安装eclipse\n安装流程:\nhttp://jingyan.baidu.com/article/d7130635194f1513fcf47557.html\n3.snoti服务开通流程\n3.1.申请开通snoti\n确定产品使用snoti后，开发者需要联系机智云技术支持，提供产品如下的对应信息，包括\nProductkey和产品名称。\n\n\n\n3.2.新建授权\n\n4.运行demo流程\n4.1.下载snoti的demo源码\nsnoti的demo源码下载链接：\nhttps://github.com/gizwits/noti-java-demo/tree/v2.0.0-netty\n机智云提供了两个款源码:\nV2.0.0-netty是加了框架的，有自己的依赖库。\nV2.0.0是没有加框架的，下面我要讲解是这个没有加框架的demo。下载的地方如下图：\n\n4.2.snoti的代码要修改的地方\n\nAuthId和AuthSecret信息如下：\n\n4.3.snoti控制设备\n（注意：1.如果用的是机智云官网上的虚拟设备测试，mac地址就填virtual:site\n2.如果用的是美东服务器snoti服务器dome上面的域名就改成ussnoti.gizwits.com\n3.snoti下发控制指令整个json数据都是utf-8格式的）\n4.3.1.V4产品的数据点格式下发控制\n\n可写数据点类型包括：布尔值类型、枚举类型、数值类型和扩展类型。写法为\"name1\": value1,(\"name1\"指数据点的标识名(name)，value1指数据点的值。值可以为true/false(bool)，Unicode编码的字符串如\\u62bd(enum)，数字或byte数组(如 [23,2,3]，用于扩展类型))，示例如下：\na.布尔值类型，如，attrs={“Switch”:false}\nb.枚举类型，如，attrs={\"Mode\":\"休眠模式\"}//如果枚举类型数据点直接下发字符串不成功，检查一下的文本下发的格式是不是utf-8的，如果不是请转换后在下发。如attrs={\"Mode\":\"休眠模式\"}由于下发的sjon数据不是utf-8格式，转换为attrs={\"Mode\":\"\n\"}在下发。utf8编码在线工具如下：\n\nc.数值类型，如，attrs={“Motor_Speed”:5}\nd.扩展类型，如，attrs={\"extension\":[1,2,3,4,5,6,7,8,9,0]}\n4.3.2.V4产品自定义协议格式（用于不定义数据点，直接透传）\n（1）snoti下发控制指令\n\n发送原始数据格式raw={1,22,33}\n（注意：二进制转 byte 数组，如要发送 010203，就是\n{\n\"raw\": [1, 2, 3]\n}\n一般情况下，协议交互都是16进制的数组，例如[0x00, 0x00, 0x1a, ...] \n就把这种数组，用10进制表示就成，如要发十进制123值为raw=[123]\n）\n（2）设备上报状态\n当设备收到云端下发的控制指令后，设备主动上报当前状态\nFF FF 00 09 05 00 00 00 04 01 02 03 18 \n因为是透传的，收到的数据是base64加密了，厂家得自己进行base64解密。\n\n\nBase64在线解密链接:http://www1.tc711.com/tool/BASE64.htm\n4.4.运行maven工程\n（1）鼠标右击工程，选择Run As->Maven Install，然后点击运行。\n\n（2）运行cmd.exe端，打开target目录的位置。运行java -jar gizwits-noti-demo-2.0.0-jar-with-dependencies.jar\n\n（3）输入rc进行下发控制指令，查看云端的通讯日志，看下发的指令是否正确\n图1：项目是走V4版本的数据点协议，下发的控制指令\n\n图2：项目是走V4版本的自定义协议（就是透传，不走数据点），下发的控制指令\n\n（4）当设备主动上报当前状态\nFF FF 00 09 05 00 00 00 04 01 02 03 18 \n因为是透传的，收到的数据是base64加密了，厂家得自己进行base64解密。\n\nbase64解密，如下\n\n5.参考资料\nSNoti API：\nhttp://docs.gizwits.com/zh-cn/Cloud/NotificationAPI.html\n"},{"title":"Websocket 网页控制设备","url":"/zh-cn/UserManual/UseWebsocket.html","content":"概述\nJavaScript网页远程控制设备，是调用了机智云开放的Open API和WebSocket API来实现的。其中，Open API用到的接口有匿名登录用户、绑定设备和获取绑定设备列表。而WebSocket API上的用户登陆、设备上线下线通知、浏览器与云端的数据交互（数据透传）、心跳和非法消息通知。\n\n当设备已经是成功连接上云端，就可使用以下流程来控制设备了：\n\n准备工作\n调用OPEN API匿名登录用户和绑定设备\n1.获取phone_id\nphone_id 可以是手机的唯一识别码。或者您已经有了自己的用户系统，不希望用户再次注册一次机智云帐号，您也可以使用该接口，为您的每一个用户创建一个对应的机智云匿名帐号。这时，phone_id 可以是用户在您的系统中的唯一识别码。如在与微信应用做对接时，phone_id 可以设置成微信用户的 openid。\n2.创建用户\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/用户管理/post_app_users\n2.1.填写appid\n\n2.2.填写body\n\n2.3.登录匿名用户，获取token\n\n3.绑定设备\nPOST请求链接：\nhttp://swagger.gizwits.com/doc/index/openapi_apps#/绑定管理/post_app_bind_mac\n3.1.填写appid\n\n3.2.填写刚才匿名登录回调的token\n\n3.3.填写Timestamp、Signature和body\n\n备注：时间戳计算链接，http://tool.chinaz.com/Tools/unixtime.aspx\nMD5计算链接，http://tool.oschina.net/encrypt?type=2，如下图:\n\nWebsocket网页控制界面\n1.websocket API封装起来的sdk\n链接如下：\nhttps://github.com/gizwits/gizwits-wechat-js-sdk\n2.运行index.html\n\n3.Websocket网页控制界面\nhttps://gizwits.github.io/gizwits-wechat-js-sdk/v0.2.0.html\n如下：\n\n控制设备分两种方式\n1.V4版本的标准数据点协议\n1.1.初始化Gizwits WS对象\n上面使用的参数有：\n\n\n\n参数\n说明\n数值\n\n\n\n\napiHost\n机智云OpenApi域名\napi.gizwits.com\n\n\ncommType\n标准数据点协议格式\nattrs_v4\n\n\nwechatOpenId\n微信用户OpenID（就是手机的iPhone_id）\nString\n\n\ngizwitsAppId\n机智云平台应用标识\nString\n\n\n\n初始化，如下：\n\n1.2.获取绑定列表\n如果该用户要获取绑定设备列表，先要确认该用户（就是该openid）是否有对要控制设备的已进行绑定了。\n\n1.3.创建Websocket连接\n选择一个要进行控制的设备did，创建websocket连接\n\n1.4.读取设备当前状态\n选择已连接的设备，读取设备的当前状态\n\n1.5.控制设备\n选择已连接的设备，下发控制指令\n如下发控制指令{\"Swicth\":true}，如下图：\n\n\n如要设置扩展类型的字段 binary 为16进制 616263 ,补齐后每组byte换成一个十进制数组的值\n设置布尔型需要是true和false:{\n  \"boolean\":true,\n  \"binary\": [97,98,99,0,0,0,0,0,0,0]\n}\n\n\n\n控制模拟设备效果：\n\n2.V4版本的自定义格式协议\nV4版本的自定义格式协议（就是无法数据点透传）\n2.1.初始化Gizwits WS对象\n上面用的的参数有：\n\n\n\n参数\n说明\n数值\n\n\n\n\napiHost\n机智云OpenApi域名\napi.gizwits.com\n\n\ncommType\n标准数据点协议格式\nattrs_v4\n\n\nwechatOpenId\n微信用户OpenID（就是手机的iPhone_id）\nString\n\n\ngizwitsAppId\n机智云平台应用标识\nString\n\n\n\n\n2.2.获取绑定列表\n\n2.3创建websocket连接\n选择一个要进行控制的设备did，创建websocket连接：\n\n2.4.读取设备的当前状态\n选择已连接的设备，读取设备的当前状态：\n\n2.5.下发控制指令\n选择已连接的设备，下发的控制指令：[0,0,0,3,9,0,0,144,1,0,1,2,3,4] （注意：下发数据的格式为十进制的，每个位端的表示为0,0,0,3为header、9为len、0为flag、0,144为cmd、1为action、0,1,2,3,4为业务指令），如下：\n\n模拟mcu收到命令，如下：\nFF FF 00 0B 03 1E 00 00 01 00 01 02 03 04 37\n\n"},{"title":"机智云全球部署方案说明","url":"/zh-cn/UserManual/WorldWideConnectSolution.html","content":"全球化方案介绍\n为满足机智云客户销售到海外的的硬件和硬件产品的消费者能更好的体验机智云平台带来的便利性，机智云在国外设有独立部署平台，以期从网络距离上缩短销售到海外的设备连接到国内长距离的网络延时问题，提供更好的交互体验。\n目前机智云海外部署节点分布在美国东部、欧洲中部（法兰克福），都使用AWS 云计算服务。如下图所示：\n\n美东节点覆盖范围：北美、南美地区；\n欧洲节点覆盖范围：欧洲地区 \n关于各节点的服务器的响应速度报告可以参阅《机智云全球联网报告》(本文主要介绍开发者接入机智云全球化方案流程。)\n前期准备工作\n确认模组使用固件版本\n目前支持全球一体化方案模组固件如下\n\nWIFI模组上烧录的固件为上图中发布时间之后的固件版本均可使用全球一体化方案，不过建议使用最新版本的固件来开发全球一体化的设备。\n如果开发者无法确认模组的固件是否支持全球一体化方案，可咨询机智云FAE确认。\n确认APP使用的SDK版本\nAPP支持全球一体化建议使用以下及其之后发布的SDK版本。\n\n一体化方案产品数据同步部署\n确定产品使用全球一体化方案后，开发者需要联系机智云技术支持，提供产品如下的对应信息。\n\n\n\n内容\n示例\n\n\n\n\n产品名称\n请填写产品名称\n\n\nProduct Key\nd187f9……\n\n\n安卓APPID\n943d59……\n\n\niOS APPID\n000593……\n\n\n开发者中心登录帐号\nMyemail@xxx.com\n\n\n\n取《产品名称》和《Product key》如下图：\n\n取《安卓与iOS APPID》如下图：\n\n设备端开发\n设备要支持全球一体化，除了需要使用支持的固件外，还需要在《3.1获取设备信息》协议中，回复一个Product Secret，具体协议如下图所示：\n\n\n上图所需产品密钥获取如下：\n\nAPP开发\n全球一体化方案的APP开发分两种方案：\n方案一：只开发一套APP适应全球设备\n方案二：根据机智云的服务器划分，分别开发相对应的APP，也就是总共三套APP。\n下面先介绍一下全球一体化使用到的启动接口。\nAndriod端\n启动方法：\npublic void startWithAppID(Context context, String appID, String appSecret, List<String>\nspecialProductKeys, ConcurrentHashMap<String, String> cloudServiceInfo, boolean\nautoSetDeviceDomain)\n\n参数解析：\n\n\n\ncontext\n上下文对象\n\n\n\n\nappID\n接入产品绑定的appID，在开发者中心上获取\n\n\nappSecret\nAPPID对应的appSecret，在开发者中心上获取\n\n\nspecialProductKeys\n要过滤的设备产品类型productKey 列表，为String 数组。开启全球一体化的功能，该参数必填，不可填NULL。\n\n\ncloudServiceInfo\n要切换的服务器域名信息。此参数默认值为null，此时SDK 将根据用户手机的地理位置信息为App 设置机智云统一部署的云服务域名。若App 希望使用独立部署的私有云服务域名，需按照以下字典{key: value}格式传值：{\"openAPIInfo\": \"xxx\", // String类型，api服务域名\"siteInfo\": \"xxx\" // String类型，site服务域名\"pushInfo\": \"xxx\" // String类型，推送服务域名}其中，openAPIInfo 和siteInfo 必须传值，pushInfo 可选。可以不指定端口号，SDK 会使用默认的服务端口。此时形如：api.gizwits.com指定端口号时，需同时指定Http 和Https 端口。此时形如：xxx.gizwits.com:81&8443\n\n\nautoSetDeviceDomain\n是否要开启设备域名的自动设置功能。此参数默认值为false，即不开启自动设置。参数值传true，则开启设备域名的自动设置功能。如果开启了设备域名的自动设置，小循环设备将被连接到App 当前使用的云服务域名上\n\n\n\n注意：cloudServiceInfo和autoSetDeviceDomain是没有任何关联的，当autoSetDeviceDomain设置为true的时候，启动SDK以后，APP需要能连上外网，让SDK去云端获取当前APP的APPID与ProudctKey列表的关联关系，只有与APPID关联的ProductKey，APP才有权限去修改其设备的域名。所以，当APP需要实现全球一体化的功能时，ProudctKey参数必填，SDK才可拿到参数值，去云端核对APPID和ProductKey的关联关系。\nAPP去修改设备域名的时机是：当设备与APP连到同一个局域网内时，APP发现局域网的设备与APP连的服务器不同，就会通过TCP给设备发送域名信息，切换设备连接的服务器。\niOS端\n启动接口：\n+(void)startWithAppID:(NSString*)appID appSecret:(NSString*)appSecret specialProductKeys:(NSArray*)specialProductKeys cloudServiceInfo:(NSDictionary *)cloudSeviceInfo autoSetDeviceDomain:(BOOL)autoSetDeviceDomain;\n\n\n\n\nappID\n接入产品绑定的appID，在开发者中心上获取\n\n\n\n\nappSecret\nAPPID对应的appSecret，在开发者中心上获取\n\n\nspecialProductKeys\n要过滤的设备产品类型productKey 列表，为NSString 数组。开启全球一体化的功能，该参数必填，不可填nil\n\n\ncloudServiceInfo\n要切换的服务器域名信息。此参数默认值为null，此时SDK 将根据用户手机的地理位置信息为App 设置机智云统一部署的云服务域名。若App 希望使用独立部署的私有云服务域名，需按照以下字典{key: value}格式传值：@{@\"openAPIInfo\": @\"xxx\", // String类型，api服务域名@\"siteInfo\": @\"xxx\" // String类型，site服务域名@\"pushInfo\": @\"xxx\" // String类型，推送服务域名}其中，openAPIInfo 和siteInfo 必须传值，pushInfo 可选。可以不指定端口号，SDK 会使用默认的服务端口。此时形如：api.gizwits.com指定端口号时，需同时指定Http 和Https 端口。此时形如：xxx.gizwits.com:81&8443\n\n\nautoSetDeviceDomain\n是否要开启设备域名的自动设置功能。此参数默认值为false，即不开启自动设置。参数值传true，则开启设备域名的自动设置功能。如果开启了设备域名的自动设置，小循环设备将被连接到App 当前使用的云服务域名上\n\n\n\niOS的cloudServiceInfo和autoSetDeviceDomain功能同安卓相同。\n一套APP适配全球设备\n该方案是让SDK自动根据时区切换连接的服务器域名，此时的启动接口调用方式如下：\n安卓端：\nGizWifiSDK.sharedInstance().startWithAppID(this, AppID, AppSecret, ProductKeyList(), null, true);\n\niOS端：\n[GizWifiSDK startWithAppID:APPID appSecret:APPSECRET specialProductKeys: ProductKeyList cloudServiceInfo:nil autoSetDeviceDomain:YES];\n\n该方案的优点：只需要一套APP就可适应所有地区的设备\n缺点：SDK自动根据时区去切换对应服务器，用户会较为被动，当APP与设备不是处于同一网络下，APP切换到另一个服务器，可能会导致找不到原来的账号和设备。\n三套APP适配全球设备\n该方案是根据机智云的服务器划分对应的APP。\n机智云主要划分出三大服务器：中国服务器，美东服务器、欧洲服务器\nAPP也按这三大服务器划分为三套：中国APP，美东APP，欧洲APP\n这三大APP基本内容相同，只在启动接口这里有差别，下面以iOS为例:\n中国APP的启动接口：\n[GizWifiSDK startWithAppID:APP_ID appSecret:APP_SECRET specialProductKeys:[GosCommon sharedInstance].productKey cloudServiceInfo:@{@\"openAPIInfo\" : @\"api.gizwits.com\" , @\"siteInfo\": @\"site.gizwits.com\", @\"pushInfo\": @\"push.gizwitsapi.com\"} autoSetDeviceDomain:YES];\n\n美东APP的启动接口：\n[GizWifiSDK startWithAppID:APP_ID appSecret:APP_SECRET specialProductKeys:[GosCommon sharedInstance].productKey cloudServiceInfo:@{@\"openAPIInfo\" : @\"usapi.gizwits.com\" , @\"siteInfo\": @\"ussite.gizwits.com\", @\"pushInfo\": @\"us.push.gizwitsapi.com\"} autoSetDeviceDomain:YES];\n\n欧洲APP的启动接口：\n[GizWifiSDK startWithAppID:APP_ID appSecret:APP_SECRET specialProductKeys:[GosCommon sharedInstance].productKey cloudServiceInfo:@{@\"openAPIInfo\" : @\"euapi.gizwits.com\" , @\"siteInfo\": @\"eusite.gizwits.com\", @\"pushInfo\": @\" eupush.gizwits.com\n\"} autoSetDeviceDomain:YES];\n\n使用该方式的优点: 用户根据所在位置下载相对应的APP，之后设备就是固定连接相对应的服务器了，运行相对稳定，APP和设备都不会出现在各个服务器之间切换的问题。\n缺点：较繁琐，需要开发和上架三套APP。\n问题说明\n1、    APP有消息推送功能，使用全球一体化方案的时候该怎么处理？\n解答：待机智云在国内外服务器上同步好产品的数据信息后，开发者需要使用同一帐号密码登录国外服务器，找到对应的产品，申请开通D3服务，并创建与国内一致的规则。\n国外服务器的访问地址：\n欧洲：http://eusite.gizwits.com/zh-cn/developer/\n美东：http://ussite.gizwits.com/zh-cn/developer/\n2、    如果发现APP有权修改非关联ProductKey的设备连接的域名，要怎么做？\n解答：更换2017年8月14号后发布的SDK，也就是从2.07.07.2开始的SDK版本才做了设备域名切换的限制。\n具体限制：在SDK启动之后，SDK会去云端确认APPID和ProductKey数组的关联关系，只有跟APPID关联的ProductKey下的设备，SDK才有权去修改设备的域名。\n3、    如果APP开启了域名修改功能，但是发现局域网的设备都无法根据APP去自动切换到相应的服务器，该怎么做？\n解答：\n   a. 确认启动接口的ProductKey参数是否有传，不可传空。\n   b. 确认APP是否能连上外网，因为从2.07.07.2版本开始的SDK需要去云端确认APPID和Productkey的关联关系之后，才会去修改设备域名。\n   c. 上机智云官网确认，APPID是否和ProductKey关联了。\n4、    当在测试全球化设备时，若出现设备列表的设备出现闪烁状态，一会出现，一会消失的状态，会是什么原因导致的？\n解答：查看同一个局域网下，是否开启了多个有权设置设备域名的APP，并且各自连的不同的服务器。\n在测试全球化的设备时，同一局域网下的APP，必须连的相同服务器。否则，会出现多个APP在来回切换设备的服务器。\n5、已经在全球化APP中创建了账号，之前登陆绑定设备一切正常，后来登陆报没有该账户、账户密码错误，这可能是什么问题导致的？\n解答：确认一下之前创建账号时，APP连到的是机智云的哪个服务器，登陆报错时，APP连到的又是哪个服务器。很可能是连接的是不同服务器导致的报错，只需要切换到原来的服务器下即可正常登陆。\n"},{"title":"个人项目产品转企业项目产品","url":"/zh-cn/UserManual/change.html","content":"个人项目无法开通企业api，D3规则引擎等功能，所以建议企业合作伙伴在创建产品时候，选择注册账号为企业账号，并且在企业项目中创建产品。\n由于许多合作伙伴并不知悉上述情况，经常在机智云官网开发者中心注册个人开发者账号，或注册企业开发者账号后在企业开发者账号下的个人项目创建产品。这样便需要企业合作伙伴将个人账号项目、或企业账号下的个人项目，转移到企业账号下的企业项目。\n\n\n个人账号项目转企业账号项目流程\n1.注册企业账号\n个人帐号不能直接转成企业帐号，只能将个人帐号下的产品转移到企业帐号下，因此，如果您只有个人帐号，那还需要重新申请一个企业帐号，才能完成产品的转移的，请登录机智云官网，点击注册开发者账号。根据注册流程，选择企业开发者类别。\n\n2.对个人账号添加管理者权限\n使用企业账号登录机智云官网开发者中心，对个人账号添加管理者权限。如下图。\n\n\n\n3.进入需要转移的产品\n使用个人账号登录机智云官网开发者中心，进入需要转移的产品。如下图。\n\n4.选择转移到的企业\n选择转移到的企业，然后输入账号的登录密码进行确认操作。\n\n同一企业账号下，个人项目产品转企业项目产品\n1.进入需要转移的产品\n使用企业账号登录机智云官网开发者中心，进入需要转移的产品。如下图。\n\n2.选择转移到的企业\n选择转移到的企业，然后输入账号的登录密码进行确认操作。\n\n"},{"title":"APP代码自动生成服务介绍","url":"/zh-cn/UserManual/devApp.html","content":"概述\n为了降低开发智能硬件APP开发门槛，降低开发资源的投入，机智云在《APP开源框架》基础上进一步推出了实现项目完整控制功能的APP开源代码。当开发者在产品项目上创建对应的数据点后，云端会根据产品定义的数据点生成对应产品的APP参考代码。\n自动生成的APP代码模块化集成了一个智能硬件APP必备功能，主要包括：\n\n1.用户部分：用户注册，找回密码、第三方登录（微信登录、QQ登录）\n2.配置设备入网（Arilink+SoftAP）\n3.设备发现，列表展示\n4.设备控制\n5.消息推送：设备报警后给APP推送报警信息，主要合作推送平台是极光推送和百度推送。\n\n开发者下载源码后，只需要优化UI和设计设备控制界面控制逻辑，源码的控制页面编写了机智云SDK控制设备的标准流程，APP源码二次开发过程中只需按照该流程进行相关代码的优化即可快速完成针对自身产品的智能控制APP。\n目前APP生成的源码支持 Andriod、iOS、APICloud平台。\n工具使用指南\n1.创建应用\n1.1.开发者在机智云开发者中心创建产品和产品数据点后点击应用配置。\n\n注意数据点的命名不能为程序的常用关键字，比如switch、static、enum、native等等，否则生成的代码会有错误！\n1.2.在应用配置界面中添加新应用\n\n1.3.分别创建一个安卓和iOS应用。\n\n\n\n2.生成代码\n2.1.查看产品的Product Secret，并复制到剪切板。\n\n2.2.点击应用开发，选择刚才创建的安卓应用，粘贴刚才复制的Product Secret，点击生成代码包\n\n2.3.等待一段时间后，即可下载源码。\n\n2.4.下载的源码是一个压缩包，解压后即可看到相关源码。\n\n2.5.关于源码的使用说明，请参考文档解压后的附带文件《源码说明》！\n\n3.    重要提示\n查阅《APP代码自动生成服务介绍》，可了解自动生成的APP代码模块具备哪些功能\n查阅《APP开源框架》，可了解\n\niOS开源框架使用指南\n\niOS App消息推送集成指南\n\niOS App集成第三方登录与换肤指南\n\niOS App快速开发实例\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送集成指南\nAndroid App集成第三方登录与换肤指南\nAPICloud开源框架使用指南\n\n查阅《APP开发SDK》，可随心开发IoT APP（很多细节设计，均可在里面找到应用案例）\n\niOS SDK 2.0集成指南\nAndroid SDK 2.0集成指南\nAPICloud SDK使用指南\nSDK数据透传方法解析\nSDK调试日志抓取教程\nSDK错误码表\n\n更多应用开发\n\n应用开发FAQ\n设备分享功能使用流程\n第三方登录平台申请流程\n\n"},{"title":"设备分组API使用教程","url":"/zh-cn/UserManual/devgroup_API.html","content":"概述\n设备分组接口可以对多个设备进行分组，只要往分组里面发送指令，做到同时控制一个分组下的多个设备。\n要使用该设备分组接口，必须创建分组。创建分组以后根据MAC地址绑定设备，再根据设备日志MAC地址对应的did将设备加进一个分组里面，再往分组里面发送指令，设备收到指令并作出反应，就完成了设备分组。\n使用例子，如：一个公司有多个部门，每个部门有多盏智能灯。每天早上一个部门来人了，就可以只打开该部门的智能灯。每天晚上一个部门的人都走光了，就可以只关闭该部门的智能灯。\n设备分组API使用流程\nOpen API的设备分组接口，就是对多个设备分组并进行控制。当开发者/企业客户设置好openAPI设备分组接口后，就可以调用该接口把多个设备加入到分组，做到分组控制多个设备。\n1.打开机智云官网文档中心->云API->OPEN API指南，下拉点击调试接口\n\n\n2.点击设备分组->创建分组\n\n3.点击创建分组->感叹号，填写App ID和token，这两个参数可以参考文档《利用openapi（postman）控制虚拟设备》中“2.3新建应用配置”和“3. Postman安装和导入”，参考文档链接http://docs.gizwits.com/zh-cn/UserManual/UseOpenAPI.html\n\n\n4.填写App ID和token之后，填写body\n\n\n5.得到分组id后，我们可以查看一下组里面有没有设备\n\n\n6.根据MAC绑定设备\n\n\nTimestamp获取链接http://tool.chinaz.com/Tools/unixtime.aspx\n\nSignature获取链接http://tool.chinaz.com/Tools/md5.aspx\n\n绑定设备成功以后会返回一个如下的响应体\n\n7.绑定设备以后，我们回到设备分组，将设备添加到分组\n\n\n8.查看设备日志\n\n9.成功添加设备到分组以后会返回如下响应体\n\n10.然后我们就可以针对设备分组发送指令远程控制设备\n\n11.这样我们就可以控制一个分组中的一个设备（RGB灯亮灭），按照同种方法添加多个设备到一个分组中，我们就可以同时控制一个分组中的多个设备。\n\n"},{"title":"如何使用机智云ECE雾计算","url":"/zh-cn/UserManual/ece.html","content":"ECE概述\n1. ECE雾计算是什么\n雾计算可以理解为设备端的计算，能协助云计算解决部分其无法解决的数据计算需求，比如要求一秒钟采集50次传感器的设备，不可能实时把数据传到云端再进行处理，更适合在设备进行必要的数据计算，向云端传输处理结果，或者模组直接将数据的分析结果转换成对设备的动作等，提高实时性。\n机智云ECE雾计算主要对接智能设备用的通信模组和手机，采取编译性语言（C语言）和解析性语言（Lua）相结合的方式，使用解析性脚本，将适配策略在云端进行配置，配置后通过推送的方式发送到模组或手机，设备收到新的配置策略后，立即执行；配置策略分别负责适配传输层协议适配、业务层协议适配、数据的计算方法等。\n2. 技术价值\n机智云ECE雾计算能降低开发成本，缩短开发周期。\n\n云端配置脚本，动态改变模组行为；\n增加不同设备的数据通信自适配的能力；\n增加不同设备的协议自动转换能力；\n增加设备端的数据计算算法实施与更换以及立即执行的能力。\n\n\n3必读术语\n3.1 ECE\nECE是Edge Computing Engine的缩写，意为边缘计算引擎。\n3.2 PK\nPK是Pruduct Key的缩写，是企业在机智云平台开发者中心创建的某款产品的唯一编号，同一款产品的Product Key都是相同的。\n3.3 协议脚本\n协议脚本可将产品自定义协议与机智云协议进行相互转换，帮助用户产品轻松接入机智云。\n3.4 通信配置\n通信配置可设置串口通信的通信参数（波特率等）。\n3.5 微应用\n微应用可设置数据通信方法（数据包格式、加密方式等），对数据的处理（取最大值、最小值等），以及设备行为参数（采样频率、心跳时间等）。\n3.6 LUA脚本\nLUA是嵌入式脚本语言，实现可配置性和可扩展性。\n使用场景与业务流程\n1.服务对象\n机智云ECE雾计算服务于企业开发者用户，暂不对个人开发者用户开放。\n2.通信配置协议转换\n设置通信接口的设置参数，比如通信串口号、波特率、数据包格式、校验方式等，通过这些设置，可以让模组与设备正常的收发数据。\n2.1场景描述\n场景1：波特率转换\n我们通过LUA脚本，将原来的设备通讯串口号从com3转换成com4，将波特率从9600转换成38400。\n我们使用ECE雾计算服务，在【通信配置】里，将修改好的脚本进行录入（如下图，设备通讯串口号从com3转换成com4，波特率从9600转换成38400），然后点击【推送】，设置好推送地址。\n\n此时，我们可以看到程序启动时（如下图），打开的串口号是COM3，波特率是9600。运行期间会收到云端的推送消息。收到消息后，模组会重启串口，并按照设定的参数，打开COM4，波特率使用38400。\n\n这样，我们的通用模组，只在云端进行简单配置，就可以和各种设备进行数据通讯，双方都不需要再做二次开发。\n2.2使用流程\n\n流程说明：\n1.通信配置LUA脚本给用户提供范例脚本头部，用户可对脚本进行新增、修改、清空操作，目前脚本只保留最新一版；\n2.通信配置可以动态更改通信参数；\n3.上传：脚本编写好，暂不进行推送，可将脚本上传云端保存；若用户不对脚本推送或上传，辑的脚本将不被保存；\n4.通信配置只能对模组进行推送，可指定MAC地址或同PK所有MAC地址推送。点击推送后脚本将上传到云端保存；\n\n3.微应用升级\n微应用升级指的是对设备获取的数据或者设备自身行为的设置。可以设置对数据的后期处理，比如对温度值的最大值、最小值、平均值的处理，也可以设置设备的行为处理，比如设置设备对温度的采集频率等。\n3.1场景描述\n场景1：业务层协议转换\n把设备采集的原始二进制数据转换成json字符串，然后再上报云端。\n我们使用ECE雾计算服务，在【微应用】里，录入协议转换脚本(如下图)，然后点击【推送】，设置好推送地址。\n\n可以看到程序一开始输出的是原始二进制数据（如下图），收到云端下发的排序指令后，模组输出的就是格式化的json串。\n\n这样，设备的私有协议都可以不用更改，我们在云端配置解析方法后，就可以做自动的适配和解析。\n场景2：新增一个设备行为\n当温度超过70度后，点亮红灯报警。\n我们使用ECE雾计算服务，在【微应用】里，录入关联动作脚本(如下图)，然后点击【推送】，设置好推送地址。\n\n从日志中（如下图），可以看到模组已经收到脚本。\n\n此时，我们使用热风枪加热传感器（如下图），可以看到超过70度后，设备亮起了红灯。\n\n这样，设备更多的功能，可以在后期方便的增加或者更改，而不用升级整个固件。\n场景3：高级数据运算\n 让设备进行比较高效复杂的数据运算，并把运算结果转换为json后上传云端。假设设备默认5秒一次温度采样频率，为了得到更多的采样点，我们设定设备新的采样频率为100毫秒采集一次温度值，5秒后，用采集的数据计算出平均值、最大值、最小值和方差，然后上报云端。\n同样是5秒上报一次，但是后者更具数据价值。\n我们使用ECE雾计算服务，在【微应用】里，录入设备行为设定以及数据分析(如下图)，然后点击【推送】，设置好推送地址。\n\n可以看到设备一开始5秒一次采集温度（如下图），并上传，收到云端的配置脚本后，设备改为100毫秒采集一次温度，然后计算出结果，上报云端。\n\n这样，就可以做到云和雾的计算平衡，雾端可以做更多的实时数据处理，实现最大的数据价值。\n3.2微应用模组推送流程\n\n流程说明：\n1.微应用LUA脚本给用户提供范例脚本头部，用户可对脚本进行新增、修改、清空操作，目前脚本只保留最新一版；\n2.微应用可用于业务层协议的自动适配和解析、添加或修改设备行为、让设备进行比较高效复杂的数据运算；\n3.上传：脚本编写好，暂不进行推送，可将脚本上传云端保存；若用户不对脚本推送或上传，编辑的脚本将不被保存；\n4.微应用可对模组或者手机进行推送：\n\n若对模组推送可指定MAC地址或同PK所有MAC地址推送；\n点击推送后脚本将上传到云端保存；\n\n\n3.3微应用手机推送流程\n\n流程说明：\n1.同【2.3.2微应用模组推送流程说明】1、2、3；\n2.微应用可对模组或者手机进行推送：\n\n有设备上，也可以只应用到这个Product_Key下被当前手机用户绑定过的设备上；\n选择对手机推送，用户则不需选择推送范围，也不需要填写MAC地址；\n点击推送后脚本将上传到云端保存；\n\n\n业务规范\n1脚本名称\n该名称为用户自定义输入，为必填项，否则无法实现推送。用户可删除或修改文案，目前版本只支持保存最新操作。支持字符输入字母A-Z、a-z、下划线、数字0-9，首字母不能为数字，字符最大输入量为64字节。此功能有两个用处：\n\n用户对本次脚本录入作备注，再次进入ECE服务时，能通过自定义文案知道当前操作内容；\n脚本推送时，作为推送的文件名；\n\n2 MAC地址\nMAC地址输入至少一个，输入限制50个内；输入多个MAC采用“回车”换行形式，地址多于输入框显示范围，输入框出现拉条，用户可点击并上下拖动到查看每一行。推送后将保存用户的填写信息。\nMAC地址输入功能包括复制、粘贴、删除。\nMAC支持输入任何符号、数字0-9、大写A-Z、小写a-z，限制12个字符或以内，地址输入操作如图：\n\nLUA脚本规格说明\n选择协议脚本后，会自动生成LUA脚本规范头部，用户不可对头部内容进行修改，用户在”--to do”下方完成内容编辑。\n1 通信配置脚本头部\n头部规范如下：\n----------luaComInit----------\n--to do\n\n----------luaComInit end----------\n功能：设置串口通信的通信参数（波特率等）。\n2微应用脚本头部\n分为不同的微应用模块，每个微应用模块有不同的头部规范，应该在”--to do”下方位置添加相应的模块实现。目前支持以下的微应用模块：\n2.1 Lua环境设置\n头部规范如下\n----------luaInit----------\n--to do\n\n----------luaInit end----------\n功能：初始化设置lua环境，比如应用内存大小。\n2.2公共基础函数\n头部规范如下：\n----------luaUtils----------\n--to do\n\n----------luaUtils end----------\n功能：开发者自己实现的公共基础函数，可以被其它微应用模块所调用。\n如果仅是一个微应用模块单独会使用的函数，不要放在该模块，放到相应微应用模块中。否则可能会导致其它微应用模块运行时占用内存过大而失败。\n2.3 APP下发数据处理\n头部规范如下：\n  ----------luaHandleDataFromApp----------\n    --to do\n\n    ----------luaHandleDataFromApp end------\n功能：处理APP端下发的业务数据。\n2.4 设备端数据处理\n头部规范如下：\n----------luaHandleDataFromDev----------\n--to do\n\n----------luaHandleDataFromDev end------\n功能：处理设备端发送的业务数据。\nECE雾计算视频教学\n1 企业账号注册\nhttps://v.qq.com/x/page/n0362u2fgws.html\n2 固件烧录\nhttp://v.qq.com/x/page/r03612h7pr0.html\n3 pk烧录\nhttp://v.qq.com/x/page/p0361baxn9z.html\n4 MCU协议介绍\nhttp://v.qq.com/x/page/a03619wrrqr.html\n5 lua脚本讲解\nhttp://v.qq.com/x/page/d03617dbq8p.html\n6 gokit跑lua演示\nhttp://v.qq.com/x/page/y0361kmy887.html\n常见问题\n1 ECE服务支持哪些通信方式的产品？\n目前支持Wi-Fi类、蓝牙类、GPRS类产品。\n2 能看到历史推送记录吗？\n目前不支持查看历史推送记录，每次脚本上传或脚本推送都只保存当前最新脚本，日后会开放此功能。\n3 LUA脚本头部规范内容可自定义吗？\n目前并不支持更改，脚本头部规范内容具有脚本类型识别作用。\n4 MAC地址输入错误了怎么办？\n用户点击推送后，云端会对MAC地址进行校验，假若MAC地址输入错误，会有弹框提醒用户。用户只需返回推送设置界面，系统会用户红色字体标出错误MAC，用户可删除或重新填写。\n5 模组或手机接收成功会收到反馈吗？\n目前版本暂不支持模组或手机是否成功接收，只给用户反馈是否推送成功。\n6 支持脚本文件上传吗？\n此版本暂不支持脚本文件上传，日后会开放此功能。\n"},{"title":"机智云ECE demo开发教程","url":"/zh-cn/UserManual/ecevideos.html","content":"本教程配合下载中心的ECE固件开发包使用，结合一个demo教程，教你如何进行ece开发。\n本教程分为4大部分,每部分介绍后都附有视频教程，你可以观看视频。\nECE 入门准备\n\n机智云账号注册\n硬件准备\nMCU协议介绍\n脚本编写以及推送\n\n1.机智云账号注册\n目前ECE的功能只有注册了机智云的企业账号，在企业账号下的企业产品项目下创建的产品才能体验。注册教程\n步骤一：点击注册链接https://accounts.gizwits.com/zh-cn/register/\n\n步骤二：填写注册信息\n\n点击《立即注册》，机智云会向您的注册邮箱发送一份激活邮件：\n\n步骤三：登陆您的邮箱，选中机智云账号激活邮件\n\n点击《登陆》，跳转到开发者类型选择界面，企业开发者必须选择《企业开发者》类型，方便后续产品的开发和支持,这里我们选择企业开发者。然后完善信息：\n\n接着完善企业信息\n\n注意：需要在企业用户里面创建企业产品才能体验ECE 个人产品目前不支持\n\n\n添加ECE服务：\n\n\n\n\n等待机智云开通ECE服务\nECE开通后如下图：\n\n观看链接：\n企业账号注册\n2.硬件准备\n机智云ECE功能现在基于GAgent ESP8266 4M Flash 硬件平台；\n第一步我们得找到一个ESP8266的WiFi模组；\n第二步拿到机智云提供的支持ECE的固件。\n当以上两步准备好，然后进入固件烧录\n烧录流程如下：\n2.1设备连接\n将ESP8266模块按照如下原理图进行接线，注意GPIO0（18号管脚）需要输入低电平，本实验直接接地处理，KEY1实现外部复位功能\n\n上图为烧录固件简易原理图，在产品中实际搭建线路时，请参考官方提供线路图，如下所示：\n\n2.2串口设置\n将上述串口连接电脑后，通过“我的电脑”->“管理”-> “设备管理器”->“端口（COM 和LPT）”选项中可以看到相应增加的COM口。\n\n2.3下载烧写软件\n下载地址：http://pan.baidu.com/s/1mhMGSeG\n下载解压后得到下面文件\n\n再次解压图中所示的文件后，双击打开烧写软件，出现如下对话框\n\n2.4使用串口方式一烧写固件\n拿到支持ECE的ESP8266机智云WiFi固件\n请务必依次对照下图所选的地方进行相应的填写：\n\n固件烧写操作：\n步骤一：当串口连接成功之后，点击如上图的“START”按钮，\n\n会出现：\n\n步骤二：将ESP8266进行复位（按下1节原理图所示的KEY1后松开）将会出现如下信息表示模块正在进行烧写。\n\n步骤三：等待一段时间后，出现“FINISH”字样表示烧写成功。\n\n产品初始化信息烧录：\n\n到产品页面找到对应产品的product key,如下图：\n\n\n\n把product key保存到init.lua脚本里面，格式如下：\n\n\n\n把该文件烧录到0xb0000地址，烧录步骤跟第五部分固件烧写操作一样\n\n\n观看链接：\n固件烧录\npk烧录\n3.MCU协议介绍\nMCU与WiFi通讯以字符串形式通讯，具体命令规范如下：\n\nMCU 通知 WiFi进入airlink配网 cmd=2:\n命令: \n\nmcu2wifi&cmd=2&mode=0/1\n//解释:\n//mode:0 softap配置模式; mode:1 airlink配网模式\n\nWiFi回复配网:\n命令:\n\nmcu2wifi&cmd=2&result=0/1\n\nMCU上传设备数据给WiFi cmd=3:\n命令:\n\nmcu2wifi&cmd=3&Infrared=1&LedSwitchOnOff=1&MotorSwitchOnOff=1&Temperature=05\n\nWiFi发送控制指令给mcu cmd=4：\n命令:\n\nwifi2mcu&cmd=4&LedSwitchOnOff=1或者MotorSwitchOnOff=1\n实现该协议的固件见机智云下载中心 ECE雾计算esp8266固件包 里面的\ngokit_mcu_stm32_ece.hex\n固件烧录教程:\nhttp://club.gizwits.com/forum.php?mod=viewthread&tid=3311&highlight=gokit%2B%E7%83%A7%E5%BD%95\n观看链接：\nMCU协议介绍\n4.脚本编译及推送\n4.1 脚本格式及编写规则*\n请参照demo.lua这个脚本为模板编写自己的lua应用程序，该demo脚本需配套gokit套件及上面提到的模组及MCU固件使用，实现了下列功能：  \n1.当检测到上报温度大于27度时，通知MCU打开电机; \n2.当红外对管检测到障碍物时，打开红灯;  \n下面我们通过注释区定义了几大块： \n应用程序初始化部分，程序请写到luaInit内容区，这部分的代码在整个脚本生命周期只会运行一次，比如分配应用的内存大小，请把lua应用程序需要初始化一次的部分放在这个区域内。\n----------luaInit----------\n---------内容------------\n\n----------luaInit end----\n应用程序公有函数部分，程序请写到luaUtils内容区。\n----------luaUtils---------\n---------内容------------\n\n----------luaUtils end---\n从app过来的数据处理，程序请写到luaHandleDataFromApp内容区。\n----------luaHandleDataFromApp----------\n---------------------内容--------------\n\n----------luaHandleDataFromApp end----\n从MCU设备过来的数据处理，程序请写到luaHandleDataFromDev内容区。\n----------luaHandleDataFromDev----------\n---------------------内容---------------\n\n----------luaHandleDataFromDev end----\n注意：由于esp8266资源紧缺，编写的lua应用程序脚本大小不能大于10Kbytes，一次性定义的变量（table\\string）不宜超过300个，总变量不宜超过500个。\n4.2 lua SDK版本及相关的API\nsdk版本：\nsdk5.1.4\nLua SDK标准库：其中string和table为sdk5.1.4标准库\ncore,math，C API，auxiliary library\n不全支持，有裁剪(详细的api请查看文档):\ngagent_esp8266_api\ntmr定时器接口用的是esp8266平台的定时器。\nGAgent封装给lua使用的API:　请查看文档:\ngagent_esp8266_api\n4.3 验证lua应用程序的语法\n编写好的lua应用程序，可以先用本地的IDE先进行语法编译验证，确保语法编译没有问题，对于调用到的GAgent API，可以先打桩。Window平台推荐LUA本地编译的IDE工具：\nSciTE或 LuaForWindows:\n\nUbuntu安装lua环境：\nsudo apt-get install lua、sudo apt-get install lua5.1-0-dev\n\n4.4 脚本推送\n把lua脚本拷贝到lua脚本录入处做推送：\n\n可以通过指向mac地址对某台或某几台设备进行脚本推送：\n\n推送结果反馈：\n推送成功：\n\nMac地址出错或设备未上线提示的推送失败：\n\nECE雾计算入门教程\n1 企业账号注册\nhttps://v.qq.com/x/page/n0362u2fgws.html\n2 固件烧录\nhttp://v.qq.com/x/page/r03612h7pr0.html\n3 pk烧录\nhttp://v.qq.com/x/page/p0361baxn9z.html\n4 MCU协议介绍\nhttp://v.qq.com/x/page/a03619wrrqr.html\n5 lua脚本讲解\nhttp://v.qq.com/x/page/d03617dbq8p.html\n6 gokit跑lua演示\nhttp://v.qq.com/x/page/y0361kmy887.html\n"},{"title":"接入亚马逊Echo音箱教程","url":"/zh-cn/UserManual/echo.html","content":"1、概述\n本文介绍了亚马逊Echo音箱如何接入机智云并且控制机智云下的GOKIT设备\n1.1 接入流程\n关系图：\n\n机智云云端：即机智云云端数据库，云端对外提供OpenApi，即访问数据的接口，企业和个人开发者想要得到设备接入、用户账号管理、用户与设备绑定管理、设备远程监控、定时任务以及设备高级数据等服务，可以调用Open Api来实现这些功能。（详情使用方法点击此处跳转）\nAlexa：Alexa是Amazon Echo的语音服务提供了功能或技能，使客户能够使用语音以更直观的方式与设备进行交互。 技能的例子包括播放音乐，回答一般问题，设置闹钟或计时器等的能力。\nAlexa Skill：Alexa技能工具包是自助服务API，工具，文档和代码示例的集合，使您能够快速，轻松地向Alexa添加技能。所有代码在云中运行，在任何用户设备上都没有。\nAWS Lambda：AWS Lambda是Amazon提供的计算服务, 它目前提供的程式语言有Node.js, Python, 以及java, 使用者可以撰写程式码, 并且使用AWS其它服务 (Ex. AWS IoT, logger)。 Lambda让使用者设定计算所需要的资源, 像是记忆体, 运算时间等等，Lambda会处理运算的部份。\n控制原理：控制机智云设备可以调用机智云的OpenAPI，OpenAPI控制设备的调用接口需要用到注册机智云用户时候返回的User Token，机智云对亚马逊授权开放该接口，与亚马逊账号进行互联互通，使得亚马逊可在Alexa里填入接口的相应的URL绑定机智云账号，从而调用到Access Token，传到Lambda里去再通过OpenAPI调用控制设备的接口进行控制。\n流程图：\n\n1.2 接入须知\n1、具备产品互联的服务功能（申请条件：机智云企业开发者，购买了GDCS服务包的企业客户）\n2、熟悉《设备快速接入机智云文档》《App快速接入机智云文档》并且能够完成整个接入\n1.3 准备工作\n硬件设备：亚马逊Echo音箱、机智云GOKIT设备\n软件：机智云APP\n其他：机智云开发者账号、亚马逊开发者账号、亚马逊AWS Lambda账号\n2、机智云配置\n本节要点：申请机智云产品互联服务，配置机智云的产品互联，配置Alexa定向URL来绑定机智云。\n2.1 设备接入\n按照文档中心的《设备快速接入机智云》绑定设备，获取设备did （点击此处跳转）\n2.1 APP开发\n按照文档中心的《App快速接入机智云》注册登陆机智云账号获取User Token和AppId进行绑定  （点击此处跳转）\n2.3 申请产品互联并配置\n\n点击个人项目-服务-添加服务，找到产品互联，点击进去开通服务（必须是购买了GDCS服务包的企业客户）\n申请完成后，点开产品互联，点击亚马逊Echo，配置你App开发中所填入的AppID，点击配置。\n\n配置Client Nname和AlexaSkill上面的Redirect URL。\n\n3、AlexaSkill配置\n本节要点：配置AlexaSkill的语音控制逻辑，配置AlexaSkill和Lambda关联，配置AlexaSkill和机智云账号互联。\n3.1 创建Skill以及配置interaction model页面\n1）打开亚马逊开发者中心（点击此处跳转），登陆之前所注册好的亚马逊开发者账号。\n\n\n2）登陆成功后。跳转到developer console，点击ALEXA，点击Alexa Skills Kit的Get Started。\n\n3）点击Add a New Skill\n\n4）\n\nSkill Information: 这里要填入一些基本资讯\nInteraction Model: 这里要填入互动模型\nConfiguration: 这里要设定Alexa收到语音命令之后, 该往哪里提交request\nTest: 这里可以对已经建制好的模型做测试, 这个阶段里, 使用者已经可以使用自己创建的服务\nPublishing: Alexa的服务流程里, 最后会将使用者设计的服务上架, 所以需要填写相关的资讯\nPrivacy & Compliance: 设定一些隐私相关的设定\n\n\n5）我们首先填Skill Information\n\nSkill type: 选择 “Custom Interaction Model”\nName: 这个地方填的是要显示给一般使用者的名称, 我们填入 “Control Light of Ameba”\nInvocation Name: 这里填的是让Alexa识别要启动session的名称。一般来说, Alexa启动session的方式有两种, 第一种是讲出完整的内容, 让Alexa分析互动模型来决定要启动哪个session, 第二种是使用者只讲Invocation Name, 让Alexa启动特定的session。这里我们填入 “Ameba Controller”\nInvocation Name的取名有一些限制, 要避开Alexa设定的关键字, 以及会造成误判语意的名称, 详细的限制说明可以参考这里:\nhttps://developer.amazon.com/appsandservices/solutions/alexa/alexa-skills-kit/docs/choosing-the-invocation-name-for-an-alexa-skill\n\n设定好之后, 我们点选Next\n\n3.1.1 intent Schema（语音控制逻辑）\nIntent Schema设定了这个Skill会用到的intent, 它使用JSON格式如下\n\n一个skill里面可以填多个intent, 每个intent触发的的情况不同。 Intent里面可以填slot（也可以不填），slot就像是程式里的列举变数, 它分成两种\nCustom slot type: 使用者需要为slot列举可能的值\nBuilt-in slot type: Amazon定义了一些常用的slot, 像是日期, 数字, 城市名……, 这类的slot会以AMAZON为前缀字\n详细的schema写法可以参考Amazon官网文章:\nhttps://developer.amazon.com/appsandservices/solutions/alexa/alexa-skills-kit/docs/defining-the-voice-interface\n这里我们将schema填入底下的值:\n\n其中intent的名称是 “ControlLight”, 它有一个slot名称是 “LightState”, 型态是custom slot type “LIGHT_STATE”\n其中LIGHT_STATE是custom slot type, 所以我们点选 “Add Slot Type”来设定\n接着会跳出一个视窗让我们填slot的名字, 以及列举的值,\n这里 “Enter Type” 的地方我们填 “LIGHT_STATE”, 接着 “Enter Values​​”的地方填入 “on”, “off”, 填完之后按 “Save”\n\n3.1.2 Sample Utterances（语音命令配置）\nSample Utterances, 这里要填的是当使用者说了什么句子时, 可以触发哪些intent, 我们填入以下的值\nControlLight Turn {LightState} the light\nControlLight Turn the light {LightState}\n它的格式里, 前面带的是intent名称, 接着是空白或tab, 后面跟着是使用者说的句子, 以第一行来说, 代表当使用者说了 “Turn on the light”会触发ControlLight intent\n填完之后我们按 “Next”\n\n3.2 configuration的配置\n这个页面里需要填写与Alexa衔接的Endpoint。当使用者触发Alexa的intent之后, Alexa会将这个intent传递给其它service处理, 使用者可以自己架构这样的server, 或是使用Amazon AWS Lambda, 这里我们将暂停设定Alexa, 并且设定AWS Lambda, 稍后再将这部份完成\n\nAccount Linking的配置方法：\n将下图页面的 Redirect URLs 设置到机智云 “产品互联” 的 Redirect URL 中，”Client Name” 可以填写 “Alexa”，填入机智云“产品互联”的Client ID和Client Secret作为请求身份验证的公共字符串。\nAuthorization URL (https://oauth.gizwits.com/oauth/authorize) 获取权限\nAccess Token URL (https://oauth.gizwits.com/oauth/token) 获取access_token\n\n\n有需要的用户可以填入隐私权限链接保护你的Alexa Skill，本教程选择不填，点击Next下一步。\n\n4、Lambda配置\n本节要点：配置Lambda绑定AWS IOT ，配置Lambda绑定Alexa，编写Lambda逻辑代码解析AlexaSkill接收和返回的语音指令，编写OpenApi代码接入机智云云端并控制设备\n进入AWS Lambda的首页 https://aws.amazon.com/cn/lambda/\n点选右边 “创建免费用户”\n\n登陆成功后，选择美国东部。\n\n点击服务-Lambda\n\n4.1  创建和配置AlexaFuntion\nLambda预先设计了一些使用情境, 这些情境提供了一些sample code与default setting。要使用Alexa与Lambda衔接, 我们在Filter的地方填入Alexa\n填完之后会筛选出与Alexa相关的blueprint, 其中“alexa-skills-kit-color-expert”与“alexa-skills-kit-color-export-python”是相似的blueprint, 差别只在于“alexa-skills -kit-color-expert”使用的程式语言是JavaScript, 而“alexa-skills-kit-color-export-python”使用python, 这里我们选择“alexa-skills-kit-color-expert”\n\n点击Configure triggers，这个页面里可以设定触发Lambda开始运算的event从哪里来, 我们点中间的虚线方框, 底下会出现预先设定好的服务列表, 这里我们选择 “Alexa Skills Kit”并且点击Next。\n\n点击Configure function页面，这个页面里, 我们要填入与程式相关的内容\n在Configure function里面, 有三个栏位:\n“Name”的栏位用来识别这个Lambda function, 这里我们填 “ControlLight”\n“Description”的栏位用来说明这个Lambda function的用途, 我们目前先使用预设值\n“Runtime”的栏位设定要使用的程式语言, 根据之前设定的blueprint, 这边出现的值是 “python2.7”, 使用者也可以在这里或之后切换使用的程式语言\n\n在Lambda function code里面, 可以设定 Code entry type, 使用者可以选择直接线上写code, 或是上传程式码, 这里我们选择线上写code\n这里我们先保留sample code, 之后再回来改code\n\n接下来设定Lambda function handler and role\n“Handler”的部份, 我们保留预设值\n“Role”的设定关系到Lambda的权限, 为了避免Lambda function使用了不该使用的服务, 我们可以设定Lambda function的权限, 这部份的服务来自于AWS IAM, 不过我们可以在这里直接设定, 在“Role”的下拉选单里, 点选“Create a custom role”\n\n此时将弹出新的浏览器页面, 并将你带至AWS IAM的服务\n在Lambda带出的AWS IAM的设定页面里, 我们设定 “Role Name”为 “control_light”\n然后点选 “View Policy Document”\n会出现这个role的权限, 我们点选 “Edit”\n会跳出视窗, 要你读过Execution Role的说明, 这里点选 “OK”\n然后我们可以编辑这个role的权限, 可以看到预设值里, 这个Role的权限只有log的权限, 因为我们需要使用AWS IoT的权限, 所以我们修改它如下\n\n然后点击“允许”。\n\n接着页面会关闭, 我们会跳回前一个Lambda设定的页面\n设定新的Role并且从AWS IAM返回之后, 可以看到 “Role”以及 “Existing Role”的栏位已经有值\n\n接着我们设定 Advanced settings\n这里可以设定 Lambda需要使用的memory与执行的时间,\n这里我们保留预设值, 接着点选 “Next”\n\n最后会让你review相关的设定, 不过这些设定都可以之后再改变, 这里我们点选 “Create function”\n\n会出现恭喜你已完成设定的讯息, 请注意, 右上角的字串“ARN - arn:aws:lambda:us-east-1:xxxxxxxxxx”, 就是这个Lambda function的end point, 这个会用来填入Alexa的设定页面\n\n4.2  Lambda中所对应skill的代码\n回到Lambda的设定页面, 点选 “code”页签\n\n4.2.1  event部分代码解析（Echo音箱逻辑处理）\n在onIntent函式里, 会比对intent的名字, 这边我们会比对我们设定的intent名字 “ControlLight”, 并且返回 light_control的处理函数\n\n在light_control里面, 我们可以取得intent的slots资讯, 这边我们要取得的slot是 “LightState”\n获取在skill上语音说话所传过来的value并传给switch_action，之后判断switch_action等于on时，则传Ture到switch_action_fun这个函数里。\n\n之后再调用机智云的openapi对设备进行控制，详情请参考openapi的使用指南\n（http://docs.gizwits.com/zh-cn/Cloud/openapi_apps.html）\n5、Alexa应用端配置\n本节要点：Echo音箱配置入网，AlexaSkill与亚马逊账号绑定，Alexa与机智云账号绑定。\n5.1  配置Echo音箱入网\n用笔记本电脑点击链接http://alexa.amazon.com/spa/index.html 配置\n或用手机App来进行配置：下载链接\n（https://www.amazon.com/gp/help/customer/display.html?nodeId=201602060）\n登陆亚马逊账号，进入Alexa配置页面，选择Echo音箱\n\n选择你使用的语言\n\n点击Connect to Wi-Fi\n\n当你的音箱旋转橙色光环，即进入配置模式，点击continue\n\n将你的电脑链接Echo音箱，当Echo音箱进入配置模式时，会发出一个Amazon-XXX的wifi，用电脑进行链接\n\n链接之后，网页自动切换成该页面，点击Continue\n\n\n选择你所要配置的wifi路由器，点击则进入配置。\n\n稍等片刻后，便配置成功，点击continue。\n\n5.2  绑定机智云所注册的账号\n进入点击进入Skills，点右上角切换到Your Skills，点击Control GOKIT。\n\n进入之后点击Enable\n\n进入之后点击Link Account\n\n之后跳转到登陆页面，这里登陆的是机智云APP所注册的用户名账号和密码，点击Sign in。\n\n点击yes，弹出链接成功的窗口\n\n\n回到Control GOKIT页面，发现Link Account按钮消失了，则说明关联绑定机智云账号成功\n\n6、AlexaSkill调试与发布\n本节要点：调试AlexaSkill是否成功与Lambda和机智云通讯，语音控制逻辑是否正确，如何发布Skill。\n6.1  AlexaSkill和Lambda的绑定\n回到Alexa页面，点击configuration，North America的框里输入AWS Lambda ARN，Lambda ARN在Lambda的Function右上角可以查看到\n\n\n6.2  发送控制指令进行测试\n在Test页面, 我们可以做一些基本测试\n在Voice Simulator里, 我们可以测试Alexa收到的语音资料里, 它会如何发音\n它使用SSML tags让Alexa发出特定的语音像是拼出hello, 点选Listen就可以听看看语音的结果\n\n这边的文字也就是Lambda回传的outputSpeech内容, 所以我们可以在Lambda的回传语音讯息里有更多弹性\n在 “Service Simulator”, 我们可以填入使用者发出的语音讯息, 并且让Alexa假装听到这个讯息做对应的处理, 这里我们填入 “Turn on the light”, 然后点选 “Ask Control Gokit”\n这段语音讯息会被Alexa处理, 送至Lambda function, Lambda function处理完之后再回传结果, 若正常返回结果，我们就可以对自己的Echo音响说话来语音控制Gokit了。\n我们可以点选右下角的 “Listen” 可以聆听这段结果。\n\n6.3  AlexaSkill发布\n测试成功后，可以将自己编写的AlexaSkill发布提供给其他的Alexa用户使用，在Publishing information里可以填入自己Skill的一些基础信息，并点击Submit for Certification提交。\n注：当Skill发布成功后，Skill的一些信息和参数等不可二次修改，请谨慎发布。\n\n\n若发布成功后，其他用户就可以在Alexa应用端的Skills-All Skills里搜索到\n\n如在发布过程中遇到相关问题，可以联系机智云，我们将帮您发布你的skill\n7、相关支持\n7.1 如果您是开发者\nGoKit是面向智能硬件开发者限量免费开放，注册我们的论坛或关注我们的官方微信均可发起申请即可。\n开发者论坛： http://club.gizwits.com/forum.php\n文档中心：http://docs.gizwits.com/hc/\n7.2 如果您是团体\nGizWits针对团体有很多支持计划，您可以和GizWtis联系，快速得到GoKit以及技术支持；\n网站地址：http://www.gizwits.com/about-us\n官方二维码：\n\n"},{"title":"实时大数据使用说明","url":"/zh-cn/UserManual/rtbd.html","content":"实时大数据简介及申请流程\n1.功能介绍\n通过拖放的方式生成API， 用于对产品数据点进行实时大数据统计分析。\n2.申请流程\n第一步：登录机智云【开发者中心】，打开需要申请开通【实时大数据】的产品(仅限机智云企业开发者)；\n第二步：点击【添加服务】，进入到【添加服务】页面，找到【实时大数据】；\n\n第三步：打开【实时大数据】，点击【开通服务】按钮，等待机智云审核；\n\n第四步：待机智云审核通过后，在服务列表即可看到实时大数据；点击【实时大数据】即可开始体验。\n\n实时大数据API构建\n1.API列表\n进入实时大数据，默认进入此产品的API列表页面。\n\nAPI列表为空时，页面显示如上图。【+新建API】/【创建】：点击后跳转至构建API页面。\n\nAPI列表不为空时，页面显示如上图。本页面显示该产品所创建的所有API。显示字段为API标识符、名称、是否开启、操作等。\n【+新建API】：点击后跳转至构建API页面；\n【是否开启】：API是否开启按钮。API创建成功后默认开启。点击关闭后该API将不能被调用(调用时提示{\"err_msg\":\"the viewid requested is disabled.\",\"err_code\":1006})。\n【详细】：点击后进入当前API构建及测试页面，可对其进行修改，保存后生效。\n【删除】：点击此按钮可将当前API删除，删除后不可恢复。\n2.数据点\n\n数据点支持四种类型，分别为D（时间戳），S（字符型），N（整型/浮点型），B（布尔型）\ncreated_at，did，mac是固定字段，所有产品都存在，其他的字段是该产品定义的数据点。\n\n\n当产品下无设备上报数据时，除固定字段外无法加载出产品定义的数据点。\n\n3.构建API\n(1)聚合\n拖动需要进行聚合计算的数据点到聚合框中，可对其进行求平均值、最小值、最大值、总和。\n\n每个API只支持对一个数据点进行聚合；\n每个API聚合数据点不能为空；\n聚合计算只支持N（整型/浮点型），B（布尔型）。\n\n\n(2)分组\n拖动需要进行分组的数据点到分组框中。\n\n只支持一个分组字段，可为空；\n分组字段支持全部数据点；\n分组字段类型对应相应的分组类型。时间戳只支持时间区域(每小时、每天、每周、每月)，整型只支持数值区域(间距值最小为1)，字符和布尔只支持字段值；\n只有选择了分组后，测试API时才能展示图表。\n\n(3)过滤\n拖动过滤的数据点到过滤框中。\n\n支持多条件，可为空；\n过滤字段支持全部数据点；\n根据过滤字段类型，支持相应的操作符。其中字符型和布尔型只支持 =；\n过滤值可支持值或者表达式。值可为空；表达式为${}，括号内的值为参数，供API调用时传入。\n\n4.测试API\n(1)运行测试&&图表\n设置好聚合数据点、分组数据点、过滤条件后，选择【图标类型】，点击【测试查询】按钮\n\n无图：分组字段为空时，无图表展示。\n线图：分组字段不能为空，才能选择线图，图形如下：\n\n柱图：分组字段不能为空，才能选择柱图，图形如下：\n\n(2)运行测试&&展示数据\n设置好聚合数据点、分组数据点、过滤条件后，点击【测试查询】按钮，再点击【显示数据】按钮(【隐藏数据】按钮)。\n备注：更新API条件后，要先点【测试查询】，再点【显示数据】，才能展示最新数据。【显示数据】按钮作用仅仅是决定是否显示数据，无查询功能。\n\n显示数据：\n\n隐藏数据：点击隐藏数据后，展示数据整个模块不显示。\n(3)保存\n构建完API，经测试符合自己的需求后，可将此API进行保存，以备下次直接调用。\n输入API名称(1到32字符长度限制)，点击创建API，即可生成API URL及API参数。此时API创建成功，在API列表即可查看此API并可对其再进行编辑、开关或删除等操作。\n\nAPI生成成功后调用方法请参考”实时大数据API使用”。\n实时大数据API使用\n1.调用方式\n采用HTTP GET的方式调用接口。\n调用的URL为 'http://119.29.123.105:8081/dataapi/view/product/kv/{api_id}'。\n其中{api_id}为API标识符，请见API列表中的“API标识符”一列。每个不同的API对应不同的api_id。当查询需要参数输入时，把参数封装成JSON格式，并以'URL?data=JSON'的形式调用。\n\n2.安全授权(Header)\n\n\n\n名称\n值\n说明\n\n\n\n\nX-Gizwits-ProductKey\n{product_key}\n产品的product_key\n\n\nX-Gizwits-Timestamp\n{timestamp_in_seconds}\n当前的Unix Epoch时间戳，单位为秒，但请注意提交的时间戳与标准时间的误差必须在10分钟以内，否则授权失败\n\n\nX-Gizwits-Signature\n{lower(MD5({product_secret} + X-Gizwits-Timestamp))}\n此值为通过计算出来的签名，计算方法如下：把小写的{product_secret}与{timestamp_in_seconds}按字符串的方式拼接在一起，然后计算其MD5值，再把MD5值转换成小写十六进制字符串的形式，如“71a78a1dd33df9e77d23a7f1171ab40”。其中{product_secret}为产品秘钥\n\n\n\n3.调用频率\n每个产品每分钟最多可调用10次（即10 req/m）。\n4.调用举例\n如调用API的参数如下\n\nAPI 标识符：AVi-5CkZNrnIcV85KPNd\n产品标识符：08f3e460b05b4500b9c3e698c6f241b8\n产品秘钥：2862c8c599fc47b2869aaf4c3efaf35e\n当前时间为：2016年8月8日10时05分07秒（北京时间）\n有一查询参数mac，值为c8934046a16d\n\n\n"},{"title":"微信应用开发教程","url":"/zh-cn/WechatDev/WeChatDev.html","content":"微信SDK\n附件：微信SDK包下载\n目标驱动的教程\n本教程以目标为驱动，去除多余的细节，让机智云的小伙伴们，可以快速的搞定微信接入。好啦，我们开始吧！\n为什么接入微信？\n\n微信有大量的用户\n\n用户不愿意，为某个垂直领域的服务，单独装一个应用\n\n微信有全平台的版本，开发一次，相当于开发多个应用\n\n\n等等……\n正是这些好处，我们才会借助微信的力量。所以，我们将借助微信的两大体系: \n\n用户体系（OpenId）\n\n微信APP（AirKiss 和 内置浏览器）。\n\n\n最终，我们希望用户，能像体验微信原生功能一样，使用我们的智能设备。\n你有微信公众号?\n首先，我们需要申请微信公众号。\n注意，不能申请订阅号（不支持微信认证）。我们将申请一个服务号，并且完成认证操作，然后才能开启“设备功能”模块，最后添加一个产品。\n最终，你会得到两件装备：\n\n公众号的原始ID\n\n设备的二维码\n\n\n当然，你也可以使用测试号，进行前期开发阶段的调试。\n你得有台设备吧？\n微信接入前，需保证，设备能正常地与机智云进行通讯，设备的具体开发流程如下。\n\n 注意，在WIFI模块中，写入AirKiss时，需要配置公众号的原始ID。也就说，除了将机智云的product_key写入MCU以外，还需要将公众号原始ID写入WIFI固件中。关于固件的烧录，厂商或者小伙伴们如有困难，可以寻求机智云 · 客服MM的帮助。\n设备二维码\n微信客户端APP可以通过扫描二维码添加设备。为使已成功接入机智云的设备能被微信控制，在微信公众平台创建产品的时候请按照以下设置来勾选。设置内容如下：\n\n其中：连接类型选择“Wi-Fi”设备；\n产品添加方式选择“每种型号唯一的二维码”，产品添加成功后，微信会生成此款产品的唯一一个二维码，通过扫描这个唯一的二维码可以进行微信配网后近场发现设备来绑定，如果选择“每个产品唯一的二维码”，那么将会为此款产品的每一个产品生成一个二维码，扫描该二维码可以直接绑定设备，但是无法通过近场发现绑定；\n产品配置方式选择“微信配网”与“不使用加密”。\n设备授权\n设备不但要在WIFI固件中写入公众号原始ID(注意，不是APPID)，还要将所有设备的Mac地址，登记到微信服务器上。一开始，微信只给你100个配额，也就是说，你只能授权100个设备。\n授权的方法，就是向微信的接口，发送一次请求，具体请看微信文档-设备授权。\n很多小伙伴反应，授权经常失败，我们这里给出一组基于WIFI通讯的示例，大家可以参考：\n\n 注意：12位xxxxxxxxxxxx，代表设备的Mac地址，id是指设备ID，也就是机智云的did。但因为设备必须在上线后，机智云才会分配一个did，所以，我们并无法预知did是什么。通常的做法是：将id和mac，都设置为设备的Mac值。\nauth_key可以不填，设置为空字符串，但不能没有这个字段。\nop_type为0时，表示添加一台设备，后面需要跟着product_id字段(产品ID，在公众号的“设备功能”中，添加产品后，会有这个id)。op_type为1时，表示更新一台设备，此时不需要product_id字段。\n批量授权时，记得更新顶部的：device_num。\n这样，我们硬件（设备）层面的准备工作，就完成啦。\n阶段性成果\n好了，到这步，你可以稍微的奖励一下自己，享受一下阶段性的成果啦! \n打开你的微信（确保是wifi链接状态），扫一扫你的产品二维码。\n\n下面有两个按钮，绿色的按钮，是启动微信的AirKiss，将WIFI的账号密码，发送给设备的WIFI模块。\n部分设备需要启动匹配模式，才能配置上网。一般先启动设备的匹配模式，再使用微信的配置功能。配置完成后，会自动跳转到设备搜索界面。\n在搜索界面，如果前面准备工作到位了，你一定能发现设备（不管是否绑定过）。点击发现的设备，然后绑定。微信会自动跳转到公众号页面。然后，你可以在微信的设置页面中，发现多了一个项目：设备。\n当然，上面的操作，只是实现绑定操作。下面的教程将介绍如何监控设备的数据点。\n简化操作的SDK\n为了简化开发者的操作，我们将一些必要的API封装成了两个SDK: java-SDK 以及 js-SDK。它们分别用于后台和前端页面，各自封装了机智云的OpenAPI 以及 WebSocket。\n这两个SDK，将大大的简化了API的操作，帮我们接管了token和用户管理，我们只需要调用相关方法，即可实现设备的绑定和解绑。\nSDK，可以在本文的附件中下载。\n业务服务器的搭建\n设备没问题了，我们现在需要的是，操控设备本身的功能。\n由于设备已经与机智云正常的通讯，因此，对设备的操作，其实就是如何与机智云交互。\n机智云设备绑定\n现在，用户已经在微信中绑定了设备，他希望看到，设备在线状态。怎么办?\n我们使用微信的OpenId，作为唯一标识，生成匿名用户。什么时候注册匿名用户呢？微信绑定设备时候，将推送一条设备绑定事件消息到我们的业务服务器。我们在这个时候，将同时完成注册匿名用户，以及绑定用户/设备的操作。\n\n微信在绑定时，发送这么一条事件消息：\n\n我们需要的是其中的OpenID和Mac，然后我们调用机智云的Java-SDK：\nDeviceInfo deviceInfo = OpenApi.bindDevice(\n                                    wechatOpenId, \n                                    gizwitsAppId, \n                                    gizwitsProductKey, \n                                    gizwitsProductSecret, \n                                    mac, \n                                    deviceAlias, \n                                    deviceRemark)\n\n\n\n\n参数名\n类型\n说明\n\n\n\n\nwechatOpenId\nString\n微信中的OpenId，也就是机智云中注册的匿名用户\n\n\ngizwitsAppId\nString\n机智云产品所绑定的APP的id\n\n\ngizwitsProductKey\nString\n机智云的产品key\n\n\ngizwitsProductSecret\nString\n机智云的产品Secret\n\n\nmac\nString\n设备的Mac地址\n\n\ndeviceAlias\nString\n设备的别名\n\n\ndeviceRemark\nString\n设备的备注\n\n\n\n 这个方法，一次性解决了两个问题：注册匿名用户，绑定用户/设备。相对的，也要设定很多参数。所有的参数都是String类型。\n其中deviceAlias（设备别名）以及deviceRemark（设备备注）都可以填空字符串“”。gizwitsProductKey就是你在开发者中心创建的产品。\n\n而gizwitsProductSecret，则是该产品对应的密匙，在产品的详细信息中可以找到。\n\ngizwitsAppId是机智云中，APP的Id。由于一个产品，可能是多个APP操作的，比如IOS的APP，Android的APP，网站Web应用，甚至微信这样的轻应用，都算是一个APP。因此，在创建产品后，你还可以在为产品绑定一个或多个APP。这里的gizwitsAppId就是我们所绑定APP的Id了。注意，APP必须绑定在产品上，才能使用。\n当你调用该方法，就能实现注册匿名用户，已经将用户/设备绑定的操作了。是不是很方便呢？当然，为了方便起见，你还可以进一步封装这个SDK。这里就不展开了。\n机智云设备解绑\n解绑操作也是类似的逻辑。当微信推送一条解绑事件消息，我们就会进行解绑操作。同样调用SDK：\nBoolean isSuccess = OpenApi.unbindDevice(wechatOpenId, gizwitsAppId, gizwitsDid);\n\n\n\n\n参数名\n属性\n说明\n\n\n\n\nWechatOpenId\nString\n微信中的OpenId，也就是机智云中注册的匿名用户\n\n\ngizwitsAppId\nString\n机智云产品所绑定的APP的id\n\n\n\n获知设备的在线状态\nBoolean isOnline = OpenApi.getDeviceOnlineStatus(wechatOpenId, gizwitsAppId, gizwitsDid);\n\n\n\n\n参数名\n属性\n说明\n\n\n\n\nwechatOpenId\nString\n微信中的OpenId，也就是机智云中注册的匿名用户\n\n\ngizwitsAppId\nString\n机智云产品所绑定的APP的id\n\n\ngizwitsDid\nString\n机智云中的设备ID，设备重置时会重新注册\n\n\n\n代码样例\n\n请注意，在服务器部署的时候，部分开发者会发现部署失败。tomcat中的catalina日志会报错：\njavax.net.ssl.SSLException:java.security.ProviderException:java.security.KeyException\n\n这是因为SDK中采用了Https的方式进行访问。\n解决方法是：升级服务器环境中的库：nss。\n微信页面操作设备\n好了，我们现在已经绑定了设备，并且也能知道设备的在线的状态了。但是具体如何操作我们的设备？一个良好的体验，当然是具有交互页面的。\n下面我们就一步步的搭建一个交互页面，来监控我们的设备吧！\n获取OpenId\n用户点击页面，我们如何知道是哪个用户呢？我们需要获取当前用户的OpenId来识别时哪个用户。如何获取呢？详细可以看微信的官方文档。\n简单的来说，我们向微信的服务器发送授权请求，微信会判断我们请求的URL，是否是授权的域名，如果验证通过，就会转发到我们的URL，并且带上几个参数。\n其中最重要的参数，是code，我们通过Code可以获取OpenId。然后，我们再将OpenId返回到页面中。\n\n连接机智云的WebSocket\n对于访问机智云的WebSocket，我们已经封装成了一个JS-SDK。大家只需要引入到页面即可。\n初始化gizwits服务\n首先是，构建一个gizwits服务：\n\n 这个gizwits服务，会负责接下来所有的操作，包括：连接设备，读取设备的数据点，操作设备等。\n\n\n\n参数名\n属性\n说明\n\n\n\n\nApiHost\nString\nwebsocket的目标API域名\n\n\nCommType\nString\n协议格式：custom(自定义协议); attrs_v4(标准数据点协议)\n\n\nwechatOpenId\nString\n当前访问的微信用户OpenId\n\n\nGizwitsAppId\nString\n机智云产品所绑定的APP的id\n\n\n\n当然，此时gizwits服务，并没有运行起来，我们还需要初始化操作。但在操作之前，我们可以选择配置一个回调函数，它会在初始化结束后，自动运行。\n\n当执行gizwits.init()的时候，就会初始化gizwits服务，并且将匿名用户OpenId绑定的所有设备，放置在回调函数的devices中。\n而我们要做的操作，都应该写在回调函数gizwits.onInit里面。\ndevices列表中的每个设备，都会有六个属性，分别是product_key(产品的Key), dev_alias(设备别名），did(设备ID)，mac，is_online(在线状态）, remark(设备备注)。我们可以根据情况来使用。\n设备列表\n\n上面的操作中，我们已经获取到了设备列表。一般来说，客户可能拥有多个设备，因此，我们在这一步，就可以罗列一个设备列表，由用户自己决定，来操作哪台设备。\n连接设备\n想要操作具体哪台设备，我们就去连接哪台设备：gizwits.connect(did)。当然连接成功后，也有一个回调函数：gizwits.onConnected。此回调函数没有传入值。\n注意，连接设备之前，必须先初始化。\n初始化和连接设备，并非同步操作，因此，如果只是简单的先后执行，可能会出错。因此，建议可以将连接设备的操作，放在初始化的回调函数中，保证执行的先后关系。\n连接成功后，我们就可以收到设备上报的数据了。上报的数据通过回调函数：gizwits.onReceivedAttrs。该回调函数会有一个回调值（参数），这个回调值的格式如下：\n\n上面的操作中，我们已经获取到了设备列表。一般来说，客户可能拥有多个设备，因此，我们在这一步，就可以罗列一个设备列表，由用户自己决定，来操作哪台设备。\n连接设备\n想要操作具体哪台设备，我们就去连接哪台设备：gizwits.connect(did)。当然连接成功后，也有一个回调函数：gizwits.onConnected。此回调函数没有传入值。\n注意，连接设备之前，必须先初始化。\n 初始化和连接设备，并非同步操作，因此，如果只是简单的先后执行，可能会出错。因此，建议可以将连接设备的操作，放在初始化的回调函数中，保证执行的先后关系。\n连接成功后，我们就可以收到设备上报的数据了。上报的数据通过回调函数：gizwits.onReceivedAttrs。该回调函数会有一个回调值（参数），这个回调值的格式如下：\n\n手动读取：设备数据点\n获取设备的数据点，也很简单，只需调用gizwits.read()方法，需要传入did。调用此方法，可以马上获取一次，同样，数据也是通过回调函数 gizwits.onReceivedAttrs，或者gizwits.onReceivedRaw来获取。\n连接错误\n当websocket连接错误时，会调用gizwits.onError函数，如有需要，可以重写该函数；回调值是错误信息：\ngizwits.onError = function(value){\n    console.log(\"error!!!!:::::\", value.toString());\n}\n\n设备上下线\n当设备发生上线，或者下线的事件时，gizwits服务，会调用gizwits.onOnlineStatusChanged 回调函数.\n回调值有两个参数：did和在线状态(is_online)。\ngizwits.onOnlineStatusChanged = function(value) {\n    alert(\"设备上下线通知，did=\", value.did);\n    alert(\"设备上下线通知，is_online=\", value.is_online);\n}\n\n控制设备\n最后是，设备的远程控制。\n  远程控制的调用方法，如果commType=custom，则使用gizwitsws.send(command)方法，如果commType=attrs_v4，则使用gizwitsws.write(command)方法。\n远程控制的值，如果commType=custom，请输入p0，例如[,,...]；如果commType=attrs_v4，请输入datapoints，例如{\"power\":true}。\n下面是远程控制RBG灯的代码样例：\nvar command = '{\"LED_R\": 0, \"LED_G\": 0, \"LED_B\": 0}';\ngizwits.write(did, JSON.parse(command));\n\n 当然，使用控制设备的前提是，我们已经连接上了一台设备。\n结语\n至此，我们已经实现了微信接入的核心部分。在此教程中，Java-SDK与js-SDK为我们带来了很大的，我们几乎不用关心如何调用机智云的API和websocket，而是直接调用SDK的方法就可以了。\n最后，希望大家能多多反馈意见，为更加便捷的开发贡献一份力量。\n"},{"title":"了解微信应用开发","url":"/zh-cn/WechatDev/了解微信应用开发.html","content":"开发流程\n1.概述\n如果开发者有通过微信公众平台作为与最终消费者的交互界面的需求，您可以通过阅读本文档了解如何借助机智云以及微信公众号、微信硬件平台进行开发。由于基于微信公众号进行硬件设备的接入、控制需要与多个平台交互。所以，有必要对每个平台的作用有清晰的了解。\n2.总体接入流程图\n\n3.机智云\n如图①在微信接入业务场景中，通过开发者中心（site.gizwits.com）的图形化界面定义设备功能，机智云自动生成设备MCU与通信模组之间的串口通信协议，开发者根据协议文档即可实现设备的联网能力。\n如图②部分，设备接入机智云后，机智云提供了面向微信应用的API，提供传输设备数据到应用、应用向设备发起的控制信息的功能。\n4.厂商服务器\n厂商服务器是厂商为了满足自己的微信应用，独立部署的WEB系统。该系统通过机智云平台提供的API进行与设备的数据、控制的实时通讯，解决智能硬件接入的需求；通过访问微信公众号平台的API实现以微信为渠道服务厂商最终消费者的需求。\n首先，开发者可以为自己的应用设计个性化的HTML交互界面与功能。（如图③④部分）\n5.微信服务器\n微信服务器主要为设备与厂商服务器之间的通信提供了一系列的接口，主要包括微信用户账号与设备的绑定/解绑定、接受/发送设备消息等，具体接口及使用方法可查看微信官方文档，微信最近推出了微信硬件平台，在做微信接入前需要仔细了解微信公众号与微信硬件平台，提供的功能要在不断完善。\n6.微信客户端\n微信客户端提供了最终与用户交互的操作界面，可以理解为就是一个运行在手机的浏览器，只不过是运行在微信公众号这套体系下。开发者可通过自己申请的公众号管理后台配置自定义的菜单\n了解微信\n了解微信公众号平台\n具体内容请参考微信公众平台\nFAQ\n1、机智云Web Socket API服务是什么？\n机智云Web Socket API服务是为了满足基于Html5应用如微信公众号这种应用远程控制设备，实时展现设备状态而开发的一套API接口。Web Socket API主要是为了弥补HTTP协议短连接的不足，能够实时将设备数据传输到网页并展现。\n2、WEB socket协议与HTTP有什么区别？\nHTTP协议是由客户端主动向服务端发起单向通信，是短连接。 \nWeb Socket是长连接双向通信，服务端与客户端都可主动发送数据。\n3、如果未成功绑定设备，是否可以调用web socket api提供的控制设备指令？\n未成功绑定设备，不能成功调用控制设备的指令。 \n4、在使用设备控制api与服务端通讯，采用什么编码？\n采用utf8编码。数据点中枚举值为非ASCII的字符明确需要以Unicode编码。 \n5、设备控制api协议中的参数详细描述有吗？\ndid：目标设备的did。attr：属性值。raw：自定义内容。\ndid是open api 注册设备的返回结果。 \nattr的值需要结合数据点的定义。 \nraw的值需要结合p0协议的定义。 \nwebsocket只是m2m客户端的一种存在形式。因此与open api的结合如同用户或设备与open api中定义的参数是一样的，可在Open api获取参数的详细意义。\n6、Web socket api提供SSL的通讯支持吗？\n支持。\n"},{"title":"ESP8266-SOC方案UART0教程","url":"/zh-cn/deviceDev/ESP8266-SOC_UART0.html","content":"教程代码\nesp8266-technical_reference_cn.pdf\n一、概述\n本文主要介绍如何在soc方案下使用esp8266的UART0，让开发者可以在soc方案下的使用esp8266串口通信。本文主要实现两种方式：\nUART0收发相同数据\nUART0_tx发送指定数据\n二、UART0收发相同数据\n1、在uart.c代码中，复制教程代码uart0_rx_intr_handler函数如下图，下图同时是UART0的中断处理过程（教程代码中有两个uart0_rx_intr_handler函数是因为用了\"#if 0\"、\"#else\"、\"#endif\"重新写一个uart0_rx_intr_handler函数）\n\n2、修改完源码，我们就可以尝试往esp8266的UART0_rx写数据，看下UART0_tx会不会将该数据发送出来\n\n3、可以看到，esp8266的UART0_rx接收到什么，UART0_tx就发送什么。\n注：关于串口的FIFO接收与发送数据，可下载本教程附件esp8266-technical_reference_cn.pdf，阅读第11章关于UART的介绍与接口\n三、UART0_tx发送指定数据\n我们可以像控制灯的开关一样，用App去控制UART0_tx分别发送“Hello,Gizwits!\\n”和“Goodbye,Gizwits!\\n”。\n1、在uart.c找到uart1_sendStr_no_wait函数，复制修改成UART0专用，在uart.h做同样的操作，如下图\n\n\n2、在gizwits_product.c添加代码如图（前提是已经定义了一个可写布尔数据点）\n\n3、UART0_tx发送数据如图\n\n4、这样，我们就可以让UART0_tx发送我们特定的数据\n"},{"title":"ESP8266串口烧写说明","url":"/zh-cn/deviceDev/ESP8266_Firmware_Programmer.html","content":"概述\n本文针对乐鑫ESP8266模块进行串口模式烧写流程整理了一篇操作流程。合作厂商在进行模块烧写操作时请依次按照如下步骤进行，否则会产生不可控的错误。\n操作流程\n1.下载ESP8266对应的固件\n \n \n  \n2.确认固件文件\n \n如图所示bin文件为我们所需要的固件。\n3.设备连接\n将ESP8266模块按照如下原理图进行接线，注意GPIO0（18号管脚）需要输入低电平，本实验直接接地处理，KEY1实现外部复位功能。\n  \n上图为烧录固件简易原理图，在产品中实际搭建线路时，请参考官方提供线路图，如下所示：\n\n4.串口设置\n4.1.确认串口参数\n将上述串口连接电脑后，通过“我的电脑”->“管理”-> “设备管理器”->“端口（COM 和LPT）”选项中可以看到相应增加的COM口。\n \n4.2 下载烧写软件\n下载地址：http://pan.baidu.com/s/1mhMGSeG\n下载解压后得到下面文件\n  \n再次解压图中所示的文件后，双击 打开烧写软件，出现如下对话框。 \n \n4.3使用串口方式一烧写固件\n \n 使用如上图所示固件烧录固件时，串口烧录工具参数需按照如下方式填写：\n 请务必依次对照下图所选的地方进行相应的填写：\n 使用MCU方案烧写方式：\n \n  使用SOC方案烧写方式：\n \n4.4使用串口方式二烧写固件\n\n 使用如上图所示固件烧录固件时，串口烧录工具参数需按照如下方式填写：\n 请务必依次对照下图所选的地方进行相应的填写：\n \n5烧写操作\n步骤一、当串口连接成功之后，点击如上图的“START”按钮，\n  \n会出现\n  \n步骤二、将ESP8266进行复位（按下2.3节原理图所示的KEY1后松开）将会出现如下信息表示模块正在进行烧写。\n  \n步骤三、等待一段时间后，出现“FINISH”字样表示烧写成功。\n \n"},{"title":"ESP8266串口烧写说明","url":"/zh-cn/deviceDev/ESP8266串口烧写说明.html","content":"概述\n本文针对乐鑫ESP8266模块进行串口模式烧写流程整理了一篇操作流程。合作厂商在进行模块烧写操作时请依次按照如下步骤进行，否则会产生不可控的错误。\n操作流程\n1.下载ESP8266对应的固件\nESP8266 GAgent固件下载地址：https://download.gizwits.com/zh-cn/p/92/94\n \n \n  \n2.确认固件文件（以combine固件为例）\n \n如图所示bin文件为我们所需要的固件。\n3.设备连接\n将ESP8266模块按照如下原理图进行接线，注意GPIO0（18号管脚）需要输入低电平，本实验直接接地处理，KEY1实现外部复位功能。\n  \n上图为烧录固件简易原理图，在产品中实际搭建线路时，请参考官方提供线路图，如下所示：\n\n4.串口设置\n下载烧写软件\n下载地址：https://www.espressif.com/sites/default/files/tools/flash_download_tools_v3.6.4.rar\n烧写固件\n 请务必依次对照下图所选的地方进行相应的填写：\n使用MCU方案烧写方式（combine固件烧写）：\n \n \n \n备注：若使用机智云官网SOC方案编译出来的固件，烧写方式如下（32Mbit方案分区烧写）：\n \n5.烧写操作\n步骤一、选择正确的串口，当串口连接成功之后，点击如上图的“START”按钮，\n \n  \n会出现\n  \n步骤二、将ESP8266进行复位（按下2.3节原理图所示的KEY1后松开）将会出现如下信息表示模块正在进行烧写。\n  \n步骤三、等待一段时间后，出现“FINISH”字样表示烧写成功。\n \n"},{"title":"GoKit3 DEV SDK Common版移植说明","url":"/zh-cn/deviceDev/GoKit3_DEV_SDK_Common_transplant.html","content":"前文需知\n1.什么是\"代码自动生成工具\"？\n为了降低开发者的开发门槛，缩短开发周期，降低开发资源投入，机智云推出了代码自动生成服务。云端会根据产品定义的数据点生成对应产品的设备端代码。\n自动生成的代码实现了机智云通信协议的解析与封包、传感器数据与通信数据的转换逻辑，并封装成了简单的API，且提供了多种平台的实例代码。当设备收到云端或APP端的数据后，程序会将数据转换成对应的事件并通知到应用层，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，就可以完成产品的开发。\nMCU方案默认支持 STM32F103C8x 平台，如果是其他MCU芯片，可以将我们生成好的 通用平台版代码 移植到符合条件的平台，从而实现机智云所提供的各种功能。\n本文将主要说明 通用平台版 的移植。\n2.如何自动生成\"通用平台代码\"？\n在机智云平台定义一个产品后，选择左侧服务中的\"MCU开发\"，选中硬件方案中的\"独立MCU方案\"，再选中\"硬件平台\"中的\"其他平台\"，最后点击\"生成代码包\"，等待生成完毕下载即可。\n\n下载完成后解压如下：\n \n3.通用平台移植需知\n开发者在移植前要确保被移植平台的硬件参数满足以下的要求：\nA. 平台支持两个串口接口（至少一个），一个负责与wifi模组间的数据收发（必须），一个用于调试信息打印（可复用数据收发串口）。\nB.平台支持定时器功能（1ms精确定时）。\nC.平台支持至少2K的RAM空间（可调整环形缓冲区大小来解决此问题，但易导致数据协议的处理异常）。\n注：环形缓冲区修改位置: Gizwits\\gizwits_protocol.h\n \n原代码中MAX_PACKAGE_LEN = 950，即环形缓冲区所占RAM空间大小为950*2 = 1900 字节，开发者可以此来调整程序所占RAM空间的大小。\n通用平台版代码移植说明\n1.文件介绍\n \n重要文件解读:\n\ngizwits_product.c\n该文件为产品相关处理函数，如gizwitsEventProcess()。\n\ngizwits_product.h\n该文件为gizwits_product.c的头文件，如HARDWARE_VERSION、SOFTWARE_VERSION。\n\ngizwits_protocol.c\n该文件为SDK API接口函数定义文件。\n\ngizwits_protocol.h\n该文件为gizwits_protocol.c对应头文件，相关API的接口声明均在此文件中。\n\n其他文件\na) User/main.c\nMCU程序入口函数所在文件，入口函数为main(void)。\n\n\n2.API介绍\n· void gizwitsInit (void)\ngizwits协议初始化接口。\n用户调用该接口可以完成Gizwits协议相关初始化（包括协议相关定时器、串口的初始化）。\n· void gizwitsSetMode (uint8_t mode)\n参数mode[in]：仅支持0,1和2,其他数据无效。\n参数为0，恢复模组出厂配置接口，调用会清空所有配置参数，恢复到出厂默认配置。\n参数为1或2，配置模式切换接口，支持SoftAP和AirLink模式。参数为1时配置模组进入SoftAp模式，参数为2配置模组进入AirLink模式。\n· void gizwitsHandle(dataPoint_t *dataPoint)\n参数dataPoint[in]:用户设备数据点。\n该函数中完成了相应协议数据的处理即数据上报的等相关操作。\n· int8_t gizwitsEventProcess(eventInfo_t info, uint8_t data, uint32_t len)\n参数info[in]:事件队列\n参数data[in]:数据\n参数len [in]:数据长度\n用户数据处理函数,包括wifi状态更新事件和控制事件。\n a). Wifi状态更新事件\nWIFI_开头的事件为wifi状态更新事件，data参数仅在WIFI_RSSI有效，data值为RSSI值,数据类型为uint8_t，取值范围0~7。\n b). 控制事件\n与数据点相关,本版本代码会打印相关事件信息，相关数值也一并打印输出，用户只需要做命令的具体执行即可。\n3.代码结构说明\n自动化代码生成工具已经根据用户定义的产品数据点信息，生成了对应的机智云串口协议层代码，用户需要移植代码到自己的工程中，完成设备的接入工作。如图如下：\n \n代码绿色部分的协议逻辑和程序主流程已经帮用户实现，图中用黄色字体注标的部分待用户实现并完成代码的移植。用户的移植分以下几步进行：\na.搭建最小平台工程（必要）。\nb.实现串口驱动（必要）：包括通信与打印功能。\nc.实现定时器驱动（必要）。\nd.实现芯片复位函数（可选）。\ne.实现应用层逻辑开发（必要）：包括数据上下行、入网配置等。\n移植步骤介绍\n下面我们以 MSP430平台的移植 为例来介绍移植步骤。\n1.搭建最小平台工程（必要）\n首先完成目标平台的最小工程搭建，以MSP430为例，我们将通信协议处理的源码文件(Gizwits目录下所有文件)导入到工程中，并将 User目录 下的示例 main.c 文件整合到工程中的主文件中，如下所示：\n/** 用户区当前设备状态结构体*/\ndataPoint_t currentDataPoint;\n\nvoid Sys_Init(void)\n{\n    //关软件看门狗Stop WDT\n\n    WDTCTL = WDTPW + WDTHOLD;\n\n    //设置时钟\n\n    InitClock();\n}\n\n/*************************************************************\n\n** 函数名称: main(void)\n\n** 函数功能: 主函数\n\n*************************************************************/\nvoid main(void)\n{\n    //System space init\n\n    Sys_Init();\n\n    //Gizwits protocol init\n\n    userInit();\n\n    gizwitsInit();\n\n    while (1)\n    {\n        userHandle();\n\n        gizwitsHandle((dataPoint_t *)&currentDataPoint);\n    }\n}\n\n2.实现串口驱动（必要）\nMCU方案需要用户实现一个串口，用于设备MCU与WIFI模组之间数据通信。用户首先需要实现串口接收中断服务函数接口UART_IRQ_FUN（MSP430平台函数接口为：USCI0RX_ISR），该接口调用gizPutData()函数实现串口数据的接收并且写入协议层数据缓冲区。\n下面以MSP430平台为例，本例使用USCI0与模组通信，串口初始化实现如下：\nvoid Sys_Init(void)\n{\n    //关软件看门狗Stop WDT\n\n    WDTCTL = WDTPW + WDTHOLD;\n\n    //设置时钟\n\n    InitClock();\n\n    //串口设置-9600bps\n\n    serial_init(9600);\n\n    cio_printf(\" Start system \\n\"; );\n}\n\n中断服务函数和串口发送报文函数实现如下：\n/*******************************************************************\n\n** 函数名称：void USCI0RX_ISR(void)\n\n** 函数功能：Echo back RXed character, confirm TX buffer is ready first\n\n** 入口参数：无\n\n** 出口参数: 无\n\n********************************************************************/\n\n#pragma vector=USCIAB0RX_VECTOR\n\n__interruptvoid USCI0RX_ISR(void)\n{\n    while (!(IFG2&UCA0TXIFG));   // USCI_A0 TX buffer ready?\n\n    gizPutData((uint8_t *)&UCA0RXBUF,1);\n\n    return;\n}\n\n\n另外，用户需要实现串口的发送接口，uartWrite()函数调用该接口实现设备数据的发送。需要特别注意的是 gizwits_product.c 文件中uartWrite()函数是伪函数，用户需根据自己实现的串口发送接口完善uartWrite()，请注意相关注释信息，以防出错。实现如下：\n/**\n\n* @brief 串口写操作，发送数据到WiFi模组\n\n*\n\n* @param buf      : 数据地址\n\n* @param len       : 数据长度\n\n*\n\n* @return : 正确返回有效数据长度;-1，错误返回\n\n*/\n\nint32_t uartWrite(uint8_t * buf, uint32_t len)\n{\n    uint32_t i = 0;\n\n    if (NULL == buf)\n    {\n        return -1;\n    }\n\n    for (i = 0; i < len; i++)\n    {\n        serial_send_blocking(buf[i]);\n\n        //实现串口发送函数,将buf[i]发送到模组\n\n        if (i >= 2 && buf[i] == 0xFF)\n        {\n\n            //实现串口发送函数,将0x55发送到模组\n\n            serial_send_blocking(0x55);\n        }\n    }\n\n    return len;\n}\n\n注：注意示例中的0x55条件处理，即出现0xFF的数据时后面要加0x55，这个操作一定要保留。\n如果用户需要打印日志调试信息，用户需实现GIZWITS_LOG函数，只需修改 gizwits_protocol.h 中对应的宏定义即可，如下：\n#define GIZWITS_LOG cio_printf  //<运行日志打印\n\n3.实现定时器驱动（必要）\n协议层使用到了一个系统时间，该事件单位为毫秒，所以要求用户实现一个毫秒定时器（必须是1ms精确定时，若不准确，会影响到超时重发、定时上报等处理），并且实现中断服务函数TIMER_IRQ_FUN（MSP430平台函数接口为：Timer_A），该函数调用gizTimerMs()实现协议层系统时间的维护。\n下面以MSP430平台为例，本例使用Timer_A实现时间维护，定时器初始化如下：\nvoid Sys_Init(void)\n{\n    //关软件看门狗Stop WDT\n\n    WDTCTL = WDTPW + WDTHOLD;\n\n    //设置时钟\n\n    InitClock();\n\n    //定时器\n\n    BCSCTL3 |= LFXT1S_2; // Set LFXT1为vol时钟即12kHZ\n\n    CCTL0 |= CCIE;  //设置捕获/比较控制寄存器，CCIE=0x0010，使能捕获比较中断\n\n    CCR0 = 12;  //设置捕获/比较寄存器，初始值为12000，对于ACLK时钟频率为12khz的频率，相当于1s 120相当于1ms\n\n    TA0CTL = TASSEL_1 + TACLR + MC_1; // 设置定时器A控制寄存器，\n\n    //串口设置-9600bps\n\n    serial _init(9600);\n\n    cio_printf(\"Start system \\n\");\n}\n\n中断服务函数实现如下：\n#pragma vector=TIMER0_A0_VECTOR//固定的格式\n\n__interruptvoid Timer_A (void) //定时器A的CC0中断处理程序必须是没有返回值的\n{\n     gizTimerMs();\n}\n\n4.实现芯片复位（可选）\n根据串口协议文档规定，模组可以发送命令复位设备MCU，所以用户需要实现 gizwits_product.c 中的mcuRestart()接口即可。下面以MSP430平台为例，实现如下：\n/**\n\n* @brief MCU复位函数\n\n* @param none\n\n* @return none\n\n*/\n\nvoid mcuRestart(void)\n{\n    ((void (*)(void))0xFFFE)();\n}\n\n至此便完成了平台的移植，后续的配置入网、上下行操作属于应用逻辑开发。\n5.应用逻辑开发\n5.1.数据下行控制\n数据点方式将转换成数据点事件，开发者只需要在 gizwits_product. c 文件的 gizwitsEventProcess ()相应事件下作具体处理即可。\n下面使用MSP430平台，以APP实现控制LED为例，如下：\n/**\n\n* @brief 事件处理接口\n\n* 说明：\n\n* 1.用户可以对WiFi模组状态的变化进行自定义的处理\n\n* 2.用户可以在该函数内添加数据点事件处理逻辑，如调用相关硬件外设的操作接口\n\n* @param[in] info : 事件队列\n\n* @param[in] data : 协议数据\n\n* @param[in] len : 协议数据长度\n\n* @return NULL\n\n* @ref gizwits_protocol.h\n\n*/\n\nint8_t gizwitsEventProcess(eventInfo_t * info, uint8_t * data, uint32_t len)\n{\n    uint8_t i = 0;\n    dataPoint_t * dataPointPtr = (dataPoint_t *)data;\n    moduleStatusInfo_t * wifiData = (moduleStatusInfo_t *)data;\n\n    if ((NULL == info) || (NULL == data))\n    {\n        return -1;\n    }\n\n    for (i = 0; i<info>num; i++)\n    {\n        switch (info > event[i])\n        {\n        caseEVENT_LED_ONOFF:\n\n            currentDataPoint.valueLED_ONOFF = dataPointPtr->valueLED_ONOFF;\n\n            if (0x01 == currentDataPoint.valueLED_ONOFF)\n            {\n                //user handle\n\n                P1OUT |= BIT6;\n            }\n            else\n            {\n                //user handle\n\n                P1OUT &= ~BIT6;\n            }\n\n            break;\n\n        //省略期间代码\n\n        default:\n            break;\n        }\n    }\n\n    return 0;\n}\n\n5.2.数据上行控制\n该工程源码在 Gizwits\\gizwits_product.c 文件的 userHandle() 函数中实现传感器数据采集，并且该函数在while中循环执行，原则上用户只需要关心如何采集数据。\n特别提醒，默认while循环执行速度较快，需要针对不同的需求，用户可调整数据点数据的采集周期和接口实现位置，预防由于传感器数据采集过快引发的不必要的问题（具体可查看STM32 的详解篇）。\n下面使用MSP430平台，以灯的状态赋值为例（ 只读型数据点 的操作会被云端自动生成），如下：\n/**\n\n* 用户数据获取\n\n* 此处需要用户实现除可写数据点之外所有传感器数据的采集,可自行定义采集频率和设计数据过滤算法\n\n* @param none\n\n* @return none\n\n*/\n\nvoid userHandle(void)\n{\n    currentDataPoint.valueLED_ONOFF = 0x01;\n}\n\n5.3.配置入网功能（必要）\n根据串口协议文档规定，MCU可以向模组发送命令使其进入相应的配置模式，所以用户可以调用gizwitsSetMode接口（在 gizwits_protocol.c 中）完成相应的操作（例如按键控制），接口调用说明如下：\n/**\n\n* @brief WiFi配置接口\n\n* 用户可以调用该接口使WiFi模组进入相应的配置模式或者复位模组\n\n* @param[in] mode 配置模式选择：0x0，模组复位;0x01，SoftAp模式;0x02，AirLink模式\n\n* @return 错误命令码\n\n*/\n\nint32_t gizwitsSetMode(uint8_t mode);\n\n5.4.实现模组状态处理功能（可选）\n开发者可以在 gizwits_product. c 文件的 gizwitsEventProcess()函数内获得WIFI状态，并做相应的逻辑处理。\n下面使用MSP430平台为例，添加一个逻辑：当WiFi模块成功连接路由后关闭LED灯，代码中示例如下：\n  case WIFI_CON_ROUTER:\n          P1OUT &= ~BIT6;\n  break;\n\n相关支持\n1)   如果您是开发者\nGoKit是面向智能硬件开发者限量免费开放，注册我们的论坛或关注我们的官方微信均可发起申请即可。\n开发者论坛： http://club.gizwits.com/forum.php\n文档中心： http://docs.gizwits.com/hc/\n2)    如果您是团体\nGizwits针对团体有很多支持计划，您可以和Gizwits联系，快速得到GoKit以及技术支持；\n网站地址： http://www.gizwits.com/about-us\n官方二维码：\n \n"},{"title":"Gokit 2使用指南","url":"/zh-cn/deviceDev/Gokit2使用指南.html","content":"\nGoKit的产品使命\n如果用一句话描述 GoKit 的产品使命,那就是“智能产品开发要像写《hello world》一样简单”。\n智能硬件,或者说大家所讲的物联网,纵向方向涉及到的行业知识很多,从下到上大概有传感器、 MCU、通讯模组(BLE、ZigBee、WiFi 等)、APP、M2M 服务、数据存储、报表分析、数据挖掘、云对接等,往往一个初创团队,没有办法迅速在每个点都投入资源。\n此时,不妨借助一下机智云(GizWits),借助一下机智云提供的 GoKit 原型,这个原型已经打通了上 述的每一个环节,并且开源 GoKit 相关技术和资料,同时也提供了根据这个原型快速开发新产品的方法。\n更重要的是,GizWits也是一个开源社区,创客、团体、厂商等圈内朋友可以一起改变智能硬件圈。\nGoKit 能给您带来什么\n1. 如果您是一个产品经理\n如果您是一个产品经理,您肯定希望快速的完成两件事情,一是做出产品的原型,实现产品初步功能;二是将产品量产,并找到销售渠道;\n第一件事情可以这样玩 GoKit:\n在我们的网页上,参照 GoKit 的模版,用图形化的方式定义您的产品功能;\n下载系统为您的产品生成的 DemoAPP,即可完成对您的产品原型;\n第二件事情可以这样玩 GoKit:\n使用系统按照您的产品定义生成的协议和源码,参考 GoKit 的工程,完成快速产品开发(1-2 天);\n使用 GizWits 提供的开源 APP(含 UI、UE 设计),参考您的产品定义,快速完成 APP 开发(1-2 天);\n通过 GizWits 的合作伙伴,找到合适的生产商,进行产品测试和生产;\n利用 GizWits 提供的 N 种宣传和渠道机会,将您的产品一夜成名;\n2. 如果您是一个APP开发者\n如果您是一个APP开发者,您可能不太熟悉硬件的处理和云端处理，您可以使用GoKit提供的丰富资源,进行APP的开发：\n您可以根据 GoKit 的电机控制功能,开发出电动窗帘的 APP；\n您也可以根据温湿度传感器,开发出家庭的温湿度检测的 APP；\n您也可以自定义 LED 的颜色和亮度,来开发出更多功能的 APP；\n当然,如果您愿意,也可以和GizWits的合作伙伴一起,针对您想实现的产品定制GoKit,合作完成一款优秀的产品。\n3. 如果您是一个嵌入式开发者\n如果您是一个嵌入式开发者,您可能不太了解APP开发以及云端处理,您可以这样玩GoKit：\n在我们的网页上,参照 GoKit 的模版,用图形化的方式定义您的产品功能;\n参考系统生成的协议和源码,以及 GoKit 工程,二次开发 GoKit 并烧写 MCU;\n下载系统为您的产品生成的DemoAPP,即可完成对您的产品发现、控制、远程控制;\n如果您愿意,也可以研究您的产品是如何被APP发现的、如何连接云端的,因为这些基本上都开源;\n4. 如果您就想讲一个故事\n如果您有一个非常好的想法,能讲一个很好的故事,这个故事可以为您找到投资,可以这样玩GoKit：\n您可以参照产品经理的做法快速做出产品原型;\n然后利用 GizWits提供的N 种活动机会,以及 N 种投资、孵化渠道,用 GoKit 原型生动的讲述您的故事;\n故事被认可后,您可以利用GizWits提供的N个生产合作伙伴实现您的故事;\nGoKit 是如何做到的\n1. GoKit背后是一个完整的产品体系\n\n这个体系包含设备、APP、M2M服务、业务服务、以及云对接等各种环节,详细说来,还有很多很多,如果您有兴趣,可以参考我们的论坛:http://club.gizwits.com/。\n2. GoKit在系统中的位置\nGoKit在系统逻辑上,位于右下角的MCU的位置,即：GoKit代表智能硬件。\n\nGoKit 2 开箱\n打开包装后，你可以看到一个黄色纸皮盒包裹着一个透明亚克力盒。里面的板子就是GoKit2代。\n \n\nGoKit 2代，我们把应用板与主控板分离，使用了Arduino标准接口，你现在可以有两个选择，使用标准的STM32主控板或者兼容Arduino的Atmel主控板。如下图：\n\n\n应用板依然板载了正反转可调速电机马达、温湿度传感器、红外感应器、RGB全彩LED灯，另外增加了OLED扩展接口，你可以为GoKit配上一块显示屏。\n\nWiFi模块方面，目前已经有二十几家国内厂商为机智云做了兼容。而且，现在所有开发者都可以拿到开发库自行开发适配。\n玩转Gokit 2\n第一步：下载 IoE Demo App\nIoE Demo是机智云推出的智能硬件调试工具，通过IoE Demo App可以对GoKit进行绑定与远程控制等操作，也可以作为其他基于机智云开发的智能硬件项目的调试工具。\n你可以通过扫描说明书上的黄色二维码下载并安装IoE Demo，也可以进入机智云开发者中心进行下载，前往下载\n为了让开发者更好的掌握客户端开发的技巧，我们提供了IoE Demo的开源版本，前往下载\n第二步：将GoKit连接上网\nGoKit通过WiFi通信模块以无线的方式连接路由器并接入互联网，这里我们需要做的就是把可用WiFi的路由器SSID和密码告诉GoKit（就像你新买的手机需要输入家里的WiFi密码一样）,但GoKit没有键盘和屏幕，如何做到呢？GoKit提供三种配置方式：AirLink 、WebConfig、 SoftAP。下面我们分别学习三种不同的配置方式，大家选一种即可。\nAirLink配置入网\nAirLink配置就是说明书上介绍的方法，实现过程就是：通过按键触发开启设备“AirLink”模式，开启后设备会不断接收特定编码的WiFi广播包，手机连接可用的WiFi网络后，通过指定的App（如IoE Demo）发送编码后的WiFi网络的SSID和密码广播，设备接收到之后自动尝试连接此WiFi网络，连接成功即配置完成。下面一步步完成GoKit通过AirLink接入路由器连接网络吧。（注意：AirLink配置不支持5G的WiFi网络，请使用传统2.4G WiFi信号）\n1）智能手机进入“系统设置”连接您附件可用的WiFi网络。\n2）打开下载好的“IoE Demo” App，点击主屏幕右上角“菜单栏”中的“添加新设备”。如下图\n\n3）使用USB线为GoKit供电，开机后长按［KEY2］3~5秒直到［RGB LED］亮绿灯，表示设备AirLink模式已经开启。如下图\n\n4）IoE Demo APP上输入已连接WiFi的密码，点击配置按钮，等待30秒到一分钟，APP提示配置成功。在此期间，您可以看到GoKit的绿灯熄灭，WiFi模组两个指示灯瞬间熄灭，直到指示灯开始交叉闪烁，这表示GoKit已经连上路由器，配置完成。\n\nSoftAP配置入网\n由于AirLink配置方式有一定的技术限制，GoKit支持另一种配置方式——SoftAP，实现过程就是将GoKit上的WiFi模组切换到AP模式，手机直接与GoKit连接，并将可用的WiFi网络SSID和密码发送给GoKit，GoKit接收到配置信息后自动尝试连接路由器。具体步骤如下：\n1）GoKit正常供电情况下，短按［KEY2］直到［RGB LED］亮红灯，表示GoKit已经初始化。而GoKit在初始状态下将自动进入“SoftAP”模式。\n\n2）手机进入“系统设置”中的“WiFi设置”，找到“XPG-GAgent-XXXX”（XXXX是你的GoKit MAC地址后4位）并连接此WiFi网络，如需密码请输入：123456789 。\n\n3）打开“IoE Demo” App，此时App会自动进入SoftAP配置模式，选择或手动输入你附近的可用WiFi网络SSIS及密码，点击“确定”。\n \n\n4）等待30秒到一分钟，当GoKit上WiFi模组的指示灯交叉闪烁时，表示配置完成。\n第三步：使用IoE Demo控制GoKit\n完成GoKit的网络配置后，GoKit已经通过路由器连接互联网，你可以使用“IoE Demo”对GoKit进行状态的查询以及控制（包括局域网和远程）。\n绑定设备\n确保手机与GoKit连接同一个WiFi网络，打开IoE Demo，刷新设备列表你将可以发现一台未绑定的新设备“微信宠物屋”，如图\n\n点击设备将自动进行绑定，如果你从未注册、登录IoE Demo，GoKit将绑定当前手机，在不更换手机的情况下，你可以对设备进行所有的状态查询与远程控制等功能，更换手机后需要重新在局域网下进行绑定。如果你希望在不同的手机下对GoKit进行控制，可以先注册账号并登录后进行绑定操作，绑定完成后只需使用账号登录，在不同手机都可以对GoKit进行远程控制。\n局域网控制设备\n绑定完成后，设备显示“局域网在线”，点击进入设备界面，即可查看GoKit最新状态以及进行控制操作。\n远程控制设备\n保持GoKit连接，手机关闭WiFi或切换到其他WiFi网络，此时”IoE Demo” App将自动识别网络环境并切换到远程连接模式。\n第四步：使用微信控制GoKit\n微信从5.x版本开始，支持服务号设备功能。通过微信扫描设备二维码关注设备公众号后即可以实现对设备的控制。机智云作为微信设备号首批技术合作伙伴，在GoKit上也加入微信控制的功能，而GoKit也是目前世界上唯一一款开通了服务好设备功能的智能硬件开发板。使用微信控制GoKit具体步骤如下：\n1）打开GoKit附带的说明书，找到一张白色二维码（此二维码每台设备唯一，请注意保管）。如图：\n\n2）打开微信扫描说明书上的二维码，点击“关注”并进入公众号。\n3）点击“窝窝”，公众号将返回你绑定的设备列表。点击进入设备主界面，如图\n\n4）在此界面上你可以看到宠物屋（GoKit）当前的状态，并可以通过点击“送风”或“抽湿”对GoKit上的电机进行控制。\n\n第五步：二次开发\n新版本的DEV SDK同样支持GoKit2，二次开发可参考如下文档：\n\n代码自动生成及二次开发请参考 MCU代码自动生成工具\nSTM32版GoKit2代码介绍请参考 GoKit3(V)源码详解\n暂不支持Arduino版GoKit2。\n\n第六步：开始您的智能硬件开发之旅\n到这里，你已经基本上体验了一款基于GoKit开发的智能硬件原型“微信宠物屋”。这仅仅是机智云团队基于GoKit开发的一款Demo产品，而GoKit本身就是一块功能强大的智能硬件开发板，你可以完全根据自己的想法，利用GoKit做出更好玩的产品，这就是你智能硬件创业的第一步。\n机智云提供“微信宠物屋”整套Demo的开源代码：\n智能宠物屋”MCU源码 for GoKit（1代、2代STM、2代Arduino）\n智能宠物屋”Demo App （iOS、Android）(或在应用商店搜索“机智云”APP，下载体验)\n为了让你更快掌握GoKit的开发，我们提供了一系列的教学视频：\n进入视频教学\n在你开发过程中，会使用到的一系列开发文档：\n进入文档中心\n如果你需要更多机智云的开发工具及其他资源，请前往下载中心：\n进入下载中心\n与全国各地智能硬件开发者交流，请前往机智云开发者社区：\n加入开发者社区\n更多的开发教程请查看社区GoKit开源套件板块\n\nGoKit开源套件 、 Gokit2历代资料(原理图等)整理 、 免费试用申请\n\n有任何疑问或技术支持，请联系我们：\n机智云众创联盟QQ群：104975951\n机智云客服QQ：800099639\n机智云客服热线：400-6525-488\n"},{"title":"HF-LPB100串口烧写说明","url":"/zh-cn/deviceDev/HF-LPB100串口烧写说明.html","content":"概述\n本文针对汉枫HF-LPB100模块进行串口模式烧写流程整理了一篇操作流程。合作厂商在进行模块烧写操作时请依次按照如下步骤进行，否则会产生不可控的错误。\n操作流程\n1.下载HF-LPB100对应的固件\n \n \n2.解压下载的固件包\n  \n解压之后会发现有两个文件，其中一个文件名为带有UART的bin文件为我们所需要的固件。\n \n3.设备连接\n将HF-LPB100模块按照如下原理图进行接线，注意nReload（45号管脚）需要输入低电平，本实验直接接地处理。KEY1实现外部复位功能。\n  \n4.串口设置\n4.1.确认串口参数\n将上述串口连接电脑后，通过“我的电脑”->“管理”-> “设备管理器”->“端口（COM 和LPT）”选项中可以看到相应增加的COM口。\n \n4.2下载串口工具SecureCRT\n下载地址：http://pan.baidu.com/s/1dECLxYD\n下载解压后双击 \n打开SecureCRT，点击快速连接后会弹出串口配置对话框。\n \n \n串口配置协议为Serial，端口为上述2.4.1中的COM口，波特率设置为115200（关键），数据位为8位，停止位为1位，无奇偶校验，最后点击连接。\n连接成功后，在SecureCRT工作区间会有光标闪烁。\n \n5.烧写操作\n5.1.进入烧写模式\n步骤一、当串口连接成功之后，将HF-LPB100进行复位（按下2.3节原理图所示的KEY1后松开）或者给模块重新上电。\n 步骤二、在完成步骤一的同时，迅速连续单击键盘空格键，将会出现如下信息表示模块进入烧写模式。 \n  \n备注：此步骤不易操作实现，需要多次进行试验，当进行进入烧写模式操作始终无法显示上述信息的时候要注意检查串口设置是否正确，待确保串口设置无误后再次进行连接操作。\n上述窗体显示信息中，各命令解释如下： \n\n\n\n命令\n含义\n\n\n\n\nB\n清除所有设置参数，包括出厂参数等\n\n\nF\n升级Firmware；Wi-Fi驱动一般不用升级，如错误擦除这部分，从汉枫官网下载HF-LPB100/HF-LPT100WiFi驱动进行升级。\n\n\nN\n升级Nvram；射频参数部分，无需改动。\n\n\nS\n升级应用程序；SDK等编译出来文件的用此选项升级。\n\n\nG\n执行应用程序。\n\n\n\n注意：‘N’、‘F’、‘S’是模块启动的必须条件，如果其中任何一个无效，模块上电会直接进入升级模式，请小心输入。\n5.2.进行烧写\n \n步骤一、输入“S”升级应用程序，再输入“Y”进入接收固件状态。\n步骤二、当窗体连续打印出“CCC….”后选择”菜单栏” 中“传输”->”发送Xmode(N)”， 选择2节中所示的固件文件，点击发送。\n  \n等待一段时候后，出现如上述信息表示烧写成功。\n"},{"title":"MXCHIP串口烧写说明","url":"/zh-cn/deviceDev/MXCHIP串口烧写说明.html","content":"概述\n本文针对庆科GAgent for MXCHIP模块进行串口模式烧写流程整理了一篇操作流程。合作厂商在进行模块烧写操作时请依次按照如下步骤进行，否则会产生不可控的错误。\n操作流程\n1.下载MXCHIP模块对应的固件\n \n  \n  \n2.确认固件文件\n \n如图所示bin文件为我们所需要的固件。\n3.设备连接\n接线原理图如下，注意PB1管脚需要输入低电平，本实验直接接地处理，KEY1实现外部复位功能。\n  \n4.串口设置\n4.1确认串口参数\n \n将上述开发板连接电脑后，通过“我的电脑”->“管理”-> “设备管理器”->“端口（COM 和LPT）”选项中可以看到相应增加的COM口。\n4.2下载串口工具SecureCRT\n下载地址：http://pan.baidu.com/s/1dECLxYD\n下载解压后双击  打开SecureCRT，点击快速连接后会弹出串口配置对话框。\n \n  \n串口配置协议为Serial，端口为上述2.4.1中的COM口，波特率设置为115200（关键），数据位为8位，停止位为1位，无奇偶校验，最后点击连接。\n5.烧写操作\n5.1、进入烧写模式\n步骤一、当串口连接成功之后，对庆科模块进行复位（按下2.3节中所示的KEY1按键后松开），在SecureCRT工作区间会显示如下信息，表示进入烧写模式，若出现乱码，请重新创建串口连接，或重启SecureCRT，若不出现以下信息，请确认设备连接是否正确。\n  \n5.2、进行烧写\n步骤一、输入“1”后回车 \n \n步骤二、当窗体连续打印出“CCC….”后选择”菜单栏” 中“传输”->”发送Ymodem(D)”， 选择第2节中所示的固件文件，点击添加后再点击确定。\n \n等待一段时候后，出现如上述信息表示烧写成功。\n"},{"title":"STM32CubeMX移植机智云自动生成代码详解","url":"/zh-cn/deviceDev/STM32CubeMX_transplant.html","content":"前言\n本文介绍如何使用STM32CubeMX将机智云自动生成的stm32源码程序移植到其他的MCU平台。\n STM32CubeMX工具请在STM官网注册账号后自行下载安装，本文不做详细说明。\n 本示例使用在机智云自助开发中心生成的STM32F103源码工程，通过STM32Cube 移植到 STM32L496ZGT6 平台（其他STM32平台的移植也与此相似），我们选择的开发板为NUCLEO-L496ZG：\n \n(NUCLEO-L496ZG是ST官方推出的Nucleo系列开发板NUCLEO144系列家族的新品，L4系列综合了低功耗与高性能的优势，其上集成了ST-LINK/V2-1，使用的是STM32L496ZGT6作为主控，具有超低功耗、丰富外设等特性。)\n我们可以通过机智云自动生成工具生成STM32F103平台的工程源码(详情查看文档：GoKit3二次开发-代码自动生成工具介绍)，下面是生成的源码目录结构说明：\n \n\n\n\n文件名\n说明\n\n\n\n\nDriver\n其中包含了所有的库文件\n\n\nGizwits\n机智云协议处理文件\n\n\nHal\n外设驱动文件\n\n\nMDK-ARM\nMDK 的工程文件\n\n\nInc\nSTM32源文件的头文件\n\n\nSrc\nSTM32源文件的 C 文件\n\n\nUtils\n公用工具库文件\n\n\n.mxproject\nSTM32Cube 的配置文件\n\n\nSTM32F103C8.ioc\nSTM32CubeMX 的工程文件(已STM32F103C8平台为例)\n\n\n\n\n注：需要移植的目录为Gizwits、Hal、Utils三个文件。\n\n#移植到其他STM32平台\n 移植分为以下几步：\n1.创建STM32CubeMX 工程文件\n在STM32CubeMX中直接选择您所使用的 MCU（比如这里我们选择STM32L496ZGTx） ，如下：\n \n点击“Project → Setting”设置工程目录位置以及相应参数如下所示：\n \n\n注：这里编译器选择为Keil 5\n\n2.导入机智云模板配置文件\n因为机智云自动生成的源码中已经包含了对应平台的STM32CubeMX工程配置文件，相关驱动参数已经是配置过的，为方便开发者将STM32的源码移植到其他的平台，我们可以使用STM32CubeMX的配置文件导入功能，将STM32F103平台的配置参数导入到STM32L496ZGT6平台，如下：\n选择File > Import Project \n \n选择在“前言”中介绍过的STM32F103C8.ioc配置文件，如下图所示：\n \n点击“OK”之后可以看到，在STM32L496ZGT6的工程中已经导入的机智云预先完成的配置文件了。\n \n \n3.特殊处理（只针对STM32 L系类的低功耗平台，其他平台的开发可跳过此步）\n由于NUCLEO-L496ZG开发板的USB串口默认连接的是MCU上的低功耗串口(LPUART1)，而不是我们在F103平台上的UART1，故将配置中的UART1换为LPUART1，如下图：\n \n\n注：需手动将管脚PG8/PG7设置为LPUART_RX/LPUART_TX类型\n\n \n4.生成工程代码\n点击Project > Generate Code或者点击快捷图标生成工程代码。\n \n5.编译并配置工程\n点击“rebuild”编译工程\n \n点击下载到STM32L496ZGT开发板。如果提示错误，可以点击图标对Option for Target 的Dubug选项进行修改。\n\n注：图上选的是ST-LINK\n\n \n \n点击Settings->Flash Download勾选 Reset and Run选项。这样程序下载后自动启动运行，不用再按一下复位或者重新上电才能运行。\n \n点击“DownLoad”烧录按钮如图所示证明烧录成功：\n \n6.移植代码\n此时的工程中只有STM32L496ZGT相关的驱动代码，若要使用机智云的联网能力就需要移植相关的协议源码（即前文介绍的已自动生成的STM32F103工程中的三个文件：Gizwits、Hal、Utils）\n移植前的STM32L496ZGT工程目录如下：\n \n移植后（即从STM32F103中复制Gizwits、Hal、Utils到STM32L496ZGT下）如下：\n \n接下来我们在STM32L496ZGT的keill5工程中添加如下的目录结构：\n \n同理加入相应的编译路径：\n \n7.添加、修改代码\n首先，为了适配对应的平台应在gizwits_product.h / hal_key.h 中替换为对应平台的头文件，例如：\n将原来F103C8平台的头文件 #include \"stm32f1xx_hal.h\"** 替换为L496ZGT平台的 **#include \"stm32l4xx_it.h\"\n\n注：可以在根目录下的 Drivers\\STM32F1xx_HAL_Driver\\Inc 中找到对应平台的头文件。\n\n接下来在main.c中添加与机智云协议处理相关的代码：\n\n首先是引用的相关头文件：\n\n/* USER CODE BEGIN Includes */\n\n#include \"hal_key.h\"\n#include \"gizwits_product.h\"\n#include \"common.h\"\n\n/* USER CODE END Includes */\n\n\n接下来是相关全局变量：\n\n/* USER CODE BEGIN PV */\n\n/* Private variables ---------------------------------------------------------*/\n#define GPIO_KEY_NUM 2 ///< Defines the total number of key member\nkeyTypedef_t singleKey[GPIO_KEY_NUM]; ///< Defines a single key member array pointer\nkeysTypedef_t keys;   \n\n/* USER CODE END PV */\n\n\n下面是长短按按键回调函数的定义：\n\n/* USER CODE BEGIN 0 */\n\n/**\n* key1 short press handle\n* @param none\n* @return none\n*/\nvoid key1ShortPress(void)\n{\n    GIZWITS_LOG(\"KEY1 PRESS ,Production Mode\\n\");\n    gizwitsSetMode(WIFI_PRODUCTION_TEST);\n}\n\n/**\n* key1 long press handle\n* @param none\n* @return none\n*/\nvoid key1LongPress(void)\n{\n    GIZWITS_LOG(\"KEY1 PRESS LONG ,Wifi Reset\\n\");\n    gizwitsSetMode(WIFI_RESET_MODE);\n\n}\n\n/**\n* key2 short press handle\n* @param none\n* @return none\n*/\nvoid key2ShortPress(void)\n{\n    GIZWITS_LOG(\"KEY2 PRESS ,Soft AP mode\\n\");\n    #if !MODULE_TYPE\n    gizwitsSetMode(WIFI_SOFTAP_MODE);\n    #endif\n}\n\n/**\n* key2 long press handle\n* @param none\n* @return none\n*/\nvoid key2LongPress(void)\n{\n    //AirLink mode\n    GIZWITS_LOG(\"KEY2 PRESS LONG ,AirLink mode\\n\");\n    #if !MODULE_TYPE\n    gizwitsSetMode(WIFI_AIRLINK_MODE);\n    #endif\n}\n\n/**\n* Key init function\n* @param none\n* @return none\n*/\nvoid keyInit(void)\n{\n    singleKey[0] = keyInitOne(NULL, KEY1_GPIO_Port, KEY1_Pin, key1ShortPress, key1LongPress);\n    singleKey[1] = keyInitOne(NULL, KEY2_GPIO_Port, KEY2_Pin, key2ShortPress, key2LongPress);\n    keys.singleKey = (keyTypedef_t *)&singleKey;\n    keyParaInit(&keys); \n}\n\n/* USER CODE END 0 */\n\n\n接下来是对相关驱动模块以及机智云协议模块的初始化：**\n\n  /* USER CODE BEGIN 2 */\n\n    timerInit();\n    uartInit();\n\n    userInit();\n    gizwitsInit();\n    keyInit();\n    GIZWITS_LOG(\"MCU Init Success \\n\");\n\n  /* USER CODE END 2 */\n\n\n最后是在main函数中的循环处理函数调用：\n\n  /* USER CODE BEGIN 3 */\n\n        userHandle();\n        gizwitsHandle((dataPoint_t *)¤tDataPoint);\n  }\n\n  /* USER CODE END 3 */\n\n以下是针对L496ZGT平台的特殊修改，其他非低功耗STM32平台可跳过以下内容\n由于NUCLEO-L496ZG 串口使用了LPUART1，而不是我们在F103平台上的UART1，故需在部分代码。\n将“Gizwits/gizwits_product.c”中的两处 ”huart1” 改为main.c中已自动生成的 ”hlpuart1”\n \n \n7.编译源码烧录测试\n移植完毕相关代码后我们运行编译，编译无错后烧录到NUCLEO-L496ZG开发板。根据CubeMX工程配置文件可知串口波特率为:115200。\n进而我们可以连接日志输出管脚来进一步调试我们的源码。\n\n#进阶开发\n##应用相关开发\n完成STM32相关平台的移植后，我们可以使用机智云提供的各种工具来开发自己的项目，相关介绍请查看机智云文档中心中的Gokit-MCU发开教程等相关章节。\n##驱动相关开发\n当硬件配置需要更改时，可以使用STM32CubeMX进行相关硬件驱动的配置开发，进而最大限度的减少源码上的重复开发，提高开发效率，这里以按键IO配置为例：\n在源码根目录打开对应平台的STM32CubeMX工程文件\n  \n在管脚配置（Pinout）界面修改管脚IO配置，例如将原先的KEY1(PB10)改为PE3，类型为GPIO_Input。\n  \n进入配置选项（Configuration），将新配置的管脚名称与之前的名称保持一致（这样就不需要更改源码中的宏定义），再选择OK\n  \n最后点击源码生成按钮，更新源码中的IO驱动（并不会影响到之前添加的代码）\n  \n由于NUCLEO-L496ZG硬件连接的方式与F103中的方式不同（下拉），要修改部分按键驱动中的程序，在 ” Hal/hal_key.c ”中，将：\n  \n改为：\nif(HAL_GPIO_ReadPin((GPIO_TypeDef\\*)keyS->singleKey[i].keyPort,keyS->singleKey[i].keyGpio))\n\n编译烧录后，测试按键效果。\n#相关支持\n1) 如果您是创客\nGoKit是面向智能硬件开发者限量免费开放，注册我们的论坛或关注我们的官方微信均可发起申请即可。\n官方网站地址：http://site.gizwits.com/developer/activity/gokit/request\n官方二维码：\n  \n2) 如果您是团体\nGizWits针对团体有很多支持计划，您可以和GizWtis联系，快速得到GoKit以及技术支持；\n网站地址：http://www.gizwits.com/about-us\n"},{"title":"ESP8266-SOC快速入门","url":"/zh-cn/deviceDev/UseSOC.html","content":"附件：SOC快速开发LED灯参考代码\n概述\n智能灯，是一个简单常见的智能产品，硬件电路简单，程序本身也不复杂；下面我们使用gokit3（s）开发板和机智云云端，实现如何将一个传统的灯泡，低成本改造成可以远控开关的智能灯。\n下面我们使用GoKit3（S）开发板，基于esp8266模块上的SoC方案，开发的智能灯项目为例，示范一下如何将设备快速接入机智云，实现硬件智能化。\n步骤\n1.准备工作\n硬件：\n1）GoKit3（S）开发板\n2）杜邦线若干\n3）Usb转串口模块，如：ft232、cp2102、ch340均可\n4）Micro USB线\n软件：\n1）Oracle VM VirtualBox\n2）乐鑫官方的esp8266开发环境\n其他：\n1）机智云开发者账号\n2）微信宠物屋 for GoKit3(S) ESP8266 V03000003源码（机智云下载中心可获得）\n3）智能灯项目自动生成SoC源码（请继续查看下述操作，即可生成获得）\n补充说明：\n1）如果没有GoKit3的小伙伴也可以参考GoKit3的原理图基于esp8266模块（模块的Flash必须为4Mbyte，建议模块型号：安信可的esp-12f）自行搭建硬件，原理图链接如下：http://club.gizwits.com/thread-2889-1-1.html\n2）GoKit3（S）购买链接：https://shop159680395.taobao.com/ （机智云官方店）\n2.开始开发\n2.1 注册开发者账号\n机智云开发者账号，用于产品接入、设备管理、OTA服务、MCU开发等的功能使用。\n注册链接：http://dev.gizwits.com/zh-cn/developer/\n2.2新建产品\n注册完成后，登陆至机智云开发者中心后台后，点击开发者中心后台右上角的“创建新产品”菜单，在跳转页面新建一个名为“GizLamp”的产品，选择“Wi-Fi/移动网络方案”方式接入，并完成产品创建。如下图：\n\n\n2.3云端数据点（产品功能点）\n数据点介绍：\n数据点：即设备产品的功能的抽象，用于描述产品功能及其参数。创建数据点后，设备与云端通讯的数据格式即可确定，设备、机智云可以相互识别设备与机智云互联互通的数据。更多的解析和新建指引，可以在开发者中心数据点页面右上角“定义数据点教程”中查看找到帮助，以建立属于你自己产品的数据点，如下图：\n\n新建数据点：\n然后以本次的项目“GizLamp”为例，简单描述一下云端数据点和产品的功能点的关系，本次的项目“GizLamp”，它需要实现的功能是远程开灯和关灯，那我们只需在云端建立一个“布尔值”的数据点即可完成这件事，如下图：\n\n添加数据点完成之后，点击下图的“应用”即可，完成整个产品的数据点的新建工作。\n\n2.4 云端自动生成源码\n2.4.1自动生成工具介绍：\n自动生成代码工具：是机智云为了降低开发者的开发门槛，缩短开发周期，降低开发资源投入，机智云推出了代码自动生成服务。云端会根据产品定义的数据点生成对应产品的设备端代码。自动生成的代码实现了机智云通信协议的解析与封包、传感器数据与通信数据的转换逻辑，并封装成了简单的API，且提供了多种平台的实例代码。当设备收到云端或APP端的数据后，程序会将数据转换成对应的事件并通知到应用层，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，就可以完成产品的开发。使用自动生成的代码开发产品，就不必再处理协议相关的部分了，开发者可以将节省出来的精力集中在产品的核心功能开发上。\n\n关于“自动生成代码工具”的更多介绍和帮助，请点击以下链接： 自动生成代码工具\n\n获取本次（GizLamp）项目，云端自动生成基于esp8266的SoC源码：\n完成产品的数据点新建之后，点击页面的左侧菜单栏的“MCU开发”根据页面提示选择“SOC方案”，目前SOC方案机智云云端默认的“硬件平台”为esp8266，选择完成之后下拉至页面底部，点击“生成代码包”，等待大概30秒左右即可生成基于esp8266的本次项目（GizLamp）代码包，下载下来即可，由于下载下来的文件名过于长，并且在文件名里包含了产品的ProductKey，所以本次项目将下载下来的文件名修改为“GizLamp”如下图：\n\n补充说明：SOC方案自动生成代码工具目前仅支持esp8266。\n2.4.2 项目源码二次开发指引：\n整个云端自动生成的SOC源码里面，用户只需要关心文件路径为“GizLamp\\app”下面的几个地方：\n如果你需要添加8266的外设，只需要在\n\n“GizLamp\\app\\driver”文件目录下添加相应外设的驱动的.c文件\n“GizLamp\\app\\include\\driver”文件目录下添加相应外设的驱动的.h文件\n\nApp通过云端下发控制事件处理，可以在\n\n“GizLamp\\app\\Gizwits”文件目录下“gizwits_product.c”文件里面的\n“gizwitsEventProcess（）函数里添加驱动外设执行事件函数即可实现控制设备\n\n上报云端状态事件处理，可以在\n\n“GizLamp\\app\\user”文件目录下“user_main.c”文件里面的“userTimerFunc（）”函数里添加数据状态上报函数即可以实现状态上报。\n\n在这套SOC源码里面需要关心也就这几个主要的地方，模块联网以及底层驱动均不需要开发者去处理和修改。\n2.4.3 前往机智云下载中心，下载“微信宠物屋 for GoKit3(S) ESP8266 V03000003”SoC源码库\n“微信宠物屋 for GoKit3(S) ESP8266 V03000003”这个是机智云工程师使用GoKit3（S）板，基于esp8266硬件平台写的案例，案例里面包含了红外传感器，温湿度传感器，小电机，RGB灯，用户按键等几个外设的驱动，可以直接复制到任何一个GoKit3（S）的板子上使用，也可以移植至其他的8266板子上去使用，获取源码方式如下图：\n\n\n备注：如需深入了解这个“微信宠物屋”这个实例源码的解析可以参考以下链接：\n微信宠物屋实例源码的解析\n2.4.4 从“微信宠物屋 for GoKit3(S) ESP8266 V03000003”案例中移植“GizLamp”项目所需要的led驱动的.c和.h文件。\n\n将“gokit3_SoC_ESP8266_03000003_2016120711\\app\\driver”文件目录下的\n “hal_rgb_led.c”的c文件复制至“gizlamp\\app\\driver”下\n\n\n\n将“gokit3_SoC_ESP8266_03000003_2016120711\\app\\include\\driver”文件目录下的   “hal_rgb_led.h”的h文件复制至“gizlamp\\app\\include\\driver”下\n\n\n完成以上动作之后就完成SOC文件的准备工作，下面进行修改相应的c文件。\n2.4.5 修改“GizLamp”的SOC源码文件\n这里我使用Sublime软件打开整个工程的，然后需要修改的两个文件，如下：\n\n“GizLamp\\app\\user”文件目录下“user_main.c”文件\n外设的驱动初始化，在这个c文件里面的“user_init（）函数中完成\n\n“GizLamp\\app\\Gizwits”文件目录下“gizwits_product.c”文件\n云端下发的数据，在这个c文件里面的“gizwitsEventProcess（）”函数中处理\n\n\n\n程序修改部分说明如下图：\n\n\n云端自动生成SOC源码的其他说明\n·Key1和Key2这部分的程序是由机智云工程师基于GoKit3（S）完成的，如果用户自行搭建的8266硬件（非GoKit3），则需要修改这部分的程序去驱动用自己的按键GPIO口，用户按键这部分的程序是必需的，它用于使能wifi进入相应的配置模式，然后通过机智云的app（IOE Dome）给wifi模块推送路由器的ssid和password，从而使wifi联网网络，如果没有这个功能，就无法配置wifi模块，从而无法使wifi模块联网。\n-云端自动生成SoC源码里面的用户按键Key1、Key2\n- Key1\n用于reset wifi和使模块进入产测模式\n\nreset wifi -> 长按key1\n\n\n\n进入产测模式 -> 短按key1\n\n\n- Key2\n用于触发模块进入airlink和softap的配置模式\n\nairlink配置模式 -> 长按key2\n\n\n\nsoftap配置模式 -> 短按key2\n\n\n首先在“user_main.c”文件里面添加以下头文件\n\n#include \"driver/hal_rgb_led.h\"\n\n接着在“user init（）”函数里面的“//user init”部分添加以下两条函数，用于初始化GoKit3上面的RGB灯，这两条函数可以在“hal_rgb_led.c”文件里找到。\n\n//LED初始化函数\nrgbGpioInit（）\nrgbLedInit（）;\n@\n\n添加“#include \"driver/hal_rgb_led.h\"”头文件\n\n\n\n\n在“user_main（）”函数里添加rgb灯的驱动函数\n\n\n然后在“gizwits_product.c”文件里面添加以下头文件\n\n#include \"driver/hal_rgb_led.h\"  \n\n接着在“gizwitsEventProcess()”函数里面的“//user handle”部分添加以下函数用于驱动GoKit3上面的RGB灯，使RGB灯开和关的动作；也可以修改rgbControl（）这条函数的参数控制rgb灯的组合色，每一个参数输入范围在“0~254”之间，这条函数可以  在“hal_rgb_led.c”文件里找到。\n\n//LED 控制函数\nrgbControl（0，0，0）;//关灯\nrgbControl（254，254，254）;//开灯\n@\n\n添加“#include \"driver/hal_rgb_led.h\"”头文件\n\n\n\n\n在“gizwitsEventProcess（）”函数添加灯的开关事件\n\n\n完成以上动作之后，进行SoC编译开发环境的搭建，请参考 >> 第6）点\n2.4.6 搭建SoC源码编译开发环境\n\n请参考这里：开发环境准备\n\n\n补充说明：新手入门建议使用virtualbox+乐鑫官方的开发环境，进行二次开发\n2.4.7 SOC源码编译\n\n请参考这里：源码编译\n\n\n2.4.8 固件烧写\n\n请参考这里：固件下载\n\n\n3. 调试与发布\n\n产品调试请参考这里：调试\n\n\n\n产品发布请参考这里：发布产品\n\n\n4. 项目完成\n\n完成以上步骤，整个项目开发就完成了,如果需要关注更多的开源项目以及和其他开发者深度交流，可以到我们公司的官方论坛进行学习：http://club.gizwits.com/forum.php\n\n附加篇：ESP8266-SOC方案UART0教程\n"},{"title":"8051平台最小资源裁剪说明","url":"/zh-cn/deviceDev/approach_to_tailoring_8051.html","content":"前序\n由于8051等型号MCU片上资源有限（以 STC15F2K60S2 为例，SRAM空间大小：2K = 2048字节），当云端定义的产品中数据点较多时会导致编译后的程序剩余内存过少，进而导致串口数据解析异常、程序卡死等情况，故 STC15F2K60S2 平台的数据点长度建议少于20个字节，对应的RAM的使用率需在60%以内。\n对于想进一步降低内存消耗的开发者，我们本文提供一种“资源裁剪最小集”的方式。\n本文档主要说明如何在自动生成的代码基础上裁剪为最小资源集的代码工程，以便节省更多的资源用于应用层的开发或是移植到更低资源的平台（如 SRAM为1K的MCU）。\n在阅读本文档前建议开发者已深入了解机智云MCU版的程序逻辑，请参考：《GoKit-MCU程序详解》一文。本文并不过多讲解MCU程序实现的细节。\n下面是裁剪的相关步骤。\n1 查看当前源码工程资源使用情况\n首先定义相应的数据点：\n接下来生成 STC15F2K60S2 平台的源码工程：\n\n数据点长度的方式：在开发者中心下载《xxx- 机智云独立MCU方案接入通信协议文档》 ,在“3.2 WiFi模组控制设备”中可以看到“attr_flags”+“attr_vals”之和即为数据点长度的总大小（字节）：\n\n\n可以看到占2个字节的数据点长度\n\n编译后的工程 SRAM 占用的大小如下图所示：\n\n\n可以看到定义的数据点所对应的 SRAM 使用量为988字节（ STC15F2K60S2 SRAM总量为2048字节）\n\n如果我们需要进一步降低内存使用率，就要进行资源最小集的裁剪。\n2 裁剪资源到最小集\n2.1 裁剪透传处理代码\n\n去除全局结构体中用于透传处理的结构体成员：\n\n\n\n屏蔽相应的处理代码：\n\n\n\n减少内存（26字节）：\n\n2.2 裁剪”数据点事件处理“代码\n\n去除全局结构体中用于事件处理的结构体成员：\n\n\n\n去除相应的处理逻辑：\n\n\n提示：可以全局搜索关键字，如：issuedProcessEvent\n\n\n\n\n修改P0转事件的处理函数：\n\n\n减少内存（19字节）：\n\n\n裁剪用户区全局P0变量（替换为\"共用协议区全局P0变量\"）：\n\n\n\n\n\n\n屏蔽控制型事件处理相关代码：\n\n\n减少内存（2字节）：\n\n\n在\"P0转事件处理\"函数中添加控制处理逻辑：\n\n\n2.3 裁剪日志打印功能\n对于类似Arduino的mcu平台，使用日志打印时会默认将打印内容存入RAM中，故会暂用大量的内存。\n\n注： STC15F2K60S2 平台并没有此问题，其打印内容会存储在 code 区，即FLASH中，不占用 xdata 区的内存空间。\n\n可以通过屏蔽打印语句或修改重定向宏来关闭日志打印功能：\n\n3 总结\n以上内容通过裁剪透传处理、数据点生成时间处理、用户区全局变量，来达到资源最小集的生成。\n由上文中的裁剪例子我们看到，当只定义一个布尔型的数据点时，协议中的数据点长度如下所示：\n\n\n可以看到占2个字节的数据点长度\n\n\n裁剪后的内存消耗从 988字节 降低到了 941字节 ，共减少了 47字节 的内存使用量。\n\n经测试，当定义20个字节的扩展型数据点时，协议中的数据点长度如下所示：\n\n\n可以看到占21个字节的数据点长度\n我们使用相同的裁剪方式，裁剪后的内存消耗能从 1332字节 降低到了 1248字节 ，共减少了 84字节 的内存使用量。\n\n结论：当定义的数据点越多时，用这种方式节省出的内存越可观。\n"},{"title":" 使用Echo音箱控制GoKit","url":"/zh-cn/deviceDev/echo.html","content":"1.概述\n\n本教程说明了用户使用Gokit除App和微信两种控制方式外第三种控制方式使用说明：Echo音箱控制。\n\n亚马逊Echo音箱：Amazon Echo是一款结合智能人工助理Alexa的音箱。\n\nAlexa：Alexa是Amazon Echo的语音服务提供了功能或技能，使客户能够使用语音以更直观的方式与设备进行交互。 技能的例子包括播放音乐，回答一般问题，设置闹钟或计时器等的能力。\nAlexa Skill：Alexa技能工具包是自助服务API，工具，文档和代码示例的集合，使您能够快速，轻松地向Alexa添加技能。所有代码在云中运行，在任何用户设备上都没有。\n\n机智云在Alexa上发布了两款用来控制Gokit的Skill，名字为“GoKit Light”和“Gokit”\n\n\n\n\n\nSkill名称\nSkill类型\n特点以及局限性\n可控制的功能\n\n\n\n\nGoKit Light\nSmartHomeSkill\n控制时省略了进入Skill的语句，唤醒音箱即可控制，可以设置设备的分组和别名，但只能控制数值和布尔型的数据点\nGokit上的RGB灯的开关与亮度\n\n\nGokit\nCustomSkill\n控制时需要进入Skill的语句，没有分组和别名的概念，但是可扩展性大，可以实现较为复杂的交互功能\nGokit上的RGB灯的开关，灯的颜色（红绿蓝），马达的开关，马达的转速，温度的获取，湿度的获取\n\n\n\n2.准备工作\n硬件：\n\nGokit2 或 Gokit3（可以到官方商城购买，链接：https://59680395.taobao.com/）\n亚马逊Echo音箱\n\n软件：\n\n机智云Gokit APP\n\n\n\n\n\n\n\n\n\n\nIOS\nAndroid\n\n\n\n\nAlexa APP\n\n\n\nAndroid客户端下载链接：http://pan.baidu.com/s/1c2iT2W4\nIOS客户端（需要在美国地区登陆app store搜索alexa下载）\n账号：\n\n机智云账号（在机智云Gokit APP里通过手机注册）\n亚马逊Alexa账号（登陆注册页面：http://alexa.amazon.com/spa/index.html）\n\n3.机智云Gokit配置绑定\n\n打开机智云Gokit app，通过手机注册，并登陆，跳转到“我的设备”页面，并点击“暂无设备，请添加”。\n\n\n\n选择你Gokit上wifi模组的类型，并选择你要配置的网络，输入wi-fi密码，点击“下一步”，长按Gokit上key2，使RGB亮绿灯，则点击“下一步”。\n\n\n\n进入“设备链接网络”的页面，稍等片刻之后，连接成功并跳转到“我的设备”页面，在“发现新设备”一栏中，有一个未绑定的设备，“微信宠物屋”可以通过设置别名来修改，“ACCF2378C44A”为该设备的MAC，点击该设备。\n注：若配置超时则检查路由器是否是在2.4GHz的频段下，路由器是否能连入外网，若配置成功却没有发现到新设备，请检查你Gokit的MCU程序中的product key，是否为出厂自带的product key。\n\n\n\n进入该设备的控制页面，当点击开启红色灯，Gokit的灯能够成功点亮，则说明配置成功了，点击返回到“我的设备”，发现该设备已经在“已绑定设备”一栏，则说明Gokit绑定成功。\n\n\n4.Alexa Echo音箱配置和Skill账号关联\n4.1配置Echo音箱入网\n\nEcho音响配置和AlexaSkill账号关联有通过Alexa App和网页两种方式来实现4.1.1 用AlexaApp来配置Echo音箱\n\n打开AlexaApp，登陆账号，跳转到welcome页面，点击“Begin Setup”，跳转到“Setup”页面，选择你的音响设备，该教程选择Echo Dot。\n\n\n\n选择你的语言，Echo音箱仅支持英语（美式发音），英语（英式发音），德语，点击“Continue”，跳转到下一页面，点击“Connect to Wi-Fi”。\n\n\n\n进入如图下页面，若Echo之前未配过网，则将你的Echo Dot电源插座插上，若Echo之前配过网，则将你的Echo Dot电源插座插上，并长按唤醒键（如该符号所示“⊙”），将会有橙色的光圈在转动，则进入了配网模式，点击“Continue”，跳转到Manually connect to Echo页面。\n\n\n\n打开手机的WiF界面，找到名字为“Amazon-XXX”的WiFi，点击链接，切回AlexaApp，显示已经链接上你的Echo，点击“Continue”。\n\n\n\n在这个页面选择你要将Echo音箱配置到哪个网路，这里选择将Echo音箱配置到“Giziwits”这个局域网内，输入密码，点击“Connect”。\n\n\n\n稍等片刻之后，跳转到Setup Complete，则说明配置成功，点击“Continue”。\n\n\n\n若你的音箱为Echo Dot，则会让你选择如何使用你的Echo Dot，这里选择“No speakers”，就会有个短的宣传视频。若你的音箱为Echo，则直接跳转到宣传视频。\n\n\n4.1.2 用网页来配置Echo音箱\n\n点击进入登陆链接：http://alexa.amazon.com/spa/index.html，输入已注册好的账号和密码。\n\n\n\n进入Alexa配置页面，点击Begin Setup，选择Echo音箱\n\n\n\n\n选择你使用的语言\n\n\n\n点击Connect to Wi-Fi\n\n\n\n当你的音箱旋转橙色光环，即进入配置模式，点击continue\n\n\n\n将你的电脑链接Echo音箱，当Echo音箱进入配置模式时，会发出一个Amazon-XXX的wifi，用电脑进行链接\n\n\n\n链接之后，网页自动切换成该页面，点击Continue\n\n\n\n选择你所要配置的wifi路由器，点击则进入配置，输入密码点击Connet\n\n\n\n稍等片刻后，便配置成功，点击continue。\n\n\n\n4.2        Enable Skill和账号关联\n\nGokit现支持两种skill，一种是名为“GoKit Light”的SmartHomeSkill，另一种是名为“Gokit”的CustomSkill，“GoKit Light”只能控制\n点击左上角菜单栏，左边弹出菜单，点击Skill进入All Skill页面，在搜索栏中搜索“Gokit”或者“gizwits”，点击搜索。\n\n\n\n搜索结果有两个Skill，一个是Smart Home Skill名字为“GoKit Light”，一个Csutom Skill名字为“Gokit”\n\n\n###4.2.1     Gokit Smart home skill使用\n\n点击名为“GoKit Light”的Skill，点击ENABLE，跳转到“Please sign in”的页面，输入在Gokit App下注册的账户，点击“Sign in”。\n\n\n\n之后跳转到一个是否链接你账号的询问，点击yes，跳转至成功页面，显示Alexa已经成功的和“GoKit Light”连上了。\n\n\n\n返回该Skill页面，则弹出“Discover Devices”提示框，保证Gokit在线的情况下，点击DISCOVER DEVICES，弹出正在搜索，稍等片刻。\n\n\n\n进度条结束后，搜索到一个设备，该设备的名字为一串十六进制的MAC地址，切回Gokit App的控制页面，点击右上角菜单，点击设置设备信息。\n\n\n\n在这里可以输入设备的别名和备注，这里输入别名为“Light”，备注也为“Light”，点击“确定”。\n\n\n\n显示设置成功之后，返回上一级页面，进入到设备列表页面，发现设备的名字已经修改成了“Light”。\n\n\n切回Alexa App，重新点击Discover devices，稍等片刻之后，发现Your Devices显示的不是MAC了，显示的是刚刚修改的别名和备注，然后就可以通过附录中的SmartHomeSkill的控制指令表格，来控制Gokit了。\n\n\n\n4.2.2 Gokit Custom skill使用\n\n点击名为“Gokit”的Skill，点击ENABLE，跳转到“Please sign in”的页面，输入在Gokit App下注册的账户，点击“Sign in”。\n\n\n\n之后跳转到一个是否链接你账号的询问，点击yes，跳转至成功页面，显示Alexa已经成功的和“Gokit”连上了。\n\n\n\n回到该Skill的页面，如图下所示，则关联完成，然后就可以通过附录中的CustomSkill的控制指令表格，来控制Gokit了。\n\n\n5.附录\n5.1        “GoKit Light”Skill控制语音指令与结果返回语音\n\n控制例句示范：Alexa,Turn on the light\nAlexa ->用于唤醒Echo\nTrun on the ->打开的控制指令\nLight ->设备别名或者组名\n\n\n\n\n用户控制语音指令\nEcho音箱回复语音\n实际操作效果\n\n\n\n\nAlexa,Turn on the <设备别名>\nOk\nGokit上的RGB灯亮\n\n\nAlexa,Turn off the <设备别名>\nOk\nGokit上的RGB灯灭\n\n\nAlexa,Set <设备别名> to xx percent\nOk\nGokit上的RGB灯亮度设置为xx％\n\n\nAlexa,Decrease <设备别名> to xx percent\nOk\nGokit上的RGB灯亮度减少xx％\n\n\nAlexa,Increase <设备别名> to xx percent\nOk\nGokit上的RGB灯亮度增加xx％\n\n\n\n5.2        “Gokit”Skill控制语音指令与结果返回语音\n\n控制例句示范：Alexa,start Gokit turn on the light\nAlexa ->用于唤醒Echo\nstart Gokit ->用于进入skill，“Gokit”为skill名称\nTurn on the light ->控制指令\n\n\n\n\n用户控制语音指令\n关键词\n音箱回复语音\n实际操作效果\n\n\n\n\nAlexa,Gokit Alexa,start Gokit  Alexa,open Gokit\n-\nWelcome to gokit. I will now receive commands for your device.If you need more help, say help.For a full list of commands, visit the About this Skill page\n进入skill并保持会议模式，提示用户如何控制Gokit，在会议模式中可以直接说控制指令，不用唤醒\n\n\nAlexa,Gokit,turn <关键词> the light  Alexa,Gokit,turn the light <关键词>  Alexa,Gokit,switch <关键词> the light\nOn / off\nThe light is <关键词>\n打开（关闭）Gokit上的RGB灯\n\n\nAlexa,Gokit,<关键词> motor    Alexa,Gokit,make the Gokit motor <关键词>    Alexa,Gokit,turn <关键词> the motor    Alexa,Gokit,fan <关键词>    / Alexa,Gokit,motor <关键词>\nStart / stop / on / off / run / work\nThe motor is now running / The motor has stopped\n运行（停止）Gokit上的马达\n\n\nAlexa,Gokit,<关键词> motor  Alexa,Gokit,motor speed <关键词>  Alexa,Gokit,speed  <关键词> / Alexa,Gokit,<关键词>\nAccelerate / decelerate / down / up / faster / slower\nThe motor speed has increased(decreased) / The motor is already running at top speed(达到最高速度时对其加速) / The motor has stopped and its speed cannot be decreased anymore.(马达停止时对其减速) / Please turn on the motor first before changing the speed.(马达停止时对其加减速)\n加速（减速）Gokit上的马达\n\n\nAlexa,Gokit,<关键词> light Alexa,Gokit,change the <关键词> light\nRed / green / blue\nthe light is <关键词>\n改变Gokit上RGB灯的颜色为红、绿、蓝\n\n\nAlexa,Gokit, <关键词> Alexa,Gokit, tell me the <关键词> Alexa,Gokit, tell me what is the <关键词>\nTemperature / humidity\nThe temperature is xx degree / The humidity is xx percent\n通过Gokit获取当前环境下的温度和湿度\n\n\nAlexa,start Gokit and help\n-\nYou can command your GoKit to turn on the light or motor. You may also ask your GoKit to tell you the humidity and temperature.For a full list of commands, please refer to the Skill card details in the alexa application program.\n帮助用户如何使用该skill并保持会议模式\n\n\n<关键词>\nsee you later / bye-bye / thank bye / goodbye / see you / bye\nThank you for using gizwits skill,Have a nice day!\n需在会议模式中使用，用于结束会议模式\n\n\n\n"},{"title":"GAgent详解","url":"/zh-cn/deviceDev/gagent_info.html","content":"GAgent功能概述\nGAgent主要的作用是数据转发，是设备数据、机智云、应用端（APP）的数据交互桥梁。可将GAgent移植到WiFi模组、GPRS模组、PC端等。目前机智云提供由机智云移植的WiFi模组对应固件有：汉枫 LPB100/ LPB120/ LPT120/ LPT220、乐鑫8266、高通4004 、RealTek 8711AM 、联盛德 TLN13SP01、锐凌微 TinyCon3350-M26、庆科3162等；GPRS模组对应固件有：广和通G510等。\n\nGAgent接入机智云流程\n1.设备上电\n\nA、GAgent请求设备信息 \nB、回复GAgent设备信息 \nC、设备正常工作，需回复GAgent发出的心跳包\nD、GAgent网络状态发生变化通知mcu。\n\n\n2.配置入网\n配置入网：使设备连接路由器，目前主要有3种配网方式airkiss(微信)、airlink、softap。\n\n\n\n3.搜索绑定设备控制设备前必须绑定设备，WIFI普遍采用局域网发现绑定设备方式，而gprs模组由于没有局域网，只能采用扫码绑定。\n\n\n4.下发、上报设备数据\n下发设备数据：一般指的是APP、云端控制设备。局域网内APP可以选择是否经过云端再下发给GAgent或者不经过云端直接下发给GAgent。\n上报设备数据：一般指的是设备主动上报当前状态，当设备MCU收到WiFi模组控制产生的状态变化,设备MCU应立刻主动上报当前状态,发送频率不受限制。但如设备的状态的变化是由于用户触发或环境变化所产生的,其发送的频率不能快于6秒每次。建议按需上报，有特殊上报需求请联系机智云。\n\n\n5.GAgent OTA流程\nGAgent OTA是指通过机智云官网创建远程推送GAgent固件规则后，通知当前模组更新到对应新固件。GAgent OTA有两种触发动作：云端主动通知OTA动作；GAgent连接云端检查是否需要OTA。\n\n\n6.MCU OTA流程\n MCU OTA是指通过机智云官网创建远程推送MCU固件规则后，通知当前MCU更新到对应新固件。MCU OTA过程，即GAgen向MCU进行大文件传输。\n\n7.MCU上传大文件至机智云\n 设备采集的数据过大时，MCU可以通过GAgent向机智云传输大文件。上传到机智云后，可通过相应接口接收。目前APP暂不支持获取MCU上传的大文件。\n\n8.产测流程\n产测主要应用在设备生产检测过程中，对设备检测的一种方法。目前产测适用于WiFi模组，不适用GPRS模组。\n\nGAgent关键策略\n1.重启与重置命令什么时候用？\n当GAgent在正常工作中因为某些因素而长时间无法连接云端，需要重启模组，可以由设备使用者手动重启设备，也可以由MCU主动发送命令重启Wifi模组。此外，GAgent有异常处理策略，当出现异常时，会自动重启。\n重置指擦除GAgent保存的DID、SSID、密码等信息。发送置命命令后，Wifi模组会自行重启。主要应用场景：当设备从A用户转移到B用户，B用户不希望A用户控制设备。\n2.可绑定时间怎么用？\n机智云设备绑定机制：APP与设备在同一局域网，如果GAgent没有设定绑定时间，则任意装有相关APP用户随时都能绑定设备，存在一定安全隐患。设备绑定时间，用户在可绑定时间内可以绑定设备，提高了安全性。\n3.局域网、广域网心跳及离线判断条件。\n局域网：\nAPP与GAgent心跳：4s一次，三次超时离线。\n广域网：\n  APP与云端心跳：55s一次，三次超时离线。\n  GAgent与云端心跳：55s一次，三次超时离线。\n4.WiFi模组配网网络环境要求\n\n.部分WiFi模组无法识别路由器ssid为中文，建议将路由器ssid设置为英文。\n.路由器加密方式建议采用AES加密\n.关闭AP隔离\n\n5.WiFi模组连接路由器策略\n\n.缓存最近一次连接成功的路由热点(不关心是否连接外网成功)\n.使用当前的ssid和pwd连接路由器，失败后立即重试，如果重试超过30S都连接不成功，则尝试连接最近一次连接成功的路由热点（当前热点与最近一次连接成功热点不同）。如果仍然失败，则交替尝试连接当前热点和最近一次成功连接的热点。\n.连接路由超过2分钟，仍然失败时，以STA模式重启模组，重新开始上一步动作。\n.连接成功，当前ssid/pwd和连接成功ssid/pwd更新。\n备注:当前ssid和最近连接成功的ssid可能是同一个\n\n\n\n6.配网策略说明\n\n.收到配置入网命令后，进入配置（softAP/AirLink）模式，等待接收ssid和pwd；\n.成功获取到ssid和pwd，则自动连接路由器，连接路由策略见上；\n.如果使用获取到的ssid和pwd成功连上路由，则发送配置成功包（可能会重启）；\n.airlink超时自动进入softAP配置模式，softAP也超时，才认为是配置超时退出；\n.获取ssid/pwd超时退出，则连接最近一次连接成功的路由热点，连接路由策略见上；\n.若没有缓存热点，则进入无网模式（STA & disconnect）。无网模式不保存，下次启动后不进入无网模式。\n\n7.上电入网策略\n\n.上电后，若没有指定工作模式，则以STA模式启动，自动连接路由器，连接路由器策略见上；\n.如果没有ssid信息，则进入softAP配置模式，配置策略见上；\n\n8.掉线重连策略\n\n.在连接路由正常情况下，掉线后立即重连。\n.若连接失败，第一次立即重连，之后每次重连间隔每次累加10秒，即10秒，20秒，30秒……。\n.连接10次仍然失败时，重新通过机智云获取设备连接域名。获取域名成功后，进行DNS解析\n.解析成功后，若ip地址相较之前ip有变化，立即重连云端，重连时间从0开始重新累加。\n.解析成功后，若ip地址相较之前ip无变化，继续按照之前的重连间隔进行累加重连；\n.当重连间隔增加到10分钟时，不再累加，以后每次重连间隔保持在10分钟；\n.累积1个小时没连上云端，则重启（无小循环连接情况下，2分钟后重启）\n.如果连接路由器不成功，不尝试重连云端。\n.恢复连接路由器后，立即重连云端，重连时间从0开始。\n.若连接失败，遵循上面连接路由正常的重连策略。\n\n\n备注:云端掉线的重启策略可定制，需要考虑小循环的优先级。若小循环优先级高，云端掉线重启理解重启；若小循环优先级中，云端掉线重启仅在无小循环客户端连接持续10分钟的情况下重连；若小循环优先级低，云端掉线重启可以立即重启。\n\n9.路由断连恢复策略\n\n.路由断连后，模组进入本地模式（小循环、大循环不可用）；\n.重连路由成功后进入正常工作模式（小循环、大循环可用），重启小循环服务，重启大循环服务；\n.断开路由连接超过2分钟仍然没有恢复路由器连接，模组重启自身。\n\n10.OTA策略\nGAgent OTA：包括下载、存储、校验、更新4个过程。\n\n.下载：获取下载链接并判断是否需要下载（硬件版本号一致，软件版本号大于当前软件版本号），进行下载，目前不支持断点续传。下载失败后不再下载。\n.存储：下载过程中进行分片存储到flash中缓存区域\n.校验：进行md5值校验，确认文件传输正确\n.更新：有主、备两个区域。替换进行更新，确认如果更新失败，程序仍然可以从另一区域正常启动。\n\nMCU OTA：包括下载、存储、校验、传输4个过程。\n\n.下载、存储、校验同GAgent OTA一样；\n.传输：通知MCU有固件传输，并分片传输给MCU，每片需要进行sum校验，传输完成后mcu需要进行md5校验。MCU成功后重启GAgent，以让GAgent重新握手获取更新后的MCU信息。\n\n11.云端OTA通知推送\n云端只会给当时在线设备推送；对于当时不在线，或者没升级成功的设备，云端会每天推送一次\n12.GPRS模组流量的基本要求\n设备与机智云数据交互主要采用MQTT协议。设备与机智云数据交互的最小数据量是设备与机智云通讯的心跳。mqtt心跳是2个字节，tcp协议头是40字节，50秒一次，需要包括心跳和心跳回复。所以每50秒流量是：（40+2）*2=84 Bytes。一个月按30天算流量大概是：4252K。所以GPRS模组至少需要每个月有4252K流量，以保证GPRS可以正常上网。\n"},{"title":"机智云串口工具使用文档","url":"/zh-cn/deviceDev/串口工具使用文档.html","content":"准备工作\n1.申请企业帐号并创建企业项目\n使用机智云串口工具需要先在机智云开发者中心创建产品，请参考这里。\n2.下载机智云测试APP\n \n3.正确烧录Gagent固件\n以ESP8266为例，在进行下面步骤的时候需要正确烧录机智云wifi固件\n此步骤请参考：ESP8266串口烧写说明\n4.将模组连接上电脑\n按照以下原理图设计好硬件原理图，并用USB转串口工具将模组连接上电脑。\n  \n5.下载机智云串口调试助手\n下载地址：https://download.gizwits.com/zh-cn/p/98/119\n6.配置串口工具\n  \n在机智云开发者中心找到项目对应的productkey，并填写到串口工具对应的位置。\n \n串口工具界面说明\n1.主界面说明\n \n2.指令界面说明\n \n3.参数界面说明\n \n配置模组入网\n1.模组首次上电\n如图所示，ESP8266模组首次上电将会在串口工具接收框内打印如下信息。\n \n2.打开“机智云APP”\n \n3.注册帐号并登录\n此处可以使用手机号码注册帐号登录或者直接点击“跳过”，进行下一步操作\n  \n4.点击添加设备\n \n5.输入路由器的ssid名称和密码\n选择对应的模组型号，这里默认选择乐鑫，并在app上输入你手机连接的路由器的ssid名称和密码，点击下一步。\n \n6.发送进入Airlink命令\n点击指令界面的Airlink，电脑模拟MCU会发送一条命令通知模组进入Airlink模式。\n \n下图为Wifi模组进入Airlink后输出信息。\n \n7.APP发送配置信息\n上述步骤完成后在app上“已完成上述操作”打勾，点击下一步。\n  \n此时app会发出配置包，并提示正在搜索设备。\n  \n8.配置成功\n注意观察串口工具接收窗口，当输出以下两条命令的时候，表示Wifi模组成功接收到了手机发送的配置信息，而且成功连接了路由器，并连接上了云端。\n \nWifi模组成功连接上路由器后，会广播配置成功包，此时app接收到配置成功包后会返回设备列表界面并显示出该设备。\n \n控制设备\n1.进入控制页面\n 点击APP上显示的设备，将进入设备控制页面。\n \n2.发送控制命令\n点击APP界面上“开启/关闭红色灯”控件，将下发控制红色灯的控制命令。\n \n3.成功控制\n当看到串口工具中出现以下命令，表示APP成功控制设备\n \n4.上报数据\n将串口工具中红外探测改为“1”，点击上报数据，模拟MCU将主动上报设备状态。\n \nAPP收到上报的数据后，显示“红外探测”被打开，模拟mcu主动向APP上报数据成功。\n \n"},{"title":"产测工具使用文档","url":"/zh-cn/deviceDev/产测工具使用文档.html","content":"产测简介\n产测是生产环节中重要的部分，保证了产品的质量，提升自身产品形象。机智云产测工具为批量生产的产品提供了方便快捷的模块与MCU产测方式。在大型生产时，保证模块与MCU可正常使用。\n该文档为产测使用流程，硬件如何开启产测模式请参考产品开发资源中MCU开发资源文档。\n产测前准备\n1.生成产测文件\n   \n产品上架后，在产品服务中点击“添加配置文件”。\n \n输入配置名称后，点击“添加步骤”添加需要进行的产测步骤，产测数据点为设备定义数据点。每点击一次“添加步骤”可以添加一个数据点步骤。指令添加完成后点击保存，会生成一个产测文件。\n注意：\n当产测步骤的数据点为只读类型数据点时，如故障报警，红外监测，温度监测等数据点，需要先配置相应设备环境，触发设备产生相应状态，才能产测成功，否则产测必定失败。（如添加红外监测开启，那么需要先配置设备所处环境，在该环境下能触发设备的红外监测开启）。\n \n2.下载产测app\n在产测文件下方点击“产测App下载”即可扫码下载App至手机中。（产测App只提供android版本）\n  \n3.下载产测文件\n   \n打开产测app后，点击下载配置文件会弹出二维码扫描框，点开设备产品配置文件下载，扫描二维码，手机端即可得到产测文件。\n \n  \n界面说明：\n\n\n\n栏目名称\n说明\n\n\n\n\n文件名称\n此次扫码下载的产测配置文件名称\n\n\n产品名称\n产测的设备名称，后面为产品的Product Key\n\n\n测试版本\n此次产测配置文件的版本\n\n\n步骤、数据点、指令\n产测需要执行的步骤\n\n\n\n4.搭建路由器环境\n4.1.路由器允许转发局域网内的广播包，不能勾选“AP隔离”选项。\n4.2.路由器要用2.4GHz的频段。\n4.3.路由器不能对2415，12414，12416这三个端口的访问加以限制。\n4.4.厂测之前需要配置路由器的信息，按照如下信息配置：\n\n\n\nSSID\nGIZWITS_TEST_1（或者GIZWITS_TEST_2）\n\n\n\n\nPassword\nGIZWITS_TEST_PASS\n\n\n加密方式\nWPA2PSK\n\n\n\n在产测过程中可以使用两个路由器来进行测试，分别设置ssid为GIZWITS_TEST_1或者GIZWITS_TEST_2，密码一致。测试过程中，模组会随机连接两个路由器，提高产测效率。\n4.5.产测路由器不能处于级联模式，必须使用独立路由器进行产测。\n开始产测\n把设备配置成厂测模式，这时候设备的wifi模组会自动连上GIZWITS_TEST_1或者GIZWITS_TEST_2路由器。装有厂测APP的手机也需要连到这个路由器。\n  \n点击app端开始测试按钮，进入产测状态，界面显示正在搜索设备。当有设备被发现的时候，将对设备进行测试。\n \n界面上方显示总发现设备数，测试成功设备数，测试失败的设备数。\n测试设备列表中依次显示的设备顺序为：测试中的设备、待测试的设备、失败的设备、成功的设备。\n点击查看，可以看到具体的测试内容：\n  \n点击停止按钮，将出现弹框提示，并结束本次测试，保存测试结果。\n \n查看产测结果日志\n  \n停止产测后，打开app菜单栏，选择测试报告选项，可查看历史测试报告。测试报告的名字为测试的时间，最新测试的结果排在最前面。\n \n测试报告中可查看本次测试的合格产品和不合格产品数量以及MAC地址。\n长按相应的栏目可以删除单条记录：\n  \n点击菜单可选择删除全部记录。\n点击对应的栏目，可以看到具体测试的设备，失败的设备优先排列在最前面。\n点击查看可以看到具体的测试内容。\n \n常见问题\n1.产测路由器需要连接外网么？\n解答：不需要，路由器接不接外网都可以测试。\n2.产测结果提示“执行失败”可能的原因是什么？\n解答：\n2.1、提示“等待设备可控，执行失败”，出现这条结果表示设备可能还未准备好，可以点击“重测”按钮来对产品进行重新测试，如果再次出现这个问题，可重启设备后再进行测试，如果还是出现这个错误，则表示该设备不通过测试。\n2.2、提示“第XX步，…… 执行失败”，出现这条结果的原因是因为APP向设备下发控制指令后，没有收到设备主动上报的数据，导致测试失败。可以点击重测来进行重新测试。\n3.扫码下载配置文件提示失败？\n解答：扫码下载配置文件的过程中需要手机能连接互联网，并且网络状态良好，可稍候重新扫码测试。\n4.测试过程中设备成功连接上了产测路由器，APP无法发现设备进行测试。\n解答：出现这个原因需要测试网络环境能否收发UDP广播包，具体方法如下：\n4.1.手机安装机智云DEMO APP，下载链接\n4.2.将手机WiFi网络链接到测试网络环境中，并且查看手机在该网络环境中的IP地址。如下图：\n  \n \n4.3.安装wireshark抓包工具，下载链接\n4.4.打开wireshark工具，按照下图指引设置。\n  \n4.5.    设置wireshark后，Wireshark跳转到抓包界面，打开机智云Demo APP。\n4.6.对wireshark抓包条件设置过滤，如下图：\n \n4.7.参考上图中设置，等待数分钟（等待期间，可以点击机智云Demo APP的设备列表刷新功能），如果可以看到Destination：255.255.255.255的数据包，则说明该测试网络环境具备UDP广播包的传输条件。如果没有，则说明该环境不具备UDP广播包的传输条件。\n"},{"title":"设备接入FAQ","url":"/zh-cn/deviceDev/设备接入FAQ.html","content":"1、概述\n本文列举了开发者在使用设备接入、MCU自动生成或者使用机智云开发板（Gokit）的时候所遇到的一些问题以及解答方案。\n2、FAQ\nQ：AirLink是什么意思，如何解释\nA： 机智云推出的实现 Onboarding 的一套技术名称，兼容了多个 Wi-Fi 模块厂商的 Smart-Config 协议以及一套良好用户体验的标准 Onboarding 操作流程，机智云的 Wi-Fi设备接入SDK 已经内置 AirLink 技术。\nQ：微信的AirKiss跟你们的AirLink有什么区别\nA：AirKiss是微信硬件平台提供的WIFI设备快速入网配置技术，AirLink是机智云提供的WIFI设备快速入网配置技术。从技术的角度上说，两者都是通过包含特定信息的UDP广播的方式使Wi-Fi模块配置连    上路由器，但二者支持的Wi-Fi模块有所差别。目前来说，机智云可提供支持AirKiss或AirLink的GAgent给开发者使用。\nQ：WIFI设备可以配置多个路由器么\nA：可以，不过GAgent里面只能保存一组SSID和Password，如果再次配置则会覆盖之前所配置的路由器\nQ：SoftAp配网的时候，模块的Ap密码是什么\nA：烧写了GAgent固件的模块，或者使用机智云协议的模块，AP模式的SSID均为”XPG-GAgent-xxxx”，其中”xxxx”为Wi-Fi模块的物理地址后四位，初始密码为”123456789”。\nQ：机智云现在支持什么模块？\nA：支持市面上LoRa/GPRS/WiFi/NB-IoT等主流模块。\n所需要的GAgent固件可以在下载中心（http://site.gizwits.com/zhcn/developer/resource/hardware?type=GAgent）上下载，烧写固件后则可正常接入机智云。\n目前提供以下种类的标准固件可供下载：\nWifi类有：乐鑫ESP8266、汉枫 LPB100/ LPB120/LPT120/ LPT220、高通QCA4004、瑞昱RealTek8711AM、联盛德 TLN13SP01、锐凌微 TinyCon3350-M26、庆科3162。\nGPRS类有：广和通G510。\nNB-IoT类有：高通MDM9206（BG60）。\n联系官方客服，签署相关协议后，可获得通信协议，源代码等资源，开发属于自己模块的GAgent。\nQ：机智云硬件与云端通信协议是什么\nA：机智云通过 M2M 服务器使用 MQTT 协议，把 APP 的设备控制命令转发到设备上，把设备数据转发到 APP 上。\nQ： 如何 下载程序到 GoKit上\nA：需要根据不同底板选择不同的下载方式，ST 底板有串口下载和 Jlink 下载 2 种方式；Arduino 底板是通过串口下载的。详细操作链接如下：\nST 底板：http://club.gizwits.com/forum.php?mod=viewthread&tid=259\nArduino 底板：http://club.gizwits.com/forum.php?mod=viewthread&tid=258\nQ：虚拟设备调试成功后，怎样开发自己的mcu？\nA：\n\n1.mcu通过串口连接已烧写机智云GAgent固件的Wi-Fi模块。\n2.根据机智云官网生成的自己产品的《XXX机智云接入串口通信协议文档》实现与Wi-Fi模块的通信。\n3.使用机智云App测试自己的MCU。\n\nQ：产品生成的MCU串口协议文档在哪里？\nA：《XXX机智云接入串口通信协议文档》是根据该产品数据点生成的，生成之前请创建数据点之后再进行生成：\n\n1.左侧产品管理页面\n2.点击产品开发资源，页面中间MCU 开发资源\n3.点击产品的《机智云接入串口通信协议文档》下载\n4.按文档要求开发MCU，则可与Wi-Fi模块及云端进行通信了。\n\nQ：如何使用自有电路板与WiFi模块连接\nA：WiFi 模块是通过串口与底板 MCU 通信的，所以只需要找到 WiFi 模块的串口引脚就可以连接到任意板子上\nQ： gokit2 代上 stm32 软件是基于 mdk 哪个版本开发的\nA：基于 Keil uVision5，目前使用 5.12 和 5.14 没有问题。\nQ：设备如何无按键配网？\nA：目前Gagent如果没有连接过路由器，或者重置过，打印Gagent日志就会发现，WiFi模块上电以后会自动进入airlink，无超时；如果想要进入softap，可以创建定时器，例如Airlink持续一分钟无配网，就进入softap。只要知道模组处于什么配网模式，就可以做到无按键配网\nQ：gokit烧写自动生成mcu代码，按key2不亮绿/红灯，不能配网？\nA：没有添加RGB灯驱动程序，所以RGB灯不会亮，但是可以通过抓取模组日志看到，实际上模组已经进入配网模式，并不影响正常配网。\n"},{"title":"设备接入准备工作以及向导","url":"/zh-cn/deviceDev/设备接入准备工作及向导.html","content":"概述\n本文为主要简单介绍了机智云设备接入的准备工作、MCU代码自动生成工具的使用、通讯模组的烧写和日志打印的方法，以及开源套件Gokit的相关资料等。\n机智云设备接入资源简述\n机智云现提供MCU和SOC两种版本的GAgent通讯协议，MCU版需要通过《机智云串口通讯协议》来实现通讯协议的解析与封包、传感器数据与通信数据的转换逻辑，而SOC版本是直接在WIFI模组上进行开发，故没有MCU这个概念。\n\n1. 设备快速接入机智云\n为了让开发者快速了解我们设备接入的流程，我们提供了基于开源套件Gokit编写的MCU和SOC两套方案的快速接入教程，两套教程都以智能灯为案例\n\n注：设备接入并非必须使用Gokit套件\n\n\nMCU方案快速接入教程\n\nSOC方案快速接入教程\n\n\n2.GAgent通讯模组使用教程\nGAgent主要的作用是数据转发，是设备数据、机智云、应用端（APP）的数据交互桥梁。\n为了适应不同通讯模组接入机智云，我们提供了多个模组的烧写方法以及日志打印的方法，以确保GAgent固件在模组里正常运行。\n\n注：合作厂商在进行模块烧写操作时请依次按照如下步骤进行，否则会产生不可控的错误\n\n\nGAgent详细介绍\nHF-LPB100串口烧写说明\nHF-LPT120串口烧写说明\nMXCHIP串口烧写说明\nESP8266串口烧写说明\n广和通G510模组烧写说明\n通讯模组调试日志获取教程\n\n3.MCU代码自动生成服务介绍\n为了降低开发者的开发门槛，缩短开发周期，降低开发资源投入，机智云推出了代码自动生成服务。云端会根据产品定义的数据点生成对应产品的设备端代码。\n\n代码自动生成工具介绍以及使用教程\nMCU SDK 通用平台版移植说明\n\n4.开源套件Gokit资料\n为了让开发者更快的体验到机智云的云服务，我们提供了开源套件Gokit来供开发者学习、参考，借此让开发者自己的产品更快接入机智云。\n\nGokit2 使用指南\nGokit3系列开发套件简介\nGokit3硬件手册\nGokit3(S)使用说明书\nGokit3(S)开发套件介绍\nGokit3(S)开发环境搭建\nGokit3(S)程序详解\n\n5.ArduinoUnoWIFI接入教程\n\nArduinoUNOWIFI接入机智云介绍\nArduinoUNOWiFi 之ESP8266固件烧写教程\nArduinoUNOWiFi SDK之API介绍\nArduinoUNOWiFi智能小夜灯\n\n6.更多设备接入指南\n\nECE Demo开发教程\n机智云串口工具使用文档\n\n准备工作\n1、创建产品\n\n\n选择产品分类以及输入产品名称，根据你的产品选择合适的技术方案和通讯方式，数据传输方式根据项目的需求可选择定长和变长\n\n创建产品后可以在产品信息-基本信息看到你项目的基本属性，其中product key是产品标识码，作为你产品的唯一标识，procduct secret是产品密钥，用于确认用户的身份和使用权限，自动生成代码中需要使用该密钥\n\n\n2、 定义数据点\n\n创建数据点，详细数据点创建方法请点击（跳转链接）\n\n\n3、下载MCU串口通讯协议以及SOC接入协议\n\n进入开发向导，根据项目需求下载所需要的通讯协议文档\n注：若数据点改变了，通讯协议需要重新下载\n\n\n\n\n"},{"title":"通讯模组调试日志抓取教程","url":"/zh-cn/deviceDev/通讯模组调试日志抓取教程.html","content":"概述\n本文档介绍了如何获取Wifi模组的调试日志。\n当在使用机智云Wifi模组进行调试的时候，如果出现一些不可控的错误，可以按照如下步骤获取相应的日志信息提供给机智云技术团队分析定位问题。\n如何获取Wifi模组日志\n1.获取乐鑫ESP 8266 Gagent日志\n以下步骤以乐鑫ESP-12S为例：\n步骤一、按照下图所示为乐鑫ESP-12S的管脚定义图，将图中所示的GPIO2（UART1_TXD）（芯片调试日志信息输出口）通过USB转串口工具连接到电脑，并记录相应的com口\n  \n步骤二、下载友善串口助手\n下载地址：http://pan.baidu.com/s/1o8ER3yM\n下载解压后安装并打开软件，按照如图所示的配置选择步骤一中记录的com口，并填写波特率74880 ，并选择ASCII，点击开启按钮。\n  \n步骤四、此时串口工具的窗口将会出现日志的内容\n \n步骤五、将日志内容全选后保存在一个txt文件中发给机智云FAE团队\n2.获取汉枫LPB100 Gagent日志\n步骤一：按照下图所示为汉枫LPB100的管脚定义图，将图中所示的8号管脚（UART1_TXD）（芯片调试日志信息输出口）通过USB转串口工具连接到电脑，并记录相应的com口\n \n步骤二至步骤五参考第1节中所列步骤，串口工具选择的波特率为57600。\n3.    获取汉枫LPB120 Gagent日志\n步骤一：按照下图所示为乐鑫LPB120的管脚定义图，将图中所示的26号管脚（UART1_TXD）（芯片调试日志信息输出口）通过USB转串口工具连接到电脑，并记录相应的com口\n \n步骤二至步骤五参考第1节所列步骤，串口工具选择的波特率为115200。\n4.    获取广和通G510 Gagent日志\n步骤一：按照下图所示为广和通G510的管脚定义图，将图中所示的19号管脚（UART1_TXD）（芯片调试日志信息输出口）通过USB转串口工具连接到电脑，并记录相应的com口\n \n步骤二至步骤五参考第1节所列步骤，串口工具选择的波特率为115200。\n注意：G510模块供电官方推荐使用4V\n"},{"title":"模块硬件资料","url":"/zh-cn/module_source/module_source.html","content":"一、模块Datasheet\n1.WIFI模块Datasheet，硬件介绍\n\n乐鑫模块系列(esp8266各型号用同一datasheet)\n\n\nesp8266-07s Datasheet\nesp8266-12f Datasheet\nesp8266-12s Datasheet\n\n汉枫模块系列\n\n\nHFLPB100 Datasheet\nHFLPB120 Datasheet\nHFLPT120 Datasheet\nHFLPT220 Datasheet\n2.GPRS模块的Datasheet，硬件介绍\n\n广和通模块系列\n\n\nG510 Datasheet\n\n锐凌微模块系列\n\n\nTinyCon3350-M26 Datasheet\n二、模块资源\n\n乐鑫模块系列\n\n\nESP8266串口烧写说明\n获取乐鑫ESP 8266 Gagent日志\nGAgent for ESP8266 04020025下载\n\n汉枫模块系列\n\n\n1.HF-LPB100\nHF-LPB100串口烧写说明\n获取汉枫LPB100 Gagent日志\nGAgent for HF LPB100 04020022下载\n2.HF-LPB120/LPT120\nHF-LPB120/HF-LPT120串口烧写说明\n获取汉枫LPB120/LPT120 Gagent日志\nGAgent for HFLPT120/LPB120/LPT220 04020025下载\n\n广和通模块系列\n\n\n广和通G510模组烧写方法\n获取广和通G510 Gagent日志\nGAgent for 广和通Fibocom G510 04020027下载\n\n锐凌微模块系列\n\n\n锐凌微TinyCon3350-M26须原厂烧写固件\n获取锐凌微TinyCon3350-M26 Gagent日志（近期推出）\nGAgent for 锐凌微 TinyCon3350-M26 04020018\n"},{"title":"平台概述","url":"/zh-cn/overview/overview.html","content":"专题热点 、 本周热门下载 、 视频教程\n机智云平台概述\n1 机智云平台概述\n机智云平台是机智云物联网公司经过多年行业内的耕耘及对物联网行业的深刻理解，而推出的面向个人、企业开发者的一站式智能硬件开发及云服务平台。平台提供了从定义产品、设备端开发调试、应用开发、产测、云端开发、运营管理、数据服务等覆盖智能硬件接入到运营管理全生命周期服务的能力。\n机智云平台为开发者提供了自助式智能硬件开发工具与开放的云端服务。通过傻瓜化的自助工具、完善的SDK与API服务能力最大限度降低了物联网硬件开发的技术门槛，降低开发者的研发成本，提升开发者的产品投产速度，帮助开发者进行硬件智能化升级，更好的连接、服务最终消费者。\n\n2 机智云平台架构\n\n3 机智云优势\n1)高可用平台\n\nSLA 99.99%\nEB级海量数据支持\n弹性可伸缩架构\n\n2)快速接入\n\n0.5天快速接入\n提供每个开发环节的SDK\n提供自动生成代码工具\n提供ECE能力，通过云端配置脚本自动适配私有协议\n提供行业完整解决方案\n\n3)专业服务\n\n专业傻瓜工具支持\n专业方案架构团队支持\n专业运维支持\n\n4)行业积累深厚\n\n10000+企业客户验证\n80W + 全球IoT开发者\n\n5)安全性\n\n遵循X.509 证书标准\n企业数据云端加密存储\n关键业务数据加密\n专业安全公司渗透测试\n遵循ISO27000系列安全管理规范\n\n6)多层次云端数据服务\n\n消息代理服务: 按需订阅企业设备数据\n企业API：提供设备控制、设备管理、设备位置服务、设备数据等服务\nD3 Engine：灵活、强大的数据编排引擎\n\n7)开放性\n\n全球最开放的物联网自助开发平台\n开放互联AWS ECHO、微信、JD、Nest、苹果HomeKit、苏宁云等各大平台\n\n8)国际化\n\n全球覆盖: 在国内、欧洲、美洲、东南亚建立独立数据中心与云平台，能覆盖客户全球大部分国家与地区的设备、用户接入\n智能连接: 提供设备自动适配就近云服务能力\n\n4 机智云全球服务器部署\n1).广州、深圳、广西、湖南、福建等城市/地区的网络响应速度均小于20ms（即0.02秒）；国内其他城市/地区的网络响应时间总体小于40ms（即0.04秒）；新加坡、马来西亚、印度尼西亚等城市/地区均小于20ms（即0.02秒）；亚洲其他城市/地区小于70ms（即0.07秒）。\n\n2).中东地区响应速度均小于70ms（即0.07秒）；大洋洲的平均在98ms左右；非洲的平均为150ms左右（即0.15秒）；总体较为良好。\n\n3).欧洲等地区的网络响应时间总体小于40ms（即0.04秒）。\n\n4).北美洲等地区的网络响应时间总体小于40ms（即0.04秒）；南美洲的城市/地区响应速度平均146ms（即0.146秒）;总体相对较为良好。\n\n（PS：由于网络的不稳定性，即存在一定小范围的响应速度误差）\n快速入门\n五分钟了解机智云\n\n五分钟了解机智云\n机智云名词定义解释快速接入向导\n\n\n应用开发（App、微信）\n机智云提供了APP SDK、开源框架、微信SDK，便于开发者快速构建手机应用端系统，只需根据工具指引实现业务功能，无需实现底层功能。\n1.App开发准备工作及向导\n\nApp开发准备工作及向导\n\n2.APP代码自动生成服务介绍\n\nAPP代码自动生成服务介绍\n\n3.App 开源框架\n\nIOS开源框架说明（含源码）\nIOS消息推送\nIOS第三方登录与换肤\nIOS开源框架的快速开发实例\nAndroid 开源框架说明（含源码）\nAndroid 消息推送\nAndroid 第三方登录与换肤\nAndroid 开源框架的快速开发实例\nAPICloud 开源框架使用指南（含源码）\n\n4.App 开发 SDK 接入\n使用SDK，可以使得开发者快速完成APP开发，开发者仅需关注APP的UI和UE设计即可，而相对复杂的协议与错误处理等事项可忽略。\n\nAndroid SDK接入\nIOS SDK接入\nAPICloud SDK使用指南\n\n5.更多App开发指南\n\nSDK数据透传方法解析\n开源框架视频教程\n\n6.微信开发\n\n了解微信应用开发\n微信应用开发教程\n\n设备接入\n1. 设备快速接入机智云\n为了让开发者快速了解我们设备接入的流程，我们提供了基于开源套件Gokit编写的MCU和SOC两套方案的快速接入教程，两套教程都以智能灯为案例\n注：设备接入并非必须使用Gokit套件\n\nMCU方案快速接入教程\nSOC方案快速接入教程\n\n2.GAgent通讯模组使用教程\nGAgent主要的作用是数据转发，是设备数据、机智云、应用端（APP）的数据交互桥梁。\n为了适应不同通讯模组接入机智云，我们提供了多个模组的烧写方法以及日志打印的方法，以确保GAgent固件在模组里正常运行。\n注：合作厂商在进行模块烧写操作时请依次按照如下步骤进行，否则会产生不可控的错误\n\nGAgent详细介绍\nHF-LPB100串口烧写说明\nHF-LPT120串口烧写说明\nMXCHIP串口烧写说明\nESP8266串口烧写说明\n广和通G510模组烧写说明\n通讯模组调试日志获取教程\n\n3.MCU代码自动生成服务介绍\n为了降低开发者的开发门槛，缩短开发周期，降低开发资源投入，机智云推出了代码自动生成服务。云端会根据产品定义的数据点生成对应产品的设备端代码。\n\n代码自动生成工具介绍以及使用教程\nMCU SDK 通用平台版移植说明\nSTM32CubeMX移植机智云自动生成代码详解\n8051平台最小资源裁剪说明\n\n4.开源套件Gokit资料\n为了让开发者更快的体验到机智云的云服务，我们提供了开源套件Gokit来供开发者学习、参考，借此让开发者自己的产品更快接入机智云。\n\nGokit2 使用指南\nGokit3系列开发套件简介\nGokit3硬件手册\nGokit3(S)使用说明书\nGokit3(S)开发套件介绍\nGokit3(S)开发环境搭建\nGoKit-SoC程序详解\nGoKit-MCU程序详解\n\n5.ArduinoUnoWIFI接入教程\n\nArduinoUNOWIFI接入机智云介绍\nArduinoUNOWiFi 之ESP8266固件烧写教程\nArduinoUNOWiFi SDK之API介绍\nArduinoUNOWiFi智能小夜灯\n\n6.更多设备接入指南\n\nECE Demo开发教程\n机智云串口工具使用文档\n\n云API\n开发者如果已完成设备接入、APP开发，还需要从机智云PaaS平台获取数据构建一套业务管理系统，或者访问机智云提供的服务，则需了解以下文档:\n1). 了解企业应用开发\n2). 了解企业API\n3). SNoti API (V2.1.3)\n4). Gizwits Open API（新）\n5). Websocket API 指南\n6). API使用教程\n\n使用openapi（postman）控制虚拟设备\n使用Websocket 网页控制设备\n使用聚合API使用教程\n设备联动API使用教程\nSnoti 数据实时同步服务demo使用教程\n\n用户手册\n\n个人项目产品转企业项目产品\nOTA使用教程\n产测工具使用文档\nD3 Engine使用教程\nECE雾计算使用教程\n接入亚马逊Echo音箱教程\n实时大数据使用说明\n全球部署方案\n视频教学\n机智云自助开发平台接入-2018-中文版\nhttps://v.qq.com/x/page/o0758i68nqc.html\n其他视频教学\nhttp://docs.gizwits.com/zh-cn/UserManual/hide/videos.html\n\n\n"},{"title":"五分钟了解机智云接入流程","url":"/zh-cn/quickstart/5分钟了解机智云.html","content":"概述\n本文主要介绍了机智云自助接入流程，并通过实操案例：《机智云调试APP控制云端虚拟设备》，来帮助您快速理解机智云平台的接入原理，即使您现在还没有开发任何设备，也可以快速上手。\n机智云接入流程\n\n1.注册成为机智云开发者\n在使用机智云平台服务前，您需要先注册一个机智云开发者账号。点击注册\n机智云开发者帐号分“个人帐号”与“企业帐号”，如下图所示，如果您是企业用户，请务必申请企业帐号（拥有更多企业服务需求）。\n\n2.创建产品\n如图所示，在开发者中心点击“创建新产品”后输入产品名称以及选择对应设备接入方案即可完成“新产品”的创建。创建的产品需要定义产品数据点，数据点点是指产品具有的功能抽象，通过不同数据类型进行表示。例如最简单的设备“开关”，具备功能为：开启、关闭，将其抽象为一个数据点为布尔型，0表示关闭，1表示开启。\n数据点是一个产品的重要属性，因此产品智能化的第一步，就是明确产品功能，并逐一在平台上创建对应的数据点来描述功能。后续，用于嵌入式开发的MCU 协议将会根据创建的数据点自动生成，根据自动生成的协议，开发者即可完成智能设备的开发。\n步骤一、点击“创建新产品”\n \n步骤二、输入产品名称与选择设备接入方案\n \n步骤三、创建数据点\n \n点击“新建数据点”，添加开关机数据点。\n \n此步骤详细操作过程请点击前往参考。\n步骤四、下载云端自动生成的协议\n如图所示，点击开发者中心“开发向导”，找到MCU 开发资源，即可查看云端根据定义的数据点自动生成的协议。\n\n3.设备与应用开发\n设备端接入\n\n开发者或企业研发人员只需在正在开发的智能硬件上嵌入写好机智云连接协议GAgent的连网模块，即可通过机智云平台实现设备连网及智能化，连网模块包括Wi-Fi、GPRS等主流连网方式，同时还支持BLE、GSM、CDMA、Zigbee、LoRa等联网方案接入。\n本文列举案例重点介绍Wi-Fi设备，如需加快研发速度，建议使用通过机智云认证的模块，型号及GAgent下载地址前往参考。\n应用端接入\n开发者或企业研发人员只需在正在开发的手机APP内集成机智云提供的APP SDK，就可以连接机智云平台实现APP通过云端控制智能设备。\n本文列举案例重点介绍如何使用机智云调试APP控制设备流程， 如需快速开发APP，可使用机智云提供的开源框架APP进行快速开发，iOS点击这里 、 Android点击这里查看开源框架。\n4.调试产品\n当开发者在机智云开发者中心创建好产品后，可参考机智云文档中心相关技术文档进行智能产品开发。\n调试产品过程中，开发调试的设备将连接机智云Sandbox服务器（测试服务器），该服务器为开发者提供了完整的测试环境，以及机智云部分开放功能。待产品开发完成后需要申请发布，届时将会将开发的产品重新部署到生产服务器上。\n5.申请发布\n当开发者的设备完成全部开发后需要进行产品发布，发布的产品将部署在机智云正式生产环境服务器上，并为你的设备免费分配独立的云端运行环境，确保你的设备24小时不间断在线以供用户使用。同时，产品正式发布后，将享受更多机智云为您提供的免费增值服务，包括：智能设备统计分析，开放平台展示以及各种无微不至的技术支持服务。\n\n6.正式量产\n产品发布后，厂家与机智云签署《GDCS协议》即可正式量产产品接入机智云，量产的产品会有机智云技术人员24小时监控，确保产品稳定运行。\n新手初体验\n机智云自助开发平台提供一套模拟软件开发工具，其中包括虚拟设备和机智云调试APP等。不管您是否已经做好智能硬件，在初次使用机智云时，都可通过虚拟设备和调试APP了解机智云接入原理，让您直观体验机智云接入服务。\n虚拟设备是机智云云端可自动生成的一个仿真智能硬件，可模拟要开发或正在开发的智能硬件，来进行云端设备控制、手机APP控制、上报数据等需求。\n\n开发者或企业研发人员在机智云平台开发时，如果正式的智能硬件产品产品还未完全开发完成，就可以很方便地使用该“虚拟设备”与正式产品的控制APP进行调试和验证，加快研发周期，降低研发成本。\n机智云调试APP是全球首款IoT设备通用调试工具，可按照实际智能硬件产品的需求自定义功能，可自动生成可响应的控制页面，有完整的用户注册、登陆和注销流程，可以完成智能硬件的配置入网、设备搜索、设备绑定、设备登录、设备控制、远程控制、状态更新、本地远程切换等基本操作和调试需求。\n开发者或企业研发人员在机智云平台开发时，如果正式产品的控制APP还未完全开发好，就可以很方便地使用该“调试APP”对正式产品进行调试和验证，加快研发周期，降低研发成本。\n下面，我们通过《机智云调试APP控制云端虚拟设备》实操案例，快速理解和体验机智云接入服务，完成新手入门，具体操作步骤方式如下：\n1.安装机智云调试APP\n点击这里下载并安装机智云调试APP。\n \n2. 启动虚拟设备\n步骤一: 进入开发者中心，点击左上角选择栏，选择《机智云实验室》：\n\n步骤二：选择一个智能硬件产品，即虚拟设备\n我们建议新手选择“开发中的产品”来模拟真实开发流程，您可以选择任一款 “开发中的产品”进行实操。\n\n我们选择《机智云智能灯2代》，并点击红框“在线调试设备”进入下一页“虚拟设备”页面。\n步骤三：启动虚拟设备\n \n点击红框“启动虚拟设备”后即进入虚拟设备在线调试页面，您将看到“调试提示”、“模拟设备上报数据”、“通信日志”三个功能区域，其中：\n\n“调试提示”内红框“显示二维码”用于机智云调试APP绑定虚拟设备。\n\n“模拟设备上报数据”用于通过开发者中心的虚拟设备上报数据\n\n“通信日志”用于显示“接受APP发送的数据”和“虚拟设备上报数据”\n\n\n\n3. 使用机智云调试APP绑定虚拟设备\n下面是机智云调试APP绑定虚拟设备流程，操作期间请保持网络畅通：\n \n步骤一：点击“调试提示”功能内的红框“显示二维码”来显示虚拟设备二维码\n\n步骤二：手机登陆机智云调试APP并绑定设备\n\n使用手机调试APP扫描虚拟设备二维码，成功绑定已选择的虚拟设备后，手机调试上“我的设备”中的“已绑定设备”将显示《机智云智能灯2代》\n步骤三：机智云调试APP控制虚拟设备\n\n点击红框《机智云智能灯2代》，进入该虚拟设备的手机调试APP界面，以“开关机”为例，进入机智云调试APP调试界面，开启智能灯“开关机”键\n \n此时可以看到云端虚拟设备的“开关机”被开启，显示为“1”，同步可以看到 “通信日志”上会显示“接受APP发送的数据” ，并自动打印通信日志。\n（备注：其他功能均可按照上述步骤操作，您可一一尝试！）\n4.虚拟设备上报数据到机智云调试APP\n\n在云端虚拟设备后台选择调节模式为“色温模式”，并点击“推送”按钮，虚拟设备将上报数据到机智云调试APP，您可以看到机智云调试APP界面中的选择调节模式变为了“色温模式”，同时云端虚拟设备后台的“通信日志”上会显示“虚拟设备上报数据” ，并自动打印通信日志。\n机智云调试APP接收到虚拟设备推送的数据后自动更新UI\n\n（备注：其他功能均可按照上述步骤操作，您可一一尝试！）\nOK，恭喜您已经通过虚拟设备和机智云测试APP快速了解和体验了机智云的连接服务，现在就开始动手开发吧！\n想了解设备快速接入机智云，请点击这里\n想了解APP快速开发流程，请点击这里\n申请机智云开源开发套件GoKit，请点击这里\n进入开发者社区与万名开发者互动，请点击这里\n"},{"title":"Android App快速开发","url":"/zh-cn/quickstart/AndroidAppFrame.html","content":"概述\n本文主要介绍了如何快速使用机智云安卓APP开源框架来进行APP的开发与测试，在阅读本文档之前，请先完成APP开发准备工作\n10分钟部署调试机智云APP开源框架\n1.    下载安卓APP开源框架\nAPP开源框架编译环境：Eclipse\n安卓APP开源框架下载地址：\nhttps://git.oschina.net/dantang/GizOpenSource_AppKit_Android\n\n2.    导入到Eclipse工程\n导入过程中可能会出现如下错误\n \n此时需要将project.properties中的target版本修改为eclipse对应的安卓SDK版本即可。\n\n3.    开源框架包结构说明\n如下图所示，将Package Presentation设置为Hierarchical\n\n此时可以清晰的看到整个工程的目录结构，如图所示，机智云开源框架将每一个模块都独立为Package， Package与Package之间进行最大程度解耦。在开发过程中，如果想删除某一功能，比如不想使用第三方登录，则可以直接将“ThirdAccountModule”包直接删除即可，不会对其他包产生影响。\n\n4.    修改UIConfig.json文件\n在上面所列的文件中。assets目录下的UIConfig.json文件是一个全局配置文件，在这里可以设置工程的配置信息，逐一介绍：\n\napp_id：机智云 app id\napp_secret：机智云 app secret\nproduct_key：机智云 product key\nwifi_type_select：默认配置模块wifi模组选择功能是否开启\ntencent_app_id：qq登录 app id\nwechat_app_id：微信登录 app id\nwechat_app_secret：微信登录 app secret\npush_type：推送类型 【0：关闭，1：极光，2：百度】\nbpush_app_key：百度推送 app key\nopenAPI_URL：openAPI 域名及端口，格式：“api.gizwits.com:80”，不写端口默认80\nsite_URL：site 域名及端口，格式：“site.gizwits.com:80”，不写端口默认80\npush_URL：推送绑定服务器 域名及端口，格式：“push.gizwits.com:80”，不写端口默认80\nbuttonColor：按钮颜色\nbuttonTextColor：按钮文字颜色\nnavigationBarColor：导航栏颜色\nnavigationBarTextColor：导航栏文字颜色\nconfigProgressViewColor：配置中界面 progress view 颜色\naddDeviceTitle：添加设备界面 导航栏标题文字\nqq：是否打开QQ登录【true：打开】\nwechat：是否打开微信登录【true：打开】\nanonymousLogin：是否打开匿名登录【true：打开】\n\n在机智云官网上分别找到产品的Product Key、App ID与App Secret分别填入json文件中对应的位置，如下图所示：\n\n5.    APP部署运行\n正确填写Product Key、App ID与App Secret后，工程就可以部署运行了，\n\n\n6.    注册新用户\n\n7.    登录用户\n注册成功后，APP会自动登录，此时将跳转到“我的设备”界面\n\n8.    启动虚拟设备并显示二维码\n打开开发者中心对应产品的“虚拟设备”栏目。\n虚拟设备：云端自动生成的一个仿真设备，可模拟真实设备上报数据的行为。在实体设备还未开发完成的情况下，开发者可以利用机智云提供的虚拟设备工具进行APP调试，测试远程控制设备的功能。\n\n\n9.    扫码绑定设备\n打开左上角菜单，点击扫描绑定设备\n\n\n扫码成功后，会跳转回到“我的设备”界面，此时界面中会出现刚才扫描的“虚拟设备”\n\n10.    点击“智能灯”，进入控制页面\n\n进入控制页面，可以发现，控制页面为一个空白的页面。机智云开源框架为了让开发者快速开发APP，已将用户登录，设备发现，设备配网等功能做成了各个标准模块，仅保留控制页面让开发者自行开发设计，节省了开发者的时间。下章节，将示例如何快速开发一个简单好看的控制页面。\n控制页面快速开发设计\n1.    控制页面代码预览\n依次打开ControlModule -> GosDeviceControlActivity.java，可以看到，整个控制页面非常简单，就只有一个TextView将设备的mac地址显示出来。\n\n2.    页面UI设计\n根据创建的产品“智能灯”，想实现的UI效果如下：\n\n点击页面中间灯的控件，APP下发命令，控制灯的开关，并将灯的图片显示为开启状态。关闭的时候显示为关闭。\n3.    页面布局代码开发\n导入图片文件\n\n将表示智能灯开关状态的图片拷贝到drawable目录下，如下图所示：\n\n添加Button控件\n1）打开控制页面对应的布局文件“activity_gos_device_control.xml”\n\n2）添加Button控件\n如图所示，将控制页面中多余控件删除，添加一个Button控件\n\n3）使用selector来对Button控件背景进行控制\n在drawable文件夹下新建一个selector文件，如图所示：\n\n在btn_light_onoff_selector.xml添加背景切换代码：\n\n代码如下：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <!-- 选中状态的背景图片 -->\n    <item android:drawable=\"@drawable/light_on\" android:state_selected=\"true\"/>\n    <!-- 未选中状态的背景图片 -->\n    <item android:drawable=\"@drawable/light_off\"/>\n\n</selector>\n\n\n4）将Button控件的背景设置为btn_light_onoff_selector，代码如下：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    android:orientation=\"vertical\" >\n\n    <Button\n        android:id=\"@+id/btn_light_onoff\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" \n        android:background=\"@drawable/btn_light_onoff_selector\"/>\n\n</LinearLayout>\n\n\n此时整个页面布局就做好了。\n4.    控制逻辑代码开发\n4.1.编写控制页面代码\n下图为该产品在云端创建的数据点。\n\n整个GosDeviceControlActivity的参考代码如下：\n\npackage com.gizwits.opensource.appkit.ControlModule;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport com.gizwits.gizwifisdk.api.GizWifiDevice;\nimport com.gizwits.gizwifisdk.enumration.GizWifiErrorCode;\nimport com.gizwits.gizwifisdk.listener.GizWifiDeviceListener;\nimport com.gizwits.opensource.appkit.CommonModule.GosBaseActivity;\nimport com.gizwits.opensource.appkit.R;\nimport android.app.ActionBar;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\n\npublic class GosDeviceControlActivity extends GosBaseActivity {\n    /** 智能灯设备 */\n    private GizWifiDevice device;\n    /** 导航栏 */\n    ActionBar actionBar;\n    /** 在云端创建的数据点标识名 */\n    public static final String LIGHT_SWITCH = \"switch\";\n    /** 开关灯Button */\n    private Button btnLightSwitch;\n    /** 设备监听器 */\n    private GizWifiDeviceListener deviceListener = new GizWifiDeviceListener() {\n        // 接收数据回调\n        public void didReceiveData(GizWifiErrorCode result, GizWifiDevice device,\n                ConcurrentHashMap<String, Object> dataMap, int sn) {\n            // 已定义的设备数据点，有布尔、数值和枚举型数据\n            if (dataMap.get(\"data\") != null) {\n                ConcurrentHashMap<String, Object> map = (ConcurrentHashMap<String, Object>) dataMap.get(\"data\");\n                // 根据标识名，在回调的map中找到设备上报的值\n                if (map.get(LIGHT_SWITCH) != null) {\n                    boolean status = (Boolean) map.get(LIGHT_SWITCH);\n                    // 根据设备上报的值更改按钮的图标\n                    btnLightSwitch.setSelected(status);\n                }\n            }\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_gos_device_control);\n        initDevice();\n        // 设置ActionBar\n        setActionBar(true, true, device.getProductName());\n        initView();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // 退出控制页面，取消设备订阅\n        device.setSubscribe(false);\n    }\n\n    /**\n     * Description:初始化控件\n     */\n    private void initView() {\n        btnLightSwitch = (Button) findViewById(R.id.btn_light_onoff);\n        btnLightSwitch.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                controlLight();\n            }\n        });\n    }\n\n    /**\n     * Description:初始化设备\n     */\n    private void initDevice() {\n        Intent intent = getIntent();\n        device = (GizWifiDevice) intent.getParcelableExtra(\"GizWifiDevice\");\n        device.setListener(deviceListener);\n        Log.i(\"Apptest\", device.getDid());\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n        case android.R.id.home:\n            this.finish();\n            break;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    /**\n     * Description::控制智能灯\n     */\n    private void controlLight() {\n        if (btnLightSwitch.isSelected()) {\n            // 下发控制命令\n            sendCommand(false);\n            // 更改Button控件状态\n            btnLightSwitch.setSelected(false);\n        } else {\n            sendCommand(true);\n            btnLightSwitch.setSelected(true);\n        }\n    }\n\n    /**\n     * Description:下发命令方法\n     * \n     * @param onOff\n     *            true表示开灯，false表示关灯\n     */\n    private void sendCommand(boolean onOff) {\n        int sn = 5;\n        ConcurrentHashMap<String, Object> command = new ConcurrentHashMap<String, Object>();\n        // map中key为云端创建数据点的标识名，value为需要传输的值\n        command.put(LIGHT_SWITCH, onOff);\n        // 调用write方法即可下发命令\n        device.write(command, sn);\n    }\n}\n\n\n4.2.    部署调试\n完成上述代码编写之后，就可以部署到手机中测试控制结果了。\n下发命令\n如图所示，APP部署到手机上后，进入到控制页面，如下图所示：\n\n点击app中灯的图标，APP将下发控制命令，此时APP的按钮图标将变为开灯状态。\n\n此时可以在云端虚拟设备的通信日志中看到app下发的控制命令，如下图：\n\n设备主动上报数据\n如图所示，在虚拟设备中，将开关的值改为“0”，点击下面的推送，此时可以看到通信日志中会有一条记录“虚拟设备上报数据”，表示设备上报数据成功了。\n\n此时APP的控制页面中，灯的按钮马上变成了关灯状态，表示APP成功收到了设备的上报数据。\n\n5. 重要提示\n查阅《APP代码自动生成服务介绍》，可了解自动生成的APP代码模块具备哪些功能\n查阅《APP开源框架》，可了解\n\niOS开源框架使用指南\n\niOS App消息推送集成指南\n\niOS App集成第三方登录与换肤指南\n\niOS App快速开发实例\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送集成指南\nAndroid App集成第三方登录与换肤指南\nAPICloud开源框架使用指南\n\n查阅《APP开发SDK》，可随心开发IoT APP（很多细节设计，均可在里面找到应用案例）\n\niOS SDK 2.0集成指南\nAndroid SDK 2.0集成指南\nAPICloud SDK使用指南\nSDK数据透传方法解析\nSDK调试日志抓取教程\nSDK错误码表\n\n更多应用开发\n\n应用开发FAQ\n设备分享功能使用流程\n第三方登录平台申请流程\n\n"},{"title":"五分钟了解机智云接入流程","url":"/zh-cn/quickstart/README.html","content":"概述\n本文主要介绍了机智云自助接入流程，并通过实操案例：《机智云调试APP控制云端虚拟设备》，来帮助您快速理解机智云平台的接入原理，即使您现在还没有开发任何设备，也可以快速上手。\n机智云接入流程\n\n1.注册成为机智云开发者\n在使用机智云平台服务前，您需要先注册一个机智云开发者账号。点击注册\n机智云开发者帐号分“个人帐号”与“企业帐号”，如下图所示，如果您是企业用户，请务必申请企业帐号（拥有更多企业服务需求）。\n\n2.创建产品\n如图所示，在开发者中心点击“创建新产品”后输入产品名称以及选择对应设备接入方案即可完成“新产品”的创建。创建的产品需要定义产品数据点，数据点点是指产品具有的功能抽象，通过不同数据类型进行表示。例如最简单的设备“开关”，具备功能为：开启、关闭，将其抽象为一个数据点为布尔型，0表示关闭，1表示开启。\n数据点是一个产品的重要属性，因此产品智能化的第一步，就是明确产品功能，并逐一在平台上创建对应的数据点来描述功能。后续，用于嵌入式开发的MCU 协议将会根据创建的数据点自动生成，根据自动生成的协议，开发者即可完成智能设备的开发。\n步骤一、点击“创建新产品”\n \n步骤二、输入产品名称与选择设备接入方案\n \n步骤三、创建数据点\n \n点击“新建数据点”，添加开关机数据点。\n \n此步骤详细操作过程请点击前往参考。\n步骤四、下载云端自动生成的协议\n如图所示，点击开发者中心“开发向导”，找到MCU 开发资源，即可查看云端根据定义的数据点自动生成的协议。\n\n3.设备与应用开发\n设备端接入\n\n开发者或企业研发人员只需在正在开发的智能硬件上嵌入写好机智云连接协议GAgent的连网模块，即可通过机智云平台实现设备连网及智能化，连网模块包括Wi-Fi、GPRS等主流连网方式，同时还支持BLE、GSM、CDMA、Zigbee、LoRa等联网方案接入。\n本文列举案例重点介绍Wi-Fi设备，如需加快研发速度，建议使用通过机智云认证的模块，型号及GAgent下载地址前往参考。\n应用端接入\n开发者或企业研发人员只需在正在开发的手机APP内集成机智云提供的APP SDK，就可以连接机智云平台实现APP通过云端控制智能设备。\n本文列举案例重点介绍如何使用机智云调试APP控制设备流程， 如需快速开发APP，可使用机智云提供的开源框架APP进行快速开发，iOS点击这里 、 Android点击这里查看开源框架。\n4.调试产品\n当开发者在机智云开发者中心创建好产品后，可参考机智云文档中心相关技术文档进行智能产品开发。\n调试产品过程中，开发调试的设备将连接机智云Sandbox服务器（测试服务器），该服务器为开发者提供了完整的测试环境，以及机智云部分开放功能。待产品开发完成后需要申请发布，届时将会将开发的产品重新部署到生产服务器上。\n5.申请发布\n当开发者的设备完成全部开发后需要进行产品发布，发布的产品将部署在机智云正式生产环境服务器上，并为你的设备免费分配独立的云端运行环境，确保你的设备24小时不间断在线以供用户使用。同时，产品正式发布后，将享受更多机智云为您提供的免费增值服务，包括：智能设备统计分析，开放平台展示以及各种无微不至的技术支持服务。\n\n6.正式量产\n产品发布后，厂家与机智云签署《GDCS协议》即可正式量产产品接入机智云，量产的产品会有机智云技术人员24小时监控，确保产品稳定运行。\n7.自助接入机智云视频\n自助接入机智云教学视频-2018年中文版\nhttps://v.qq.com/x/page/o0758i68nqc.html\n新手初体验\n机智云自助开发平台提供一套模拟软件开发工具，其中包括虚拟设备和机智云调试APP等。不管您是否已经做好智能硬件，在初次使用机智云时，都可通过虚拟设备和调试APP了解机智云接入原理，让您直观体验机智云接入服务。\n虚拟设备是机智云云端可自动生成的一个仿真智能硬件，可模拟要开发或正在开发的智能硬件，来进行云端设备控制、手机APP控制、上报数据等需求。\n\n开发者或企业研发人员在机智云平台开发时，如果正式的智能硬件产品产品还未完全开发完成，就可以很方便地使用该“虚拟设备”与正式产品的控制APP进行调试和验证，加快研发周期，降低研发成本。\n机智云调试APP是全球首款IoT设备通用调试工具，可按照实际智能硬件产品的需求自定义功能，可自动生成可响应的控制页面，有完整的用户注册、登陆和注销流程，可以完成智能硬件的配置入网、设备搜索、设备绑定、设备登录、设备控制、远程控制、状态更新、本地远程切换等基本操作和调试需求。\n开发者或企业研发人员在机智云平台开发时，如果正式产品的控制APP还未完全开发好，就可以很方便地使用该“调试APP”对正式产品进行调试和验证，加快研发周期，降低研发成本。\n下面，我们通过《机智云调试APP控制云端虚拟设备》实操案例，快速理解和体验机智云接入服务，完成新手入门，具体操作步骤方式如下：\n1.安装机智云调试APP\n点击这里下载并安装机智云调试APP。\n \n2. 启动虚拟设备\n步骤一: 进入开发者中心，点击左上角选择栏，选择《机智云实验室》：\n\n步骤二：选择一个智能硬件产品，即虚拟设备\n我们建议新手选择“开发中的产品”来模拟真实开发流程，您可以选择任一款 “开发中的产品”进行实操。\n\n我们选择《机智云智能灯2代》，并点击红框“在线调试设备”进入下一页“虚拟设备”页面。\n步骤三：启动虚拟设备\n \n点击红框“启动虚拟设备”后即进入虚拟设备在线调试页面，您将看到“调试提示”、“模拟设备上报数据”、“通信日志”三个功能区域，其中：\n\n“调试提示”内红框“显示二维码”用于机智云调试APP绑定虚拟设备。\n\n“模拟设备上报数据”用于通过开发者中心的虚拟设备上报数据\n\n“通信日志”用于显示“接受APP发送的数据”和“虚拟设备上报数据”\n\n\n\n3. 使用机智云调试APP绑定虚拟设备\n下面是机智云调试APP绑定虚拟设备流程，操作期间请保持网络畅通：\n \n步骤一：点击“调试提示”功能内的红框“显示二维码”来显示虚拟设备二维码\n\n步骤二：手机登陆机智云调试APP并绑定设备\n\n使用手机调试APP扫描虚拟设备二维码，成功绑定已选择的虚拟设备后，手机调试上“我的设备”中的“已绑定设备”将显示《机智云智能灯2代》\n步骤三：机智云调试APP控制虚拟设备\n\n点击红框《机智云智能灯2代》，进入该虚拟设备的手机调试APP界面，以“开关机”为例，进入机智云调试APP调试界面，开启智能灯“开关机”键\n \n此时可以看到云端虚拟设备的“开关机”被开启，显示为“1”，同步可以看到 “通信日志”上会显示“接受APP发送的数据” ，并自动打印通信日志。\n（备注：其他功能均可按照上述步骤操作，您可一一尝试！）\n4.虚拟设备上报数据到机智云调试APP\n\n在云端虚拟设备后台选择调节模式为“色温模式”，并点击“推送”按钮，虚拟设备将上报数据到机智云调试APP，您可以看到机智云调试APP界面中的选择调节模式变为了“色温模式”，同时云端虚拟设备后台的“通信日志”上会显示“虚拟设备上报数据” ，并自动打印通信日志。\n机智云调试APP接收到虚拟设备推送的数据后自动更新UI\n\n（备注：其他功能均可按照上述步骤操作，您可一一尝试！）\nOK，恭喜您已经通过虚拟设备和机智云测试APP快速了解和体验了机智云的连接服务，现在就开始动手开发吧！\n想了解设备快速接入机智云，请点击这里\n想了解APP快速开发流程，请点击这里\n申请机智云开源开发套件GoKit，请点击这里\n进入开发者社区与万名开发者互动，请点击这里\n"},{"title":"独立MCU方案接入机智云","url":"/zh-cn/quickstart/UseMCU.html","content":"mcu快速开发LED灯参考代码\n附件：mcu快速开发RGB_LED灯参考代码\n概述\n机智云平台是致力于物联网、智能硬件云服务的开放平台。机智云专注于提供智能云服务及物联网的软硬件解决方案，帮助传统硬件厂商产品升级，快速实现硬件智能化。要实现硬件的智能化，除了硬件本身外，还需要实现：智能云平台、手机APP、联网模块，每一个领域都需要专业的团队来支撑。机智云提供完整的解决方案，让厂商或开发者只需要专注于自身产品硬件。以最小的成本和风险实现硬件智能化，获得产品最大的增值。本文主要介绍设备接入机智云基本流程。\n设备与机智云数据交互流程.\n以一款空调为例。空调厂家开发者开发空调电控板的时候，使用移植机智云GAgent的WiFi/GPRS模组建立桥梁，使空调设备的数据与机智云互联互通。设备与机智云数据交互的基本数据流如下图。\n\n在机智云官网创建设备产品.\n这里以“智能灯”的例子介绍设备接入机智云的整个流程。\n1.注册机智云开发者账号\n进入机智云官网开发者中心， 根据界面指引注册开发者账号。\n\n2.登录账号，选择对应项创建新产品\n\n3.填写设备产品基本信息\n\n4.项目基本信息\n在机智云官网上已成功创建智能灯产品，机智云为该产品分配Product Key和Product Secret参数。Product Key参数由开发者写入设备MCU（设备主控板），并告知WiFi/GPRS模块，WiFi/GPRS模块登录机智云后，机智云将会识别该Product Key的产品。Product Secret参数是APP开发或服务器对接时所使用的参数。\n\n创建数据点\n数据点即设备产品的功能的抽象，用于描述产品功能及其参数。创建数据点后，设备与云端通讯的数据格式即可确定，设备、机智云可以相互识别设备与机智云互联互通的数据。\n\n1.数据点详解\n数据点定义基本内容可分为显示名称，标识名，读写类型，数据类型及备注。概图如下：\n\n1.1 显示名称：自定义功能点名称。\n1.2 标识名：用于应用层传输，客户端或业务云开发时需要使用。命名规则遵循标准的开发语言变量名命名规范，支持英文字母、数字和下划线，以英文字母开头。\n1.3 读写类型：\n①　只读：表示该数据点非控制，数据只支持从设备上报。\n②　可写：表示该数据点可控制。设备端可上报该数据点数据；云端/客户端可对该数据点数据做出下发控制。\n③　报警：表示该数据点非控制，数据只支持从设备上报，数据类型需为布尔值。\n④　故障：表示该数据点非控制，数据只支持从设备上报，数据类型需为布尔值。云端会对设备上报的该数据点做统计，可在“运行状态”查看。\n1.4 数据类型：\n①　布尔值：表示两个状态：0，或1。如开关状态等，建议使用布尔数据类型。例如GoKit开发板的“宠物屋”，“开启/关闭红色灯”该数据点。\n②　枚举类型：可定义一个有限的取值集合。当定义的某个功能（元器件）有固定的若干个值。例如GoKit开发板的“宠物屋”，“设定LED组合颜色”该数据点的枚举定义值：“自定义,黄色,紫色,粉色”。\n③　数值：填写数值范围，数值可为负数/小数，机智云自动将数值转换为正数。例如GoKit开发板的“宠物屋”，“设定电机转速”该数据点：电机有正反转、调速功能，数据点值可定义为：-5～5。\n④　扩展：填写数据长度，数据内容由用户自定义。对于上述功能点无法满足的复杂功能可采用。机智云不建议使用此类型数据，设备上报该数据点的数据，机智云无法识别。\n1.5  备注：选填，用一段文本描述当前数据点的功能及定义方法，对字符格式不做限制。只用于提高数据点的易读性，如果需要团队协作开发，建议规范填写。\n1.6 数据点数值型分辨率、增量换算实现原理\n如以上提到，在定义数值型数据点的时候，取值范围可以使用包括小数、负数等非uint类型数值，熟悉嵌入式开发的开发者会知道，这些数值在设备端都是不被支持的。\n机智云为了让设备功能定义更加简单直接、所见即所得，研究出来一套算法，用于将用户输入的数值转换成设备能够识别的uint类型，这套算法的核心公式是：y=kx+m。\ny表示“显示值”，就是用户可见的最终数值，也是数据点定义时输入的值。包括Ymin(最小值) 和 Ymax(最大值)。\nx表示“传输值”，就是实际指令间传输使用的数值，云端/客户端接收到的值。一定是uint格式。也包括 Xmin 和 Xmax。\nk表示“分辨率”，就是用户输入的分辨率一值，确定了每个取值的步进。\nm表示“取值偏移量”或“增量”，算法通过m值将y值偏移到满足x值uint格式的要求，m值默认等于Ymin，确保Xmin＝0 。\n以下用一个电子温度计举例说明换算过程 数据点内容： 取值范围：-30（Ymin） ~ 50（Ymax），分辨率：0.1\n根据公式：y=kx＋m，m默认等于Ymin -30\nXmin = (-30+30) / 0.1 = 0\nXmax = (50+30) / 0.1 = 800\n2.根据产品需求，分析硬件开发需求\n“智能灯”的产品需求是：将RGB_LED灯的开关状态和调色功能同步到手机APP，可以使用APP远程控制灯。\n3.结合设备功能需求，分析设备数据点需求\n\n4.创建4个对应数据点\n\n\n\n5.修改数据点\n\n\n智能灯MCU开发\n1.自动生成MCU SDK\n自动生成的MCU SDK代码实现了机智云通信协议的解析与封包、传感器数据与通信数据的转换逻辑，并封装成了简单的 API。当设备收到云端或 APP 端的数据后，程序会将数据转换成对应的事件并通知到应用层，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，便可完成产品的开发。这里选择独立MCU方案、硬件平台STM32f103c8x后，机智云直接生成适应STM32f103c8x的工程代码。\n\n\n\n\n2.MCU SDK文件内容目录结构\n如下图，其中黑色标注部分为STM32f103cx8硬件平台开发基本文件。绿色标注部分为机智云逻辑部分，硬件的串口驱动、定时器驱动、按键驱动等驱动实现完毕，开发者可直接在Gizwits_product.c&Gizwits_product.h文件编写硬件动作执行函数。\n\n其中主要文件说明：\n\n\n\n文件\n说明\n\n\n\n\nGizwits_product.c\n该文件为产品相关处理函数，如gizEventProcess()平台相关硬件初始化，如串口、定时器等。\n\n\nGizwits_product.h\n该文件为gizwits_product.c的头文件，存放产品相关宏定义如：HARDWARE_VERSION、SOFTWARE_VERSION\n\n\nGizwits_protocol.c\n该文件为SDK API接口函数定义文件\n\n\nGizwits_protocol.h\n该文件为gizwits_protocol.c对应头文件，相关API的接口声明均在此文件中。\n\n\n\n协议API介绍\n\n\n\nAPI名称\nAPI功能\n\n\n\n\nVoid gizwitsInit(void)\ngizwits 协议初始化接口。用户调用该接口可以完成 Gizwits 协议相关初始化（包括协议相关定时器、串口的初始化）。\n\n\nVoid gizwitsSetMode(unit8_t mode)\n参数mode[in]：仅支持0,1和2,其他数据无效。参数为 0，恢复模组出厂配置接口，调用会清空所有配置参数，恢复到出厂默认配置;  参数为 1 时配置模组进入 SoftAp 模式； 参数为 2 配置模组进入 AirLink 模式。\n\n\nVoid gizwitsHandle(dataPoint_t *dataPoint)\n参数 dataPoint[in]:用户设备数据点。该函数中完成了相应协议数据的处理即数据上报的等相关操作。\n\n\nInt8_t gizwitsEventProcess(eventInfo_t *info,uint8_t *data,uint32_t len)\n参数 info[in]:事件队列参数 ;  data[in]:数据;                                                                                                         参数 len [in]:数据长度。用户数据处理函数,包括 wifi 状态更新事件和控制事件。a) Wifi 状态更新事件WIFI_开头的事件为 wifi 状态更新事件，data 参数仅在WIFI_RSSI 有效，data 值为 RSSI 值,数据类型为 uint8_t，取值范围 0~7。  b) 控制事件与数据点相关,本版本代码会打印相关事件信息，相关数值也一并打印输出，用户只需要做命令的具体执行即可。\n\n\n\n3.开发步骤\n3.1 程序主函数\n位置：main.c 中 main()函数\n\n相关说明：\n\n\n\n函数\n说明\n\n\n\n\nSystemInit()\n平台相关的硬件初始化 ==（非 MCU SDK API，不同的平台名称可能不同）==\n\n\nuserInit()\n用户相关的初始化，如：外设驱动初始化、打印串口初始化 ==（非MCU SDK API，不同的平台名称可能不同）==\n\n\ngizwitsInit()\n平台、协议处理初始化，如：用户定时器初始化、协议通信串口初始化 （MCU SDK API）\n\n\nuserHandle()\n用户事件回调函数，用户可以自定义事件在该函数中完成相应的协议处理。==（非MCU SDK API，不同的平台名称可能不同）==\n\n\ngizwitsHandle()\n协议相关的主函数 ==（MCU SDK API）==\n\n\n\n3.2 移植RGB_LED驱动程序\n从MCU SDK文件内容目录结构看到，自动生成MCU代码里面没有rgb_led灯驱动，我们可以去机智云官网，开发者中心，下载中心，去参考下载其他含rgb_led灯驱动的项目，把里面的rgb_led灯驱动提取出来移植，以移植微信宠物屋rgb_led灯驱动为例。\n\n\n\n我们把刚刚下载的微信宠物项目解压，进入如下目录，可以看到有个rgb_led灯驱动文件夹，把文件夹复制到自己的自动生成MCU驱动目录里面\n\n\n回到我们自己MCU代码，在驱动目录里面添加rgb_led驱动文件\n\n\n在main.c和gizwits_product.c文件加入#include \"Hal_rgb_led/Hal_rgb_led.h\"\n\n\n3.4 用户程序初始化\n位置：main.c 中 userInit() 函数\n\n3.5 WiFi模块Reset/入网方式\n设备需要进入配置模式才能进行联网，并与云端进行通信，MCU SDK在工程中是通过按键触发进入相应的配置模式。这里，我们简单地添加成功触发WiFi模组进入AirLink配置模式后LED灯亮起。\n进入 Soft AP 模式：key2 按键短按。\n\nB. 进入 AirLink 模式：key2 按键长按亮蓝blue灯。\n\nC. 模组复位：key1 按键长。\n\n3.6 处理云端/APP发送过来的控制事件。\n与控制型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\nprotocolIssuedProcess\n该函数被 gizwitsHandle 调用，接收来自云端或 app端下发的相关协议数据，==MCU SDK自处理，开发者可不关注==\n\n\nACTION_CONTROL_DEVICE\n进行“控制型协议”的相关处理，==MCU SDK自处理，开发者可参考协议进一步理解==\n\n\ngizDataPoint2Event\n根据协议生成“控制型事件”，并进行相应数据类型的转化转换，==MCU SDK自处理，开发者可参考协议进一步理解==\n\n\ngizwitsEventProcess\n根据已生成的“控制型事件”进行相应处理（包括相应的驱动函数），==需开发者处理控制事件==\n\n\n\n相关代码位置：...\\Gizwits\\gizwits_product.c 中 gizwitsEventProcess() 函数：\n功能说明：完成写类型外设的事件处理。\n相应代码：\n\n\n3.7 上报设备状态\n与上报型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\nuserHandle\n获取用户区的上报型数据，需开发者关注\n\n\ngizCheckReport\n判断是否上报当前状态的数据，MCU SDK自处理，开发者可不关注\n\n\ngizDataPoints2ReportData\n完成用户区数据到上报型数据的转换，MCU SDK自处理，开发者可不关注\n\n\ngizReportData\n将转换后的上报数据通过串口发送给 WiFi 模块，MCU SDK自处理，开发者可不关注\n\n\n\n相关代码位置: ...\\User\\main.c 中 userHandle() 函数：\n使用说明：该函数中完成了用户区上报型数据的获取。用户只需将读到的数据赋值到 用户区当前设备状态结构体即可，赋值完的数据是通过 gizwitsHandle 上报云端的，开发者不需要关注变化上报和定时上报。\n\n3.8 编译并将固件烧写到GoKit3代MCU主控板\n调试\n1. 手机安装机智云APP\n\n2. 打开机智云APP，注册登录APP账号\n\n3. 配置WiFi模块入网\n\n\n\n4. 配置成功后，选择相应设备\n\n5. APP收发设备数据\n\n6. 机智云后台查看设备交互数据\n\n\n发布产品\n产品发布到正式生产环境后，机智云将为你的设备免费分配独立的云端运行环境，确保你的设备24小时不间断在线以供用户使用，将享受更多机智云为您提供的免费增值服务，包括：智能设备统计分析，开放平台展示以及各种无微不至的技术支持服务。\n产品如何申请发布上线，具体步骤如下：\n1.进入产品详细信息页面，在产品名称旁边显示【申请发布】按钮\n\n2.点击【马上申请】按钮，如实填写申请信息审核\n\n3.点击【提交申请】按钮，跳转提交成功页面。机智云将免费为你提供人工审核以及严谨的测试，审核通过后，会根据你提交的量产计划免费提供后台服务器支持。\n\n产测简介\n产测是生产环节中重要的部分，保证了产品的质量，提升自身产品形象。机智云产测工具为批量生产的产品提供了方便快捷的模块与MCU产测方式。在大型生产时，保证模块与MCU可正常使用。使用产测工具，必须让产品先上架。由产品创建者向机智云申请发布。机智云将免费为你提供人工审核以及严谨的测试。详情请点击浏览。\n"},{"title":"定义数据点教程","url":"/zh-cn/quickstart/datapoint_tutorial.html","content":"一、概述\n数据点即设备产品的功能的抽象，用于描述产品功能及其参数。创建数据点后，设备与云端通讯的数据格式即可确定，设备、机智云可以相互识别设备与机智云互联互通的数据。\n\n二、数据点详解\n数据点定义基本内容可分为显示名称，标识名，读写类型，数据类型及备注。概图如下：\n\n2.1 显示名称\n  自定义数据点的显示名称，如：开关、温度等。\n2.2 标识名\n  用于应用层传输，客户端或业务云开发时需要使用。命名规则遵循标准的开发语言变量名命名规范，支持英文字母、数字和下划线，以英文字母开头。\n2.3 读写类型\n①　只读：表示该数据点非控制，数据只支持从设备上报。\n②　可写：表示该数据点可控制。设备端可上报该数据点数据；云端/客户端可对该数据点数据做出下发控制。\n③　报警：表示该数据点非控制，数据只支持从设备上报，数据类型需为布尔值。\n④　故障：表示该数据点非控制，数据只支持从设备上报，数据类型需为布尔值。云端会对设备上报的该数据点做统计，可在“运行状态”查看。\n2.4 数据类型\n①　布尔值：表示两个状态：0，或1。如开关状态等，建议使用布尔数据类型。例如GoKit开发板的“宠物屋”，“开启/关闭红色灯”该数据点。\n②　枚举类型：可定义一个有限的取值集合。当定义的某个功能（元器件）有固定的若干个值。例如GoKit开发板的“宠物屋”，“设定LED组合颜色”该数据点的枚举定义值：“自定义,黄色,紫色,粉色”。\n③　数值：填写数值范围，数值可为负数/小数，机智云自动将数值转换为正数。例如GoKit开发板的“宠物屋”，“设定电机转速”该数据点：电机有正反转、调速功能，数据点值可定义为：-5～5。\n④　扩展：填写数据长度，数据内容由用户自定义。对于上述功能点无法满足的复杂功能可采用。机智云不建议使用此类型数据，设备上报该数据点的数据，机智云无法识别。\n2.5  备注\n选填，用一段文本描述当前数据点的功能及定义方法，对字符格式不做限制。只用于提高数据点的易读性，如果需要团队协作开发，建议规范填写。\n2.6 分辨率、增量换算\n如以上提到，在定义数值型数据点的时候，取值范围可以使用包括小数、负数等非uint类型数值，熟悉嵌入式开发的开发者会知道，这些数值在设备端都是不被支持的。\n机智云为了让设备功能定义更加简单直接、所见即所得，研究出来一套算法，用于将用户输入的数值转换成设备能够识别的uint类型，这套算法的核心公式是：y=kx+m。\ny表示“显示值”，就是用户可见的最终数值，也是数据点定义时输入的值。包括Ymin(最小值) 和 Ymax(最大值)。\nx表示“传输值”，就是实际指令间传输使用的数值，云端/客户端接收到的值。一定是uint格式。也包括 Xmin 和 Xmax。\nk表示“分辨率”，就是用户输入的分辨率一值，确定了每个取值的步进。\nm表示“取值偏移量”或“增量”，算法通过m值将y值偏移到满足x值uint格式的要求，m值默认等于Ymin，确保Xmin＝0 。\n以下用一个电子温度计举例说明换算过程 数据点内容： 取值范围：-30（Ymin） ~ 50（Ymax），分辨率：0.1\n根据公式：y=kx＋m，m默认等于Ymin -30\nXmin = (-30+30) / 0.1 = 0\nXmax = (50+30) / 0.1 = 800\n三、数据点创建步骤\n3.1 分析硬件需求\n这里以“智能灯”作为例子介绍数据点的定义。\n“智能灯”的产品需求是：将RGB_LED灯的开关状态和调色功能同步到手机APP，可以使用APP远程控制灯。\n3.2 定义数据点\n\n3.3 创建数据点\n\n\n\n3.4 修改数据点\n\n\n"},{"title":"iOS App快速开发","url":"/zh-cn/quickstart/iOSAPPFrame.html","content":"概述\n本文主要介绍了如何快速使用机智云iOS APP开源框架来进行APP的开发与测试，在阅读本文档之前，请先完成APP开发准备工作\n10分钟部署调试机智云APP开源框架\n1. 下载iOS APP开源框架\nAPP开源框架编译环境：XCode\niOS APP开源框架下载地址：\nhttps://git.oschina.net/dantang/GizOpenSource_AppKit_iOS\n\n2. 导入工程到XCode\n下载的开源框架如下图所示，双击红色框部分打开\n\n框架目录如下：\n\n3. 开源框架包结构说明\n开源框架的整体目录结构如下图所示，其中开源代码存储在路径《GOpenSourceModules》下，根据框架的功能划分，将框架划分为五大模块，各个模块之间具有极低的耦合度，除了公共模块《CommonModule》的文件不可随意删减之外，其他模块用户可以根据自己的需要删减相应模块，比如：不需要推送功能，则可以直接删除掉《PushModule》，并注释掉相关属性和方法在其它类中的调用即可。\n\n4. 修改UIConfig.json文件\n\n如上图所示，UIConfig.json文件是一个全局配置文件，在这里可以设置工程的配置信息，逐一介绍：\n\napp_id：机智云app id\napp_secret：机智云app secret\nproduct_key：机智云 product key\nwifi_type_select：默认配置模块wifi模组选择功能是否开启\ntencent_app_id：qq登录 app id\nwechat_app_id：微信登录 app id\nwechat_app_secret：微信登录 app secret\npush_type：推送类型 【0：关闭，1：极光，2：百度】\njpush_app_key：极光推送app key\nbpush_app_key：百度推送 app key\nopenAPIDomain：域名及端口，格式：“api.gizwits.com:80”，不写端口默认80\nsiteDomain 域名及端口，格式：“site.gizwits.com:80”，不写端口默认80\npushDomain：推送绑定服务器 域名及端口，格式：“push.gizwits.com:80”，不写端口默认80\nbuttonColor：按钮颜色\nbuttonTextColor：按钮文字颜色\nnavigationBarColor：导航栏颜色\nnavigationBarTextColor：导航栏文字颜色\nconfigProgressViewColor：配置中界面 progress view颜色\nstatusBarStyle：状态栏样子【0：默认的黑色样式， 1：白色样式]\naddDeviceTitle：添加设备界面 导航栏标题文字\nqq：登陆界面的QQ登陆按钮【true：显示， false：隐藏】\nwechat：登陆界面的微信登陆按钮【true：显示, flase：隐藏】\nanonymousLogin：登陆界面的跳过按钮【true：显示, flase：隐藏】\n\n在机智云官网上分别找到产品的Product Key（如《1. 创建产品并定义数据点》中的图），App ID（如《2. 为产品创建安卓和iOS应用》的第二个图）与App Secret分别填入json文件中对应的位置，如下图所示：\n\n5. 控制界面入口\n在框架中若要将控制界面切换为用户自定义的控制界面，而非框架自带的界面，则可以将下图的《GosDeviceController》切换为自定义控制界面即可，即删除图右边红框中的代码，做两步操作：\n1)初始化自定义的控制界面\n2)从deviceListController（设备列表界面）跳转到自定义控制界面\n\n6. APP部署运行\n正确填写Product Key、App ID与App Secret后，工程就可以部署运行了\n\n\n7. 注册新用户\n\n8. 登陆用户\n注册成功后，APP会自动登录，此时将跳转到“我的设备”界面\n\n9. 启动虚拟设备并显示二维码\n打开开发者中心对应产品的“虚拟设备”栏目。\n   虚拟设备：云端自动生成一个仿真设备，可模拟真实设备上报数据的行为。在实体设备还未开发完成的情况下，开发者可以利用机智云提供的虚拟设备工具进行APP开发调\n\n\n10. 扫描绑定设备\n打开左上角菜单，点击扫描绑定设备\n\n\n扫码成功后，会跳转回到“我的设备”界面，此时界面中会出现刚才扫描的“虚拟设备”\n\n11. 点击“智能灯”，进入控制界面\n\n进入控制页面，可以发现，控制页面为一个空白的页面。机智云开源框架为了让开发者快速开发APP，已将用户登录，设备发现，设备配网等功能做成了各个标准模块，仅保留控制页面让开发者自行开发设计，节省了开发者的时间。下章节，将示例如何快速开发一个简单好看的控制页面。\n控制页面快速开发设计\n1. 控制页面代码预览\n依次打开DeviceModule -> GosDeviceController，可以看到，整个控制页面非常简单，只有一个UILabel将设备的mac地址显示出来\n\n2. 页面UI设计\n根据创建的产品“智能灯”，想实现的UI效果如下：\n\n点击页面中间灯的控件，APP下发命令，控制灯的开关，并将灯的图片显示为开启状态。关闭的时候显示为关闭。\n3. 页面布局代码开发\n3.1 导入图片文件\n\n将表示智能灯开关状态的图片拷贝到CommonModule/Images目录下，如下图所示：\n\n3.2 添加Button控件\n1)打开控制器的xib文件 – GosDeviceController.xib，删除Label控件，并到GosDeviceController.m文件中删除所有相关代码\n\n2)添加Button控件\n如图所示，往xib中拖一个Button控件，布局控件于xib中央，设置Button的State Config属性为Default时，Image即按钮图片为关灯图light_off.png；Button的State Config属性为Selected时，Image为light_on.png。\n\n3)关联xib的Button到GosDeviceController.m文件中\n\n此时整个页面布局就做好了。\n4. 控制逻辑代码开发\n4.1 定义数据点宏\n根据数据点的名称定义宏：DataPointSwitch\n\n\n4.2 实现控制逻辑\n实现控制逻辑需要以下三个步骤：\n1)    指定设备的代理\n2)    遵守设备协议\n3)    下发控制指令\n\n// 点击界面按钮的控制逻辑\n- (void)switchBtnDidClick:(UIButton *)btn\n{\n    if (btn.isSelected)\n    {\n        // 关灯\n        btn.selected = NO;\n        // 下发控制指令到设备端\n        [self.device write:@{DataPointSwitch:@NO} withSN:5];\n    }\n    else\n    {\n        // 开灯\n        btn.selected = YES;\n        // 下发控制指令到设备端\n        [self.device write:@{DataPointSwitch:@YES} withSN:5];\n    }\n}\n\n4.3 实际接收数据逻辑\n如图所示，在设备代理方法中实现回调逻辑，并控制开关图片的切换。\n\n// 接收到设备状态回调\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)dataMap withSN:(NSNumber *)sn\n{\n    NSDictionary *data = dataMap[@\"data\"];\n    if (data != nil && data.count != 0)\n    {\n        NSNumber *switchNum = data[DataPointSwitch];\n        self.switchBtn.selected = switchNum.boolValue;\n    }\n}\n\n4.4 解除订阅\n从控制界面退回到设备列表界面时，需要做一个解除订阅的动作，否则会出现不可预见的错误。\n- (void)dealloc\n{\n    [self.device setSubscribe:NO];\n}\n\n4.5 部署测试\n完成上述代码编写之后，就可以部署到手机中测试控制结果了。\n1)下发命令\n如图所示，APP部署到手机上后，进入到控制页面，如下图所示：\n\n点击app中灯的图标，APP将下发控制命令，此时APP的按钮图标将变为开灯状态。\n\n此时可以在云端虚拟设备的通信日志中看到app下发的控制命令，如下图：\n\n2)设备主动上报数据\n如图所示，在虚拟设备中，将开关的值改为“0”，点击下面的推送，此时可以看到通信日志中会有一条记录“虚拟设备上报数据”，表示设备上报数据成功了。\n\n此时APP的控制页面中，灯的按钮马上变成了关灯状态，表示APP成功收到了设备的上报数据。\n\n重要提示\n查阅《APP代码自动生成服务介绍》，可了解自动生成的APP代码模块具备哪些功能\n查阅《APP开源框架》，可了解\n\niOS开源框架使用指南\n\niOS App消息推送集成指南\n\niOS App集成第三方登录与换肤指南\n\niOS App快速开发实例\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送集成指南\nAndroid App集成第三方登录与换肤指南\nAPICloud开源框架使用指南\n\n查阅《APP开发SDK》，可随心开发IoT APP（很多细节设计，均可在里面找到应用案例）\n\niOS SDK 2.0集成指南\nAndroid SDK 2.0集成指南\nAPICloud SDK使用指南\nSDK数据透传方法解析\nSDK调试日志抓取教程\nSDK错误码表\n\n更多应用开发\n\n应用开发FAQ\n设备分享功能使用流程\n第三方登录平台申请流程\n\n"},{"title":"机智云名词定义解释","url":"/zh-cn/quickstart/noun.html","content":"说明\n此文档将对机智云相关的术语进行定义与解析。如果在开发过程中遇到一些术语不太理解的可以参阅此文档。\n云端名词定义\n1.ProductKey\n定义：产品标识码，开发者通过机智云后台创建新产品后，自动生成的一个32位字符串。在机智云的数据库中是一个唯一的号码，开发者将ProductKey写入设备主控MCU后，机智云通过此标识码对设备进行识别并自动完成注册。\n解析：设备接入机智云的前提是，需要机智云认同这个设备。Productkey是设备接入机智云的一个重要参数，该参数的基本含义是：一款设备识别码。例如某公司生产空调、热水器，空调和热水器是不同款设备，该公司设备接入机智云，至少需要两个Productkey参数。在开发MCU过程中，需要使用到该参数。Product Key在机智云官网上可以查看到，请参考下图：\n\nProductkey在开发过程中的角色：\n\n2.Product Secret\n定义：产品密钥，在生成Productkey的时候云端会对应生成一个Product Secret，该参数为关键性机密参数，不应向第三方泄露。该参数在绑定远程设备（一般为GPRS接入方案）的时候会使用到。\n3.DID\n定义：设备号，当一个设备初次接入机智云时，机智云自动根据ProductKey以及设备Wi-Fi模块MAC地址为此设备注册一个did，此did全网唯一，用于与用户的绑定及后续操作。\n\n4.AppID\n定义：应用标识码，当开发者需要为一款智能产品开发应用（包括iOS、Android、Web应用等）时，后台会自动生成一个AppID，并与此设备进行关联。应用开发时需要填入此AppID。\n解析：在云端创建一个产品的同时需要在该产品下添加一个应用，并区分Android与iOS等。AppID主要在开发APP的时候用到。并且在app中注册的所有用户绑定在该Appid下。Appid可以在机智云官网上可以查看到。\n\n\n5.App Secret\n定义：应用密钥，在云端生成AppID的时候，会对应生成一个App Secret，该参数在APP端SDK注册手机用户时，获取手机短信验证码的时候会用到。\n6.小循环\n定义：智能设备与手机、智能设备与智能设备之间，通过连接同一个路由器实现局域网内部的通信（查看状态或控制），我们称之为小循环。\n7.大循环\n定义：智能设备通过路由器或直接接入互联网以实现用户的远程监测与控制，我们称为大循环。\n\n设备端名词定义\n1.Gagent\n定义：全称Gizwits Agent，运行于Wi-Fi模块中，设备通过GAgent接入机智云服务器。 目前已兼容国内主流的Wi-Fi模块， 开发者也可以通过获取GAgent二次开发包实现自定义的模块接入机智云。\n解析：Gagent是机智云运行在Wi-Fi模组的应用程序，Gagent主要作用是使得wifi模块主动连接机智云服务器，并实现与云端的TCP/UDP通信。因此，在开发者产品的控制电路板上集成Wifi模块，只需要实现与Wifi模组的串口通信，即可直接接入机智云服务器，而不需要处理底层的网络传输处理。如图所示：\n\n2.PassCode\n定义：设备通行证，用于校验用户的绑定/控制权限。当用户发起设备绑定时，只要是合法操作即可拿到此通行证，通过此通行证绑定设备并对设备进行有效期内的查看、控制等操作。GAgent首次运行时生成随机数作为设备通行证，生成后保存在非易失性存储器上。设备上线时需要上报给服务器。\n\n3.Onboarding\n定义：也叫配置入网，用户将一款基于Wi-Fi的物联网设备配置连接上路由器的过程称为Onboarding。新设备第一次使用时需要知道路由器的账号和密码，以通过路由器连接互联网。由于大多数的物联网设备没有自带的屏幕和键盘，所以需要通过智能手机向设备发送路由器的SSID和密码，这个过程机智云称为Onboarding。机智云提供的Wi-Fi设备接入SDK中已经内置了此配置的功能。\n\n4.Station模式\nStation模式（简称sta）, 类似于无线终端，sta本身并不接受无线的接入，它可以连接到AP，一般无线网卡即工作在该模式。\n5.AP模式\nAP模式: Access Point，提供无线接入服务，允许其它无线设备接入，提供数据访问，一般的无线路由/网桥工作在该模式下。AP和AP之间允许相互连接。\n6.AirLink\n定义：机智云对各种SmartConfig、SmartLink这种UDP广播报方式对设备配置入网的技术统称，兼容了多个Wi-Fi模块厂商的配置协议，总结了一套良好用户体验的标准Onboarding操作流程，机智云的Wi-Fi 设备接入SDK已经内置AirLink技术。\n7.SoftAP\n定义：由于目前各个Wi-Fi模块厂商的Smart Config协议均未完全成熟，也不支持5G路由器信号。机智云在提供了AirLink配置模式的同时也支持SoftAP模式配置设备接入路由器。当设备进入SoftAP配置模式时，设备本身将成为一个AP，智能手机可直接与设备进行连接，然后在手机上的界面上输入路由器的SSID和密码，设备接收到信息的时候会自动尝试连接路由器，连接成功则自动切换到正常使用的模式。\n开发者中心工具名词定义\n1.虚拟设备\n虚拟设备是机智云云端可自动生成的一个仿真智能硬件，可模拟要开发或正在开发的智能硬件，来进行云端设备控制、手机APP控制、上报数据等需求。\n不管您是否已经做好智能硬件，在初次使用机智云时，都可通过虚拟设备和调试APP了解机智云接入原理，让您直观体验机智云接入服务。\n开发者或企业研发人员在机智云平台开发时，如果正式的智能硬件产品产品还未完全开发完成，就可以很方便地使用该“虚拟设备”与正式产品的控制APP进行调试和验证，加快研发周期，降低研发成本。\n开发者或企业研发人员在机智云平台开发时，如果正式产品的控制APP还未完全开发好，就可以很方便地使用该“调试APP”对正式产品进行调试和验证，加快研发周期，降低研发成本。\n使用教程：http://docs.gizwits.com/zh-cn/quickstart/README.html#%E6%96%B0%E6%89%8B%E5%88%9D%E4%BD%93%E9%AA%8C\n2.MCU代码自动生成器\n为了降低开发者的开发门槛，缩短开发周期，降低开发资源投入，机智云推出了代码自动生成服务。云端会根据产品定义的数据点生成对应产品的设备端代码。\n自动生成的代码实现了机智云通信协议的解析与封包、传感器数据与通信数据的转换逻辑，并封装成了简单的API，且提供了多种平台的实例代码。当设备收到云端或APP端的数据后，程序会将数据转换成对应的事件并通知到应用层，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，就可以完成产品的开发。\n使用自动生成的代码开发产品，就不必再处理协议相关的部分了，开发者可以将节省出来的精力集中在产品的核心功能开发上。\n\nMCU代码自动生成功能特性如下:\n\n自动生成服务支持的硬件方案有：独立MCU方案、SOC方案。\n独立MCU方案支持的硬件平台有：51单片机、MSP430、STM32、arduino，含正点原子等，支持生成支持8位、16位、32位的MCU\nSOC方案支持的硬件平台有：ESP8266平台，含8M、16M、32M模组\n能与Cubemx无缝对接 \n\n使用教程：http://docs.gizwits.com/zh-cn/deviceDev/DevSDK/%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7.html\n3.APP代码自动生成器\nAPP的代码自动生成工具：当开发者在产品项目上创建对应的数据点后，云端会根据产品定义的数据点生成对应产品的APP参考代码，一键点击生成下载，编译安装即可完成专属物联网APP。\n开发者下载源码后，只需要优化UI和设计设备控制界面控制逻辑，源码的控制页面编写了机智云SDK控制设备的标准流程，APP源码二次开发过程中只需按照该流程进行相关代码的优化即可快速完成针对自身产品的智能控制APP。\n目前APP生成的源码支持 Andriod、iOS、APICloud平台。\n\n自动生成的APP代码模块化集成了一个智能硬件APP必备功能，主要包括：\n\n1.用户部分：用户注册，找回密码、第三方登录（微信登录、QQ登录）\n2.配置设备入网（Arilink+SoftAP）\n3.设备发现，列表展示\n4.设备控制\n5.消息推送：设备报警后给APP推送报警信息，主要合作推送平台是极光推送和百度推送。\n\n使用教程：http://docs.gizwits.com/zh-cn/UserManual/devApp.html\n4.D3 Engine\nD3 Engine,全称 Dynamic Data Director Engine,是机智云为开发者提供的傻瓜式的数据处理、开发引擎。“使用D3引擎，只需“拖拉拽”即可轻松创建APP和短信推送规则，即可将设备、用户数据与外部第三方数据进行有机整合。使用门槛低，小白也可轻松利用D3引擎来创建APP和短信推送规则”\nD3 可以灵活定义数据的输入，能将设备、用户数据与外部第三方数据进行有机整合，还可以支持脚本解析与自定义数据输入，满足不同开发者的数据处理需要。主要特点如下：\n\n1）多样的数据源：支持自定义多种数据源，第三方公共数据甚至您的ERP系统的数据输入。\n2）强大的规则处理：基于决策树算法支持灵活多重条件组合。\n3）灵活的输出：除了App推送、邮件、短信等服务，还可以支持回调服务以及存储服务；存储服务通过数据平台的计算与开放API服务对各类应用提供数据服务，降低各类应用的开发成本以及面对海量数据的性能处理风险。\n\n目前D3 Engine仅支持企业开发者试用或购买GDCS的客户使用。\n\n使用教程：http://docs.gizwits.com/zh-cn/UserManual/D3.html\n5.产测工具\n机智云产测工具是一个对产品进行批量测试的工具App，使用产测工具，可以快速检验工厂生产线上的成品或者半成品。\n您可以在页面中定义产品产测的测试项，再对工厂的设备进行相关定义项的自动测试。设备针对测试项测试通过后，表示产品合格。在大型生产中，通过产测工具，能够有效的监测批量产品质量，保证产品功能。\n   \n使用教程：http://docs.gizwits.com/zh-cn/deviceDev/%E4%BA%A7%E6%B5%8B%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3.html\n6.OTA固件升级\nOTA 英文全称是Over-the-Air Technology，即空间下载技术。当设备连上云端时会收到OTA升级通知，再通过HTTP完成固件升级。\n机智云的OTA服务主要提供以下功能：\n\n1）OTA通知服务，即离线升级。当设备的固件程序有新版本发布，OTA 通知服务会推送升级通知到设备。\n2）OTA透传服务，即在线升级。设备固件程序通过M2M 消息服务透传到设备端。\n3）支持一个产品同时有多个推送\n4）支持wifi/mcu升级\n5）支持定向升级。可指定设备mac地址、区域、旧固件版本进行推送。\n6）支持定时推送。可自定义推送周期及推送时段。\n7）OTA进度统计分析\n\n远程对设备Wi-Fi，MCU模块进行固件程序升级，修复固件程序Bug或新增功能当设备连上云端时会收到OTA升级通知，再通过HTTP完成固件升级。\nGAgent OTA使用教程：http://docs.gizwits.com/zh-cn/UserManual/OTA.html\nMCU OTA使用教程：http://docs.gizwits.com/zh-cn/UserManual/MCUOTA.html\n7.SNoti服务\nSNoti服务是机智云为企业或产品运营商提供的设备管理类服务，用于实时推送设备与产品相关的事件，远程控制设备。 主要的功能如下：\n\n1）设备实时数据推送；\n2）产品相关事件推送；\n3）设备远程控制。\n\n企业客户可通过SNoti提供的安全数据传输通道，实时的接收设备的数据，用于设备信息归类整理，设备状态统计，设备监控等；也可以通过远程控制功能，实时发送业务指令控制在线设备。\n使用教程：http://docs.gizwits.com/zh-cn/Cloud/NotificationAPI.html\n8.企业API\n企业API是机智云为接入机智云平台 的企业开发者提供的开放API服务。\n使用企业API的企业将设备接入到机智云平台后，通常还有进一步基于接入机智云设备数据开展企业某个垂直领域的业务需求，如用户管理、订单管理等，以满足企业开发者的运营管理需要。\n企业API就是从接入机智云平台的企业的运营管理的需求出发，为企业的业务管理系统提供REST API接口，为企业提供企业视角全局的设备管理、数据分析等功能，让企业更关注业务管理系统本身，减少不必要的开发成本与时间。\n使用教程：http://docs.gizwits.com/zh-cn/Cloud/enterprise_api.html\n9.应用邮件模板\napp用户用邮箱注册成功时会收到一个注册成功邮箱，通过邮箱找回密码时会收到一个找回密码邮箱。\n通过应用邮件的配置可自行自定义设置邮件模板的内容，并可配置第三方邮件服务器，或者使用机智云代发服务器。\n实时大数据\n通过拖放的方式生成API， 用于对产品数据点进行实时大数据统计分析。\n10.离线数据\n离线数据下载是机智云为接入机智云平台的企业开发者提供的数据服务。\n通过机智云提供的安全下载链接，企业客户可以下载设备历史的通讯日志数据（单次最多可下载3个月的数据）。便于企业做数据分析、数据挖掘和制定数据报告。\n客户端开发相关工具\n1.机智云开源框架\n开源框架是机智云出品的，包含Wi-Fi类智能硬件app通用功能的一套源码。只要是使用机智云协议的产品，开发者开发配套的app时都可以直接使用该框架的源码实现快速开发，从而也满足app的开发周期短、成本低的要求。\n开源框架包括智能硬件app通用的5个模块，分别是：初始化模块、用户模块、配置模块、设备列表模块、控制模块。\n\niOS版开源框架：https://gitee.com/dantang/GizOpenSource_AppKit_iOS\nAndriod版开源框架：https://gitee.com/dantang/GizOpenSource_AppKit_Android\nAPICloud版开源框架：https://github.com/gizwits/GizOpenSourceAppKit_APICloud\n或在下载中心下载：https://download.gizwits.com/zh-cn/p/95/96\n\n2.设备接入SDK\n设备接入SDK封装了手机（包括PAD等设备）与机智云智能硬件的通讯过程，以及手机与云端的通讯过程。这些过程包括配置入网、发现、连接、控制、心跳、状态上报、报警通知等。\n使用SDK，可以使得开发者快速完成APP开发，开发者仅需关注APP的UI和UE设计即可，而相对复杂的协议与错误处理等事项可忽略。另外还提供了APICloud版本的wifi设备接入SDK，可以使用JS语言更加快速完成APP开发。\n下载地址：https://download.gizwits.com/zh-cn/p/95/97\n3.统计分析SDK\n统计分析SDK用于将数据进行云存储、云获取和云计算，蓝牙产品是主要使用对象。产生的数据会通过手机传输到云存储器中，如需数据调用，则通过接口获取即可。\n目前提供的基本数据运算有：数据求和、数据平均、数据最大值及最小值查找等。\n下载地址：https://download.gizwits.com/zh-cn/p/95/111\n开发与调试工具\n1.调试APP（IoE Demo）\n调试APP（IoE Demo）又称机智云调试APP，简称“机智云APP”。可在应用商店搜索“机智云”下载，或在下载中心下载：https://download.gizwits.com/zh-cn/p/98/99\n机智云APP是全球首款IoT设备通用调试工具，可按照实际智能硬件产品的需求自定义功能，可自动生成可响应的控制页面，有完整的用户注册、登陆和注销流程，可以完成智能硬件的配置入网、设备搜索、设备绑定、设备登录、设备控制、远程控制、状态更新、本地远程切换等基本操作和调试需求。\n2.机智云串口调试助手\n机智云串口调试助手是一款提供设备快速开发的强力助手，拥有双串口调试、模拟MCU、效验和计算等功能。双串口调试可以让嵌入式开发清晰地分析模组和MCU之间的数据交互，迅速定位问题；模拟MCU可以在设备未开发完成时同时开发APP，缩减开发周期，另外可以用于验证模组的可用性等。\n下载地址：https://download.gizwits.com/zh-cn/p/98/119\n3.产测工具\n使用产测工具，可以快速检验工厂生产线上的成品或者半成品。产测工具是一个简单的手机APP，可以在用户产品中定义产测的测试项，再对工厂的设备进行相关定义项的自动测试。设备针对测试项测试通过后，表示产品合格。\n产测工具可以将设备并行处理，平均5～10秒可以完成一个设备的测试，从而大大提高测试的速度。\n产测工具下载：https://download.gizwits.com/zh-cn/p/98/100\n"},{"title":"App开发准备工作以及向导","url":"/zh-cn/quickstart/准备工作.html","content":"概述\n本文为主要介绍了机智云设备接入SDK以及机智云APP开源框架的功能与作用，以及前期的准备工作，开发者可以根据自己的项目需求。选取合适的方式进行APP开发\n机智云APP开发资源简述\n机智云现提供三种APP（集成SDK、使用app开源框架、使用app自动生成）的开发方式，针对不同开发者的不同需求，帮助开发者更加快速开发自己的APP，以下为不同需求建议选用的开发方式\n1. 机智云设备接入SDK\n机智云的设备接入SDK（以下简称SDK）封装了手机（包括PAD等设备）与机智云智能硬件的通讯过程，以及手机与云端的通讯过程。这些过程包括配置入网、发现、连接、控制、心跳、状态上报、报警通知等。使用SDK，可以使得开发者快速完成APP开发，开发者仅需关注APP的UI和UE设计即可，而相对复杂的协议与错误处理等事项可忽略。\n适合开发者的项目需求中，APP需要做复杂的业务逻辑处理，或者在自己已经完成的APP项目下，需要集成机智云的SDK实现远程控制的功能。\n机智云目前提供3套SDK：iOS平台原生SDK、Android平台原生SDK、APICloud跨平台SDK。开发者可以根据项目需要自行选择，其中APICloud版本SDK可以用H5技术一次开发，同时适配iOS和Android两个平台。\nIOS平台原生SDK下载地址（下载链接）\n  IOS平台原生SDK集成指南（跳转链接）\n  Android平台原生SDK下载地址（下载链接）\n  Android平台原生SDK集成指南（跳转链接）\n  APICloud跨平台SDK下载地址（下载链接）\n  APICloud跨平台SDK集成指南（跳转链接）\n \n2.机智云APP开源框架\n为了进一步降低开发者的开发难度，机智云推出了APP开源框架。在框架中，已经模块化集成了如下功能：\n适合开发者的项目需求中，APP需要做简单的业务逻辑处理。\n\n1.用户部分：用户注册，找回密码、第三方登录（微信登录、QQ登录）用户登录：包括云端用户登录，第三方登录（微信登录、QQ登录）\n2.配置设备入网（Arilink+SoftAP）\n3.设备发现，列表展示\n4.消息推送：极光推送、百度推送\n5.自定义皮肤\n\nAPP开源框架将各个模块独立成包，开发者如果想了解其中某一个模块的实现代码与流程，直接参考框架代码即可。\nIOS开源框架使用说明（跳转链接）\n基于IOS开源框架的快速开发实例（跳转链接）\nAndroid开源框架使用说明（跳转链接）\n基于Android开源框架的快速开发实例（跳转链接）\nAPICloud开源框架使用说明（跳转链接）\n开源框架使用视频教程（跳转链接）\n3.机智云APP自动生成服务\n使用APP自动生成开发：开发者的项目需求中，需要一款属于自己项目产品的APP给予调试，或者APP开发中，需要一款完整的APP代码给予参考\n为了降低开发智能硬件APP开发门槛，降低开发资源的投入，机智云在《APP开源框架》基础上进一步推出了实现项目完整控制功能的APP开源代码。当开发者在产品项目上创建对应的数据点后，云端会根据产品定义的数据点生成对应产品的APP参考代码。\n自动生成的APP代码模块化集成了一个智能硬件APP必备功能，主要包括：\n\n1.用户部分：用户注册，找回密码、第三方登录（微信登录、QQ登录）\n2.配置设备入网（Arilink+SoftAP）\n3.设备发现，列表展示\n4.设备控制\n5.消息推送：设备报警后给APP推送报警信息，主要合作推送平台是极光推送和百度推送。\n\n开发者下载源码后，只需要优化UI和设计设备控制界面控制逻辑，源码的控制页面编写了机智云SDK控制设备的标准流程，APP源码二次开发过程中只需打包、安装即可快速完成针对自身产品的智能控制APP。\nAPP自动生成代码服务介绍以及使用教程（跳转链接）\n4.APP其他开发教程\nIOS消息推送指南（跳转链接）\nIOS第三方登陆与换肤教程（跳转链接）\nAndroid消息推送指南（跳转链接）\nAndroid第三方登录与换肤教程（跳转链接）\nSDK数据透传方法解析（跳转链接）\nPS：以上方法都是基于开源框架使用\n准备工作\n1.    创建产品并定义数据点\n\n\n2.    为产品创建安卓和iOS应用\n在服务栏目下，点击“应用配置”，分别添加安卓与iOS应用。\n\n\n3.    App ID与App Secret含义与作用\nApp ID：应用标识码，当开发者需要为一款智能产品开发应用（包括iOS、Android、Web应用等）时，在机智云开发者中创建应用的时候，后台会自动生成一个AppID，并与此设备进行关联。应用开发时需要填入此AppID。在APP注册的所有用户绑定在该Appid下。\nApp Secret：App ID的验证密钥。\n如下图所示，为APPID在开发APP过程中的作用。\n\n4.    重要提示\n查阅《APP代码自动生成服务介绍》，可了解自动生成的APP代码模块具备哪些功能；\n查阅《APP开源框架》，可了解\n\niOS开源框架使用指南\n\niOS App消息推送集成指南\n\niOS App集成第三方登录与换肤指南\n\niOS App快速开发实例\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送集成指南\nAndroid App集成第三方登录与换肤指南\nAPICloud开源框架使用指南\n\n查阅《APP开发SDK》，可随心开发IoT APP（很多细节设计，均可在里面找到应用案例）\n\niOS SDK 2.0集成指南\nAndroid SDK 2.0集成指南\nAPICloud SDK使用指南\nSDK数据透传方法解析\nSDK调试日志抓取教程\nSDK错误码表\n\n更多应用开发\n\n应用开发FAQ\n设备分享功能使用流程\n第三方登录平台申请流程\n\n"},{"title":"Guide of Gizwits Device SDK 2.0 for Android App","url":"/en-us/AppDev/AndroidSDKA2.html","content":"SDK_API Reference Manual\nAttachment: Android_SDK2.0_API Reference Manual\nOverview\n1. Objectives\nThe Gizwits Device SDK (hereinafter referred to as the SDK) encapsulates the communication process between mobile phones (including PAD and other devices) and smart devices, and the communication process between mobile phones and Gizwits Cloud. These processes involve configuring network access, device discovery, connectivity, device control, heartbeat, status report, and alarm notification. Using the SDK, you only need to focus on the App UI/UE and are able to rapidly complete your App development, while ignoring the related issues such as complex protocols and error handling.\nThe SDK has been further simplified based on the definition of the new APIs, and its process is briefer. You have no need to understand the concept of device connectivity underneath at all.\n2. Gizwits IoT Architecture\n\n3. Choose the right SDK\nGizwits currently offers three types of SDKs: the native Device SDK for iOS, the native Device SDK for Android, and the cross-platform APICloud SDK. you can choose any one of those SDKs that best aligns with your desired scenario and customize as needed. The APICloud SDK can be developed once with HTML5 and adapt to both iOS and Android. For details, please refer to Guide of Gizwits Device SDK for APICloud.\n4. Term definitions\n4.1 GAgent\nThe full name is Gizwits Agent, which runs on Wi-Fi modules, and through which devices access the Gizwits server. Currently, it is compatible with mainstream Wi-Fi modules of China. Developers can also implement their own custom modules to access Gizwits using the GAgent secondary development package provided by Gizwits.\n4.2 Micro Cycle\nConnections between smart devices and mobile phones, smart devices and smart devices via the same router to achieve WLAN communication (status check or control), which is called a Micro Cycle.\n4.3 Macro Cycle\nSmart devices access the Internet via routers to accomplish remote monitoring and control by users, which is called a Macro Cycle.\n4.4 ProductKey\nProduct identification code, a 32 characters long string that is automatically generated by the developer after creating a new product in Gizwits cloud. It is a unique code in the database of Gizwits cloud. After the developer writes the ProductKey to the device master MCU, the Gizwits identifies the device through this code and automatically completes the registration.\n4.5 DID\nDevice code. When a device is connected to Gizwits for the first time, Gizwits automatically generates a DID for the device based on its ProductKey and Wi-Fi module MAC address. DID which is used to associate with users and perform subsequent operations, should be unique across the entire network.\n4.6 PassCode\nDevice Pass Code, used to verify the user's binding/control permission. When the user initiates a device binding, the device pass code can be obtained by users with legal means to bind the device and perform operations such as device status check and control during the valid period. GAgent generates a random number as a device pass when it is first run. It is generated and stored in non-volatile memory. When the device goes online, it needs to be reported to the server.\n4.7 AppID\nApplication identification code. When you need to develop an application (including iOS, Android, Web application, etc.) for a smart device, an AppID is automatically generated in Gizwits cloud and associated with the device. This AppID is required for application development.\n4.8 Onboarding\nNetwork access configuration, the process of connecting a Wi-Fi-based IoT device to a router is called Onboarding. When the new device is used for the first time, it needs to know the router's SSID and password to connect to the Internet via the router. Since most IoT devices do not have their own screens and keyboards, it is necessary to send the router's SSID and password to the device through a smart phone. The network access SDK for Wi-Fi devices provided by Gizwits has such built-in configuration function.\n4.9 AirLink\nCollectively, the features of UDP broadcast messages that allow you to configure the network access for devices, such as SmartConfig and SmartLink, are called AirLink. It provides the standard onboarding operation procedures with a good user experience, which is compatible with configuration protocols from multiple Wi-Fi module manufacturers. The network access SDK for Wi-Fi devices provided by Gizwits has built-in AirLink function. \n4.10 SoftAP\nBecause each Smart Config protocol from different Wi-Fi module manufacturers is not fully mature and neither does it support 5G router signal. Gizwits has provided AirLink configuration mode and also supports SoftAP mode to configure devices to access routers. When a device enters the SoftAP configuration mode, the device itself becomes an AP, and the smart phone can directly connect to the device. Then the SSID and password of the router are input on the mobile phone and sent to the device which will automatically switch to the normal mode and try to connect to the router.\n5. Integration preparation\n5.1 Register a Gizwits developer account\nBefore using Gizwits services, you need to sign up for a developer account on site.gizwits.com. Please refer to Quick Start to complete your registration.\n5.2 Create device connection\nFor this section, please refer to Quick Start.\n5.3 Get App ID and product identification code (productkey)\nFor this section, please refer to Quick Start.\n5.4 Download the SDK\n\n5.5 Import the SDK\nStep 1: Double-click to unzip GizWifiSDK-Android-xxx.zip.\nStep 2: Copy all the files in the decompressed libs directory to the libs directory of the specified project, and ensure that the files in the red box below are loaded into the project:\n\n5.6 Update AndroidManifest.xml\nCopy the following permission configuration code snippet into the AndroidManifest.xml file:\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" />\n<uses-permission android:name=\"android.permission.CHANGE_WIFI_MULTICAST_STATE\" />\nNote:\n\n\n\nPermission\nUsage\n\n\n\n\nACCESS_NETWORK_STATE\nAllows applications to access information about networks.\n\n\nACCESS_WIFI_STATE\nAllows applications to access information about Wi-Fi networks.\n\n\nREAD_PHONE_STATE\nAllows read only access to phone state, including the phone number of the device, current cellular network information, the status of any ongoing calls, and a list of any PhoneAccounts registered on the device.\n\n\nACCESS_COARSE_LOCATION\nAllows an app to access approximate location for CellID or WiFi hotspots.\n\n\nACCESS_FINE_LOCATION\nAllows an app to access precise location.  (such as GPRS)\n\n\nWRITE_EXTERNAL_STORAGE\nAllows an application to write to external storage like SD card.\n\n\nINTERNET\nAllows applications to open network sockets.\n\n\nCHANGE_WIFI_STATE\nAllows applications to change Wi-Fi connectivity state.\n\n\nCHANGE_WIFI_MULTICAST_STATE\nAllows applications to enter Wi-Fi Multicast mode.\n\n\n\n5.7 Read and write permission settings for Android 6.0 system files\nAndroid 6.0 has added the new feature of runtime permission dynamic check. The following permission used in GizWifiSDK need to be detemined at runtime: ACCESS_FINE_LOCATION, which can detect the current Wi-Fi networks and connectable Wi-Fi network list of for the mobile phone.\nHere's an example of how to write dynamic check code with this permission request:\nThe Android 6.0 grants all the permissions requested for the application with targetSdkVersion less than 23 by default, so if the targetSdkVersion used by the App is lower than 23, it can run normally. However, if the user cancels the granted permission in the settings, or the targetSdkVersion used by the App is 23 or higher, it needs to be solved in the App code. The following is an example with Android Studio:\n\nTarget SDK version\n\nSet targetSdkVersion to 23 in build.gradle:\nandroid {\n    compileSdkVersion 23\n    buildToolsVersion \"23.0.1\"\n    defaultConfig {\n        applicationId \"com.yourcomany.app     \n        minSdkVersion 18     \n        targetSdkVersion 23     \n        versionCode 1     \n        versionName \"1.0\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\nCheck and request the permission\n\nCheck if the App already has ACCESS_FINE_LOCATION permission, if not, request the permission:\nif(ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {          \n    ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.ACCESS_FINE_LOCATION }, ACCESS_FINE_LOCATION_REQUEST_CODE);      \n}\n\nAfter requesting the permission, the system will pop up a dialog box asking for the permission:\n\n\n\nAfter the user chooses Allow, the onRequestPermissionsResult method will be called back. This method can be handled like this:\n\nonActivityResult  \nOverride  \npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {      \n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);      \n    doNext(requestCode,grantResults);  \n}\n\n// Then follow the requestCode and grantResults (authorization results) for subsequent processing\nprivate void doNext(int requestCode, int[] grantResults) {\n    if (requestCode == ACCESS_FINE_LOCATION_REQUEST_CODE) {\n        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                      // Permission Granted          \n        } else {\n                      // Permission Denied\n        }\n    }\n}\nSpecial handling for runtime permissions in Fragment\n\nFor permission request in Fragment, do not use ActivityCompat.requestPermissions, directly use Fragment's requestPermissions method, otherwise it will callback Activity onRequestPermissionsResult\nIf nesting Fragment in Fragment, use requestPermissions method in the child Fragment, onRequestPermissionsResult will not be called back. It is recommended to use getParentFragment().requestPermissions method. This method will call back the onRequestPermissionsResult of the parent Fragment, and add the following code snippet to the callback method to pass the callback to the child Fragment:\n\nOverride  \npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    List<Fragment> fragments = getChildFragmentManager().getFragments();      \n    if (fragments != null) {\n        for (Fragment fragment : fragments) {\n            if (fragment != null) {\n                fragment.onRequestPermissionsResult(requestCode,permissions,grantResults);    \n            }          \n          }      \n     }  \n}\n5.8 How to use GizWifiSDK with Android Studio\nStep 1, download sdk here.\nPlease unzip the file after the download is complete.\n\nStep 2, import the jar package in Android Studio.\n\nStep 3, add the jar files as libraries.\n\nStep 4, import the so files.\nPlease create the folder jniLibs under the main folder and paste armeabi into the created folder:\n\nStep 5, after the import is completed, check the corresponding build.gradle\nIn the figure below, you can see the associated library:\n\nStep 6, test if it is successful.\n\nIf there is a log in the picture below, it means success:\n\nThe SDK workflow\n1. General flow chart\n\n2. Key point description\n1) The SDK has encapsulated all the activities related to user, configuration, discovery, connection, and control. You can use these APIs to develop the functions in the above flow chart without having to implement the communication protocol by yourself.\n2) The SDK adopts the callback method, so it is necessary to set up necessary delegates, such as the common delegate and the device delegates. For more information, please refer to the detailed workflow. The SDK calls the App in the main thread.\n3) The SDK supports Applications to transfer objects between Activities and between Activity and Service.\n\nYou can use intent to pass objects between Activities.\n\n(Send)\nIntent intent = new Intent(Context, A.class);\n    Bundle bundle = new Bundle();\n    bundle.putParcelable(\"parameter name\", device type object);\n    intent.putExtras(bundle);\n    startActivity(intent);\n(Receive)\nIntent intent = getIntent();\n    intent.getParcelableExtra(\"parameter name\");\n\nFor passing objects between activity and service, it can be achieved by broadcast. One party sends data and the other party receives it.\n\n(Register broadcast receiver)\nIntentFilter filter = new IntentFilter();// Create IntentFilter object\n    //Register a broadcast receiver to receive commands sent by the Activity to control the behaviors of the Service, such as: sending data, stopping services, etc.\n    filter.addAction(\"AAAAAAA\");\n    //Register Broadcast Receiver\n    registerReceiver(cmdReceiver, filter);\n(Send broadcast)\nIntent intent = new Intent();  \n    intent.setAction(\"AAAAAAA\");  \n    Bundle bundle = new Bundle();\n    bundle.putParcelable(\"parameter name\",  device type object);\n    intent.putExtras(bundle);\n    sendOrderedBroadcast(intent, null);\n\nObtain the Service object in the Activity via bindService, and directly call the Service method to get the desired device object.\n\n3. Key point description\nIf your project uses Proguard obfuscation, in order to avoid the SDK being confused twice and the SDK cannot be used normally, be sure to add the following code snippet into proguard-project.txt:\n-libraryjars libs/GizWifiSDK.jar\n-dontwarn com.gizwits.**\n-keep class com.gizwits.**{\n    *;\n}\nAnd refer to the Android obfuscation file in project.properties:\nproguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt\nDetailed workflow of the SDK\n1. Initialization\n1.1 Flow chart\n\n1.2 Set up the common listener\nRegistering the common listener for the SDK is to enable the App to receive events from GizWifiSDK class, which involves the callback interfaces such as registration, login, device configuration, and device binding. This is a very important listener in the use of the SDK, where the operations related to GizWifiSDK class will be called back. If the common listener is not properly registered, the SDK will not work normally. When registering the listener, you can implement callback interfaces on your behalf.\nThere are two recommended ways:\n1) Instantiate a listener and register it once in each used Activity, and only implement the required callback interface. This method is more flexible and can be used in the service. But ensure that every time you start the activity you must register the listener, and multiple Activities cannot receive the callback at the same time.\n[Code sample]\n// Instantiate a listener\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n\n// Callback for user registration with mobile phone\nOverride\npublic void didRegisterUser(GizWifiErrorCode result, String uid, String token){\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n};\n\npublic void onCreate() {\nsuper.onCreate();\n\n// Register the listener\nGizWifiSDK.sharedInstance().setListener(mListener);\n// Call the SDK interface for user registration with mobile phone\nGizWifiSDK.sharedInstance().registerUser(\"HelloGizwits\", \"12345678\");\n}\n2) Instantiate a listener in a base class and throw the callback. The subclass inherits the base class, which eliminates the need for each subclass to instantiate the listener. In this way, by inheritance, multiple Activities can receive the callback. But this method cannot be used in the Service. Except where otherwise noted, the examples in this documentation use this method to register the listener.\n[Code sample]\n// Create a base class that instantiates and registers the listener\npublic class BaseActivity extends Activity {\nprivate GizWifiSDKListener mListener = new GizWifiSDKListener() {\nOverride\npublic void didRegisterUser(GizWifiErrorCode result, String uid, String token) {\nBaseActivity.this.didRegisterUser(result, uid, token);\n}\n};\n\npublic void didRegisterUser(GizWifiErrorCode result, String uid, String token)\n{\n// to do\n}\n\nOverride\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\n\n//Every time you start the activity, you must register the SDK listener to ensure that the SDK state can be passed into the callback correctly.\nGizWifiSDK.sharedInstance().setListener(mListener);\n}\n}\n\n//The subclass inherits the base class and implements the callback interface of the base class.\npublic class TestActivity extends BaseActivity {\n    protected void onCreate(android.os.Bundle savedInstanceState) {\n        //Call the parent class method\n        super.onCreate(savedInstanceState);\n        //Call the method for user registration \nGizWifiSDK.sharedInstance().registerUser (\"your_phone_number\", \"your_ password\", “your_verify_code”, GizUserAccountType.GizUserPhone);\n}\n\n@Override\npublic void didRegisterUser(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n1.3 Initialize the SDK\nBefore the SDK is launched, any feature is not working properly. When the SDK starts, it will be initialized and automatically discover devices in the current LAN. The SDK will report the discovered devices and corresponding events through the common listener. You can set the SDK's common listener first, then launch the SDK so as to handle these events.\nWhen the SDK starts, the App AppID needs to be specified. You should apply for an AppID for your own App in the Gizwits Developer Center. Please call the method in the App Application or the onCreate of the first started Activity with the specified AppID. This method only needs to be called once.\nThe SDK's log can help you discover issues that occur while the App is running. By default, the SDK outputs all log information to the debug terminal and log files. If the phone has an SD card, the log file will be saved on the SD card. If there is no SD card, it will only be saved in the application path. The log file directory on the SD card is GizWifiSDK/app_package_name/GizSDKLog under the path of the mobile phone SD card. If you do not want to output logs in the debugging terminal, you can change the log output level to GizLogPrintNone.\n[Code sample]\npublic void onCreate() {\nsuper.onCreate();\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().startWithAppID(getApplicationContext(), \"your_app_id\");\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didNotifyEvent(GizEventType eventType, Object eventSource, GizWifiErrorCode eventID, String eventMessage) {\nif (eventType == GizEventType.GizEventSDK) {\n// SDK event notification\n                Log.i(\"GizWifiSDK\", \"SDK event happened: \" + eventID + \", \" + eventMessage);\n} else if (eventType == GizEventType.GizEventDevice) {\n                // Notification that may occur when the device is disconnected\n                GizWifiDevice mDevice = (GizWifiDevice)eventSource;\n                Log.i(\"GizWifiSDK\", \"device mac: \" + mDevice.getMacAddress() + \" disconnect caused by eventID: \" + eventID + \", eventMessage: \" + eventMessage);\n} else if (eventType == GizEventType.GizEventM2MService) {\n                // Notification for the M2M service exception\n                Log.i(\"GizWifiSDK\", \"M2M domain \" + (String)eventSource + \" exception happened, eventID: \" + eventID + \", eventMessage: \" + eventMessage);\n} else if (eventType == GizEventType.GizEventToken) {\n                // Notification for invalid token\n                Log.i(\"GizWifiSDK\", \"token \" + (String)eventSource + \" expired: \" + eventMessage);\n}\n}\n};\n2. User Management\nThe user management of Gizwits Cloud includes functions such as user registration, login, password recovery, and personal information modification. Gizwits Cloud distinguishes users by APPID, and the users with different APPIDs are independent of each other. After changing the APPID of a user, you need to re-register the user.\nThe listener registration method involved in the following process is implemented using class inheritance.\n2.1 Flow chart\n\nThere are many ways for users to register, such as mobile phone number, user name, email address, etc. The App can take the method as needed. For other processes such as login, password change, personal information modification, etc., see the following section.\n2.2 User registration\nGizwits provides three user registration methods, such as register via mobile phone, regular user registration, and register via Email.\n2.2.1 Register as a mobile phone user\nTo register an account with your mobile phone, you need a valid mobile phone number. Two steps are required for registration: get the SMS verification code and register the user with the SMS verification code.\nStep 1: get the SMS verification code. The SDK sends a SMS verification code request to the cloud. If the request is successful, the cloud will respond a SMS verification code to the mobile phone.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().requestSendPhoneSMSCode (\"your_app_secret\", \"your_phone_number\");\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRequestSendPhoneSMSCode(GizWifiErrorCode result, String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\nStep 2: Register with SMS verification code. The App passes the SMS verification code received by the mobile phone to the SDK, and fills in the mobile phone number and password to register.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().registerUser(\"your_phone_number\", \"your_password\", \"your_verify_code\", GizUserAccountType.GizUserPhone);\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRegisterUser(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.2.2 Register as a regular user\nRegister as a regular user account with a username and a password.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().registerUser(\"your_user_name\", \"your_password\", null, GizUserAccountType.GizUserNormal);\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRegisterUser(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.2.3 Register as an Email user\nRegister a user account with a valid email address. After the registration is successful, the cloud will send an Email of the successful registration to the specified Email address.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().registerUser(\"your_email_address\", \"your_password\", null, GizUserAccountType.GizUserEmail);\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRegisterUser(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.3 User login\nGizwits Cloud provides three user login methods: real-name login, anonymous login, and third-party authentication. Real-name login is suitable for those Apps which have login UI and need to register before use. Anonymous login is applicable to the Apps that do not have login UI and user accounts are automatically generated in the cloud when needed. The token obtained after login is valid in 7 days.\n2.3.1 Real-name login\nFor real-name login, the user name can be the registered mobile phone number, Email address, and regular user name. If the AppID is changed, the user account needs to be re-registered.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().userLogin(\"your_user_name\", \"your_password\");\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didUserLogin(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.3.2 Anonymous login\nEvery time a user logs in anonymously, the obtained uid is the same. The SDK uses the Android ID to generate a login account. Each Android system has a separate Android ID, which will change after the system is flashed. Therefore, the anonymously logged in user information cannot be retained after the system is flashed.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().userLoginAnonymous();\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didUserLogin(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.3.3 Third-party authentication\nGizwit Cloud currently supports third-party authentication from Baidu, Sina, and Tencent. You can use the APIs of these three platforms to obtain uid and token to log into Gizwits Cloud. When using third-party authentication, you do not need to register on Gizwits Cloud, you can log in directly.\nYou can get uid and token through those APIs of Sina, Baidu or Tencent. For details, please refer to the corresponding development documentation. \n[Code sample]\n// Take the Sina account as example\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().loginWithThirdAccount(GizThirdAccountType.GizThirdSINA, \"your_third_uid\", \"your_third_token\");\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didUserLogin(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.4 Password reset\nIf you have forgotten your password, you can set a new password via mobile phone or Email, which are supported by the SDK. For the password reset via mobile phone, the verification code will sent to your mobile phone. For the password reset via Email, there will be a hyperlink delivered to your Email address which prompts you to complete the rest steps.\n2.4.1 Password reset via mobile phone\nFor the password reset via mobile phone, you need to get the SMS verification code. The approach of obtaining the SMS verification code is the same as when you registered with your mobile phone.\nStep 1: get SMS verification code\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().requestSendPhoneSMSCode(\"your_app_secret\", \"your_phone_number\");\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRequestSendPhoneSMSCode(GizWifiErrorCode result, String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\nStep 2: Reset your password with SMS verification code\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().resetPassword(\"your_phone_number\", \"your_verify_code\", \"your_new_password\", GizUserAccountType.GizUserPhone);\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.4.2 Password reset via Email\nFor the password reset via Email, the cloud sends a secure link to the specified Email address. You needs to check the Email in the mailbox and follow the instructions to perform the reset operation. It is possible that the password reset link is delivered into the trash folder of your mailbox, which you needs to be aware of.\nThe callback for the successful Email delivery is the same with the callback for the password change, so it is necessary to notice the distinction between these two cases.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().resetPassword(\"your_email_address\", null, \"your_new_password\", GizUserAccountType.GizUserEmail);\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n                //The reset password email is sent successfully, prompting the user to check\n} else {\n                //The reset password email failed to send, an error message pops up\n}\n}\n}\n2.5 Password change\nThe password can be changed after you log in.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().changeUserPassword(\"your_token\", \"your_old_password\", \"your_new_password\");\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.6 User type conversion\nAn anonymous user can be converted to a real-name user, such as a regular user or a user registered with mobile phone. After the conversion, the anonymous user's information will be transferred to the real-name user, and the original anonymous user account will be invalid. However, the user name or the mobile phone number of the target user must be unregistered before conversion, otherwise it will fail.\n2.6.1 An anonymous user converted to a regular user\nFor an anonymous user converted to a regular user, fill in the username, password, and token of the target regular user.\n[Code sample]\n// An anonymous user converted to a regular user\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().transAnonymousUser(\"your_token\", \"your_user_name\", \"your_password\", null, GizUserAccountType.GizUserNormal);\n\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didTransAnonymousUser(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.6.2 An anonymous user converted to a user registered with mobile phone\nFor an anonymous user converted to a mobile phone user, fill in the mobile phone number, password, SMS verification code, and token of the target user registered with mobile phone. The procedure of obtaining the SMS verification code is the same as when registering as a mobile phone user.\n[Code sample]\n// An anonymous user converted to a user registered with mobile phone\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().transAnonymousUser(\"your_token\", \"your_phone_number\", \"your_password\", \"your_verify_code\", GizUserAccountType. GizUserPhone);\n\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didTransAnonymousUser(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.7 Update user information\nFor real-name users, Gizwis does not support the regular user name modification. But you can modify the Email address and mobile phone number, supplement personal information after logging in, and the Email address or mobile phone number to be modified must be already registered.\nAfter the real-name user has modified the email address or mobile phone number, he can log in using the modified email address or mobile phone number. The list of bound devices retrieved after login is the same as the original real-name user.\nWhen you modify your Email address or mobile phone number, you can supplement your personal information at the same time. When you do not want to modify your personal information, the corresponding parameter can be set to nil. In the case of the Email address or user name is successfully modified and the personal information fails to be modified, the callback method will return success and prompt the failure reason of the personal information modification in errorMessage.\n2.7.1 Modify Email address\nWhen only Email address is needed to be modified, the parameter of the personal information is set to nil, and the user type can be set to GizUserEmail. The following is a code sample to modify a user's Email address.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", \"your_email_address\", null, GizUserAccountType.GizUserEmail, null);\n\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.7.2 Modify mobile phone number\nWhen only the user's mobile phone number is needed to be modified, the personal information parameter is set to nil, and the user type can be set to GizUserPhone. Before modifying your mobile phone number, you need to get the SMS verification code. The following code sample is used to modify the user's mobile phone number. For the code to get the SMS verification code, please refer to the registration with mobile phone number. \n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", \"your_phone_number\", \"your_verify_code\", GizUserAccountType.GizUserPhone, null);\n\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.7.3 Modify personal information\nWhen only the user's personal information is needed to be modified, the phone number or mailbox parameter is set to null, and the user type can be set to GizUserNormal. The personal information can contain multiple items, which can be specified by GizUserInfo class. The information that you do not want to modify is set to null, and the cloud will retain the last modified value.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\n\nGizUserInfo additionalInfo = new GizUserInfo();\nadditionalInfo.setName(\"nickname\");\nadditionalInfo.setGender(GizUserGenderType.Male);\nadditionalInfo.setBirthday(\"1990-1-1\");\nadditionalInfo.setAddress(\"Beijing\");\nadditionalInfo.setRemark(\"home\");\n\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", null, null, GizUserAccountType.GizUserNormal, additionalInfo);\n\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.7.4 Modify both Email addres and personal information\nWhen modifying the Email address and personal information at the same time, the user type must be set to GizUserEmail.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\n\nGizUserInfo additionalInfo = new GizUserInfo();\nadditionalInfo.setName(\"nickname\");\nadditionalInfo.setGender(GizUserGenderType.Male);\nadditionalInfo.setBirthday(\"1990-1-1\");\nadditionalInfo.setAddress(\"Beijing\");\nadditionalInfo.setRemark(\"home\");\n\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", \"your_email_address\", null, GizUserAccountType.GizUserEmail, additionalInfo);\n\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n2.7.5 Modify both mobile phone number and personal information\nWhen modifying the mobile phone number and personal information at the same time, the user type must be set to GizUserPhone. To modify the mobile phone number, you also need to get the SMS verification code first. For the SMS verification code, please refer to the registration with mobile phone. \n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\n\nGizUserInfo additionalInfo = new GizUserInfo();\nadditionalInfo.setName(\"nickname\");\nadditionalInfo.setGender(GizUserGenderType.Male);\nadditionalInfo.setBirthday(\"1990-1-1\");\nadditionalInfo.setAddress(\"Beijing\");\nadditionalInfo.setRemark(\"home\");\n\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", \"your_phone_number\", \"your_verify_code\", GizUserAccountType.GizUserPhone, additionalInfo);\n\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n}\n3. Configure device to access network\nBefore controlling a device, you need to connect the device to a router. If the router can access internet, the device connected to the router will automatically register to Gizwits Cloud.\nThere are two ways to configure the device to connect to the router. One is Airlink and the other is SoftAP. The App can adopt the favorite approach according to product requirements. Before configuration, the device must first enter the configuration mode, and then the App calls the configuration API to send the router SSID and password to be configured. After the device is successfully configured, the SDK returns the configured MAC address and product type identifier of the device to the App, which is convenient for the App to perform the next step. If the device has entered the configuration mode after reset and does not have time to get the DID from the cloud when the configuration is successful, the DID value obtained by the App is empty.\nIf the timeout period of the configuration API of the SDK is not over, the next configuration cannot be performed. In addition, because the broadcast packet of the successful device configuration can be received only if the App is connected to the same router, the above timeout period should reserve the time for the App to connect to the router.\nIt should be noted that if the device configured is not the expected product type for the App, the device will not appear in the App device list.\n3.1 Flow chart\n\n3.2 Configuration with AirLink\nAirLink uses UDP broadcast sent from a mobile phone which contains the target router SSID and password. The Wi-Fi module on the device automatically connects to the target router after receiving the broadcast packet, and then sends a configuration success broadcast after connecting to the router to notify the mobile phone that the configuration has been completed.\nAfter the Wi-Fi module enables AirLink mode, if it does not receive AirLink broadcast within one minute or is not able to connect to the router correctly, it will enter SoftAP mode.\n[Code sample]\n// Let the phone connect to the target Wi-Fi\n// The MCU issues a serial port command to notify the module to enable AirLink mode. For details, please refer to \"Gizwits Air Conditioner –Serial Port Communication Protocol Document for Gizwits Cloud Access \"\n\n// Configure the device to access the network and send the Wi-Fi SSID and password to be configured.\nGizWifiSDK.sharedInstance().setListener(mListener);\nList<GizWifiGAgentType> types = new ArrayList<GizWifiGAgentType> ();\ntypes.add(GizWifiGAgentType.GizGAgentESP); \n// This code example uses the latest network configuration API (Espressif or Hanfeng firmware require the version of 040002027 or higher, other module types do not require the minimum version)\nGizWifiSDK.sharedInstance().setDeviceOnboardingDeploy(\"your_ssid\", \"your_key\", GizWifiConfigureMode.GizWifiAirLink, null, 60, types, false);\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n//Wait for configuration to complete or timeout, then call back the configuration completion interface\n@Override\npublic  void didSetDeviceOnboarding (GizWifiErrorCode result, String mac, String did, String productKey) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Configuration is successful\n        } else if (result == GIZ_SDK_DEVICE_CONFIG_IS_RUNNING) {\n        // Configuration in progress\n} else {\n            // Failed to configure\n}\n}\n};\n3.3 Configuration with SoftAP\nAfter the device enters SoftAP mode, a Wi-Fi hotspot is created on it. After the mobile phone is connected to this hotspot, the SSID and password to be used are sent to the device. After receiving the SoftAP configuration package, the Wi-Fi module on the device automatically connects to the target router. Just like the AirLink, after the router is connected, the configuration success broadcast is sent to notify the mobile phone that the configuration is completed.\nUsing the Wi-Fi module firmware provided by Gizwits, the Wi-Fi hotspot created by the device starts with “XPG-GAgent-” and the password is “123456789”. Modules provided by other vendors, SoftAP hotspot names are specified by respective vendors. The App can give the correct hotspot prefix as needed.\n[Code sample]\n// The MCU issues a serial port command to notify the module to enable SoftAP mode. For details, please refer to \"Gizwits Air Conditioner –Serial Port Communication Protocol Document for Gizwits Cloud Access \"\n//Let the phone connect to the module's SoftAP hotspot\n\n//Configure the device to access the network and send the Wi-Fi SSID and password to be configured.\nGizWifiSDK.sharedInstance().setListener(mListener);\n// This code example uses the latest network configuration API (Espressif or Hanfeng firmware require the version of 040002027 or higher, other module types do not require the minimum version)\nGizWifiSDK.sharedInstance().setDeviceOnboardingDeploy(\"your_ssid\", \"your_key\", GizWifiConfigureMode.GizWifiSoftAP, \"your_gagent_hotspot_prefix\", 60, null, false);\n\n//The module receives the configuration information, tries to connect to the router and automatically turns off the hotspot\n//Let the phone connect to the configured Wi-Fi network\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n//Wait for configuration to complete or timeout, then call back the configuration completion interface\n@Override\npublic  void didSetDeviceOnboarding (GizWifiErrorCode result, String mac, String did, String productKey) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n} else {\n            // Failure\n}\n}\n};\n4. Device discovery and subscription\n4.1 Flow chart\n\n4.2 Device discovery\nAfter setting a delegate for the App and launching the SDK, the App can receive the push notification of device list from the SDK. Each time there are changes for the devices in the current LAN or bound devices, the SDK will automatically report the latest device list. When a device is powered off and then powered on, or a new device comes online, the device list will be refreshed. After the user logs in, the SDK will automatically report the list of devices that the user has bound to the App. The bound device can be obtained by the same user account on different mobile phones.\nIf the App wants to refresh the list of bound devices, you can call the bound device list API and specify the product type identifier that you care about. The SDK will return the filtered device list to the App.\nThe SDK provides a device list cache, and device objects in the device list remain valid throughout the App lifecycle. The cached device list is updated synchronously with the most recently discovered devices.\n[Code sample]\n// Refresh the UI with a cached device list\nList<GizWifiDevice> devices = GizWifiSDK.sharedInstance().getDeviceList();\n\n// Receive the reported device list change, refresh UI\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didDiscovered(GizWifiErrorCode result, List<GizWifiDevice> deviceList) {\n        // Prompt error reason\n        if(result != GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            Log.d(\"\", \"result: \" + result.name());\n        }\n        // Display the changed list of devices\n        Log.d(\"\", \"discovered deviceList: \" + deviceList);\ndevices = deviceList;\n}\n};\n\n// Actively refresh the list of bound devices, specify productKey to filter devices \nList<String> pks = new ArrayList<String> ();\npks.add(\"your_productKey\");\nGizWifiSDK.sharedInstance().getBoundDevices(\"your_uid\", \"your_token\", pks);\n4.3 Set device delegate\nGet the device objects in the device list, set the device delegate for each of them, in order to refresh the device related UI. The App implements the corresponding callback according to its own needs.\n4.4 Device subscription and binding\nAfter the App gets the device list and sets delegate, you can subscribe to the device. The subscribed device will be automatically bound and automatically log in. After the device logs in successfully, it will automatically report the latest status.\nThe automatically bound devices are limited to the same LAN where your App resides. For devices that cannot be discovered in the LAN, the App can bind them manually. A device that is successfully bound must be subscribed before it can be used.\nWhether it is manual binding or automatic binding, the remark and alias information of the device must be set after the device is successfully bound.\nIf the device is unsubscribed, the connection will be disconnected and instructions are not able to be issued to the device.\n4.4.1 Device subscription\nAll devices obtained through the SDK can be subscribed, and the subscription result is returned via callback. Status query and instructions issuing can only be perform on those successfully subscribed devices when their network becomes available.\n[Code sample]\n// Take the first device instance in the device list as an example, set the listener for it.\nGizWifiDevice mDevice = null;\nfor (int i = 0; i < deviceList.size(); i++) {\n    mDevice = deviceList[0];\nmDevice.setListener(mListener);\nmDevice.setSubscribe(true);\nbreak;\n}\n\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic  void didSetSubscribe(GizWifiErrorCode result, GizWifiDevice device, boolean isSubscribed) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n};\n4.4.2 Non-LAN device binding\nThe App can complete the binding of the non-LAN device through the MAC, productKey, and productSecret of the device. The above information can be used to generate a QR code, which will be used by the App to bind the device. GPRS devices, Bluetooth devices, etc. are devices that cannot be discovered through the Wi-Fi LAN, and all belong to non-LAN devices.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().bindRemoteDevice (\"your_uid\", \"your_token\", \"your_device_mac\", \"your_device_product_key\", \"your_product_secret\");\n\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didBindDevice(GizWifiErrorCode result, String did) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n} else {\n            // Failure\n}\n}\n};\n4.4.3 Set device binding information\nYou can also set the binding information of the device without subscribing to it. Find the device you want to modify the remark and alias information in the device list if it is bound already.\n[Code sample]\n// mDevice is the device entity object obtained from the device list, setting the listener for it.\nmDevice.setCustomInfo(\"your_remark\", \"your_alias\");\n\n\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic void didSetCustomInfo(GizWifiErrorCode result, GizWifiDevice device) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// Success\n} else {\n// Failure\n}\n}\n};\n4.5 Unbind device\nThe bound device can be unbound. To unbind a device requires the App to invoke the API to complete the operation. The SDK does not support automatic unbinding. For the device subscribed to, after unbound, it will be un-subscribed and disconnected and not report status. Thus, the App will not get the device when it refreshes the device list.\n[Code sample]\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().unbindDevice(\"your_uid\", \"your_token\", \"your_device_did\");\n\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didUnbindDevice(GizWifiErrorCode result, String did) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n} else {\n            // Failure\n}\n}\n};\n4.6 Get hardware information\nHardware information can be obtained without subscribing to the device. The App can get hardware information such as the module protocol version number and the MCU firmware version number, but only by the way of Micro Cycle.\n[Code sample]\n// mDevice is the device entity object obtained from the device list, setting the listener for it.\nmDevice.setListener(mListener);\nmDevice.getHardwareInfo();\n\n\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic  void didGetHardwareInfo(GizWifiErrorCode result, GizWifiDevice device, ConcurrentHashMap<String, String> hardwareInfo) {\nStringBuilder sb = new StringBuilder();\nif(result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\nsb.append(\"Wifi Hardware Version:\" + hardwareInfo.get(\"wifiHardVersion\")\n                        + \"\\r\\n\");\nsb.append(\"Wifi Software Version:\" + hardwareInfo.get(\"wifiSoftVersion\")\n                        + \"\\r\\n\");\nsb.append(\"MCU Hardware Version:\" + hardwareInfo.get(\"mcuHardVersion\")\n                        + \"\\r\\n\");\nsb.append(\"MCU Software Version:\" + hardwareInfo.get(\"mcuSoftVersion\")\n                        + \"\\r\\n\");\nsb.append(\"Firmware Id:\" + hardwareInfo.get(\"wifiFirmwareId\") + \"\\r\\n\");\nsb.append(\"Firmware Version:\" + hardwareInfo.get(\"wifiFirmwareVer\")\n                        + \"\\r\\n\");\nsb.append(\"Product Key:\" + hardwareInfo.get(\"productKey\") + \"\\r\\n\");\nsb.append(\"Device ID:\" + device.getDid() + \"\\r\\n\");\nsb.append(\"Device IP:\" + device.getIPAddress() + \"\\r\\n\");\nsb.append(\"Device MAC:\" + device.getMacAddress() + \"\\r\\n\");\n\n}else{\nsb.append(\"获取失败，错误号：\" + result);\n}\n\nMessage msg = new Message();\nmsg.what = HARDWARE;\nmsg.obj = sb.toString();\nhandler.sendMessage(msg);\n}\n};\n5. Device control\nThe SDK controls devices and receives device status through dictionary key-value pairs. After receiving dictionary key-value pairs of an instruction sent by the App, the SDK parses the data that can be recognized by the device and sends it to the device. In the opposite direction, after receiving the data that the device replies or reports, the SDK parses it to dictionary key-value pairs and reports it to the App.\nThe GAgent firmware and Gizwits serial port communication protocol need to be flashed onto the smart device correctly. If data points are defined for the device, the instructions sent by the App must conform to the data point definition. If there is no data point defined for the device, the device instructions can be issued in a custom format.\n5.1 Flow chart\n\n5.2 Send device instructions\nAfter the device subscription becomes available, the App can send instructions. Device instructions are in dictionary format, with key-value pairs being data point names and values. The instruction result is returned in the didReceiveData callback.\nWhen the App issues an instruction in which the parameter sn can be specified, and the parameter sn in the callback can indicate whether the issued instruction is successfully sent. However, the callback parameter dataMap may be an empty dictionary, depending on whether the device passes the current data point status when replying.\nIf the App only concerns whether there is a device status report after the instruction is issued, the parameter sn of the issued instruction can be filled with 0, and the callback parameter sn is also 0.\n[Code sample]\n// mDevice is the device entity object obtained from the device list, setting the listener for it.\nmDevice.setListener(mListener);\n\n// After the device is subscribed and becomes controllable, the light-on action is performed.\nint sn = 5;\nConcurrentHashMap<String, Object> command = new ConcurrentHashMap<String, Object> ();\ncommand.put(\"LED_OnOff\", true);\nmDevice.write(command, sn);\n\n\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic  void didReceiveData(GizWifiErrorCode result, GizWifiDevice device, ConcurrentHashMap<String, Object> dataMap, int sn) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\nif (sn == 5) {\n        // The command sequence number matches, and the light-on command is executed successfully.\n} else {\n        // ACK for other command or data report\n}\n} else {\n// Failure\n}\n}\n};\n5.3 Get device status\nAfter the device subscription becomes available, the App can receive the device status report at any time through the didReceiveData callback. When the device reports its status, the callback parameter sn is 0, and the callback parameter dataMap has the status reported by the device.\n[Code sample]\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic void didReceiveData(GizWifiErrorCode result, GizWifiDevice device, ConcurrentHashMap<String, Object> dataMap, int sn) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n\n    // Defined device data points with boolean, numeric, and enumeration data\n    if (dataMap.get(\"data\") != null) {\n    ConcurrentHashMap<String, Object> map = (ConcurrentHashMap<String, Object>) dataMap.get(\"data\");\n\n        // Regular data points, print the corresponding key and value pairs\n        StringBuilder sb = new StringBuilder();\n        for (String key : map.keySet()) {\n            sb.append(key + \"  :\" + map.get(key) + \"\\r\\n\");\n            Toast.makeText(DeviceControlActivity.this,\n                    sb.toString(), Toast.LENGTH_SHORT).show();\n        }\n\n        // Extended data point, if the key is \"BBBB\"\n        byte[] bytes = (byte[]) map.get(\"BBBB\");\n        String string = Arrays.toString(bytes);\n        Toast.makeText(DeviceControlActivity.this,\n                string, Toast.LENGTH_SHORT).show();\n    }\n\n        // The device defined fault data points. After the device failures occurred, the field is populated. If there is no fault, it is empty.\n    if (dataMap.get(\"faults\") != null) {\n    ConcurrentHashMap<String, Object> map =  (ConcurrentHashMap<String, Object>)dataMap.get(\"faults\");\n        StringBuilder sb = new StringBuilder();\n\n        for (String key : map.keySet()) {\n            sb.append(key + \"  :\" +  map.get(key) + \"\\r\\n\");\n            Toast.makeText(DeviceControlActivity.this,\n                    sb.toString(), Toast.LENGTH_SHORT).show();\n        }\n    }\n\n        // The device defined alarm data points. After the device has alarms, the field is populated. If there is no alarm, it is empty.\n    if (dataMap.get(\"alerts\") != null) {\n    ConcurrentHashMap<String, Object> map =  (ConcurrentHashMap<String, Object>)dataMap.get(\"alerts\");\n        StringBuilder sb = new StringBuilder();\n\n        for (String key : map.keySet()) {\n                    sb.append(key + \"  :\" +  map.get(key) + \"\\r\\n\");\n                    Toast.makeText(DeviceControlActivity.this,\n                    sb.toString(), Toast.LENGTH_SHORT).show();\n        }\n    }\n\n        // Transparent transmission, no defined data points, suitable for developers to define their own protocols\n    if (dataMap.get(\"binary\") != null) {\n        byte[] binary = (byte[]) dataMap.get(\"binary\");\n        Log.i(\"\", \"Binary data:\"\n                + bytesToHex(binary, 0, binary.length));\n    }\n    }\n}\n};\n5.4 Device status query\nAfter the device subscription becomes available, the App can query the device status. The device status query result is also obtained by the didReceiveData callback, and the callback parameter sn is 0. The callback parameter dataMap has the status of the returned status.\n[Code sample]\n// mDevice is the device entity object obtained from the device list, setting the listener for it\nmDevice.setListener(mListener);\nmDevice.getDeviceStatus();\n\n\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n    @Override\n    public  void didReceiveData(GizWifiErrorCode result, GizWifiDevice device, ConcurrentHashMap<String, Object> dataMap, int sn) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // The data parse is the same as section 3.5.3\n        } else {\n            // Failure\n        }\n    }\n};\n6. Device task scheduling\nBy setting up a scheduled task for a device, you can have the device perform certain actions on a predetermined date and time. These tasks can be repeated on certain days of each month or on certain days of each week.\nScheduled tasks can be set first and then executed or stopped at any time. The scheduled task is enabled by default when it is created.\n6.1 Flow chart\n\n6.2 Create a scheduled task\nScheduled tasks can be executed repeatedly or only once, and repeated tasks are divided into monthly occurring tasks and weekly occurring tasks. However, you can only specify one type of repetition at the same time, that is, not repeated or repeated on a weekly basis or repeated on a monthly basis.\nWhen using the SDK API, the parameter weekDays is set for weekly occurring tasks and the parameter monthDays is set for monthly occurring tasks. However, if both are set, only the parameter weekDays will be used.\nThe following three examples are shown below.\n6.2.1 Create a one-time scheduled task\nSuppose we need to turn on a light at 6:30 am on January 16, 2017. In the following code, the date and time are set to the corresponding values, where the date is 2017-01-16, the time is 06:30 (in 24-hour format).\n[Code sample]\n// Set up scheduled task listener\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// Create a one-time scheduled task，to turn on a light at 6:30 am on January 16, 2017. \nGizDeviceScheduler scheduler = new GizDeviceScheduler();\nscheduler.setDate(\"2017-01-16\");\nscheduler.setTime(\"06:30\");\nscheduler.setRemark(\"开灯任务\");\nConcurrentHashMap<String, Object> attrs = new ConcurrentHashMap<String, Object>();\nattrs.put(\"LED_OnOff\", true);\nscheduler.setAttrs(attrs);\n\n// Create a scheduled task for the device mDevice that is the device object obtained in the device list.\nGizDeviceSchedulerCenter.createScheduler(\"your_uid\", \"your_token\", mDevice, scheduler);\n\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n        } else {\n            // Failure\n        }\n    }\n};\n6.2.2 Create a weekly occurring scheduled task\nWe now get the scheduled task executed on a weekly basis, and we have to turn on a light every Monday to Friday at 6:30 in the morning.\n[Code sample]\n// Set up scheduled task listener\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// Create a weekly occurring scheduled task to turn on a light every Monday to Friday \nGizDeviceScheduler scheduler = new GizDeviceScheduler();\nscheduler.setDate(\"2017-01-16\");\nscheduler.setTime(\"06:30\");\nscheduler.setRemark(\"开灯任务\");\nConcurrentHashMap<String, Object> attrs = new ConcurrentHashMap<String, Object>();\nattrs.put(\"LED_OnOff\", true);\nscheduler.setAttrs(attrs);\nList<GizScheduleWeekday> weekDays = new ArrayList<GizScheduleWeekday>();\nweekDays.add(GizScheduleWeekday.GizScheduleMonday);\nweekDays.add(GizScheduleWeekday.GizScheduleTuesday);\nweekDays.add(GizScheduleWeekday.GizScheduleWednesday);\nweekDays.add(GizScheduleWeekday.GizScheduleThursday);\nweekDays.add(GizScheduleWeekday.GizScheduleFriday);\nscheduler.setMonthDays(monthDays);\n\n// Create a scheduled task for the device mDevice that is the device object obtained in the device list.\nGizDeviceSchedulerCenter.createScheduler(\"your_uid\", \"your_token\", mDevice, scheduler);\n\n\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n        } else {\n            // Failure\n        }\n    }\n};\n6.2.3 Create a monthly occurring scheduled task\nWe now get the scheduled tasks executed on a monthly basis, and we have to turn on the light on the 1st and 15th of each month at 6:30 in the morning. \nNote that do not set a weekly occurring scheduled task together with a monthly occurring scheduled task. If you do so, the monthly occurring scheduled task will be ignored. \n[Code sample]\n// Set up scheduled task listener\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// Create a monthly occurring scheduled task to turn on the light on the 1st and 15th of each month\nGizDeviceScheduler scheduler = new GizDeviceScheduler();\nscheduler.setDate(\"2017-01-16\");\nscheduler.setTime(\"06:30\");\nscheduler.setRemark(\"开灯任务\");\nConcurrentHashMap<String, Object> attrs = new ConcurrentHashMap<String, Object>();\nattrs.put(\"LED_OnOff\", true);\nscheduler.setAttrs(attrs);\nList<Integer> monthDays = new ArrayList<Integer>();\nmonthDays.add(1);\nmonthDays.add(15);\nscheduler.setMonthDays(monthDays);\n\n// Create a scheduled task for the device mDevice that is the device object obtained in the device list.\nGizDeviceSchedulerCenter.createScheduler(\"your_uid\", \"your_token\", mDevice, scheduler);\n\n\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n        } else {\n            // Failure\n        }\n    }\n};\n6.3 Obtain the scheduled task list\nAfter creating a scheduled task, you can get a list of all scheduled tasks that have been created. After obtaining the scheduled task list, you can modify or delete any created scheduled task in the list.\n[Code sample]\n// Set up scheduled task listener\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// Synchronize the scheduled task list of the device mDevice that is the device object obtained in the device list.\nGizDeviceSchedulerCenter.updateSchedulers(\"your_uid\", \"your_token\", mDevice);\n\n\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n        } else {\n            // Failure\n        }\n    }\n};\n6.4 Modify a scheduled task\nYou can modify a scheduled task that has been created. When modifying, the scheduled task object is taken out from the obtained scheduled task list.\nNote that once a scheduled task is created, it is assigned an ID that cannot be modified.\n[Code sample]\n// Set up scheduled task listener\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// Modify the previously created one-time scheduled task to a scheduled task that is executed repeatedly on the 1st and 15th of each month. The scheduler is the scheduled task object to be modified in the scheduled task list.\nscheduler.setTime(\"06:30\");\nscheduler.setRemark(\"开灯任务\");\nConcurrentHashMap<String, Object> attrs = new ConcurrentHashMap<String, Object>();\nattrs.put(\"LED_OnOff\", true);\nscheduler.setAttrs(attrs);\nList<Integer> monthDays = new ArrayList<Integer>();\nmonthDays.add(1);\nmonthDays.add(15);\nscheduler.setMonthDays(monthDays);\n\n// Modify the scheduled task of the device mDevice that is the device object in the device list to create a scheduled task.\nGizDeviceSchedulerCenter.editScheduler(\"your_uid\", \"your_token\", mDevice, scheduler);\n\n\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n        } else {\n            // Failure\n        }\n    }\n};\n6.5 Delete a scheduled task\nIn the obtained scheduled task list, find the scheduled task ID to be deleted and delete it.\n[Code sample]\n// Set up scheduled task listener\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// Delete the scheduled task list of the device mDevice that is the device object obtained in the device list. your_scheduler_id is the ID of the scheduled task to be deleted.\nGizDeviceSchedulerCenter.deleteScheduler(\"your_uid\", \"your_token\", mDevice, \"your_scheduler_id\");\n\n\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n        } else {\n            // Failure\n        }\n    }\n};\n7. Device sharing\nAfter binding a device, you can let others use the device through device sharing. When multiple customers use the same device, device sharing provides device permission management with a more secure and convenient device binding. There are four types of device permissions for device binding:\n\nOwner: The primary account of the device, which can share the device;\nGuest: The shared account of the device, which can accept the sharing invitation and can no longer share the device to other users;\nSpecial: The account which has bound to the device at the earliest but has not shared the device, and will become the Owner of the device after sharing it;\nNormal: The account that has bound to the device but cannot share the device or become the Owner of the device.\n\nOnly the user bound to a device at the earliest or the Owner of a device can share the device. Once a device has an Owner account, other users can no longer bind the device. The Owner can view the currently users bound to the device and can unbind other users. When a device does not have an Owner, other users can bind the device.\n7.1 Flow chart\n\n7.2 Make a device sharing invitation\nBefore sharing your devices, check which devices you can share. Using the SDK, the App can traverse the list of devices and find those devices on which the currently logged in user has a permission of GizDeviceSharingSpecial or GizDeviceSharingOwner to create a device sharing invitation.\nThere are two ways to create a device sharing invitation by Owner and Special: Account Sharing and QR code Sharing.\n7.2.1 Account Sharing\nFor Account sharing, the receiver's account can be a mobile phone number, an email address, a regular user name, or an anonymous account, but it must be a user who has already registered in Gizwits Cloud. If the user is already the Guest account of this device or has already bound the device, the sharing invitation will fail to be created. The account sharing invitation is valid for 24 hours, that is, the receiver must respond within 24 hours, otherwise the invitation will expire. \nYou need to specify the account type for Account Sharing. The guestUser parameter for the anonymous user should be set to the uid of the anonymous user. When the Account Sharing is created successfully, the sharingID will be returned in the callback parameter, but the QRCodeImage will not be returned. The following is only an example of device sharing to a user registered with mobile phone number:\n[Code sample]\n// Set device sharing listener\nGizDeviceSharing.setListener(mListener);\n\n// Find devices that can be shared in the device list\n\n// Share the device via phone number\nGizDeviceSharing.sharingDevice(\"your_token\", \"your_device_id\", GizDeviceSharingWay.GizDeviceSharingByNormal, \"guest_phone_number\", GizUserAccountType.GizUserPhone);\n\nGizDeviceSharingListener mListener = new GizDeviceSharingListener() {\n\n    @Override\n    public void didSharingDevice(GizWifiErrorCode result, String deviceID, int sharingID, Bitmap QRCodeImage) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n        } else {\n            // Failure\n        }\n    }\n};\n7.2.2 QR code Sharing\nFor the QR code Sharing, the QR code is valid for 15 minutes, that is, the receiver must scan the generated QR code within 15 minutes and respond, otherwise the QR code invitation will expire. When the QR code Sharing invitation is created successfully, the sharingID will be returned in the callback parameter, and the corresponding QRCodeImage will also be returned. The App can directly load the QR code image.\n[Code sample]\n// Set device sharing listener\nGizDeviceSharing.setListener(mListener);\n\n// Find devices that can be shared in the device list\n\n// Share the device via QR code\nGizDeviceSharing.sharingDevice(\"your_token\", \"your_device_id\", GizDeviceSharingWay.GizDeviceSharingByQRCode, null, null);\n\nGizDeviceSharingListener mListener = new GizDeviceSharingListener() {\n\n    @Override\n    public void didSharingDevice(GizWifiErrorCode result, String deviceID, int sharingID, Bitmap QRCodeImage) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n        } else {\n            // Failure\n        }\n    }\n};\n7.3 Accept sharing invitation\nThe Guest account can query the received sharing invitations. Only the Guest account can accept the sharing invitation.\n7.3.1 Accept Account Sharing invitation\nIf a sharing invitation received by the Guest has not yet been accepted, the Guest can accept or reject it.\n[Code sample]\n// Set device sharing listener\nGizDeviceSharing.setListener(mListener);\n\n// Query the list of sharing invitations sent to you\nGizDeviceSharing.getDeviceSharingInfos(\"your_token\", GizDeviceSharingType.GizDeviceSharingToMe, \"your_device_id\");\n\nGizDeviceSharingListener mListener = new GizDeviceSharingListener() {\n\n\n    @Override\n    public void didGetDeviceSharingInfos(GizWifiErrorCode result, String deviceID, List<GizDeviceSharingInfo> deviceSharingInfos) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n\n            // Successfully retrieved. Find the share invitations that have not yet been accepted in deviceSharingInfos. your_sharing_id is the ID of the share invitation to be acceptted\n            int your_sharing_id = -1;\n            for (int i = 0; i < deviceSharingInfos.size(); i++) {\n                GizDeviceSharingInfo mDeviceSharing = deviceSharingInfos.get(i);\n                if (mDeviceSharing.getStatus() == GizDeviceSharingStatus.GizDeviceSharingNotAccepted) {\n                    your_sharing_id = mDeviceSharing.getId();\n                    break;\n                }\n            }\n\n            // Accept invitation\n            if (your_sharing_id != -1) {\n                GizDeviceSharing.acceptDeviceSharing(\"your_token\", your_sharing_id, true);\n            }\n\n        } else {\n            // Failed to retrieve\n        }\n    }\n\n\n    @Override\n    public void didAcceptDeviceSharing(GizWifiErrorCode result, int sharingID) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // Success\n        } else {\n            // Failure\n        }\n    }\n};\nSee Also\nSee \"Introduction to App code auto-generator\" to understand what functions the automatically generated App code has;\nSee \"App open source framework\" to understand\n\nGuide of App open source framework for iOS\nGuide of iOS App push notification integration\nGuide of iOS App third-party authentication and re-skin\nQuick start of iOS App development\nGuide of App open source framework for Android\nGuide of Android App push notification integration\nGuide of Android App third-party authentication and re-skin\nGuide of APICloud open source framework\n\nSee \"App Development SDK\" to develop the IoT App (many user cases of design details can be found here)\n\nGuide of Gizwits Device SDK 2.0 for iOS App\nGuide of Gizwits Device SDK 2.0 for Android App\nGuide of Gizwits Device SDK for APICloud App\nExplanation of SDK data transparent transmission\nGuide of SDK debug log capture\nSDK error codes\n\nMore application development guides\n\nApplication development FAQ\nDevice sharing guide\nApplication process for third-party authentication platform \n\n"},{"title":"Gizwits Open API","url":"/en-us/cloud/OpenAPI.html","content":"\nCtrl + F on a Windows, is the keyboard shortcut for quick search.\nCommand+F on a Mac, is the keyboard shortcut for quick search.\n\nOverview\nGizwits is an open IoT device management platform that provides enterprise and individual developers with services such as fast device onboarding, provisioning, authentication, configuration, remote monitoring, task scheduling, and advanced data analytics. \nGizwits exposes a significant range of functionality via Open API. \nThe Open API lets developers securely authenticate users with custom applications so they can control the Gizwits powered devices associated with their accounts.\nAPIs\nThe following are several sets of API lists that specify the structure of the data that is exchanged between your applications and the Gizwits Cloud.\n\nUser Management：Manage user registration, login, password reset etc.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_users\nGet user information\n\n\npost_app_users\nCreate a new user\n\n\nput_app_users\nUpdate user information\n\n\npost_app_login\nUser login\n\n\npost_app_request_token\nRequest an access token\n\n\npost_app_reset_password\nRequest to password reset\n\n\npost_app_sms_code\nGet and verify a SMS verification code\n\n\nget_app_verify_codes\nGet an image verification code\n\n\npost_app_verify_codes\nVerify an image verification code\n\n\nput_app_verify_codes\nVerify a SMS verification code\n\n\n\n\nMessage Center：Get, mark as read and delete system messages etc.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_messages\nGet a message list\n\n\nput_app_messages\nMark as read or delete a message\n\n\n\n\nBinding Management：Bind/unbind user and devices.\n\n\n\n\nAPI List\nDescription\n\n\n\n\npost_app_bind_mac\nBind a device by its MAC address\n\n\ndelete_app_bindings\nUnbind devices\n\n\nget_app_bindings\nGet a list of bound devices\n\n\npost_app_bind_latest\nBind a device by its QRCode\n\n\nput_app_bindings_did\nUpdate binding information\n\n\nget_app_did_bindings\nGet guest users information for a given device\n\n\n\n\nDevice Remote Monitoring: Get device current status, reported raw data, online&offline status records, and control it remotely etc.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_devdata_did_latest\nGet latest status of a given device\n\n\nget_app_datapoint\nGet the definition of product datapoint\n\n\nget_app_devices_did\nGet details of a given device\n\n\nget_app_devices_did_raw_data\nGet communication log and online&offline status records of a device\n\n\n\npost_app_control_did\nControl a given device remotely\n\n\n\n\nDevice Sharing: Users share their own bound device to other users to bind, and unbind other users' binding to their own devices, etc. \n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_sharing\nGet a list of sent and received sharing invitations\n\n\npost_app_sharing\nCreate a sharing invitation\n\n\ndelete_app_sharing_id\nCancel/retract a sharing invitation\n\n\nput_app_sharing_id\nAccept/reject a sharing invitation\n\n\nget_app_sharing_code\nGet sharing invitation information of a given QRCode\n\n\npost_app_sharing_code\nAccept a sharing invitation by a given QRCode\n\n\nput_app_sharing_idalias\nUpdate a guest or owner alias of a given invitation\n\n\npost_app_sharing_did_transfer\nTransfer ownership of a device to a guest\n\n\n\n\nDevice Grouping: Group multiple devices so that send an instruction to control multiple devices incoming a group at once.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_group\nGet all user groups\n\n\npost_app_group\nCreate a group\n\n\ndelete_app_group_id\nDelete a device group\n\n\nput_app_group_id\nUpdate group information\n\n\nget_app_group_id_devices\nGet devices information of a given group\n\n\npost_app_group_id_devices\nAdd devices into a group\n\n\ndelete_app_group_id_devices\nRemove devices from a group\n\n\npost_app_group_id_control\nControl all devices in a given group\n\n\n\n\nDevices Linkage: Set up rules of devices linkage that will be triggered by some devices to control other devices. \n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_rules_params\nGet datapoints of all products can be used by rules \n\n\nget_app_rules\nGet rules list for devices linkage\n\n\npost_app_rules\nCreate a rule of devices linkage\n\n\ndelete_app_rules\nDelete a rule of devices linkage\n\n\nput_app_rules\nUpdate a rule of devices linkage\n\n\n\n\nUser Scenario: Predefine a series of device actions according to a scenario that will be triggered when needed.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_scene\nGet all scenarios\n\n\npost_app_scene\nCreate a scenario\n\n\ndelete_app_scene_id\nDelete a scenario\n\n\nput_app_scene_id\nUpdate a scenario information\n\n\nget_app_scene_id_task\nGet task execution status of a given scenario\n\n\npost_app_scene_id_task\nPerform a scenario task\n\n\n\n\nTask Scheduling Management: Addition, deletion, modification, etc. of device task scheduling.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_devices_scheduler\nGet a list of scheduled tasks\n\n\npost_app_devices_scheduler\nCreate a scheduled task\n\n\ndelete_app_devices_scheduler\nDelete a scheduled task\n\n\nput_app_devices_scheduler\nUpdate a scheduled task\n\n\n\n\nCommon Task Scheduling: Schedule tasks for individual devices, device groups, and scenarios.    \n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_common_scheduler\nGet a common scheduled task\n\n\npost_app_common_scheduler\nCreate a common scheduled task\n\n\ndelete_app_common_scheduler\nDelete a common scheduled task\n\n\nput_app_common_scheduler\nUpdate a common scheduled task\n\n\n\n\nAdvanced Data API: Retrieve aggregated values of daily maximum, average, etc. for the numeric data reported by devices.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_app_bindings\nGet an aggregated value of a given device\n\n\n\n\nSystem Information: Check the current version of Open API and retrieve a list of all possible errors.\n\n\n\n\nAPI List\nDescription\n\n\n\n\nget_status\nGet service status\n\n\nget_errors\nGet error status code list\n\n\n\nSpecification\nUsing HTTP API\nGizwits Open API exposes a significant range of functionality via a RESTful API set, which can be accessed via any client using standard HTTP.\nRecommended HTTP Clients：\n\nGUI  client PostMan\nCommand-line client curl\n\nHTTP Request Headers\nX-Gizwits-Application-Id\nX-Gizwits-Application-Id referred to as AppID, is a unique identifier applied to the Gizwits platform. When issuing a HTTP request, your request must include this header parameters.\nOn the product page of the developer center, click the \"Application Configuration\" menu in the left column to create an application and get an AppID as well:\n\nX-Gizwits-User-token\nX-Gizwits-User-token referred to as UserToken, represents the user context during the API interaction.\nUserToken has a validity period. By default, it expires after 7 days.\nUserToken can be obtained through user registration or login request. UserToken is the token field returned in the response, and expire_at field is the timestamp of UserToken expiration:\n{\n  \"uid\": \"29db4f0d806e451a84264ba3da64d9de\",\n  \"token\": \"86a0ee91548f4971832e371811702316\",\n  \"expire_at\": 13894002020\n}\nA new UserToken is generated when login request is issued every time. Either the new UserToken or the old one can be used.\nBecause most of the Gizwits Open API are user-related, the call sequence of APIs is as follows generally:\n\nCheck if there is a local UserToken, and if it expires\nIf there is no UserToken or UserToken expired, issue the user login request, get and save the returned UserToken\nUse the UserToken to call other APIs\n\nEncrypting Parameters\n\nUse 32-bit encryption uniformly\nLower: lowercase\nUpper: uppercase\n\nExample：\nlower (md5(product_secret + X-Gizwits-Timestamp ))\nSelect md5, 32 bits [small] for encryption, fill in product_secret and X-Gizwits-Timestamp, without the \"+\" sign, as shown below\n\nOnline debugger\nWe provide online API debugging tools. The corresponding debug link is given in each API description.\nThe following example illustrates the usage of API debugging tools via user login:\n\nClick  user login to enter the API debugging page\nThere is a red exclamation mark on the right side of the API. After clicking it, a dialog box pops up prompting for the required header information.\nThe API needs to enter the X-Gizwits-Application-Id, get the AppID according to the previous instructions and fill it in, click \"Authorize\" to authorize\nThe page is automatically refreshed and the exclamation mark turns blue, indicating that the required header information has been filled in (filled does not necessarily indicate that the value is correct. If the value is incorrect, the corresponding result will be returned in the response)\nEnter the parameter value in the input box (click the Example Value yellow box to the right of the parameter to enter the sample JSON quickly)\nClick the \"Try\" button to complete the API request\nThe request completes, displaying the equivalent curl statement of local call, request URL, response body, response code, and response header\n\nUser Management\nCreate a user\nDebug console\nThere are several ways to create new users:\n\nAnonymous registration, creating a user with a unique phone_id\nUser name&password registration, create a user by username and passowrd\nMobile phone registration, create users via phone, password and code (SMS verification code). About SMS verification code acquisition, please refer to the following section.\nEmail registration, create users via email and password\nThird-party authentication, creating a user through src, uid, and token in authData. Currently supports Tencent QQ, Sina Weibo, Baidu, WeChat, Facebook, Twitter, Google+, Amazon\n\nThird-party authentication notes:\n\nFor Google and Amazon third-party authentication, token in authData needs to start with \"Bearer\"\nFor QQ and Twitter third-party authentication, it needs to fill API_KEY and API_Secret in Developer Center\nFacebook, Twitter, Google, Amazon third-party authentication can only be used in the Eastern United States and Europe regions\n\nPassword strength requirements:\n\nThe password length is not less than 8 characters\nThe password should be combination of three of four types of characters, which are uppercase, lowercase, numbers, special symbols\n\nRequest method and URL\nPOST\nhttp://api.gizwits.com/app/users\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nphone_id\nstring\nNo\nbody\nAnonymous identity, the request parameter for anonymous registration\n\n\nusername\nstring\nNo\nbody\nUser name, the request parameter for user name&password registration \n\n\npassword\nstring\nNo\nbody\nPassword, the request parameter for username&password registration, mobile registration, email registration\n\n\nemail\nstring\nNo\nbody\nEmail Address, the Request Parameter for Email registration \n\n\nphone\nstring\nNo\nbody\nMobile phone number, the request parameter for mobile phone registration\n\n\ncode\nstring\nNo\nbody\nVerification code, SMS verification code, request parameter for mobile registration\n\n\nlang\nstring\nNo\nbody\nLanguage:en,zh-cn\n\n\nsrc\nstring\nNo\nbody\nPlatform type: qq, sina, baidu, wechat, twitter, facebook, google, amazon\n\n\nuid\nstring\nNo\nbody\nreturned uid from third-party authentication platform \n\n\ntoken\nstring\nNo\nbody\nreturned token from third-party authentication platform \n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nuid\nstring\nUnique user id\n\n\ntoken\nstring\nUser token\n\n\nexpire_at\ninteger\nToken expiration time (timestamp)\n\n\n\nExample Response\n{\n  \"token\": \"f8324047f20144f6914e7be19304f943\",\n  \"uid\": \"f082f4e235974cfeb6a1b40a6024f47e\",\n  \"expire_at\": 1504772734\n}\nGet user information\nDebug console\nRequest method and URL\nGET\nhttp://api.gizwits.com/app/users\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nusername\nstring\nUser name\n\n\nphone\nstring\nPhone number\n\n\nemail\nstring\nEmail address\n\n\nname\nstring\nName\n\n\ngender\nstring\nGender，M：Male, F：Female, N：Unknown\n\n\nbirthday\nstring\nBirthday，date format：YYYY-MM-DD or MM-DD\n\n\naddress\nstring\nAddress\n\n\nlang\nstring\nLanguage version,en, zh-cn\n\n\nremar\nstring\nRemark\n\n\nuid\nstring\nUnique user id\n\n\nis_anonymous\nboolean\nIs anonymous user or not\n\n\n\nExample Response\n{\n    \"username\": \"gizwits\",\n    \"uid\": \"f082f4e235974cfeb6a1b40a6024f47e\",\n    \"phone\": \"18888888888\",\n    \"birthday\": \"2017-01-01\",\n    \"address\": \"guangzhou\",\n    \"lang\": \"zh-cn\",\n    \"remark\": \"remark\",\n    \"name\": \"gizwits\",\n    \"is_anonymous\": false,\n    \"gender\": \"M\",\n    \"email\": \"club@gizwits.com\"\n}\nUpdate user information\nDebug console\nThere are several corresponding ways to update user information for different registration types:\n\nConvert anonymously registered users to regular users: Enter username, password\nConvert anonymously registered users to mobile users: Enter phone, password, code (returned by obtaining the verification code API)\nChange Password: Enter old_pwd, new_pwd\nModify phone number: Enter phone, code (returned by obtaining the verification code API)\nModify basic information: name, gender, birthday, address, language version, remarks\n\nRequest method and URL\nPUT\nhttp://api.gizwits.com/app/users\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nusername\nstring\nNo\nbody\nUsername for converting an anonymous user to a regular user\n\n\npassword\nstring\nNo\nbody\nPassword for converting an anonymous user to a regular user\n\n\nphone\nstring\nNo\nbody\nMobile phone number for converting an anonymous user to a mobile registered user\n\n\ncode\nstring\nNo\nbody\nVerification code for converting an anonymous user to a mobile registered user\n\n\nold_pwd\nstring\nNo\nbody\nOld password, used to change the password\n\n\nnew_pwd\nstring\nNo\nbody\nNew password, used to change the password\n\n\nemail\nstring\nNo\nbody\nRegistered email for converting an  anonymous user to a registered user\n\n\nname\nstring\nNo\nbody\nName\n\n\ngender\nstring\nNo\nbody\nGender, M: Male, F: Female, N: Unknown\n\n\nbirthday\nstring\nNo\nbody\nBirthday, date format: YYYY-MM-DD or MM-DD\n\n\naddress\nstring\nNo\nbody\naddress\n\n\nlang\nstring\nNo\nbody\nLanguage version en, zh-cn\n\n\nremar\nstring\nNo\nbody\nRemark\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nupdatedAt\nstring\nUpdate time(UTC time)\n\n\n\nExample Response\n{\n  \"updatedAt\": \"2017-01-01T08:32:56.996638\"\n}\nUser login\nDebug console\nAnonymous and third-party authentication users invoke the creating user API to log in.\nRequest method and URL\nPOST\nhttp://api.gizwits.com/app/login\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nusername\nstring\nYes\nbody\nUser name，can be the user's username/email/phone\n\n\npassword\nstring\nYes\nbody\nPassword\n\n\nlang\nstring\nNo\nbody\nLanguage version\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nuid\nstring\nUnique user id\n\n\ntoken\nstring\nUser token\n\n\nexpire_at\ninteger\nToken expiration time (timestamp) \n\n\n\nExample Response\n{\n  \"token\": \"f8324047f20144f6914e7be19304f943\",\n  \"uid\": \"f082f4e235974cfeb6a1b40a6024f47e\",\n  \"expire_at\": 1504772734\n}\nRequest an access token\nDebug console\nThe token parameter obtained by the API is mainly used as a request parameter when the SMS verification code API and the image verification code API are invoked.\nRequest method and URL\nPOST  \nhttp://api.gizwits.com/app/request_token\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-Application-Auth\nstring\nYes\nheader\nMD5_32-bit encryption(appid + appsecret)\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nuid\nstring\nUnique user id\n\n\nexpire_at\ninteger\nToken expiration time (timestamp)\n\n\n\nExample Response\n{\n  \"token\": \"f8324047f20144f6914e7be19304f943\",\n  \"expire_at\": 1504772734\n}\nRequest to password reset\nDebug console\nOnly those users who have set email or phone can reset the password.\n\nReset your password via email, just provide email, password reset link is sent to the email address\nReset the password via phone, provide phone number, new_pwd, code (returned by calling get SMS verification code API)\n\nRequest method and URL\nPOST\nhttp://api.gizwits.com/app/reset_password\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nemail\nstring\nNo\nbody\nRegistered e-mail\n\n\nphone\nstring\nNo\nbody\nRegistered phone number\n\n\nnew_pwd\nstring\nNo\nbody\nNew password\n\n\ncode\nstring\nNo\nbody\nVerification code\n\n\n\nResponse Parameters\nNo\nGet and verify a SMS verification code\nDebug console\nThe main uses of the SMS verification code are:\n\nRegistration for mobile phone user\nPassword reset for mobile phone user\nOther sensitive actions that you think require a SMS verification code\nThe API can obtain and verify the verification code:\nObtaining SMS verification code only needs phone number\nVerifying SMS verification code needs phone number and code\n\nAbout foreign mobile phone number\n\nTo send a SMS verification code to a foreign mobile phone number, follow the format: +{country code}{mobile phone number}. Assume that an U.S. phone number (country code is 1) is 4246531234, then the phone should be filled as \"+14246531234\"\nThe list of country codes can be obtained here.\n\nThe SMS verification code is invalid immediately after the code is verified correctly. The default validity period is 24 hours.\nRequest method and URL\nPOST\nhttp://api.gizwits.com/app/sms_code\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token, obtained by request an access token API\n\n\nphone\nstring\nYes\nbody\nPhone number\n\n\ncode\nstring\nYes\nbody\nVerification code\n\n\n\nResponse Parameters\nNo\nGet an image verification code\nDebug console\nThe returned captcha_url is the URL of the image captcha and the image is displayed to the user.\nRequest method and URL\nGET\nhttp://api.gizwits.com/app/verify/codes\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token, obtained by request an access token API\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ncaptcha_url\nstring\nURL of the image captcha\n\n\ncaptcha_id\nstring\nID of the image captcha\n\n\n\nExample Response\n{\n  \"captcha_url\": \"http://api.gizwits.com/captcha/image/22d9cdc8edb13fd19f770afbed45351831403b5d/\",\n  \"captcha_id\": \"22d9cdc8edb13fd19f770afbed45351831403b5d\"\n}\nVerify an image verification code\nDebug console\nVerify the image captcha obtained by get image verification code API, if it is entered correctly, a SMS verification code will be sent. \nRequest method and URL\nPOST\nhttp://api.gizwits.com/app/verify/codes\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token, obtained by request an access token API\n\n\ncaptcha_id\nstring\nYes\nbody\nID of the image captcha\n\n\ncaptcha_code\nstring\nYes\nbody\nValue of the image captcha\n\n\nphone\nstring\nYes\nbody\nPhone number\n\n\n\nResponse Parameters\nNo\nVerify a SMS verification code\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/verify/codes\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token, obtained by request an access token API\n\n\nphone\nstring\nYes\nbody\nPhone number\n\n\nsms_code\nstring\nYes\nbody\nVerification code\n\n\n\nResponse Parameters\nNo\nMessage Center\nGet a message list\nDebug console\nGet user's messages, such as sharing information, messages pushed by D3 rules.\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/messages?type=1&limit=20&skip=0\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ntype\ninteger\nYes\nquery\nMessage type，1：device sharing message\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned items   \n\n\nskip\ninteger\nNo\nquery\nIndicates the number of skipped messages, indirectly indicating the number of pages.\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nTotal number of messages\n\n\nlimit\ninteger\nThe number of returned items   \n\n\nskip\ninteger\nNumber of skipped messages\n\n\nprevious\nstring\nRequest address for previous page\n\n\nnext\nstring\nRequest address for next page\n\n\nid\nstring\nMessage ID\n\n\ncreated_at\nstring\nMessage creation time (UTC time)\n\n\nupdated_at\nstring\nMessage update time (UTC time)\n\n\ntype\ninteger\nMessage type, 1: Device sharing message\n\n\nstatus\ninteger\nMessage status, 0 unread, 1 read, 2 delete\n\n\ncontent\nstring\nInformation content\n\n\n\nExample Response\n{\n  \"meta\": {\n    \"total\": 50,\n    \"limit\": 1,\n    \"skip\": 0,\n    \"previous\": \"/app/messages?skip=5&type=1&limit=1\",\n    \"next\": \"/app/messages?skip=7&type=1&limit=1\"\n  },\n  \"objects\": [\n    {\n        \"status\": 0,\n        \"created_at\": \"2017-09-11T11:41:23Z\",\n        \"updated_at\": \"2017-09-11T11:41:23Z\",\n        \"content\": \"您给 188****888 共享了设备 微信宠物屋!\",\n        \"type\": 1,\n        \"id\": \"59b676638c7d500018a9ed98\"\n     },\n  ]\n}\nMark as read or delete a message\nDebug console\nMark user messages as read and delete messages.\nRequest method and URL\nPUT\nhttps://api.gizwits.com/app/messages/{id}?status=1\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\ninteger\nYes\npath\nMessage ID\n\n\nstatus\ninteger\nYes\nquery\nMessage status, 1 read, 2 delete\n\n\n\nResponse Parameters\nNo\nBinding Management\nAfter a device is bound to a user, there is a corresponding \"binding role\" relationship between the device and the user.\nBinding roles are divided into four types, first bind users: special; owner user: owner; guest user: guest; normal user: normal\nRole scenarioes description:\n\nWhen the device is not shared and the device is not bound by any user. An A user is bound to the device. The A user becomes a special user. When a B user is bound to the device. The user B becomes a normal user.\nLet the A user be a special user and the B user be a normal user. When the A user releases the binding and the B user becomes a special user, there is no \"binding role\" relationship between the A user and the device.\nLet the A user be a special user and the B user be a normal user. The product turns on device sharing. The A user shares the device with the C user. Whether or not the C user accepts it, the A user becomes the owner user, and the B user becomes the guest user.\nWhen sharing is turned on and the device does not have any user bindings. An A user is bound to the device. The A user becomes owner user and other users cannot bind the device.\nAssume the A user as owner and C user has not bound the device. The A user shares the device with the C user, and the C user accepts the sharing. A user is still the owner and C is the guest.\nAssume the A user as owner and B user as guest. The A user unbinds the device. There is no \"binding role\" relationship between A or B users and the device.\nOther users cannot share the device except the owner user, there is only one owner for each device.\n\nBinding device\nYou can bind the device in two ways:\n\nBind the device with product_key and MAC address\nBind the device with a QRCode. The content of QRCode is encrypted product_key and MAC, so it is essentially the same as the above one. \n\nBind a device by its MAC address\nDebug console\nBind the user to the device.\nRequest method and URL\nPOST\nhttp://api.gizwits.com/app/bind_mac\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nX-Gizwits-Timestamp\nstring\nYes\nheader\nRequest timestamp, The difference with the server time cannot exceed 5 minutes\n\n\nX-Gizwits-Signature\nstring\nYes\nheader\nSignature, calculated as lower(md5(product_secret + X-Gizwits-Timestamp))\n\n\nproduct_key\nstring\nYes\nbody\nProduct_key\n\n\nmac\nstring\nYes\nbody\nDevice mac address\n\n\nremark\nstring\nNo\nbody\nRemark\n\n\ndev_alias\nstring\nNo\nbody\nDevice alias\n\n\nset_owner\ninteger\nNo\nbody\nWhether it is set to owner, it is only valid for products with device sharing enabled; 0 (default): not set as owner, 1: set as owner\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nproduct_key\nstring\nProduct_key\n\n\ndid\nstring\nDevice ID\n\n\nmac\nstring\nDevice mac address\n\n\nis_online\nboolean\nWhether online or not\n\n\npasscode\nstring\nDevice passcode\n\n\nhost\nstring\nServer domain name\n\n\nport\ninteger\nMQTT port number for M2M\n\n\nport_s\ninteger\nMQTT SSL port number for M2M\n\n\nws_port\ninteger\nWebsocket port number\n\n\nwss_port\ninteger\nWebsocket SSL port number\n\n\nremark\nstring\nDevice remark\n\n\nis_disabled\nboolean\nWhether to log out or not\n\n\ntype\nstring\nDevice type, Single Item Device: normal, Central Control Device: center_control, Central Control Sub Device: sub_dev\n\n\ndev_alias\nstring\nDevice alias\n\n\ndev_label\nArray[string]\nList of device tags, currently used for devices control via voice API\n\n\nrole\nstring\nBinding role, Special user: special, Owner user: owner, Guest user: guest, Normal user: normal\n\n\n\nExample Response\n{\n    \"product_key\": \"4214bf2d79694a259232431b6f2ef46b\",\n    \"did\": \"gKufzxZwYeyd3Skbsb6mza\",\n    \"mac\": \"accf2350d446\",\n    \"is_online\": false,\n    \"passcode\": \"JHHOOIWJBA\",\n    \"host\": \"m2m.gizwits.com\",\n    \"port\": 1883,\n    \"port_s\": 8883,\n    \"ws_port\": 8080,\n    \"wss_port\": 8880,\n    \"remark\": \"备注信息\",\n    \"is_disabled\": false,\n    \"type\": \"normal\",\n    \"dev_alias\": \"设备别名\",\n    \"dev_label\": [],\n    \"role\": \"special\"\n\n}\nUnbind devices\nDebug console\nUnbind the bound devices by users.\nRequest method and URL\nDELETE\nhttps://api.gizwits.com/app/bindings\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndevices\nArray\nYes\nbody\nDevices array to be unbound\n\n\ndid\nstring\nYes\nbody\nDevice ID\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nsuccess\nArray[string]\nDevcies that are unbound successfully\n\n\nfailed\nArray[string]\nDevcies that are unbound unsuccessfully\n\n\n\nExample Response\n{\n    \"failed\": [],\n    \"success\": [\n        \"xAAcCYawLFD9JfMysqYf7d\",\n        \"WCWGkbS4Ttynzwx9brzpEa\"\n    ]\n}\nGet a list of bound devices\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/bindings\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned items   \n\n\nskip\ninteger\nNo\nquery\nIndicates the number of skipped records, indirectly indicating the number of pages.\n\n\nshow_disabled\ninteger\nNo\nquery\nWhether to display the device that has been logged out, 1: Display, 0: Do not display\n\n\nshow_proto_ver\ninteger\nNo\nquery\nWhether to display the device communication protocol version, 1: Display, 0: Do not display\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ndevices\nArray\nA group of bound devices\n\n\nproduct_key\nstring\nProduct_key\n\n\ndid\nstring\nDevice ID\n\n\nmac\nstring\nDevice MAC address\n\n\nis_online\nboolean\nWhether online\n\n\npasscode\nstring\nDevice passcode\n\n\nhost\nstring\nServer domain name\n\n\nport\ninteger\nMQTT port number for M2M\n\n\nport_s\ninteger\nMQTT SSL port number for M2M\n\n\nws_port\ninteger\nWebsocket port number\n\n\nwss_port\ninteger\nWebsocket SSL port number\n\n\nremark\nstring\nDevice remark\n\n\nis_disabled\nboolean\nWhether is logged out\n\n\ntype\nstring\nDevice Type, Single Item Device: normal, Central Control Device: center_control, Central Control Sub Device: sub_dev\n\n\ndev_alias\nstring\nDevice alias\n\n\ndev_label\nArray[string]\nList of device tags, currently used for devices control via voice API\n\n\nproto_ver\nstring\nProtocol version number, '01', '01_01', '03', '04' \n\n\nwifi_soft_version\nstring\nWiFi version number\n\n\nis_sandbox\nboolean\nWhether connecting the sandbox environment\n\n\nrole\nstring\nBinding role, Special user: special, Owner user: owner, Guest user: guest, Normal user: normal\n\n\n\nExample Response\n{\n    \"devices\": [\n      {\n          \"product_key\": \"55af63815cc34788aeeb9451a2454412\",\n          \"did\": \"7r7u8XPkCRLGVYTYrtjoCB\",\n          \"mac\": \"virtual:site\",\n          \"is_online\": false,\n          \"passcode\": \"123456\",\n          \"host\": \"sandbox.gizwits.com\",\n          \"port\": 1883,\n          \"port_s\": 8883,\n          \"ws_port\": 8080,\n          \"wss_port\": 8880,\n          \"remark\": \"备注信息\",\n          \"is_disabled\": false,\n          \"type\": \"normal\",\n          \"dev_alias\": \"设备别名\",\n          \"dev_label\": [],\n          \"proto_ver\": \"04\",\n          \"wifi_soft_version\": null,\n          \"is_sandbox\": true,\n          \"role\": \"special\"\n      },\n      {\n          \"product_key\": \"4214bf2d79694a259232431b6f22f46b\",\n          \"did\": \"gKufzxZwYeyd3Skbsb6mza\",\n          \"mac\": \"accf2350d447\",\n          \"is_online\": false,\n          \"passcode\": \"JHHOOIWJBA\",\n          \"host\": \"m2m.gizwits.com\",\n          \"port\": 1883,\n          \"port_s\": 8883,\n          \"ws_port\": 8080,\n          \"wss_port\": 8880,\n          \"remark\": \"备注信息\",\n          \"is_disabled\": false,\n          \"type\": \"normal\",\n          \"dev_alias\": \"设备别名\",\n          \"dev_label\": [],\n          \"proto_ver\": \"04\",\n          \"wifi_soft_version\": \"04000006\",\n          \"is_sandbox\": true,\n          \"role\": \"special\"\n      }\n    ]\n}\nBind a device by its QRCode\nDebug console\nOnly the QR code generated by Gizwits QR code generation service can be used to invoke this API (Here is the tutorial). \nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/bind_latest\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nqr_content\nstring\nYes\nbody\nThe string obtained by scanning the QR code\n\n\nset_owner\ninteger\nNo\nbody\nWhether to set as owner, only valid for products with device sharing enabled; 0 (default): not to set as owner, 1: set as owner\n\n\n\nResponse Parameters\nNo\nUpdate binding information\nDebug console\nUsers can modify aliases and notes of the bound devices.\nThe same device can be bound by multiple users. Each user can set aliases and notes for the device without conflict.\nRequest method and URL\nPUT\nhttps://api.gizwits.com/app/bindings/{did}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\ninteger\nYes\npath\nDevice ID\n\n\nremark\nstring\nNo\nbody\nDevice remark\n\n\ndev_alias\nstring\nNo\nbody\nDevice alias\n\n\ndev_label\nArray[string]\nNo\nbody\nList of device tags, currently used for devices control via voice API\n\n\n\nNote: Fill in at least one of the body parameters.\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nremark\nstring\nDevice remark\n\n\ndev_label\nArray[string]\nList of device tags, currently used for devices control via voice API\n\n\ndev_alias\nstring\nDevice alias\n\n\n\nExample Response\n{\n    \"remark\": \"备注\",\n    \"dev_label\": [\n        \"标签1\",\n        \"标签2\"\n    ],\n    \"dev_alias\": \"设备别名\"\n}\nGet guest users information for a given device\nDebug console\nView user information of those who accepted device sharing invitation.\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/{did}/bindings\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nusername\nstring\nAccount username, the middle 4 letters are replaced with *\n\n\nphone\nstring\nAccount phone, the middle 4 digits are replaced with *\n\n\ncreated_at\nstring\nThe time the guest user accepted the sharing invitation (UTC time)\n\n\nuid\nstring\nGuest user's UID\n\n\nemail\nstring\nAccount email, 4 characters before @  are replaced with *\n\n\n\nExample Response\n[\n    {\n        \"username\": \"2****2\",\n        \"phone\": null,\n        \"created_at\": \"2017-09-19T07:12:32Z\",\n        \"uid\": \"c0a85d0773e24f15a6853f3148c82313\",\n        \"email\": null\n    }\n]\nUnbind a guest user\nDebug console\nThe owner removes the binding relationship between a guest user and the device.\nRequest method and URL\nDELETE\nhttps://api.gizwits.com/app/{did}/bindings\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID\n\n\nuid\nstring\nNo\nquery\nGuest user uid, cannot be yourself \n\n\n\nResponse Parameters\nNo\nDevice Remote Monitoring\nGet latest status of a given device\nDebug console\nThe API obtains the last reported data point value of the device within 24 hours.\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/devdata/{did}/latest\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\ndid\nstring\nYes\npath\nDevice ID\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ndid\nstring\nDevice ID\n\n\nupdated_at\nstring\nLast update time\n\n\nattr\nobject\nData points and their values\n\n\n\nExample Response\n{\n  \"did\": \"WCWGkbS42tynzwx9brzpEa\",\n  \"updated_at\": 1505809000,\n  \"attr\": {\n    \"alert_full\": 0,\n    \"alert_shutdown\": 0,\n    \"mode\": \"制冷\",\n    \"fan_swing\": 0,\n    \"switch\": 0,\n    \"fan_speed\": \"低风\",\n    \"fault_roomtemp\": 0,\n    \"room_temp\": -10,\n    \"set_temp\": 16,\n    \"off_timing\": 0,\n    \"on_timing\": 0\n  }\n}\nGet the definition of product datapoint\nDebug console\nAPI restrictions\n\nThe association between AppID and product_key exists\nAppID is super AppID\n\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/datapoint?product_key={product_key}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nproduct_key\nstring\nYes\npath\nProduct product_key\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nname\nstring\nProduct name\n\n\nentities\nArray\n[EntityItem]\n\n\nprotocolType\nstring\nFixed value: standard\n\n\nproduct_key\nstring\nProduct_key\n\n\npacketVersion\nstring\nFixed value: 4\n\n\nui\ninline_model_7\nMobile phone client UI definition\n\n\nEntityItem\n——————\n——————\n\n\nid\ninteger\nFixed value: 0\n\n\nname\nstring\nFixed value: entity0\n\n\ndisplay_name\nstring\nFixed value: Gizwits  development kit\n\n\nattrs\nArray\n[AttrItem] \n\n\ninline_model_7\n——————\n——————\n\n\nobject\ninline_model_1\n\n\n\nsections\nArray\nUI section list: [SectionItem]\n\n\nAttrItem\n——————\n——————\n\n\nid\ninteger\nData point order\n\n\nname\nstring\nData point label name\n\n\ndisplay_name\nstring\nData point display name\n\n\ndesc\nstring\nFixed value:…..\n\n\ntype\nstring\nRead/write type, W: Read/write, R: Read only, N: Alarm, E: Fault\n\n\ndata_type\nstring\nData type, bool: Boolean; 'uint8', 'uint16', 'uint32': numeric; enum: enumeration; binary: extended type\n\n\nuint_spec\ninline_model_4\nThis field is available when data_type is uint8/uint16/uint32\n\n\nenum\nArray\nThis field is available when data_type is enum\n\n\nposition\ninline_model_5\nByte and bit description\n\n\ninline_model_1\n——————\n——————\n\n\nversion\ninteger\nFixed value: 4\n\n\nshowEditButton\nboolean\nFixed value: false\n\n\nSectionItem\n——————\n——————\n\n\nelements\nArray\n[ElementItem]\n\n\ninline_model_4\n——————\n——————\n\n\nmin\ninteger\nMinimum value\n\n\nmax\ninteger\nMaximum value\n\n\nratio\nnumber\nResolution k\n\n\naddition\ninteger\nIncrement\n\n\ninline_model_5\n——————\n——————\n\n\nbit_offset\ninteger\nBit index, fixed to 0 if it’s variable-length protocol\n\n\nlen\ninteger\nlength\n\n\nunit\nstring\nUnits, 'bit’, ‘byte’\n\n\nbyte_offset\ninteger\nByte index, fixed to 0 if it’s variable-length protocol\n\n\nElementItem\n——————\n——————\n\n\ntitle\nstring\nData point display name\n\n\nkey\nstring\nentity0.{data point distinguished name }\n\n\ntype\nstring\n‘QBooleanElement’, ‘QFloatElement’, ‘QRadioElement’, ‘QMultilineElement’, ‘QLabelElement’\n\n\nkeyboardType\nstring\nKeyboard type, fixed value, \"NumbersAndPunctuation\"\n\n\nmaxLength\ninteger\nThis field is available when the type is QMultilineElement. The maximum length, which is 2 times the defined length of the data point.\n\n\nitems\nArray\nThis field is available when the type is QRadioElement, enumerated value list \n\n\nboolValue\nboolean\nThis field is available when the type is QBooleanElement, fixed value: false \n\n\nbind\nstring\nThis field is available when the type is QFloatElement, fixed value: floatValue:float\n\n\nmaximumValue\nnumber\nThis field is available when the type is QFloatElement, the maximum value\n\n\nminimumValue\nnumber\nThis field is available when the type is QFloatElement, the minimum value\n\n\nvalue\ninteger\nThis field is available when the type is QFloatElement, fixed value: 0\n\n\nobject\ninline_model_6\n\n\n\ninline_model_6\n——————\n——————\n\n\naction\nstring\nFixed value: entity0\n\n\nbind\nArray[string]\nFixed value: entity0.{data point distinguished name }\n\n\nperm\nstring\nRead/Write type: W: Read/Write, R: Read Only, N: Alarm, E: Fault \n\n\nunit_spec\ninline_model_2\nThis field is only available for type QFloatElement\n\n\ninline_model_2\n——————\n——————\n\n\nmax\ninteger\nMaximum value\n\n\nstep\ninteger\nStep value\n\n\nmin\ninteger\nMinimum value\n\n\n\nExample Response\n{\n  \"name\": \"宠物屋\",\n  \"entities\": [\n    {\n      \"id\": 0,\n      \"display_name\": \"机智云开发套件\",\n      \"attrs\": [\n        {\n          \"display_name\": \"开启/关闭红色灯\",\n          \"name\": \"LED_OnOff\",\n          \"data_type\": \"bool\",\n          \"position\": {\n            \"bit_offset\": 0,\n            \"len\": 1,\n            \"unit\": \"bit\",\n            \"byte_offset\": 0\n          },\n          \"type\": \"status_writable\",\n          \"id\": 0,\n          \"desc\": \".....\"\n        }\n      ],\n      \"name\": \"entity0\"\n    }\n  ],\n  \"protocolType\": \"standard\",\n  \"product_key\": \"268162799f764b999f834b5a02eb894d\",\n  \"packetVersion\": \"0x00000004\",\n  \"ui\": {\n    \"object\": {\n      \"version\": 4,\n      \"showEditButton\": false\n    },\n    \"sections\": [\n      {\n        \"elements\": [\n          {\n            \"boolValue\": false,\n            \"object\": {\n              \"action\": \"entity0\",\n              \"bind\": [\n                \"entity0.LED_OnOff\"\n              ],\n              \"perm\": \"W\"\n            },\n            \"type\": \"QBooleanElement\",\n            \"key\": \"entity0.LED_OnOff\",\n            \"title\": \"开启/关闭红色灯\"\n          }\n        ]\n      }\n    ]\n  }\n}\nGet details of a given device\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/devices/{did}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nproduct_key\nstring\nProduct_key\n\n\ndid\nstring\nDevice ID\n\n\nmac\nstring\nDevice MAC address\n\n\nis_online\nboolean\nWhether online\n\n\npasscode\nstring\nDevice passcode\n\n\nhost\nstring\nServer domain name\n\n\nport\ninteger\nMQTT port number of M2M\n\n\nport_s\ninteger\nMQTT SSL port number for M2M\n\n\nws_port\ninteger\nWebsocket port number\n\n\nwss_port\ninteger\nWebsocket SSL port number\n\n\nremark\nstring\nDevice remark\n\n\nis_disabled\nboolean\nWhether is logged out\n\n\ntype\nstring\nDevice Type, Single Item Device: normal, Central Control Device: center_control, Central Control Sub Device: sub_dev\n\n\ndev_alias\nstring\nDevice alias\n\n\ndev_label\nArray[string]\nList of device tags, currently used for devices control via voice API\n\n\nrole\nstring\nBinding role, Special user: special, Owner user: owner, Guest user: guest, Normal user: normal\n\n\n\nExample Response\n{\n  \"remark\": \"\",\n  \"ws_port\": 8080,\n  \"did\": \"gKufzxZwYeyd3Skbsb6mzz\",\n  \"port_s\": 8883,\n  \"is_disabled\": false,\n  \"host\": \"m2m.gizwits.com\",\n  \"product_key\": \"4214bf2d79694a259232431b6f2ef46a\",\n  \"port\": 1883,\n  \"mac\": \"accf2350d446\",\n  \"role\": \"guest\",\n  \"is_online\": false,\n  \"passcode\": \"JHHOOIWJBY\",\n  \"wss_port\": 8880\n}\nGet communication log and online&offline status records of a device\nDebug console\nUsed to query the device's communication log and online and offline status records for any two days in the last 7 days.\nInput type (type)\n\nCommunication log query, type field value is cmd\nOnline and offline status records query, the type field value is online\n\nOutput type (type)\n\nmeta:\n\nCommunication log query, type field value is cmd\n\nOnline and offline status records query, the type field value is online\n\nobjects:\n\nThe type field value of the data returned by the communication log query: app2dev (app-to-device communication), dev2app (device-to-app communication)\n\nThe type field value of the data returned by the online and offline query: dev_online (online), dev_re_online (re-login before the offline process is completed), and dev_offline (offline)\n\nThe end timestamp end_time\n\nMust be less than or equal to the current system timestamp\nMust be greater than the start timestamp.\nThe difference between the end timestamp and the start timestamp must be less than 48 hours\n\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/devices/{did}/raw_data?type={type}&start_time={start_time}&end_time={end_time}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDeviceID\n\n\ntype\nstring\nYes\nquery\ncmd: communication log；online：online and offline record\n\n\nstart_time\ninteger\nYes\nquery\nStart timestamp, in seconds\n\n\nend_time\ninteger\nYes\nquery\nEnd timestamp, in seconds\n\n\nskip\ninteger\nNo\nquery\nNumber of skipped items, number of skip items + number of returned items must be <= 5000, default is 0\n\n\nlimit query\ninteger\nNo\nquery\nThe number of returned items, should be <=1000, the default is 20\n\n\nsort\nstring\nNo\nquery\nSorting type, dese: descending order; ase: ascending order. The default is descending order\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nsort\nstring\nSorting type, dese: descending order; ase: ascending order.\n\n\nlimit\ninteger\nThe number of returned items\n\n\nend_time\ninteger\nThe end timestamp\n\n\ndid\nstring\nDevice ID\n\n\nskip\ninteger\nNumber of skipped items\n\n\nstart_time\ninteger\nThe start timestamp\n\n\ntotal\ninteger\nThe number of query results\n\n\ntype\nstring\nThe type of the meta. Query type, cmd: communication log; online: online and offline record\n\n\ntype\nstring\nThe type of the objects. Type: app2dev: app-to-device communication; dev2app: device-to-app communication; dev_online: online; dev_re_online: login again before completing the offline process; dev_offline: offline\n\n\nip\nstring\nIP address of the data reporter\n\n\npayload_bin\nstring\nPayload\n\n\ntimestamp\ninteger\nTime for reporting data\n\n\nsource\nstring\nThis field is only available for app2dev type. The trigger type, d3: D3 trigger by rules engine; client: reporting data by clients\n\n\nuid\nstring\nThis field is only available for app2dev type. User ID\n\n\nappid\nstring\nThis field is only available for app2dev type. APP ID\n\n\n\nExample Response\n{\n  \"meta\": {\n    \"sort\": \"desc\",\n    \"limit\": 20,\n    \"end_time\": 1505871861,\n    \"did\": \"WCWGkbS4Ttynzwx9brzpEa\",\n    \"skip\": 0,\n    \"start_time\": 1505750399,\n    \"total\": 17,\n    \"type\": \"cmd\"\n  },\n  \"objects\": [\n    {\n      \"ip\": \"10.104.222.219\",\n      \"payload_bin\": \"000000030b0000910400000010000000\",\n      \"type\": \"dev2app\",\n      \"timestamp\": 1505871342.875\n    },\n    {\n      \"ip\": \"127.0.0.1\",\n      \"payload_bin\": \"0000000309000090010200000010\",\n      \"type\": \"app2dev\",\n      \"timestamp\": 1505871743.564,\n      \"source\": \"d3\"\n    },\n    {\n      \"uid\": \"c0a85d0773e24f15a6853f3148c80a33\",\n      \"timestamp\": 1505871743.2,\n      \"ip\": \"183.233.131.216\",\n      \"payload_bin\": \"000000030400009002\",\n      \"source\": \"client\",\n      \"appid\": \"17f5eabb5782434da65fffdc87e605bf\",\n      \"type\": \"app2dev\"\n    }\n  ]\n}\nControl a given device remotely\nDebug console\nControl the device from the cloud.\nRaw instructions (raw):\nThe default format is a decimal array. The binary_coding parameter can be set as hex and base64.\nIf you want to send a payload of binary 011000010110001001100011, after every byte of the binary string is converted to a decimal, you will get an array: [97,98,99];\nIf you want to send a payload of hexadecimal 616263, after every byte of the binary string is converted to a decimal, you will get an array: [97,98,99].\n{\n  \"raw\": [97,98,99]\n}\nData point (attrs):\nDevice products must have defined data points. If you want to set the value of the extended field binary to hexadecimal 1234567, you need to pad the extended field to the given length.\nThe default type of the extended field is hex16, and base64 can be used to set the binary_coding parameter as well.\n{\n  \"attrs\": {\n    \"binary\": \"1234567000\"\n  }\n}\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/control/{did}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID\n\n\nraw\nArray[integer]\nNo\nbody\nRaw instructions\n\n\nattrs\nobject\nNo\nbody\n\n\n\n\nNote: Fill in at least one of the body parameters\nResponse Parameters\nNo\nDevice Sharing\nAfter the device sharing function is enabled, there are two binding roles: Owner and Guest.\nThere are two main ways to share devices:\n\nNormal device sharing\nSharing devices via QR code\n\nSharing scenarios\nNormal device sharing\n\nThe Owner selects a device to share, and invokes the create a sharing invitation API to create a sharing invitation\nBoth the Owner and Guest receive a device sharing message\nThe receiver invokes the query sharing invitation API to query the received invitation\nThe receiver call accept the sharing invitation API to accept the invitation and the receiver becomes Guest\nBoth the Owner and Guest receive a message after the device sharing invitation is accepted\n\nSharing devices via QR code\n\nThe Owner selects a device to share, and invokes the create a sharing invitation API to create a sharing invitation\nThe qr_content in the response has the QR code information, and the Owner displays the QR code image to the receiver \nThe receiver scans the QR code, obtains the invitation code, calls the get sharing invitation information of a given QR code API, and views the shared content.\nCall the accept a sharing invitation by a given QRCode API, accept the sharing invitation, and the receiver becomes Guest \nBoth the Owner and Guest receive a device sharing message\n\nCancel device sharing\n\nOwner invokes the cancel/retract a sharing invitation API, cancels invitation sent out, and recalls accepted invitation\nIf the Guest user has not accepted it, the Owner will receive a cancelation message of device sharing\nThe guest user's binding to the device is cancelled. At the same time, both the Owner and Guest receive a cancelation message of device sharing.\n\nOwnership transfer\n\nThe Owner invokes the transfer ownership of a device to a guest API and fills in the information of the device to be transferred and ID of the user to be the owner\nThe original Owner user unbinds the device. The original Guest user becomes the new Owner.\n\nCreate a sharing invitation\nDebug console\nThis API can only be called by master account of the device.\n\nIf the type is normal sharing, use one field of uid/username/email/phone, which is the receiver information;\nIf the type is QR code sharing, the uid, username, email, and phone are set with empty values, if the setting does not take effect;\nNormal sharing is expired for 24 hours, and the QR code sharing is expired for 15 minutes. \nFor QR code sharing, the client generates the QR code image locally after receiving the returned QR code content.\n\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/sharing\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ntype\ninteger\nYes\nbody\nSharing type, 0: Normal sharing, 1: QR code sharing\n\n\ndid\nstring\nNo\nbody\nDevice ID\n\n\nuid\nstring\nNo\nbody\nNormal sharing type, receiver user ID\n\n\nusername\nstring\nNo\nbody\nNormal sharing type, receiver username\n\n\nemail\nstring\nNo\nbody\nNormal sharing type, receiver email address\n\n\nphone\nstring\nNo\nbody\nNormal sharing type, receiver mobile number\n\n\nduration\ninteger\nNo\nbody\nSharing duration, the length of time the device can be used after the guest accepts sharing. Unit: minutes. The minimum is 1 minute, the maximum is 1440 minutes \n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nSharing record ID for normal sharing\n\n\nqr_content\ninteger\nQR code image content, only for the QR code sharing\n\n\n\nExample Response\n{\n    \"qr_content\": \"type=share&code=60a6cacabe4046f4aa25ac1f79d81a4f\",\n    \"id\": null\n}\nGet a list of sent and received sharing invitations\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/sharing?sharing_type={sharing_type}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nsharing_type\ninteger\nYes\nquery\nSharing type, 0: Devices I want to share, 1: Devices shared to me\n\n\nstatus\nstring\nNo\nquery\nSharing status, 0: unread sharing invitation, 1: Accepted sharing invitation, 2: Refused sharing invitation, 3: Cancelled sharing invitation\n\n\ndid\nstring\nNo\nquery\nSpecified device did, only the owner user can query the sharing information of the specified did\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned items, default is 20\n\n\nskip\ninteger\nNo\nquery\nThe number of skipped items, default is 0\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ntotal\ninteger\nThe total number\n\n\nlimit\ninteger\nThe number of returned items\n\n\nskip\ninteger\nThe number of skipped items\n\n\nprevious\nstring\nRequest address of previous page\n\n\nnext\nstring\nRequest address of next page \n\n\nid\ninteger\nSharing record ID\n\n\ntype\ninteger\nSharing type, 0: Normal sharing, 1: QR code sharing\n\n\nuid\nstring\nUser ID\n\n\nusername\nstring\nUser name, middle 4 letters are replaced with * \n\n\nuser_alias\nstring\nUser alias\n\n\nemail\nstring\nUser email address, 4 characters before @  are replaced with * \n\n\nphone\nstring\nUser's mobile phone number, the middle 4 digits are replaced with *\n\n\ndid\nstring\nDevice ID\n\n\nproduct_name\nstring\nProduct name\n\n\ndev_alias\nstring\nDevice alias\n\n\nstatus\ninteger\nSharing status, 0: unread sharing invitation, 1: Accepted sharing invitation, 2: Refused sharing invitation, 3: Cancelled sharing invitation\n\n\ncreated_at\nstring\nSharing creation time (UTC time)\n\n\nupdated_at\nstring\nSharing status update time (UTC time)\n\n\nexpired_at\nstring\nSharing expiration time (UTC time)\n\n\n\nNotes:\n\nIf sharing_type is 0, it means the queried sharing invitations had been sent out as an Owner and the returned users’ information is about Guests.\nIf sharing_type is 1, it means the queried sharing invitations had been received as a Guest, and the returned users’ information is about Owner.\n\nExample Response\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 1,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"status\": 0,\n      \"username\": \"G****s\",\n      \"uid\": \"f082f4e235974cfeb6a1b2346024f47e\",\n      \"did\": \"gKufzxZwYeyd3Skbsb6mza\",\n      \"created_at\": \"2017-07-21T09:46:56Z\",\n      \"updated_at\": \"2017-07-21T09:46:56Z\",\n      \"email\": \"G****s@gizwits.com\",\n      \"phone\": null,\n      \"dev_alias\": \"设备别名\",\n      \"id\": 10411,\n      \"user_alias\": \"gizwits\",\n      \"type\": 0,\n      \"product_name\": \"微信宠物屋\",\n      \"expired_at\": \"2017-07-22T09:46:56Z\"\n    }\n  ]\n}\nCancel/retract a sharing invitation\nDebug console\nSharing invitation via QR code cannot be retracted\nRequest method and URL\nDELETE\nhttps://api.gizwits.com/app/sharing/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\ninteger\nYes\npath\nSharing record ID\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\ninteger\nSharing record ID\n\n\n\nExample Response\n{\n    \"id\": 10471\n}\nAccept/reject a sharing invitation\nDebug console\nSharing invitation via QR code cannot be retracted\nRequest method and URL\nPUT\nhttps://api.gizwits.com/app/sharing/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\ninteger\nYes\npath\nSharing record ID\n\n\nstatus\ninteger\nYes\nquery\nAccept/reject a sharing invitation，1：Accept，2：Reject\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\ninteger\nSharing record ID\n\n\n\nExample Response\n{\n    \"id\": 10471\n}\nGet sharing invitation information of a given QRCode\nDebug console\nDevice owner cannot use this API\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/sharing/code/{code}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ncode\ninteger\nYes\npath\nShared QR code content\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nowner\nstring\nDevice owner information, mobile phone number/Email/username/uid\n\n\nproduct_name\nstring\nProduct name\n\n\ndev_alias\nstring\nDevice alias\n\n\nexpired_at\nstring\nSharing expiration time (UTC time)\n\n\n\nExample Response\n{\n  \"owner\": \"G****s\",\n  \"product_name\": \"微信宠物屋\",\n  \"dev_alias\": \"设备别名\",\n  \"expired_at\": \"2017-08-21T12:22:58Z\"\n}\nAccept a sharing invitation by a given QRCode\nDebug console\nDevice owner cannot use this API\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/sharing/code/{code}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ncode\ninteger\nYes\npath\nShared QR code content\n\n\n\nResponse Parameters\nNo\nUpdate a guest or owner alias of a given invitation\nDebug console\nRequest method and URL\nPUT\nhttps://api.gizwits.com/app/sharing/{id}/alias?user_alias={user_alias}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\ninteger\nYes\npath\nSharing record ID\n\n\nuser_alias\nstring\nYes\nquery\n\n\n\n\nResponse Parameters\nNo\nTransfer ownership of a device to a guest\nDebug console\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/sharing/1/transfer?uid=1\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\n\nDevice ID\n\n\nuid\nstring\nYes\nquery\nNew owner User ID\n\n\n\nResponse Parameters\nNo\nDevice Grouping\nCommon scenarios of device grouping:\n\nClassify multiple devices into a single physical space, such as a room or living room. It is easy to manage.\nFirstly invoke the create a group API to create a group and enter the group name.\nTo add/delete devices in the group in batches after successful creation, invoke the add devices into a group API and the remove devices from a group API.\nView all the devices under a group by calling the get devices information of a given group API.\n\n\nUnified control of multiple devices of the same product, such as: switch on/off all lights in the hallway.\nFirstly invoke the create a group API to create a group and enter the group name and product PK.\nTo add/delete devices in the group in batches after successful creation, invoke the add devices into a group API and the remove devices from a group API.\nBatch control of devices by sending commands to the devices within a device group by invoking the control all devices in a given group API. \n\n\n\nGet all user groups\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/group\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ncreated_at\nstring\nDevice group creation time (UTC time)\n\n\nupdated_at\nstring\nDevice group update time (UTC time)\n\n\nproduct_key\nstring\nProduct product_key, the group with single product key will have a value\n\n\ngroup_name\nstring\nDevice group name\n\n\nverbose_name\nstring\nProduct name, the group with single product key will have a value \n\n\nid\nstring\nDevice group ID\n\n\n\nExample Response\n[\n  {\n    \"created_at\": \"2017-09-22T09:57:44Z\",\n    \"updated_at\": \"2017-09-22T09:57:44Z\",\n    \"product_key\": \"4214b12d79694a259232431b6f2ef46a\",\n    \"group_name\": \"分组名称1\",\n    \"verbose_name\": \"微信宠物屋\",\n    \"id\": \"59c4de98dc348f001a08feba\"\n  },\n  {\n    \"created_at\": \"2017-09-22T09:58:18Z\",\n    \"updated_at\": \"2017-09-22T09:58:18Z\",\n    \"product_key\": \"\",\n    \"group_name\": \"分组名称2\",\n    \"verbose_name\": \"\",\n    \"id\": \"59c4deba8c7d50001ba06df3\"\n  }\n]\nCreate a group\nDebug console\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/group\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nproduct_key\nstring\nNo\nbody\nProduct PK, enter this parameter for a group with single PK\n\n\ngroup_name\nstring\nYes\nbody\nDevice group name\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nDevice group ID\n\n\n\nExample Response\n{\n  \"id\": \"59c4deba8c7d50001ba06df3\"\n}\nDelete a device group\nDebug console\nRequest method and URL\nDELETE\nhttps://api.gizwits.com/app/group/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nDevice group ID\n\n\n\nResponse Parameters\nNo\nUpdate group information\nDebug console\nRequest method and URL\nPUT\nhttps://api.gizwits.com/app/group/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nDevice group ID\n\n\ngroup_name\nstring\nYes\nbody\nDevice group name\n\n\n\nResponse Parameters\nNo\nGet devices information of a given group\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/group/{id}/devices\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nDevice group ID\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ndid\nstring\nThe device ID under this group\n\n\ntype\nstring\nDevice Type: Normal Device: noramal; Central Control Device: center_control; Central Control Sub Device: sub_dev\n\n\nverbose_name\nstring\nProduct name, the group with single PK will have a value\n\n\ndev_alias\nstring\nDevice alias\n\n\nproduct_key\nstring\nProduct product_key, the group with single PK will have a value \n\n\n\nExample Response\n[\n  {\n    \"did\": \"WCWGkbS4Ttynzwx9brzpEa\",\n    \"type\": \"normal\",\n    \"verbose_name\": \"微信宠物屋\",\n    \"dev_alias\": \"设备别名\",\n    \"product_key\": \"4234bf2d79694a259232431b6f2ef46a\"\n  }\n]\nAdd devices into a group\nDebug console\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/group/{id}/devices?show_detail={show_detail}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nDevice group ID\n\n\nshow_detail\ninteger\nNo\nquery\nReturn error information, 1: return detail error information, 0 (default): Not return detail error information\n\n\ndids\nArray\nYes\nbody\nAn array of device IDs that need to be added to the group\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nfailed\nArray\nUnsuccessfully added devices ID array\n\n\ndetail\nArray\nFail reason for addition, this field will be returned only when show_detail is set with 1.\n\n\nsuccess\nArray\nSuccessfully added devices ID array \n\n\ndid\nstring\nUnsuccessfully added device ID\n\n\nerror_message\nstring\nError message\n\n\nerror_code\ninteger\nError code\n\n\ndetail_msg\nstring\nError detail message\n\n\n\nExample Response\n{\n  \"failed\": [\n      \"WCWGkbS4Ttynz123czpEa\"\n    ],\n  \"detail\": [\n      {\n        \"did\": \"WCWGkbS123cynzwxrzpEa\",\n        \"error_message\": \"device not found!\",\n        \"error_code\": 9014,\n        \"detail_msg\": null\n      }\n    ],\n  \"success\": [\n    \"XD3GkbS21tynzwx9brzpEa\"\n  ]\n}\nRemove devices from a group\nDebug console\nRequest method and URL\nDELETE\nhttps://api.gizwits.com/app/group/{id}/devices\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nDevice group ID\n\n\ndids\nArray\nYes\nbody\nID array of devices to be removed\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nfailed\nArray\nUnsuccessfully added devices ID array \n\n\nsuccess\nArray\nSuccessfully added devices ID array\n\n\ndid\nstring\nUnsuccessfully added device ID \n\n\n\nExample Response\n{\n  \"failed\": [],\n  \"success\": [\n    \"WCWGkb234tynzwx9brzpEa\"\n  ]\n}\nControl all devices in a given group\nDebug console\nControl all devices in a group from cloud, the API can only control the devices in a group with single PK.\nRaw instructions (raw):\nThe default format is a decimal array. The binary_coding parameter can be set as hex and base64.\nIf you want to send a payload of binary 011000010110001001100011, after every byte of the binary string is converted to a decimal, you will get an array: [97,98,99];\nIf you want to send a payload of hexadecimal 616263, after every byte of the binary string is converted to a decimal, you will get an array: [97,98,99].\n{\n  \"raw\": [97,98,99]\n}\nData point (attrs):\nDevice products must have defined data points. If you want to set the value of the extended field binary to hexadecimal 1234567, you need to pad the extended field to the given length:\nThe default type of the extended field is hex16, and base64 can be used to set the binary_coding parameter as well.\n{\n  \"attrs\": {\n    \"boolean\":true,\n    \"binary\": \"1234567000\"\n  }\n}\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/group/{id}/control\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nDevice group ID\n\n\nraw\nArray[integer]\nNo\nbody\nRaw instructions\n\n\nattrs\nobject\nNo\nbody\n\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ndid\nstring\nID of the device under the group\n\n\nresult\nboolean\nWhether the control is successful, true: successful; false: failed\n\n\n\nExample Response\n[\n  {\n    \"did\": \"WCWGkbS4Tty123x9brzpEa\",\n    \"result\": true\n  },\n  {\n    \"did\": \"gKufzxZw43dd3Skbsb6mzz\",\n    \"result\": false\n  }\n]\nDevices Linkage\nYou can create rules for devices linkage to automatically control the state change of one or more devices when the status of other devices is changed.\nDevices with such a functionality need to be bound to the same user. Devices under different products need to be associated with each other at first.\nAfter a devices linkage rule is created, it can be modified or deleted at any time.\nClick to see detail tutorial\nGet datapoints of all products that can be used by rules\nDebug console\nYou can query the data points of all products bound to the appid by this API.\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/rules/params?product_key={product_key}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nproduct_key\nstring\nYes\nquery\nMultiple PK are separated by “,”. When the field is empty, all PKs bound to the appid are used by default. When the used PK is not bound to the appid, it is invalid.\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\ndisplay_name\nstring\nData point display name\n\n\nenum\nArray\nEnumeration value\n\n\ntype\nstring\nData type, numeric: int; boolean: bool; enumeration: enum; extended: binary\n\n\nname\nstring\nData point name\n\n\n\nExample Response\n{\n  \"4214b435f9694a259232431b6f2ef46a\": [\n    {\n      \"display_name\": \"开关\",\n      \"enum\": [],\n      \"type\": \"bool\",\n      \"name\": \"switch\"\n    },\n    {\n      \"display_name\": \"倒计时开机\",\n      \"enum\": [],\n      \"type\": \"int\",\n      \"name\": \"on_timing\"\n    },\n    {\n      \"display_name\": \"倒计时关机\",\n      \"enum\": [],\n      \"type\": \"int\",\n      \"name\": \"off_timing\"\n    }\n  ]\n}\nGet rules list for devices linkage\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/rules?limit=20&skip=0\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned items   \n\n\nskip\ninteger\nNo\nquery\nIndicates the number of skipped items, indirectly indicating the number of pages\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nremark\nstring\nRule remarks\n\n\nname\nstring\nRule name\n\n\ndid\nstring\nDevice ID\n\n\ninterval\ninteger\nMinimum trigger interval (unit: seconds)\n\n\nproduct_key\nstring\nProduct PK\n\n\nrule_id\ninteger\nRule ID\n\n\nevent\nstring\nTrigger mode\n\n\nevent_attr\nobject\nWhen the trigger mode is alert/fault, [RulesEventAttr]\n\n\ninput\nArray\nRequired device data in rules [RulesInput]\n\n\ncondition\nArray\nRules condition [RulesCondition]\n\n\noutput\nArray\nRules action [RulesOutput]\n\n\nRulesEventAttr\n——————\n——————\n\n\nattr_name\nstring\nThe data point at which an alarm/fault occurred\n\n\nvalue\nstring\nOccurrence/cancellation of alarm/fault, 1 means occurrence, 0 means cancellation \n\n\nRulesOutput\n——————\n——————\n\n\ndid\nstring\nControlled device ID\n\n\ntype\nstring\nTrigger type, devctrl: control device; delay: delay\n\n\nattrs\nobject\nControl device using data point mode\n\n\nraw\nArray\nRaw instructions\n\n\ndelay\ninteger\nDelay time, unit: second\n\n\nRulesInput\n——————\n——————\n\n\ndid\nstring\nThe source device ID in the rule\n\n\nprefix\nstring\nThe prefix used to reference the data point value of this device in the condition and output\n\n\nproduct_key\nstring\nThe corresponding product PK of the source device in the rule\n\n\nRulesCondition\n——————\n——————\n\n\nopt\nstring\nComparison operators, optional values are: >, >=, <, <=, ==, != (Note: Only numeric values can be compared)\n\n\nright\nstring\nRight operand of comparison\n\n\nleft\nstring\nLeft operand of comparison\n\n\n\nExample Response\n{\n    \"rules\": [\n        {\n            \"remark\": \"\",\n            \"name\": \"打开开关，三灯100值\",\n            \"did\": \"WCWGkbS4Ttynzwx9brzpEa\",\n            \"interval\": 0,\n            \"product_key\": \"4214bf2d123194a259232431b6f2ef46a\",\n            \"event\": \"data\",\n            \"output\": [\n                [\n                    {\n                        \"did\": \"WCWGk43ftynzwx9brzpEa\",\n                        \"type\": \"devctrl\",\n                        \"attrs\": {\n                            \"LED_R\": 100,\n                            \"LED_G\": 100,\n                            \"LED_B\": 100\n                        }\n                    }\n                ],\n                [\n                    {\n                        \"did\": \"WCWGk43ftynzwx9brzpEa\",\n                        \"type\": \"devctrl\",\n                        \"attrs\": {\n                            \"fan_swing\": 1\n                        }\n                    }\n                ]\n            ],\n            \"input\": [\n                {\n                    \"did\": \"WCWGk43ftynzwx9brzpEa\",\n                    \"prefix\": \"device1\",\n                    \"product_key\": \"4214bf2d123194a259232431b6f2ef46a\"\n                },\n                {\n                    \"did\": \"WCWGk43ftynzwx9brzpEa\",\n                    \"prefix\": \"device2\",\n                    \"product_key\": \"4214bf2d123194a259232431b6f2ef46a\"\n                }\n            ],\n            \"rule_id\": 8826,\n            \"condition\": [\n                [\n                    {\n                        \"opt\": \"==\",\n                        \"right\": \"1\",\n                        \"left\": \"device1.switch\"\n                    }\n                ]\n            ]\n        }\n    ]\n}\nCreate a rule of devices linkage\nDebug console\nproduct_key and did\nWhen the trigger mode is online/offline/alert/fault/data, the device that generates the corresponding event is specified by this trigger mode. The specified device is designated as the master device.\nevent parameter\nIndicates the trigger mode of the rule. The meanings of the optional values are as follows:\n\nOnline : Device goes online\nOffline : Device goese offline\nAlert : An alarm occurred on one alarm data point of the device\nFault : A fault occurred on one fault data point of the device\nData : Device reported status\n\nevent_attr parameter\nWhen the trigger mode is alert/fault, this parameter specifies the data point at which this alarm/fault occurs and its occurrence/recovery\n\"event_attr\": {\n    \"attr_name\": \"datapoint_alert\",  // the data point at which this alarm/fault occurs\n    \"value\": \"1\" // Occurrence/cancellation of alarm/fault, 1 means occurrence, 0 means cancellation\n}\nNotes:\n\nThe \"occurrence\" of the alarm/fault mentioned here means that the value of the alarm/fault data point was reported as 0 last time, and is reported as 1 this time, then the alarm/failure occurs.\nThe “recovery” of the alarm/fault mentioned here means that the value of the alarm/fault data point was reported as 1 last time, and is reported as 0 this time, then the alarm/failure recovers.\nOther situations are not of “occurrence” and “recovery”\n\ninput parameter\nSpecifies the device data to be used in the rule. Each object in the array represents data of one device. Ignore this parameter when you do not need to use the device data:\n[{\n    \"product_key\": \"pk1\", // Product key of the device\n    \"did\": \"did1\",        // Device did\n    \"prefix\": \"device1\"   // The prefix used to reference the data point value of the device in the condition and output. If this parameter is set to device1, then device1.datapoint1 indicates referring to the data point datapoint1 of the device device1 \n}]\ncondition parameter\nSpecify the conditions to be satisfied by the trigger rule. The conditions in the array will be checked on a group-by-group basis in the cloud processing. When any group of conditions is met, the output action is triggered.\n[\n    [{\n        \"left\": \"device1.datapoint1\",// Left operand of comparison, the type of the operand needs to be the same as the type of the right operand \n        \"opt\": \"==\", // Comparison operators, optional values are: >, >=, <, <=, ==, != (Note: Only numeric values can be compared) \n        \"right\": \"1\" // Right operand of comparison, the type of the operand needs to be the same as the type of the left operand. When using a constant, note that \"1\" represents the number 1, and \"'1'\" or \"\\\"1\\\"\" is the string \"1\" \n    }],\n    [{//Each array represents a group of conditions. When all the conditions in the group are met, the group is met \n        \"left\": \"device1.datapoint1\",\n        \"opt\": \"==\",\n        \"right\": \"1\"\n    },{\n        \"left\": \"device2.datapoint2\",\n        \"opt\": \">\",\n        \"right\": \"25\"\n    }]\n]\noutput paramter\nSpecify what needs to be done when the conditions are met. All groups of actions are performed in the cloud at the same time. Each group does not affect each other.\nRaw instructions (raw):\nThe default format is a decimal array. \nIf you want to send a payload of binary 011000010110001001100011, after every byte of the binary string is converted to a decimal, you will get an array: [97,98,99];\nIf you want to send a payload of hexadecimal 616263, after every byte of the binary string is converted to a decimal, you will get an array: [97, 98, 99].\n{\n  \"raw\": [97,98,99]\n}\nData point (attrs):\nDevice products must have defined data points. If you want to set the value of the extended field binary to hexadecimal 1234567, you need to pad the extended field to the given length:\n{\n  \"attrs\": {\n    \"binary\": \"1234567000\"\n  }\n}\nOutput parameter example：\n[\n    [{ // Each array represents a set of output actions, which are executed sequentially. When the previous action fails to execute, the following actions will not be executed \n        \"type\": \"devctrl\",   // output type, devctrl indicates to control device\n        \"did\": \"did1\",       // device did to be controlled\n        \"attrs\": {           // key-value format\n            \"datapoint1\": 1, // set datapoint1 value as 1\n            \"datapoint2\": 25,\n            \"datapoint3\": \"黄色\"\n        }\n    },{\n        \"type\": \"delay\", // output type, delay\n        \"delay\": 5       // Delay time, unit: second\n    },{\n        \"type\": \"devctrl\",\n        \"did\": \"QxP6E9qFwwzsqKb2UYf4uw\",\n        \"raw\": [1, 2, 3] // raw format\n    }],\n    [{\n        \"type\": \"devctrl\",\n        \"did\": \"QxP6E9qFwwzsqKb2UYf4uw\",\n        \"attrs\": {\n            \"datapoint1\": 1,\n            \"datapoint2\": 25,\n            \"datapoint3\": \"黄色\"\n        }\n    }]\n]\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/rules\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nremark\nstring\nNo\nbody\nRule remarks\n\n\nname\nstring\nYes\nbody\nRule name\n\n\ndid\nstring\nYes\nbody\nDevice ID\n\n\ninterval\ninteger\nNo\nbody\nMinimum trigger interval (unit: seconds)\n\n\nproduct_key\nstring\nYes\nbody\nProduct PK\n\n\nevent\nstring\nYes\nbody\nTrigger mode\n\n\nevent_attr\nobject\nNo\nbody\nWhen the trigger mode is alert/fault, [RulesEventAttr]\n\n\ninput\nArray\nYes\nbody\nRequired device data in rules [RulesInput]\n\n\ncondition\nArray\nYes\nbody\nRule condition[RulesCondition]\n\n\noutput\nArray\nYes\nbody\nRule action [RulesOutput]\n\n\nRulesEventAttr\n——————\nNo\nbody\n——————\n\n\nattr_name\nstring\nNo\nbody\nThe data point at which this alarm/fault occurred\n\n\nvalue\nstring\nNo\nbody\nOccurrence/cancellation of alarm/fault, 1 means occurrence, 0 means cancellation \n\n\nRulesOutput\n——————\nYes\nbody\n——————\n\n\ndid\nstring\nYes\nbody\nControlled device ID\n\n\ntype\nstring\nYes\nbody\nTrigger type, devctrl: control device; delay: delay\n\n\nattrs\nobject\nNo\nbody\nControl device using data point mode\n\n\nraw\nArray\nNo\nbody\nRaw instructions\n\n\ndelay\ninteger\nNo\nbody\nDelay time, unit: second\n\n\nRulesInput\n——————\nYes\nbody\n——————\n\n\ndid\nstring\nYes\nbody\nThe source device ID in the rule\n\n\nprefix\nstring\nYes\nbody\nThe prefix used to reference the data point value of this device in the condition and output\n\n\nproduct_key\nstring\nYes\nbody\nThe corresponding product PK of the source device in the rule\n\n\nRulesCondition\n——————\nYes\nbody\n——————\n\n\nopt\nstring\nYes\nbody\nComparison operators, optional values are: >, >=, <, <=, ==, != (Note: Only numeric values can be compared)\n\n\nright\nstring\nYes\nbody\nRight operand of comparison\n\n\nleft\nstring\nYes\nbody\nLeft operand of comparison\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nrule_id\ninteger\nRule ID\n\n\n\nExample Response\n{\n  \"rule_id\": 1213\n}\nDelete a rule of devices linkage\nDebug console\nRequest method and URL\nDELETE\nhttps://api.gizwits.com/app/rules/{rule_id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nrule_id\ninteger\nYes\npath\nID of the rule to be deleted\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nrule_id\ninteger\nRule ID\n\n\n\nExample Response\n{\n  \"rule_id\": 1234\n}\nUpdate a rule of devices linkage\nDebug console\nRequest method and URL\nPUT\nhttps://api.gizwits.com/app/rules/{rule_id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nremark\nstring\nNo\nbody\nRule remarks\n\n\nname\nstring\nYes\nbody\nRule name\n\n\ndid\nstring\nYes\nbody\nDevice ID\n\n\ninterval\ninteger\nNo\nbody\nMinimum trigger interval (unit: seconds)\n\n\nproduct_key\nstring\nYes\nbody\nProduct PK\n\n\nrule_id\ninteger\nYes\nbody\nRule ID\n\n\nevent\nstring\nYes\nbody\nTrigger mode\n\n\nevent_attr\nobject\nNo\nbody\nWhen the trigger mode is alert/fault, [RulesEventAttr]\n\n\ninput\nArray\nYes\nbody\nRequired device data in rules [RulesInput]\n\n\ncondition\nArray\nYes\nbody\nRules condition [RulesCondition]\n\n\noutput\nArray\nYes\nbody\nRules action [RulesOutput]\n\n\nRulesEventAttr\n——————\nNo\nbody\n——————\n\n\nattr_name\nstring\nNo\nbody\nThe data point at which an alarm/fault occurred\n\n\nvalue\nstring\nNo\nbody\nOccurrence/cancellation of alarm/fault, 1 means occurrence, 0 means cancellation \n\n\nRulesOutput\n——————\nYes\nbody\n——————\n\n\ndid\nstring\nYes\nbody\nControlled device ID\n\n\ntype\nstring\nYes\nbody\nTrigger type, devctrl: control device; delay: delay\n\n\nattrs\nobject\nNo\nbody\nControl device using data point mode\n\n\nraw\nArray\nNo\nbody\nRaw instructions\n\n\ndelay\ninteger\nNo\nbody\nDelay time, unit: second\n\n\nRulesInput\n——————\nYes\nbody\n——————\n\n\ndid\nstring\nYes\nbody\nThe source device ID in the rule\n\n\nprefix\nstring\nYes\nbody\nThe prefix used to reference the data point value of this device in the condition and output\n\n\nproduct_key\nstring\nYes\nbody\nThe corresponding product PK of the source device in the rule\n\n\nRulesCondition\n——————\nYes\nbody\n——————\n\n\nopt\nstring\nYes\nbody\nComparison operators, optional values are: >, >=, <, <=, ==, != (Note: Only numeric values can be compared)\n\n\nright\nstring\nYes\nbody\nRight operand of comparison\n\n\nleft\nstring\nYes\nbody\nLeft operand of comparison\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nrule_id\ninteger\nRule ID\n\n\n\nExample Response\n{\n  \"rule_id\": 1234\n}\nUser Scenario\nGet all scenarios\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/scene\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nScenario ID\n\n\nscene_name\nstring\nScenario name\n\n\ncreated_at\nstring\nScenario creation time (UTC time)\n\n\nupdated_at\nstring\nScenario update time (UTC time)\n\n\nremark\nstring\nScenario remarks \n\n\ntask_type\nstring\nScenario task type: \"delay\": Delayed task, \"device\": Control a single device task, \"group\": Control the device group task (only control the group with a single product_key)\n\n\ndid\nstring\nDevice did, for a single control task\n\n\nproduct_key\nstring\nProduct key, for the non-delayed task\n\n\ngroup_name\nstring\nDevice group name, for the device group task\n\n\nraw\nstring\nFor non-delayed task, raw instructions, base64 encoding\n\n\nattrs\nobject\nFor non-delayed task, data point control commands, fill in order number for enumeration data point, fill in base64 encoded string for extended data point \n\n\ndev_remark\nstring\nDevice remarks, for device control task\n\n\ntime\ninteger\nDelay time for delayed task in seconds, maximum: 3600 seconds\n\n\ngroup_id\nstring\nDevice group ID for the device group task\n\n\nverbose_name\nstring\nProduct name for non-delayed task\n\n\ndev_alias\nstring\nDevice aliase for device control task\n\n\n\nExample Response\n[\n  {\n    \"remark\": \"备注\",\n    \"tasks\": [\n      {\n        \"task_type\": \"device\",\n        \"did\": \"WCWGkbS4Ttynzw123rzpEa\",\n        \"product_key\": \"4214bf2d79321259232431b6f2ef46a\",\n        \"group_name\": \"\",\n        \"raw\": \"\",\n        \"attrs\": {\n          \"switch\": true\n        },\n        \"dev_remark\": \"\",\n        \"time\": 0,\n        \"group_id\": \"\",\n        \"verbose_name\": \"微信宠物屋\",\n        \"dev_alias\": \"\"\n      }\n    ],\n    \"created_at\": \"2017-09-25T10:09:07Z\",\n    \"updated_at\": \"2017-09-25T10:09:07Z\",\n    \"scene_name\": \"场景名\",\n    \"id\": \"59c8d5c3234d50001a21c872\"\n  }\n]\nCreate a scenario\nDebug console\nRaw instructions (raw):\nThe default format is base64. The binary_coding parameter can be set as hex.If you want to send a payload of 010203, after encoding you will get: AQID;\n{\n  \"raw\": \"AQID\"\n}\nData point (attrs):\nDevice products must have defined data points. If you want to set the value of the extended field binary to hexadecimal 1234567, you need to pad the extended field to the given length:\nThe default type of the extended field is hex16, and base64 can be used to set the binary_coding parameter as well.\n{\n  \"attrs\": {\n    \"boolean\":true,\n    \"binary\": \"1234567000\"\n  }\n}\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/scene\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nscene_name\nstring\nYes\nbody\nScenario name\n\n\nremark\nstring\nNo\nbody\nScenario remarks\n\n\ntask_type\nstring\nYes\nbody\nScenario task type: \"delay\": Delayed task, \"device\": Control a single device task, \"group\": Control the device group task (only control the group with a single product_key) \n\n\ntime\ninteger\nNo\nbody\nDelay time for delayed task in seconds, maximum: 3600 seconds\n\n\ndid\nstring\nNo\nbody\nDevice did, for a single control task\n\n\ngroup_id\nstring\nNo\nbody\nDevice group ID for the device group task\n\n\nattrs\nobject\nNo\nbody\nFor non-delayed task, data point control commands, fill in order number for enumeration data point, fill in base64 encoded string for extended data point\n\n\nraw\nstring\nNo\nbody\nFor non-delayed task, raw instructions, base64 encoding\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nScenario ID\n\n\n\nExample Response\n{\n  \"id\": \"59c8d5c38c7d50001a21c872\"\n}\nDelete a scenario\nDebug console\nRequest method and URL\nDELETE\nhttps://api.gizwits.com/app/scene/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nScenario ID\n\n\n\nResponse Parameters\nNo\nUpdate a scenario information\nDebug console\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/scene/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nScenario ID\n\n\nscene_name\nstring\nYes\nbody\nScenario name\n\n\nremark\nstring\nNo\nbody\nScenario remarks\n\n\ntask_type\nstring\nYes\nbody\nScenario task type: \"delay\": Delayed task, \"device\": Control a single device task, \"group\": Control the device group task (only control the group with a single product_key)\n\n\ntime\ninteger\nNo\nbody\nDelay time for delayed task in seconds, maximum: 3600 seconds\n\n\ndid\nstring\nNo\nbody\nDevice did, for a single control task\n\n\ngroup_id\nstring\nNo\nbody\nDevice group ID for the device group task\n\n\nattrs\nobject\nNo\nbody\nFor non-delayed task, data point control commands, fill in order number for enumeration data point, fill in base64 encoded string for extended data point\n\n\nraw\nstring\nNo\nbody\nFor non-delayed task, raw instructions, base64 encoding\n\n\n\nResponse Parameters\nNo\nGet task execution status of a given scenario\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/scene/{id}/task\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nScenario ID\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nstatus\ninteger\nScenario task execution status, 0: In progress; 1: Execution completed; 2: Execution failed; 3: Task not executed\n\n\n\nExample Response\n{\n  \"status\": 1\n}\nPerform a scenario task\nDebug console\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/scene/{id}/task\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nScenario ID\n\n\n\nResponse Parameters\nNo\n\nIf return successfully, start to perform scenario task\n\nTask Scheduling Management\nScheduled tasks are divided into the following categories:\n\nOne-time tasks\nWeekly scheduled recurring tasks\nDaily scheduled recurring tasks\n\nThe enabled status of each scheduled task can be set. Only those scheduled tasks that are enabled can be executed.\nAll APIs under scheduling task management use UTC time\nScheduling task management API can only set scheduled tasks for a single device\nGet a list of scheduled tasks\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/devices/{did}/scheduler?limit=20&skip=0\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID for the scheduled task\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned items  \n\n\nskip\ninteger\nNo\nquery\nIndicates the number of skipped items, indirectly indicating the number of pages.\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nTask ID\n\n\ncreated_at\nstring\nTask creation time(UTC time)\n\n\nproduct_key\nstring\nProduct PK \n\n\ndid\nstring\nDevice ID of the scheduled task\n\n\nraw\nstring\nRaw instructions \n\n\nattrs\nobject\n\n\n\ndate\nstring\nExecution time for one-time task\n\n\ntime\nstring\nScheduled task execution time, accurate to minute, format xx:xx, eg: 02:30\n\n\nrepeat\nstring\nWhether to repeat, \"none\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\nDate list for repeat, for example [1, 15] repeats on the 1st and 15th of each month\n\n\nstart_date\nstring\nThe start date of scheduled task execution, starting at 0:00, format xxxx-xx-xx, eg 2016-09-01\n\n\nend_date\nstring\nThe end date of scheduled task execution, ending at the end of the day, format xxxx-xx-xx, eg 2016-10-01\n\n\nenabled\nboolean\nWhether it is enabled, if it is not enabled, it will not be triggered at the set time. The default is enabled.\n\n\nremark\nstring\nTask remarks\n\n\n\nExample Response\n[\n  {\n    \"remark\": \"备注\",\n    \"repeat\": \"none\",\n    \"end_date\": \"2017-09-26\",\n    \"did\": \"LWHWrRAnzRbxtv9cyuNFSY\",\n    \"created_at\": \"2017-09-26T06:36:47\",\n    \"enabled\": true,\n    \"days\": [],\n    \"product_key\": \"b6777e0a343b422b8c474254e016b4dc\",\n    \"id\": \"59c9f57f8c7d50001963992c\",\n    \"raw\": \"\",\n    \"attrs\": {\n      \"bool\": true\n    },\n    \"time\": \"15:00\",\n    \"date\": \"2017-09-26\",\n    \"start_date\": \"2017-09-20\"\n  }\n]\nCreate a scheduled task\nDebug console\nCreating one-time tasks\n\nrepeat is set with none\ndate and time must be filled in, and note that date and time are UTC time when performing scheduled tasks\n\nCreate weekly occurring scheduled tasks\n\nrepeat is a repeating days of each week, separated by multiple commas; For example, if a task is executed every Monday, it is set to “mon”, if executed every Monday and Wednesday, it is set to “mon, wed”;\nWhen repeat is a repeating days of each week, the optional values are: mon,tue,wed,thu,fri,sat,sun\ntime must be filled in, and note that the week and time for performing scheduled tasks are UTC time\nstart_date and end_date can be filled in optionally, which indicate the date range for scheduled tasks to perform\n\nCreate daily occurring scheduled tasks\n\nrepeat is set with day\ndays is set with the date list for the task excution; For example, if the task is executed on the 1st of each month, set to [“1”]; if executed on the 1st, 15th of each month, set to [“1”, “15”]\ntime must be filled in, and note that days and time are UTC time when performing scheduled tasks\nstart_date and end_date can be filled in optionally, which indicate the date range for scheduled tasks to perform\n\nRaw instructions (raw):\nThe default format is hex16. The binary_coding parameter can be set as base64.\nIf you want to send a payload of binary 011000010110001001100011, after every byte of the binary string is converted to a hexadecimal, you will get: 616263;\n{\n  \"raw\": 616263\n}\nData point (attrs):\nDevice products must have defined data points. If you want to set the value of the extended field binary to hexadecimal 1234567, you need to pad the extended field to the given length:\nThe default type of the extended field is hex16, and base64 can be used to set the binary_coding parameter as well.\n{\n  \"attrs\": {\n    \"boolean\":true,\n    \"binary\": \"1234567000\"\n  }\n}\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/devices/{did}/scheduler\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID of the scheduled task\n\n\nraw\nstring\nNo\nbody\nRaw instructions \n\n\nattrs\nobject\nNo\nbody\n\n\n\ndate\nstring\nYes\nbody\nExecution time for one-time task\n\n\ntime\nstring\nYes\nbody\nScheduled task execution time, accurate to minute, format xx:xx, eg: 02:30\n\n\nrepeat\nstring\nYes\nbody\nWhether to repeat, \"none\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\nNo\nbody\nDate list for repeat, for example [1, 15] repeats on the 1st and 15th of each month\n\n\nstart_date\nstring\nNo\nbody\nThe start date of scheduled task execution, starting at 0:00, format xxxx-xx-xx, eg 2016-09-01\n\n\nend_date\nstring\nNo\nbody\nThe end date of scheduled task execution, ending at the end of the day, format xxxx-xx-xx, eg 2016-10-01\n\n\nenabled\nboolean\nNo\nbody\nWhether it is enabled, if it is not enabled, it will not be triggered at the set time. The default is enabled.\n\n\nremark\nstring\nNo\nbody\nTask remarks\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nTask ID\n\n\n\nExample Response\n{\n  \"id\": \"59c9f57f8c7d50001963992c\"\n}\nUpdate a scheduled task\nDebug console\nRequest method and URL\nPUT\nhttps://api.gizwits.com/app/devices/{did}/scheduler/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID of the scheduled task\n\n\nid\nstring\nYes\npath\nID of the task to be updated\n\n\nraw\nstring\nNo\nbody\nRaw instructions \n\n\nattrs\nobject\nNo\nbody\n\n\n\ndate\nstring\nYes\nbody\nExecution time for one-time task\n\n\ntime\nstring\nYes\nbody\nScheduled task execution time, accurate to minute, format xx:xx, eg: 02:30\n\n\nrepeat\nstring\nYes\nbody\nWhether to repeat, \"none\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\nNo\nbody\nDate list for repeat, for example [1, 15] repeats on the 1st and 15th of each month\n\n\nstart_date\nstring\nNo\nbody\nThe start date of scheduled task execution, starting at 0:00, format xxxx-xx-xx, eg 2016-09-01\n\n\nend_date\nstring\nNo\nbody\nThe end date of scheduled task execution, ending at the end of the day, format xxxx-xx-xx, eg 2016-10-01\n\n\nenabled\nboolean\nNo\nbody\nWhether it is enabled, if it is not enabled, it will not be triggered at the set time. The default is enabled.\n\n\nremark\nstring\nNo\nbody\nTask remarks\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nTask ID\n\n\n\nExample Response\n{\n  \"id\": \"59c9f57f8c7d50001963992c\"\n}\nDelete a scheduled task\nDebug console\nRequest method and URL\nDELETE\nhttps://api.gizwits.com/app/devices/{did}/scheduler/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID for setting a scheduled task\n\n\nid\nstring\nYes\npath\nTask ID\n\n\n\nResponse Parameters\nNo\nCommon Task Scheduling\nThe common task scheduling is a set of upgraded APIs for task scheduling management. It can create scheduled tasks for scenarios, groups, and individual devices.\nGet a common scheduled task\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/app/common_scheduler?did={did}&group_id={group_id}&scene_id={scene_id}&limit={limit}&skip={skip}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nNo\npath\nDevice ID for setting a scheduled task\n\n\ngroup_id\nstring\nNo\npath\nGroup ID\n\n\nscene_id\nstring\nNo\npath\nScenario ID\n\n\nlimit\ninteger\nNo\nquery\nThe number of returned items \n\n\nskip\ninteger\nNo\nquery\nIndicates the number of skipped items, indirectly indicating the number of pages. \n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nTask ID\n\n\ncreated_at\nstring\nTask creation time(UTC time)\n\n\nproduct_key\nstring\nProduct PK\n\n\nscene_id\nstring\n\n\n\ngroup_id\nstring\n\n\n\ndid\nstring\nDevice ID for setting a scheduled task\n\n\nraw\nstring\nRaw instructions\n\n\nattrs\nobject\n\n\n\ndate\nstring\nExecution time for one-time task\n\n\ntime\nstring\nScheduled task execution time, accurate to minute, format xx:xx, eg: 02:30\n\n\nrepeat\nstring\nWhether to repeat, \"none\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\nDate list for repeat, for example [1, 15] repeats on the 1st and 15th of each month\n\n\nstart_date\nstring\nThe start date of scheduled task execution, starting at 0:00, format xxxx-xx-xx, eg 2016-09-01\n\n\nend_date\nstring\nThe end date of scheduled task execution, ending at the end of the day, format xxxx-xx-xx, eg 2016-10-01\n\n\nenabled\nboolean\nWhether it is enabled, if it is not enabled, it will not be triggered at the set time. The default is enabled.\n\n\nremark\nstring\nTask remarks\n\n\n\nExample Response\n[\n  {\n    \"remark\": \"备注\",\n    \"repeat\": \"none\",\n    \"end_date\": \"2017-09-26\",\n    \"did\": \"LWHWrRAnzRbxtv9cyuNFSY\",\n    \"created_at\": \"2017-09-26T06:36:47\",\n    \"enabled\": true,\n    \"days\": [],\n    \"product_key\": \"b6777e0a343b422b8c474254e016b4dc\",\n    \"id\": \"59c9f57f8c7d50001963992c\",\n    \"raw\": \"\",\n    \"attrs\": {\n      \"bool\": true\n    },\n    \"time\": \"15:00\",\n    \"date\": \"2017-09-26\",\n    \"scene_id\": \"\",\n    \"group_id\": \"\",\n    \"start_date\": \"2017-09-20\"\n  }\n]\nCreate a common scheduled task\nDebug console\n\nOnly one of the did, group_id, and scene_id parameters need to be filled in. They are used to create scheduled tasks for device, devices group, and user scenario.\nIf more than one are filled in at the same time, the first valid string is taken according to the priority; \nFor scenario tasks, you do not need to fill in the raw and attrs commands. The filled value will be ignored.\nCreating recurring tasks is same as the task scheduling management API.\n\nRaw instructions (raw):\nThe default format is hex16. The binary_coding parameter can be set as base64.\nIf you want to send a payload of binary 011000010110001001100011, after every byte of the binary string is converted to a hexadecimal, you will get: 616263;  \n{\n  \"raw\": 616263\n}\nData point (attrs):\nDevice products must have defined data points. If you want to set the value of the extended field binary to hexadecimal 1234567, you need to pad the extended field to the given length:\nThe default type of the extended field is hex16, and base64 can be used to set the binary_coding parameter as well.\n{\n  \"attrs\": {\n    \"boolean\":true,\n    \"binary\": \"1234567000\"\n  }\n}\nRequest method and URL\nPOST\nhttps://api.gizwits.com/app/common_scheduler\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nNo\nbody\nDevice ID of the scheduled task\n\n\ngroup_id\nstring\nNo\nbody\nGroup ID of the scheduled task\n\n\nscene_id\nstring\nNo\nbody\nScenario ID of the scheduled task\n\n\nraw\nstring\nNo\nbody\nRaw instructions\n\n\nattrs\nobject\nNo\nbody\n\n\n\ndate\nstring\nYes\nbody\nExecution time for one-time task\n\n\ntime\nstring\nYes\nbody\nScheduled task execution time, accurate to minute, format xx:xx, eg: 02:30\n\n\nrepeat\nstring\nYes\nbody\nWhether to repeat, \"none\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\nNo\nbody\nDate list for repeat, for example [1, 15] repeats on the 1st and 15th of each month\n\n\nstart_date\nstring\nNo\nbody\nThe start date of scheduled task execution, starting at 0:00, format xxxx-xx-xx, eg 2016-09-01\n\n\nend_date\nstring\nNo\nbody\nThe end date of scheduled task execution, ending at the end of the day, format xxxx-xx-xx, eg 2016-10-01\n\n\nenabled\nboolean\nNo\nbody\nWhether it is enabled, if it is not enabled, it will not be triggered at the set time. The default is enabled.\n\n\nremark\nstring\nNo\nbody\nTask remarks\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nTask ID\n\n\n\nExample Response\n{\n  \"id\": \"59c9f57f8c7d50001963992c\"\n}\nUpdate a common scheduled task\nDebug console\nRequest method and URL\nPUT\nhttps://api.gizwits.com/app/common_scheduler/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\nid\nstring\nYes\npath\nTask ID\n\n\ndid\nstring\nNo\nbody\nDevice ID of the scheduled task\n\n\ngroup_id\nstring\nNo\nbody\nGroup ID of the scheduled task\n\n\nscene_id\nstring\nNo\nbody\nScenario ID of the scheduled task\n\n\nraw\nstring\nNo\nbody\nRaw instructions\n\n\nattrs\nobject\nNo\nbody\n\n\n\ndate\nstring\nYes\nbody\nExecution time for one-time task\n\n\ntime\nstring\nYes\nbody\nScheduled task execution time, accurate to minute, format xx:xx, eg: 02:30\n\n\nrepeat\nstring\nYes\nbody\nWhether to repeat, \"none\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\nNo\nbody\nDate list for repeat, for example [1, 15] repeats on the 1st and 15th of each month\n\n\nstart_date\nstring\nNo\nbody\nThe start date of scheduled task execution, starting at 0:00, format xxxx-xx-xx, eg 2016-09-01\n\n\nend_date\nstring\nNo\nbody\nThe end date of scheduled task execution, ending at the end of the day, format xxxx-xx-xx, eg 2016-10-01\n\n\nenabled\nboolean\nNo\nbody\nWhether it is enabled, if it is not enabled, it will not be triggered at the set time. The default is enabled.\n\n\nremark\nstring\nNo\nbody\nTask remarks\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nid\nstring\nTask ID\n\n\n\nExample Response\n{\n  \"id\": \"59c9f57f8c7d50001963992c\"\n}\nDelete a common scheduled task\nDebug console\nRequest method and URL\nDELETE\nhttps://api.gizwits.com/app/common_scheduler/{id}\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID of the scheduled task\n\n\nid\nstring\nYes\npath\nTask ID\n\n\n\nResponse Parameters\nNo\nAdvanced Data API\nGet an aggregated value of a given device\nThe API can aggregate the numeric values of the data point reported by the device, and can aggregate the data point values into sum/average/maximum/minimum by hours/days/weeks/months.\nYou can get aggregated data for multiple data points at a time.\nTo use this API, you must request to open it at first. After its acception, data reported will be aggregated.\nDebug console\nRequest method and URL\nPUT\nhttps://api.gizwits.com/app/devdata/{did}/agg_data\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\nYes\nheader\nUser token\n\n\ndid\nstring\nYes\npath\nDevice ID\n\n\nstart_ts\ninteger\nYes\nquery\nStart time in milliseconds\n\n\nend_ts\ninteger\nNo\nquery\nEnd time in milliseconds\n\n\nattrs\nstring\nYes\nquery\nNumeric data point name, multiple data points separated by commas\n\n\naggregator\nstring\nYes\nquery\nStatistical method, sum: total; avg: average; max: maximum; min: minimum\n\n\nunit\nstring\nYes\nquery\nSummary method, hours,days,weeks,months\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\naggregator\nstring\nStatistical method, sum: total; avg: average; max: maximum; min: minimum\n\n\nend_ts\ninteger\nStart time in milliseconds\n\n\nstart_ts\ninteger\nEnd time in milliseconds\n\n\nattrs\nstring\nQueried data points\n\n\nunit\nstring\nSum: total; avg: average; max: maximum; min: minimum\n\n\ndatatime\nstring\n\n\n\nuid\nstring\nUser ID\n\n\nproduct_key\nstring\nProduct PK\n\n\nattrs\nobject\nAggregation results for data points\n\n\n\nExample Response\n{\n  \"query\": {\n    \"aggregator\": \"sum\",\n    \"end_ts\": null,\n    \"start_ts\": 1505318400000,\n    \"attrs\": \"set_temp, alert_shutdown, room_temp\",\n    \"unit\": \"HOURS\"\n  },\n  \"data\": [\n    {\n      \"datatime\":\"\",\n      \"uid\":\"c0a85d0773e24f15a6853f3148c80a33\",\n      \"product_key\":\"42121342d79694a259232431b6f2ef46a\",\n      \"attrs\":{\n        \"set_temp\":\"12\",\n        \"alert_shutdown\":\"12\",\n        \"room_temp\":\"12\"\n      }\n    }\n  ]\n}\nSystem Information\nGet service status\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/status\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nversion\nstring\nOpen API version\n\n\n\nExample Response\n{\n  \"status\": {\n    \"version\": \"2.15.1\"\n  }\n}\nGet error status code list\nDebug console\nRequest method and URL\nGET\nhttps://api.gizwits.com/errors\nRequest paramters\n\n\n\nParams\nData Type\nRequired\nParam Type\nDescription\n\n\n\n\nX-Gizwits-Application-Id\nstring\nYes\nheader\nappid\n\n\n\nResponse Parameters\n\n\n\nParams\nData Type\nDescription\n\n\n\n\nstatus\nstring\nResponse code\n\n\nerror_code\nstring\nError code\n\n\nerror_message\nstring\nError message\n\n\n\nExample Response\n[\n  {\n    \"status\": 404,\n    \"error_message\": \"scene not found!\",\n    \"error_code\": 9220\n  },\n  {\n    \"status\": 400,\n    \"error_message\": \"the scene does not belong to you!\",\n    \"error_code\": 9221\n  }\n]\nDetailed error information can be viewed in the following table Open API error code table.\nAppendix: Open API error codes table\n\n\n\nError Code\nError Type\nDescription\n\n\n\n\n9001\nGIZ_OPENAPI_MAC_ALREADY_REGISTERED\nmac already registered!\n\n\n9002\nGIZ_OPENAPI_PRODUCT_KEY_INVALID\nproduct_key invalid\n\n\n9003\nGIZ_OPENAPI_APPID_INVALID\nappid invalid\n\n\n9004\nGIZ_OPENAPI_TOKEN_INVALID\ntoken invalid\n\n\n9005\nGIZ_OPENAPI_USER_NOT_EXIST\nuser not exist\n\n\n9006\nGIZ_OPENAPI_TOKEN_EXPIRED\ntoken expired\n\n\n9007\nGIZ_OPENAPI_M2M_ID_INVALID\nm2m_id invalid\n\n\n9008\nGIZ_OPENAPI_SERVER_ERROR\nserver error\n\n\n9009\nGIZ_OPENAPI_CODE_EXPIRED\ncode expired\n\n\n9010\nGIZ_OPENAPI_CODE_INVALID\ncode invalid\n\n\n9011\nGIZ_OPENAPI_SANDBOX_SCALE_QUOTA_EXHAUSTED\nsandbox scale quota exhausted!\n\n\n9012\nGIZ_OPENAPI_PRODUCTION_SCALE_QUOTA_EXHAUSTED\nproduction scale quota exhausted!\n\n\n9013\nGIZ_OPENAPI_PRODUCT_HAS_NO_REQUEST_SCALE\nproduct has no request scale!\n\n\n9014\nGIZ_OPENAPI_DEVICE_NOT_FOUND\ndevice not found!\n\n\n9015\nGIZ_OPENAPI_FORM_INVALID\nform invalid!\n\n\n9016\nGIZ_OPENAPI_DID_PASSCODE_INVALID\ndid or passcode invalid!\n\n\n9017\nGIZ_OPENAPI_DEVICE_NOT_BOUND\ndevice not bound!\n\n\n9018\nGIZ_OPENAPI_PHONE_UNAVALIABLE\nphone unavailable!\n\n\n9019\nGIZ_OPENAPI_USERNAME_UNAVALIABLE\nusername unavailable!\n\n\n9020\nGIZ_OPENAPI_USERNAME_PASSWORD_ERROR\nusername or password error!\n\n\n9021\nGIZ_OPENAPI_SEND_COMMAND_FAILED\nsend command failed!\n\n\n9022\nGIZ_OPENAPI_EMAIL_UNAVALIABLE\nemail unavailable!\n\n\n9023\nGIZ_OPENAPI_DEVICE_DISABLED\ndevice is disabled!\n\n\n9024\nGIZ_OPENAPI_FAILED_NOTIFY_M2M\nfail to notify m2m!\n\n\n9025\nGIZ_OPENAPI_ATTR_INVALID\nattr invalid!\n\n\n9026\nGIZ_OPENAPI_USER_INVALID\nuser invalid!\n\n\n9027\nGIZ_OPENAPI_FIRMWARE_NOT_FOUND\nfirmware not found!\n\n\n9028\nGIZ_OPENAPI_JD_PRODUCT_NOT_FOUND\nJD product info not found!\n\n\n9029\nGIZ_OPENAPI_DATAPOINT_DATA_NOT_FOUND\ndatapoint data not found!\n\n\n9030\nGIZ_OPENAPI_SCHEDULER_NOT_FOUND\nscheduler not found!\n\n\n9031\nGIZ_OPENAPI_QQ_OAUTH_KEY_INVALID\nqq oauth key invalid!\n\n\n9032\nGIZ_OPENAPI_OTA_SERVICE_OK_BUT_IN_IDLE\nota upgrade service OK, but in idle or disable!\n\n\n9033\nGIZ_OPENAPI_BT_FIRMWARE_UNVERIFIED\nbt firmware unverified,except verify device!\n\n\n9034\nGIZ_OPENAPI_BT_FIRMWARE_NOTHING_TO_UPGRADE\nbt firmware is OK, but nothing to upgrade!\n\n\n9035\nGIZ_OPENAPI_SAVE_KAIROSDB_ERROR\nSave kairosdb error!\n\n\n9036\nGIZ_OPENAPI_EVENT_NOT_DEFINED\nevent not defined!\n\n\n9037\nGIZ_OPENAPI_SEND_SMS_FAILED\nsend sms failed!\n\n\n9038\nGIZ_OPENAPI_APPLICATION_AUTH_INVALID\nX-Gizwits-Application-Auth invalid!\n\n\n9039\nGIZ_OPENAPI_NOT_ALLOWED_CALL_API\nNot allowed to call deprecated API!\n\n\n9040\nGIZ_OPENAPI_BAD_QRCODE_CONTENT\nbad qrcode content!\n\n\n9041\nGIZ_OPENAPI_REQUEST_THROTTLED\nrequest was throttled\n\n\n9042\nGIZ_OPENAPI_DEVICE_OFFLINE\ndevice offline!\n\n\n9043\nGIZ_OPENAPI_TIMESTAMP_INVALID\nX-Gizwits-Timestamp invalid!\n\n\n9044\nGIZ_OPENAPI_SIGNATURE_INVALID\nX-Gizwits-Signature invalid!\n\n\n9045\nGIZ_OPENAPI_DEPRECATED_API\nAPI deprecated!\n\n\n9046\nGIZ_OPENAPI_REGISTER_IS_BUSY\nRegister already in progress!\n\n\n9077\nGIZ_OPENAPI\nemail already exists but not activate!\n\n\n9080\nGIZ_OPENAPI_CANNOT_SHARE_TO_SELF\ncan not share device to self!\n\n\n9081\nGIZ_OPENAPI_ONLY_OWNER_CAN_SHARE\nguest or normal user can not share device!\n\n\n9082\nGIZ_OPENAPI_NOT_FOUND_GUEST\nguest user not found!\n\n\n9083\nGIZ_OPENAPI_GUEST_ALREADY_BOUND\nguest user alread bound!\n\n\n9084\nGIZ_OPENAPI_NOT_FOUND_SHARING_INFO\nsharing record not found!\n\n\n9085\nGIZ_OPENAPI_NOT_FOUND_THE_MESSAGE\nmessage record not found!\n\n\n9087\nGIZ_OPENAPI_SHARING_IS_WAITING_FOR_ACCEPT\nsharing alread created,waiting for the guest to accept!\n\n\n9088\nGIZ_OPENAPI_SHARING_IS_EXPIRED\nsharing record expired!\n\n\n9089\nGIZ_OPENAPI_SHARING_IS_COMPLETED\nsharing record status is not unaccept!\n\n\n9090\nGIZ_OPENAPI_INVALID_SHARING_BECAUSE_UNBINDING\nowner binding disabled!\n\n\n9092\nGIZ_OPENAPI_ONLY_OWNER_CAN_BIND\nowner exist, guest can not bind!\n\n\n9093\nGIZ_OPENAPI_ONLY_OWNER_CAN_OPERATE\npermission denied, you are not owner!\n\n\n9094\nGIZ_OPENAPI_SHARING_ALREADY_CANCELLED\nsharing already canceled!\n\n\n9095\nGIZ_OPENAPI_OWNER_CANNOT_UNBIND_SELF\ncan not unbind self!\n\n\n9096\nGIZ_OPENAPI_ONLY_GUEST_CAN_CHECK_QRCODE\npermission denied, you are not guest!\n\n\n9098\nGIZ_OPENAPI_MESSAGE_ALREADY_DELETED\nnotify delele binding failed!\n\n\n9099\nGIZ_OPENAPI_BINDING_NOTIFY_FAILED\nnotify delele binding failed!\n\n\n9100\nGIZ_OPENAPI_ONLY_SELF_CAN_MODIFY_ALIAS\npermission denied, you are not owner or guest!\n\n\n9101\nGIZ_OPENAPI_ONLY_RECEIVER_CAN_MARK_MESSAGE\npermission denied, you are not the receiver!\n\n\n9999\nGIZ_OPENAPI_RESERVED\nreserved\n\n\n\n"},{"title":"APICloud SDK使用指南","url":"/zh-cn/AppDev/APICloudWifiSDK.html","content":"概述\n机智云gizWifiSDK主要帮助开发者通过sdk接口调用的方式维护用户系统，用户与设备的绑定关系，设备的配置上线以及设备状态的获取和控制指令的发送。\nAPICloud机智云模块更新说明\n当前版本变更内容：\n1、版本号为1.3.0，原生SDK为2.04.04版本\n2、SDK启动接口：startWithAppID，增加域名和过滤productKey参数：\n3、设备配置接口：setDeviceOnboarding，模组类型参数增加了一个自定义枚举值，用于开发者使用自己的配置库\n4、定时任务接口将在下一个新版本中有接口更新发布，现有定时任务接口已被废弃，不推荐使用\n当前版本对1.2.4之前版本的兼容：\n我们对1.2.4之前版本的一些接口做了兼容，这些接口在当前版本中已被废弃。已经使用了这些接口的App不需要修改接口调用，但要注意以下三点修改：\n一、新版gizWifiSDK模块上报设备数据点时，布尔类型的数据点值是严格按照json格式定义返回true或false，而旧版gizWifiSDK模块返回的是1或0。App在接收布尔类型数据点时，请修改变量接收方式，使用布尔类型接收。\n二、新版gizWifiSDK模块除以下废弃接口外的所有接口，返回值均使用了新错误码值。App可以通过新旧错误码转换函数errorCodeConversion，将新错误码值转换为旧错误码值。errorCodeConversion函数说明在Constant页面的新旧错误码对照表后。\n三、接口执行成功时返回的错误码0对应的描述，msg字段，均统一使用了新错误码值对应的字符串\"GIZ_SDK_SUCCESS\"。\n此外，SDK对下发的设备操作指令，将严格按照Json格式限制数据类型。例如，如果设备的数据点定义的是布尔类型，指令下发时只能发true/false，如果发的是1/0或者\"1\"/\"0\"，都会拒绝下发。\n废弃接口与新接口功能对比\n废弃接口（即兼容接口）不强制要求更换，已经开发的app还可以继续使用，但新开发的app建议直接使用新接口。不关心废弃接口的开发者，请跳过本节直接看接口说明。\n枚举值变更：\nGizWifiConfigureMode \n变更说明：枚举值的起始序号统一从0开始。见Constant页相应表格\n变更方式：原来的softap模式为1，变更为0；原来的airlink模式为2，变更为1\n废弃接口：\ngizWifiSDK类\n\nsetDeviceWifi\n  废弃说明：更换接口名称\n  替代接口：setDeviceOnboarding，参数mode枚举值有变更（0 = GizWifiSoftAP、1 = GizWifiAirLink）\n\nupdateDeviceFromServer\n  废弃说明：机智云SDK模块会自动下载并更新设备的配置文件，App可以不再依赖这个接口了\n  替代接口：无。\n\nbindDevice\n  废弃说明：出于设备安全考虑，推荐使用更安全的设备绑定接口。机智云SDK模块会对已登录的局域网设备做自动绑定，因此对于局域网设备，App不需要调用绑定接口了\n  替代接口：bindRemoteDevice，需要产品productKey和对应的productSecret，以及设备mac才能绑定\n\nregisterUserByPhoneAndCode\n\nregisterUserByEmail\n  废弃说明：接口合并\n  替代接口：registerUser\n\ntransAnonymousUserToNormalUser\n\ntransAnonymousUserToPhoneUser\n  废弃说明：接口合并\n  替代接口：transAnonymousUser\n\nchangeUserPasswordByCode\n\nchangeUserPasswordByEmail\n  废弃说明：接口合并\n  替代接口：resetPassword\n\nchangeUserEmail\n\nchangeUserPhone\nchangeUserAdditionalInfo\n  废弃说明：接口合并。这三个接口已删除\n  替代接口：resetPassword\n\n\ngizWifiDevice类、GizWifiCentralControlDevice类\n\nlogin\ndisconnect\n  废弃说明：变更设备登录机制。机智云SDK模块已支持设备自动登录和掉线后自动恢复，成功时会上报设备的当前状态\n  替代接口：setSubscribe\n\ngetIsBind\n  废弃说明：优化接口使用方式。机智云SDK模块能够判断出设备的绑定状态，App不需要传递其他参数\n  替代接口：getDeviceInfo方法的isBind字段\n\n\n弃用的字段：\n\npasscode \n  弃用说明：出于安全考虑不再返回真实有效的设备密码字符串\n\n  相关接口：\n  GizWifiSDK类getBoundDevices接口返回值的devices信息\n  GizWifiDevice类的getDeviceInfo接口返回值的devices信息\n  GizWifiCentralControlDevice类的getDeviceInfo接口返回值的devices信息\n\nisOnline\n\nisConnected\n  弃用说明：字段含义合并，由netStatus替代。\n          netStatus为2 等同于 isConnect为true\n          netStatus为0或1 等同于 isConnect为false\n          netStatus为0 等同于 isOnline为false\n          netStatus为1或2 等同于 isOnline为true\n  相关接口：\n  GizWifiSDK类getBoundDevices接口返回值的devices信息\n  GizWifiDevice类的registerNotifications接口返回值\n  GizWifiCentralControlDevice类的registerNotifications接口返回值\n  GizWifiCentralControlDevice类的getSubDevices接口返回值\n  GizWifiCentralControlDevice类的addSubDevice接口返回值\n  GizWifiCentralControlDevice类的deleteSubDevice接口返回值\n  GizWifiSubDevice类的registerNotifications接口返回值\n  GizWifiSubDevice类的getDeviceInfo接口返回值\n\n\n\ncmd\nentity0\n  弃用说明：优化指令下发的参数格式。指令下发时，直接传数据点名称和值即可，数据上报时，也直接上报数据点名称和值\n  相关接口：\n  GizWifiDevice类的write接口下发参数\n  GizWifiCentralControlDevice类的write接口下发参数\n  GizWifiSubDevice类的write接口下发参数\n\nstatus\n  弃用说明：优化数据上报格式，直接上报数据点名称和值\n  相关接口：\n  GizWifiDevice类的registerNotifications接口返回值\n  GizWifiCentralControlDevice类的registerNotifications接口返回值\n  GizWifiSubDevice类的registerNotifications接口返回值\n\n  GizWifiDevice类的write接口返回值\n  GizWifiCentralControlDevice类的write接口返回值\n  GizWifiSubDevice类的write接口返回值\n\n\n枚举值变更：\n\nGizWifiConfigureMode \n 变更说明：枚举值的起始序号统一从0开始。见Constant页相应表格\n 变更方式：原来的softap模式为1，变更为0；原来的airlink模式为2，变更为1\n\n\n接口说明\ngizWifiSDK类接口\n机智云 Wi-Fi SDK 的基础类。该类提供了SDK初始化、基本设置、用户管理、设备管理的基本接口。\nstartWithAppID\n启动 SDK。 注意，该接口执行成功后才能正常执行其他接口功能。SDK启动在Android平台上可能会耗费1～2秒的时间，建议App开发者在收到启动ret返回8316(SDK启动成功)时或者启动后延时2秒左右再调用其他接口。\nstartWithAppID({params}, callback(ret, err))\nparams\nappID:\n\n类型： 字符串\n默认值：无\n描述：开发者在机智云网站申请的应用标识。\n\ncloudServiceInfo:\n\n类型： 数字类型数组\n默认值：0\n描述：要切换的服务器域名信息。使用机智云生产云服务的开发者不用传值，需要连接其他云服务的要传值。域名信息不指定端口则SDK使用默认服务端口，此时这样写域名：api.gizwits.com。若需要指定特殊端口，需同时指定 Http 和 Https 端口，此时这样写域名：api.gizwits.com:81&8443\n内部字段\n  {\n  openAPIInfo:     // api服务域名\n  siteInfo:       // site服务域名\n  pushInfo:       // 推送服务域名\n  }\n\n\nspecialProductKeys:\n\n类型： 字符串数组\n默认值：无\n描述：要过滤的设备 productKey 列表。如果希望返回所有能发现的设备则不需要传参。指定了之后,SDK 将只返回过滤后的设备\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      errorCode: 8316,    // SDK启动成功，数字类型\n      msg:                // 成功消息的描述，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\n// 不指定域名和过滤productKey，参考代码如下：\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.startWithAppID({\"appID\": \"your_app_id\"}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n    });\n// 要指定cloudServiceInfo和过滤的productKey，则参考代码如下：\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.startWithAppID({\"appID\": \"your_app_id\", \"specialProductKeys\": [\"your_product_key\"], \"cloudServiceInfo\": {\"openAPIInfo\": \"xxx.xxxx.com\", \"siteInfo\": \"xxx.xxxx.com\"}}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n    });\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nregisterNotifications\n注册 SDK 事件通知。通知的事件包括SDK启动失败或成功、设备列表变化上报等\nregisterNotifications({params}, callback(ret, err))\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      GizEventSDK:         // SDK事件\n      {errorCode: xxx, msg: \"xxx\"},   // 事件码（见GizWifiErrorCode，数字类型），事件描述（字符串类型）\n      GizEventDevice:     // 设备异常事件\n      {errorCode: xxx, msg: \"xxx\"},   // 事件码（见GizWifiErrorCode，数字类型），事件描述（字符串类型）\n      GizEventM2MService: // M2M异常事件\n      {errorCode: xxx, msg: \"xxx\"},   // 事件码（见GizWifiErrorCode，数字类型），事件描述（字符串类型）\n      GizEventToken\":     // Token失效\n      {errorCode: xxx, msg: \"xxx\"},   // 事件码（见GizWifiErrorCode，数字类型），事件描述（字符串类型）\n      devices: [{            // 设备数组（以下字段是设备对象信息），数组类型\n          mac:            // 设备MAC地址，字符串类型\n          did:              // 设备唯一标识，字符串类型\n          ip:                // 设备IP地址，字符串类型\n          productKey:        // 设备的产品识别码，字符串类型\n          productName:    // 设备的产品名称，字符串类型\n          remark:            // 设备备注信息，字符串类型\n          alias:            // 设备别名，字符串类型\n          type:            // 设备类型（见枚举定义GizWifiDeviceType），数字类型\n          netStatus:        // 设备网络状态（见枚举定义GizWifiDeviceNetStatus），数字类型\n          isLAN:            // 设备是否是局域网设备，布尔类型\n          isBind:            // 设备是否已绑定，布尔类型\n          isDisabled:        // 设备是否已在云端注销，布尔类型\n          isProductDefined:  // 设备是否定义了数据点，布尔类型\n          isSubscribed:    // 设备是否已订阅，布尔类型\n      }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.registerNotifications(function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetVersion\n获取SDK版本号\ngetVersion(callback(ret, err))\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      version:    // SDK版本号，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.getVersion(function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nsetLogLevel\n设置 SDK 日志。\nsetLogLevel({params})\nparams\nlogLevel:\n\n类型： 数字类型，见枚举定义GizLogPrintLevel\n默认值：3，为详细日志输出\n描述：SDK日志输出级别\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.setLogLevel({\"logLevel\": 3});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ndisableLAN\n禁用小循环\ndisableLAN({params}, callback(ret, err))\nparams\ndisabled:\n\n类型： 布尔类型\n默认值：false，开启\n描述：可禁用局域网下设备发现、设备控制等小循环下的功能\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      errorCode: 0,    // 执行成功，数字类型\n      msg:            //成功消息的描述，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.disableLAN({\"disabled\": true}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nsetCloudService\n切换服务域名\nsetCloudService({params}, callback(ret, err))\nparams\nopenAPIDomain:\n\n类型：字符串类型\n默认值：无\n描述：openAPI服务域名\n\nopenAPIPort:\n\n类型：数字类型\n默认值：无\n描述：openAPI服务端口\n\nsiteDomain:\n\n类型：字符串类型\n默认值：无\n描述：site服务域名\n\nsitePort:\n\n类型：数字类型\n默认值：无\n描述：site服务端口\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      openAPIDomain:    // api域名，字符串类型\n      openAPIPort\":    // api端口，数字类型\n      siteDomain:        // site域名，字符串类型\n      sitePort:             // site端口，数字类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.setCloudService({\n    \"openAPIDomain\": \"your_api_domain\", \n    \"openAPIPort\": your_api_port, \n    \"siteDomain\": \"your_site_domain\", \n    \"sitePort\": your_site_port\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetListInfo\n获取SDK版本号\ngetListInfo(callback(ret, err))\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段  {\n      devices: [{            // 设备数组（以下字段是设备对象信息），数组类型\n          mac:            // 设备MAC地址，字符串类型\n          did:              // 设备唯一标识，字符串类型\n          ip:                // 设备IP地址，字符串类型\n          productKey:        // 设备的产品识别码，字符串类型\n          productName:    // 设备的产品名称，字符串类型\n          remark:            // 设备备注信息，字符串类型\n          alias:            // 设备别名，字符串类型\n          type:            // 设备类型（见枚举定义GizWifiDeviceType），数字类型\n          netStatus:        // 设备网络状态（见枚举定义GizWifiDeviceNetStatus），数字类型\n          isLAN:            // 设备是否是局域网设备，布尔类型\n          isBind:            // 设备是否已绑定，布尔类型\n          isDisabled:        // 设备是否已在云端注销，布尔类型\n          isProductDefined:  // 设备是否定义了数据点，布尔类型\n          isSubscribed:    // 设备是否已订阅，布尔类型\n      }]\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.getListInfo(function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetPhoneSSID\n获取手机当前Wifi的SSID\ngetPhoneSSID(callback(ret, err))\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      SSID:    // 手机当前wifi的SSID，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.getPhoneSSID(function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nsetDeviceOnboarding\n配置设备路由。设备要能连接到WiFi网络，需要先把设备配置到WiFi路由器上。配置时，需要给设备发送要配置的路由SSID和密码。\n设备配置支持两种方式：SoftAP方式、AirLink方式。在设备上按不同的按键，可以使设备进入对应的配置模式。详细的操作方式，请访问机智云网站。\n进行 SoftAP 配置时，设备要处于 softap 模式。此时模组会产生一个热点名称，手机 wifi 必须连接此热点后才可以配置。如果是机智云提供的固件，模组热点名称前缀为\"XPG-GAgent-\"，密码为\"123456789\"。设备处于 airlink 模式时，手机随时都可以开始配置。但无论哪种配置方式，设备上线时，手机要连接到配置的局域网 wifi 上，才能够确认设备已配置成功。设备配置成功时，在回调中会返回设备 mac 地址。如果设备重置了，设备did可能要在设备搜索回调中才能获取。\nsetDeviceOnboarding({params}, callback(ret, err))\nparams\nssid:\n\n类型： 字符串\n默认值：无\n描述：要配置的Wifi SSID\n\nkey:\n\n类型： 字符串\n默认值：无\n描述：要配置的 Wifi 密码\n\nmode:\n\n类型： 数字类型\n默认值：无\n描述：设备配置方式（见 GizWifiConfigureMode 枚举定义）\n\nsoftAPSSIDPrefix:\n\n类型： 字符串\n默认值：无\n描述：SoftAPMode 模式下SoftAP 的 SSID 全名。机智云的GoKit，默认前缀为\"XPG-GAgent-\"\n\ntimeout:\n\n类型： 数字类型\n默认值：30\n描述：配置超时时间。超时时间建议设置为60秒\n\ngagentTypes:\n\n类型： 数字类型数组\n默认值：4\n描述：模组类型（见 GAgentType 枚举定义），若不指定此参数则默认配置乐鑫模组。GizWifiGAgentType定义了 SDK 支持的所有模组类型。GizWifiGAgentType还定义了一个GizGAgentOther枚举值，用于开发者使用自己的配置库进行设备配置，此时参数传GizGAgentOther即可\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device:{        // 配置成功的设备，以下字段是设备信息：\n          \"mac\":        // 设备mac\n             \"did\":        // 设备did\n             \"productKey\":// 设备类型标识码\n         }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\n// softap配置\ngizWifiSDK.setDeviceOnboarding({\n    \"ssid\": \"your_ssid\",\n    \"key\": \"your_key\",\n    \"mode\": 0,\n    \"softAPSSIDPrefix\": \"your_prefix\",\n    \"timeout\": 60\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n\n// airlink配置乐鑫模组\nGizGAgentESP = 4;\ngizWifiSDK.setDeviceOnboarding({\n    \"ssid\": \"your_ssid\",\n    \"key\": \"your_key\",\n    \"mode\": 1,\n    \"gagentTypes\": [GizGAgentESP],\n    \"timeout\": 60\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetSSIDList\n获取设备热点列表。设备 wifi 模组处于 SoftAP 热点模式时，可以获取设备搜索到的 WiFi 热点列表。此接口需要手机当前 Wifi 连上设备模组的 SoftAP 热点后才能工作。\ngetSSIDList(callback(ret, err))\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      wifiSSIDs:[{       // WiFi热点列表，以下字段是热点信息：\n             \"ssid\":        // WiFi的ssid\n             \"rssi\":        // WiFi的信号强弱\n         }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.getSSIDList(function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \"  JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetBoundDevices\n获取绑定设备列表。在不同的网络环境下，有不同的处理：\n当手机能访问外网时，该接口会向云端发起获取绑定设备列表请求；\n当手机不能访问外网时，局域网设备是实时发现的，但会保留之前已经获取过的绑定设备；\n手机处于无网模式时，局域网未绑定设备会消失，但会保留之前已经获取过的绑定设备；\ngetBoundDevices({params}, callback(ret, err))\nparams\nuid:\n\n类型： 字符串\n默认值：无\n描述：用户登录后获取到的uid。uid 和 token 都不传时，将只会得到小循环设备\n\ntoken:\n\n类型： 字符串\n默认值：无\n描述：用户登录后获取到的token。uid 和 token 都不传时，将只会得到小循环设备\n\nspecialProductKeys:\n\n类型： 字符串数组\n默认值：无\n描述：指定过滤的产品类型识别码，可同时指定多个要过滤的 Product Key\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      devices: [{            // 设备数组（以下字段是设备对象信息），数组类型\n          mac:            // 设备MAC地址，字符串类型\n          did:              // 设备唯一标识，字符串类型\n          ip:                // 设备IP地址，字符串类型\n          productKey:        // 设备的产品识别码，字符串类型\n          productName:    // 设备的产品名称，字符串类型\n          remark:            // 设备备注信息，字符串类型\n          alias:            // 设备别名，字符串类型\n          type:            // 设备类型（见枚举定义GizWifiDeviceType），数字类型\n          netStatus:        // 设备网络状态（见枚举定义GizWifiDeviceNetStatus），数字类型\n          isLAN:            // 设备是否是局域网设备，布尔类型\n          isBind:            // 设备是否已绑定，布尔类型\n          isDisabled:        // 设备是否已在云端注销，布尔类型\n          isProductDefined:  // 设备是否定义了数据点，布尔类型\n          isSubscribed:    // 设备是否已订阅，布尔类型\n      }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\n    gizWifiSDK.getBoundDevices({\n        \"uid\": 'your_uid',\n        \"token\": 'your_token',\n        \"specialProductKeys\": ['your_product_key']\n     }, function (ret1, err1) {\n        alert(\"ret1 = \" + JSON.stringify(ret1) + \"err1 = \" + JSON.stringify(err1))\n    });\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nbindRemoteDevice\n绑定远端设备到云端\nbindRemoteDevice({params}, callback(ret, err))\nparams\nuid:\n\n类型： 字符串\n默认值：无\n描述：用户登录后获取到的uid。\n\ntoken:\n\n类型： 字符串\n默认值：无\n描述：用户登录后获取到的token。\n\nmac:\n\n类型： 字符串\n默认值：无\n描述：待绑定设备的mac\n\nproductKey:\n\n类型： 字符串\n默认值：无\n描述：待绑定设备的productKey。\n\nproductSecret:\n\n类型： 字符串\n默认值：无\n描述：待绑定设备的productSecret\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      did:  // 设备唯一标识，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\n    gizWifiSDK.bindRemoteDevice({\n    \"uid\": 'your_uid',\n    \"token\": 'your_token',\n    \"mac\": 'your_device_mac',\n    \"productKey\": 'your_product_key',\n    \"productSecret\": 'your_product_secret'\n    }, function (ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n    });\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nunbindDevice\n把设备从云端解绑。用户登录后，可以将已绑定的设备与云端自己的账户解绑。\nunbindDevice({params}, callback(ret, err))\nparams\nuid:\n\n类型： 字符串\n默认值：无\n描述：用户登录后获取到的uid。\n\ntoken:\n\n类型： 字符串\n默认值：无\n描述：用户登录后获取到的token。\n\ndid:\n\n类型： 字符串\n默认值：无\n描述：设备唯一标识。\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      did:  // 设备唯一标识，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.unbindDevice({\n    \"uid\": 'your_uid',\n    \"token\": 'your_token',\n    \"did\": 'your_device_id'    \n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nuserLoginAnonymous\n匿名登录。匿名方式登录，不需要注册用户账号\nuserLoginAnonymous(callback(ret, err))\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      uid:      // 用户uid，字符串类型\n      token:    // 登录会话token，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.userLoginAnonymous(function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nuserLogin\n用户登录。需使用注册成功的用户名、密码进行登录，可以是手机用户名、邮箱用户名或普通用户名\nuserLogin({params}, callback(ret, err))\nparams\nuserName:\n\n类型： 字符串\n默认值：无\n描述：要登录的用户名。\n\npassword:\n\n类型： 字符串\n默认值：无\n描述：要登录的密码。\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      uid:      // 用户uid，字符串类型\n      token:    // 登录会话token，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.userLogin({\n    \"userName\": 'your_user_name',\n        \"password\": 'your_password'\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n})\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nuserLoginWithThirdAccountType\n第三方账号登录。第三方账号支持百度、新浪、QQ，需要通过第三方的 shareSDK 工具或各自对应的SDK，获取到 uid 和 token 之后才可以使用此接口。\nuserLoginWithThirdAccountType({params}, callback(ret, err))\nparams\nuid: 登录第三方账号之后得到的uid\n\n类型： 字符串\n默认值：无\n描述：要登录的用户id\n\ntoken: 登录第三方账号之后得到的token\n\n类型： 字符串\n默认值：无\n描述：要登录的密码\n\nthirdAccountType:\n\n类型： 数字类型\n默认值：无\n描述：第三方账号类型（见 GizThirdAccountType 枚举定义）\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      uid:      // 登录机智云后得到的 uid，字符串类型\n      token:    // 登录机智云后得到的 token，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.userLoginWithThirdAccountType({\n        \"thirdAccountType\": 0,\n        \"uid\": 'your_third_uid',\n        \"token\": 'your_third_token'\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nrequestSendVerifyCode\n通过App secret和手机号请求短信验证码。\nrequestSendVerifyCode({params}, callback(ret, err))\nparams\nappSecret: \n\n类型： 字符串\n默认值：无\n描述：应用的 secret 信息，从 site.gizwits.com 中可以看到\n\nphone: \n\n类型： 字符串\n默认值：无\n描述：手机号\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      errorCode: 0,     // 验证码获取成功，数字类型\n      msg:             // 消息描述，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.requestSendVerifyCode({\n        \"appSecret\": 'your_app_secret',\n        \"phone\": 'your_phone_number'\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetCaptchaCode\n通过 App Secret 获取图片验证码。\ngetCaptchaCode({params}, callback(ret, err))\nparams\nappSecret: \n\n类型： 字符串\n默认值：无\n描述：应用的 secret 信息，是与 AppID 对应的应用签名字符串，从 site.gizwits.com 中可以看到\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      token:             // 图片验证码 token，图片验证码token在1小时后过期。字符串类型\n      captchaId:        // 图片验证码 id，图片验证码5分钟后过期。字符串类型\n      captchaURL:        // 图片验证码 url，图片验证码 url 在使用后过期。字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.getCaptchaCode({\n        \"appSecret\": 'your_app_secret'\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nrequestSendPhoneSMSCode\n通过图形验证码获取手机短信验证码\nrequestSendPhoneSMSCode({params}, callback(ret, err))\nparams\ntoken: \n\n类型： 字符串\n默认值：无\n描述：验证码 token，通过 getCaptchaCode 获取\n\ncaptchaId: \n\n类型： 字符串\n默认值：无\n描述：验证码 id，通过 getCaptchaCode 获取\n\ncaptchaCode: \n\n类型： 字符串\n默认值：无\n描述：验证码，来自图片的验证内容\n\nphone: \n\n类型： 字符串\n默认值：无\n描述：手机号\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      errorCode: 0,     // 验证码获取成功，数字类型\n      msg:             // 消息描述，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.requestSendPhoneSMSCode({\n        \"token\": 'your_captcha_code_token',\n        \"captchaId\": 'your_captcha_code_id',\n        \"captchaCode\": 'your_captcha_code',\n        \"phone\": 'your_phone_number'\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nverifyPhoneSMSCode\n验证手机短信验证码。注意，验证短信验证码后，验证码就失效了，无法再用于手机号注册\nverifyPhoneSMSCode({params}, callback(ret, err))\nparams\ntoken: \n\n类型： 字符串\n默认值：无\n描述：验证码 token，通过 getCaptchaCode 获取\n\nphoneCode: \n\n类型： 字符串\n默认值：无\n描述：手机短信中的验证码内容\n\nphone: \n\n类型： 字符串\n默认值：无\n描述：手机号\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      errorCode: 0,   // 验证码获取成功，数字类型\n      msg:            // 消息描述，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.verifyPhoneSMSCode({\n        \"token\": 'your_captcha_code_token',\n        \"phoneCode\": 'your_phone_sms_code',\n        \"phone\": 'your_phone_number'\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nregisterUser\n用户注册。需指定用户类型注册。手机用户的用户名是手机号，邮箱用户的用户名是邮箱、普通用户的用户名可以是普通用户名\nregisterUser({params}, callback(ret, err))\nparams\nuserName: \n\n类型： 字符串类型\n默认值：无\n描述：用户名。\n\npassword: \n\n类型： 字符串类型\n默认值：无\n描述：密码。\n\nverifyCode: \n\n类型： 字符串类型\n默认值：无\n描述：手机短信验证码。短信验证码注册后就失效了，不能被再次使用\n\naccountType: \n\n类型： 字符串类型\n默认值：无\n描述：用户类型，详细见 GizUserAccountType 枚举定义。注册手机号时，此参数指定为手机用户，注册邮箱时，此参数指定为邮箱用户，注册普通用户名时，此参数指定为普通用户\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      uid:      // 注册成功后返回的uid，字符串类型\n      token:    // 注册成功后返回的token，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.registerUser({\n    \"userName\": 'your_phone_number',\n    \"password\": 'your_password',\n    \"verifyCode\": 'your_verify_code',\n    \"accountType\": 1\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ntransAnonymousUser\n匿名用户转换，可转换为手机用户或者普通用户。注意，待转换的帐号必须是还未注册过的\ntransAnonymousUser({params}, callback(ret, err))\nparams\ntoken: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 token\n\nuserName: \n\n类型： 字符串\n默认值：无\n描述：待转换的普通账号或手机号\n\npassword: \n\n类型： 字符串\n默认值：无\n描述：转换后的帐号密码\n\nverifyCode: \n\n类型： 字符串\n默认值：无\n描述：转换为手机用户时要使用的手机短信验证码\n\naccountType: \n\n类型： 数值类型\n默认值：无\n描述：用户类型，详细见 GizThirdAccountType 枚举定义。待转换的用户名是手机号时，此参数指定为1，待转换用户名是普通账号时，此参数指定为0\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      uid:      // 注册成功后返回的uid，字符串类型\n      token:    // 注册成功后返回的token，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.transAnonymousUser({\n    \"token\": 'your_token',\n    \"userName\": 'your_phone_number',\n    \"password\": 'your_password',\n    \"verifyCode\": 'your_verify_code',\n    \"accountType\": 1\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nresetPassword\n重置密码\nresetPassword({params}, callback(ret, err))\nparams\nuserName: \n\n类型： 字符串\n默认值：无\n描述：待重置密码的手机号或邮箱\n\nverifyCode: \n\n类型： 字符串\n默认值：无\n描述：重置手机用户密码时需要使用手机短信验证码\n\nnewPassword: \n\n类型： 字符串\n默认值：无\n描述：新密码\n\naccountType: \n\n类型：数值类型\n默认值：无\n描述：用户类型，详细见 GizThirdAccountType 枚举定义。待重置密码的用户名是手机号时，此参数指定为手机用户，待重置密码的用户名是邮箱时，此参数指定为邮箱用户\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      errorCode: 0    // 执行成功，数字类型\n      msg:            // 错误描述，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.resetPassword({\n    \"userName\": 'your_phone_number',\n    \"verifyCode\": 'your_verify_code',\n    \"newPassword\": 'your_new_password',\n    \"accountType\": 1\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nchangeUserPassword\n修改用户密码\nchangeUserPassword({params}, callback(ret, err))\nparams\ntoken: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 token\n\noldPassword: \n\n类型： 字符串\n默认值：无\n描述：旧密码\n\nnewPassword: \n\n类型： 字符串\n默认值：无\n描述：新密码\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      errorCode: 0    // 执行成功，数字类型\n      msg:            // 错误描述，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.changeUserPassword({\n    \"token\": 'your_token',\n    \"oldPassword\": 'your_old_password',\n    \"newPassword\": 'your_new_password'\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nchangeUserInfo\n匿名用户转手机用户。手机匿名登录后，可以转换为手机用户，但需要先获取到手机验证码才可以转换。转换后，匿名用户已经绑定的设备，会迁移到转换后的用户账号下。\nchangeUserInfo({params}, callback(ret, err))\nparams\ntoken: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 token\n\nuserName: \n\n类型： 字符串\n默认值：无\n描述：待修改的手机号或邮箱\n\nverifyCode: \n\n类型： 字符串\n默认值：无\n描述：修改手机号时要使用的手机短信验证码\n\naccountType: \n\n类型： 字符串\n默认值：无\n描述：用户类型，详细见 GizThirdAccountType 枚举定义。修改手机号时，accountType传1；修改普通用户名时，accountType传2；只修改个人信息时，accountType传0；同时修改用户名和个人信息时，可根据待修改的是手机号还是邮箱来指定\n\nadditionalInfo: \n\n类型： 字符串\n默认值：无\n描述：待修改的个人信息，详细见 GizUserInfo 类定义。如果只修改个人信息，需要指定token，username、code不用传\n内部字段：  {\n      \"name\":         // 昵称，字符串类型\n      \"gender\":    // 性别，见UserGenderType枚举，数字类型\n      \"birthday\":     // 生日，字符串类型\n      \"address\":     // 住址，字符串类型\n      \"remark\":     // 备注，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      errorCode: 0,     // 转换成功，数字类型\n      msg:             // 消息描述，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\n// 修改手机号\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.changeUserInfo({\n    \"token\": 'your_token',\n    \"userName\": 'your_phone_number',\n    \"verifyCode\": 'your_verify_code',\n    \"accountType\": 1\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetUserInfo\n获取用户信息。用户登录后，可以获取用户的个人信息。\ngetUserInfo({params}, callback(ret, err))\nparams\ntoken: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 token\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      \"uid\":             // 用户登录的uid，字符串类型\n      \"username\":     // 用户名，字符串类型\n      \"email\":         // email信息，字符串类型\n      \"phone\":        // 电话号码，字符串类型\n      \"isAnonymous\":    // 是否为匿名用户，布尔类型\n      \"name\":         // 昵称，字符串类型\n      \"gender\":        // 性别，UserGenderType枚举类型\n      \"birthday\":        // 生日，字符串类型\n      \"address\":        // 住址，字符串类型\n      \"remark\":         // 备注，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.getUserInfo({\n    \"token\": 'your_token'\n},function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetGroups\n获取用户账号下的设备分组列表。需要先完成用户登录，才能获取设备分组列表。设备分组是指把中控网关管理的子设备分成多个组，便于批量执行子设备操作。一个设备分组只能添加一种类型的设备。常见的应用场景，比如睡前把房间里所有的开关灯关掉，把床头的两个落地灯调暗，这时就可以把子设备分成两个组，一个是开关灯组，一个是落地灯组。\ngetGroups({params}, callback(ret, err))\nparams\nuid: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 uid\n\ntoken: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 token\n\nspecialProductKeys: \n\n类型： 字符串\n默认值：无\n描述：待筛选的组类型标识，字符串数组。不指定则不筛选\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      groups:[{      // 组对象（以下字段是组对象信息），数组类型\n          \"gid\":    // 组ID，字符串类型\n      }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.getGroups({\n        \"uid\": 'your_uid',\n        \"token\": 'your_token',\n        \"specialProductKeys\": []\n},function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\naddGroup\n添加设备分组。添加后返回当前的设备分组列表\naddGroup({params}, callback(ret, err))\nparams\nuid: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 uid\n\ntoken: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 token\n\nproductKey: \n\n类型： 字符串\n默认值：无\n描述：指定组类型标识\n\ngroupName: \n\n类型： 字符串\n默认值：无\n描述：指定组名称\n\nspecialDevices: \n\n类型： JSON对象\n默认值：无\n描述：指定加入组内的设备。字典数组，依赖键值 sdid（子设备标识码）、did（父设备标识码）。不加入设备则不传\n内部字段\n  {\n      \"mac\":        // 子设备所属中控网关的mac地址，字符串类型\n      \"did\":         // 子设备所属中控网关的did，字符串类型\n      \"subDid\":    // 子设备的did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      groups:[{      // 组对象（以下字段是组对象信息），数组类型\n          \"gid\":    // 组ID，字符串类型\n      }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.addGroup({\n            \"uid\": 'your_uid',\n            \"token\": 'your_token',\n            \"productKey\": 'your_group_type',\n            \"groupName\": 'your_group_name',\n            \"specialDevices\": []\n    },function(ret, err) {\n            alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err));\n    });\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nremoveGroup\n删除设备分组。删除后返回当前的设备分组列表\nremoveGroup({params}, callback(ret, err))\nparams\nuid: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 uid\n\ntoken: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 token\n\ngid: \n\n类型： 字符串\n默认值：无\n描述：待删除的组id\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      groups:[{      // 组对象（以下字段是组对象信息），数组类型\n          \"gid\":    // 组ID，字符串类型\n      }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\ngizWifiSDK.removeGroup({\n    \"uid\": 'your_uid',\n            \"token\": 'your_token',\n       \"gid\": 'your_group_id'\n}, function (ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\neditGroup\n编辑设备分组。编辑分组后返回当前的设备分组列表\neditGroup({params}, callback(ret, err))\nparams\nuid: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 uid\n\ntoken: \n\n类型： 字符串\n默认值：无\n描述：用户登录或注册时得到的 token\n\ngid: \n\n类型： 字符串\n默认值：无\n描述：待编辑组的组id\n\ngroupName: \n\n类型： 字符串\n默认值：无\n描述：待编辑组的组名称\n\nspecialDevices: \n\n类型： JSON对象\n默认值：无\n描述：要编辑的组内设备信息，依赖键值 sdid（子设备标识码）、did（父设备标识码）。不指定设备则不传\n内部字段\n  {\n      \"mac\":        // 子设备所属中控网关的mac地址，字符串类型\n      \"did\":         // 子设备所属中控网关的did，字符串类型\n      \"subDid\":    // 子设备的did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      groups:[{      // 组对象（以下字段是组对象信息），数组类型\n          \"gid\":    // 组ID，字符串类型\n      }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar gizWifiSDK = api.require('gizWifiSDK');\n    gizWifiSDK.editGroup({\n    \"uid\": 'your_uid',\n        \"token\": 'your_token',\n        \"gid\": 'your_group_id',\n        \"groupName\": 'your_group_name',\n        \"specialDevices\": []\n    }, function (ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n    });\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngizWifiDevice类接口\n机智云 Wi-Fi 的设备类。该类提供了设备登录，控制、接收设备信息功能。\nregisterNotifications\n注册设备状态变化通知。只要得到设备的mac地址和did，就可以注册设备通知。注册后，设备后续的登录状态变化、运行状态变化都会实时上报给APP。设备解绑或断开连接后，就不会再上报数据了。\nregisterNotifications({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要注册通知的设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device: {   // 执行成功的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n      netStatus: // 设备在线状态（见枚举定义GizWifiDeviceNetStatus），数字类型\n      data: {                    // 设备状态，字符串类型\n          \"attrName\":\"attrValue\",    // 数据点名称: 操作值\n      }\n      alerts: {                    // 报警，数组类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 报警内容\n      }   \n      faults: {                     // 故障，数组类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 故障内容\n      }\n      binary:     // 二进制透传数据，base64编码字符串，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 执行失败的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiDevice = api.require('gizWifiDevice');\ngizWifiDevice.registerNotifications({\n    \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac'\n         }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nsetSubscribe\n设备订阅或解除订阅。订阅了设备，表示使用者关心这个设备的消息推送。解除订阅，表示使用者不关心这个设备的消息推送。订阅设备后，SDK将自动登录和自动绑定设备。解除订阅后，设备连接将自动断开，但不会自动解绑。一般来说，设备订阅都会成功的，SDK会记住设备是否被订阅了。\nsetSubscribe({params}, callback(ret, err))\nparams\nsubscribed: \n\n类型：布尔类型\n默认值：无\n描述：订阅或解除订阅。true表示订阅，false表示解除订阅\n\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要登录的设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      isSubscribed:     // 设备是被订阅了还是被取消订阅了，布尔类型\n      device: {       // 执行成功的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":      // 设备mac地址，字符串类型\n          \"did\":      // 设备did，字符串类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 执行失败的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiDevice = api.require('gizWifiDevice');\ngizWifiDevice.setSubscribe({\n    \"subscribed\": true,\n    \"device\": {\n        \"mac\": 'your_device_mac',\n        \"did\": 'your_device_id'\n      }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本 \ngetDeviceStatus\n获取设备状态。已订阅的设备变为可控状态后才能获取到状态，包括设备的运行状态、报警、故障、透传数据等。\ngetDeviceStatus({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要查询的设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device:{       // 操作命令执行成功的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n      \"data\": {                    // 设备状态，对象类型\n          \"attrName\":\"attrValue\",    // 数据点名称: 操作值。如果数据点是扩展类型，操作值为base64编码字符串\n      }\n      \"alerts\": {                    // 报警，对象类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 报警内容\n      }\n      \"faults\": {                     // 故障，对象类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 故障内容\n      }\n      \"binary\":     // 二进制透传数据，base64编码字符串，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 查询失败的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiDevice = api.require('gizWifiDevice');\ngizWifiDevice.getDeviceStatus({\n    \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac'\n    }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nwrite\n给设备发送控制指令，已订阅的设备变为可控状态后才能发送控制指令。设备控制时也分为大循环和小循环（即远程和局域网环境），SDK会优先进行小循环控制。当设备只能通过大循环访问时，才进行大循环控制。APP的设备控制指令到达设备端后，设备状态变化时会上报当前状态。APP通过回调函数可以得到状态数据，包括设备的运行状态、报警、故障、透传数据等。\n硬件产品开发者根据产品功能来定义设备的操作命令集。在APP端，设备的操作命令以数据点形式格式化后发送到设备端。数据点可以定义布尔类型、字符串类型、数字类型、扩展类型的数据。如何定义数据点，请访问机智云网站。\n如果开发者有需要透传的数据指令，可以通过定义扩展类型的数据点实现。如果要透传的是二进制数据，需要先用base64编码转换为字符串再写入write接口的data参数。同样，设备向APP透传的二进制数据，APP接收后，要先经过base64解码为二进制数据才能正确使用。请注意，一定要用base64编解码，否则二进制数据无法正确透传。\n要求：下发的指令格式需按照正确的json类型下发。例如，布尔类型的值，下发的是0或1，可能会导致无法下发。\nwrite({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要发送操作指令的设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n  }\n\n\nsn: \n\n类型： 数字类型\n默认值：无\n描述：发送操作指令时可以携带指令序号，指令序号由App生成和维护\n\ndata: \n\n类型： JSON对象\n默认值：无\n描述：要发送的操作指令。\n内部字段\n  {\n      \"data\": {                    // 设备数据点对象类型\n          ……\n          \"attrName\": \"attrValue\",// 操作命令：数据点名称、操作值\n                                  // 数据点名称是字符串类型，操作值的类型是在数据点中定义的\n                                  // 如果数据点是扩展类型，操作值需为base64编码字符串\n          ……\n      }\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device:{       // 执行成功的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n      \"sn\":         // 操作指令下发时的指令序号\n      \"data\": {                       // 状态，对象类型\n          \"attrName\": \"attrValue\",    // 数据点名称: 操作值。如果数据点是扩展类型，操作值需为base64编码字符串\n      }\n      \"alerts\": {                    // 报警，对象类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 报警内容\n      }\n      \"faults\": {                    // 故障，对象类型\n          \"attrName\":\"attrValue\"    // 数据点名称: 故障内容\n      }   \n      \"binary\":         // 二进制透传数据，base64编码字符串，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 执行失败的设备对象，对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiDevice = api.require('gizWifiDevice');\ngizWifiDevice.write({\n    \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac'\n    },\n    \"sn\": 5\n    \"data\": {\n        \"LED_G\": 127,\n               \"LED_B\":254,\n               \"LED_R\":127,\n               \"LED_OnOff\":true,\n               \"Motor_Speed\":2\n         }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetHardwareInfo\n获取设备硬件信息。只有在小循环时，设备登录后才能够获取到设备硬件信息。\ngetHardwareInfo({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device: {   // 执行成功的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n      hardwareInfo: {            // 设备硬件信息，对象类型\n          \"wifiHardVer\":        // WiFi硬件版本号，字符串类型\n          \"wifiSoftVer\":        // WiFi软件版本号，字符串类型\n          \"mcuHardVer\":        // 设备硬件版本号，字符串类型\n          \"mcuSoftVer\":        // 设备软件版本号，字符串类型\n          \"firmwareId\":        // 固件fid，字符串类型\n          \"firmwareVer\":        // 固件版本号，字符串类型\n          \"productKey\":        // 产品类型识别码\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 执行失败的设备对象，对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiDevice = api.require('gizWifiDevice');\ngizWifiDevice.getHardwareInfo({\n        \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac'\n        }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nexitProductionTesting\n退出产测模式。不订阅设备就可以调用此接口，设备进入产测模式后会做出响应\nexitProductionTesting({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device: {   // 执行成功的设备对象，对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 执行失败的设备对象，对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiDevice = api.require('gizWifiDevice');\ngizWifiDevice.exitProductionTesting({\n        \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac'\n        }\n},function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nsetCustomInfo\n修改设备的备注和别名。设备绑定后才能修改\nsetCustomInfo({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要修改备注和别名的设备对象\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n  }\n\n\nremark: \n\n类型： JSON对象\n默认值：无\n描述：待修改的备注信息。不修改可不传\n\nalias: \n\n类型： JSON对象\n默认值：无\n描述：待修改的别名信息。不修改可不传\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device: {   // 执行成功的设备对象，对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 执行失败的设备对象，对象类型\n          \"mac\":    // 设备mac地址，字符串类型\n          \"did\":     // 设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiDevice = api.require('gizWifiDevice');\ngizWifiDevice.setCustomInfo({\n       \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac'\n       },\n    \"remark\": \"your_remark\",\n    \"alias\": \"your_alias\"\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetDeviceInfo\n获取设备基本信息。\ngetDeviceInfo({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：设备对象，设备mac和did可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 中控设备mac地址，字符串类型\n      \"did\":         // 中控设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device: {           // 设备对象（以下字段是设备信息），对象类型\n          mac:            // 设备MAC地址，字符串类型\n          did:              // 设备唯一标识，字符串类型\n          ip:                // 设备IP地址，字符串类型\n          productKey:        // 设备的产品识别码，字符串类型\n          productName:    // 设备的产品名称，字符串类型\n          remark:            // 设备备注信息，字符串类型\n          alias:            // 设备别名，字符串类型\n          type:            // 设备类型（见枚举定义GizWifiDeviceType），数字类型\n          netStatus:        // 设备网络状态（见枚举定义GizWifiDeviceNetStatus），数字类型\n          isLAN:            // 设备是否是局域网设备，布尔类型\n          isBind:            // 设备是否已绑定，布尔类型\n          isDisabled:        // 设备是否已在云端注销，布尔类型\n          isProductDefined:  // 设备是否定义了数据点，布尔类型\n          isSubscribed:    // 设备是否已订阅，布尔类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device: {       // 设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":        // 设备mac地址，字符串类型\n          \"did\":         // 设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiDevice = api.require('gizWifiDevice');\ngizWifiDevice.getDeviceInfo({\n    \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac'\n        }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngizWifiCentralControlDevice类接口\n机智云 Wi-Fi 的中控设备类。该类提供了中控设备获取子设备列表、添加子设备、删除子设备功能。中控设备类继承自GizWifiDevice类，可以使用GizWifiDevice类的所有接口。\n在获取到设备列表时，通过GizWifiDevice类的getDeviceInfo()接口中的type字段信息，可以知道该设备是否为中控设备。中控设备登录后，就可以进行子设备添加、删除等操作了。\nregisterNotifications\n注册子设备列表变化通知。当中控设备处于子设备加网状态时，会主动上报当前已入网的子设备。APP注册通知后，SDK就会将子设备列表上报给APP。\nregisterNotifications({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要注册通知的中控设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 中控设备mac地址，字符串类型\n      \"did\":         // 中控设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device:{       // 注册成功的中控设备对象，对象类型\n          \"mac\":    // 中控设备mac地址，字符串类型\n          \"did\":     // 中控设备did，字符串类型\n      }\n      netStatus:     // 中控设备的网络状态（见枚举定义GizWifiDeviceNetStatus），数值类型\n      subDevices: {            // 中控设备上报的子设备列表，对象数组类型\n          \"mac\":                 // 中控设备mac，字符串类型\n          \"did\":                // 中控设备did，字符串类型\n          \"subDid\":            // 中控子设备did，字符串类型\n          \"netStatus\":        // 中控子设备是否在线（见枚举定义GizWifiDeviceNetStatus），数值类型\n          \"subProductKey\":     // 中控子设备类型标识码，字符串类型\n          \"subProductName\":     // 中控子设备产品名称，字符串类型\n          \"type\":             // 中控子设备类型（见枚举定义GizWifiDeviceType），数值类型\n          \"productKey\":         // 中控设备类型标识码，字符串类型\n          \"productName\":         // 中控设备产品名称，字符串类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device: {   // 注册失败的设备对象，对象类型\n          \"mac\":    // 中控设备mac地址，字符串类型\n          \"did\":     // 中控设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiCentralControlDevice = api.require('gizWifiCentralControlDevice');\ngizWifiCentralControlDevice.registerNotifications({\n        \"device\": {\n                \"mac\": 'your_device_mac',\n                \"did\": 'your_device_id'\n        }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetSubDevices\n获取子设备列表。\ngetSubDevices({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：中控设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 中控设备mac地址，字符串类型\n      \"did\":         // 中控设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device: {   // 执行成功的中控设备对象，对象类型\n          \"mac\":    // 中控设备mac地址，字符串类型\n          \"did\":     // 中控设备did，字符串类型\n      }\n      subDevices: {    // 中控设备上报的子设备列表，对象数组类型\n          \"mac\":                     // 中控设备mac，字符串类型\n          \"did\":                    // 中控设备did，字符串类型\n          \"subDid\":                 // 子设备did，字符串类型\n          \"subProductKey\":        // 子设备类型标识，字符串类型\n          \"subProductName\":        // 子设备产品名称，字符串类型\n          \"type\":                    // 子设备类型，数字类型\n          \"netStatus\":            // 中控子设备是否在线（见枚举定义GizWifiDeviceNetStatus），数值类型\n          \"productKey\":            // 中控设备类型标识，字符串类型\n          \"productName\":            // 中控设备产品名称，字符串类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 执行失败的中控设备对象，对象类型\n          \"mac\":    // 中控设备mac地址，字符串类型\n          \"did\":     // 中控设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiCentralControlDevice = api.require('gizWifiCentralControlDevice');\ngizWifiCentralControlDevice.getSubDevices({\n        \"device\": {\n                \"mac\": 'your_device_mac',\n        \"did\": 'your_device_id'\n        }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\naddSubDevice\n添加子设备。\naddSubDevice({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：中控设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 中控设备mac地址，字符串类型\n      \"did\":         // 中控设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device:{       // 执行成功的中控设备对象，对象类型\n          \"mac\":    // 中控设备mac地址，字符串类型\n          \"did\":     // 中控设备did，字符串类型\n      }\n      subDevices:{    // 中控设备上报的子设备列表，对象数组类型\n          \"mac\":         // 中控设备mac，字符串类型\n          \"did\":        // 中控设备did，字符串类型\n          \"subDid\":                 // 子设备did，字符串类型\n          \"subProductKey\":        // 子设备类型标识，字符串类型\n          \"subProductName\":        // 子设备产品名称，字符串类型\n          \"type\":                    // 子设备类型，数字类型\n          \"netStatus\":            // 中控子设备是否在线（见枚举定义GizWifiDeviceNetStatus），数值类型\n          \"productKey\":            // 中控设备类型标识，字符串类型\n          \"productName\":            // 中控设备产品名称，字符串类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 执行失败的中控设备对象，对象类型\n          \"mac\":    // 中控设备mac地址，字符串类型\n          \"did\":     // 中控设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiCentralControlDevice = api.require('gizWifiCentralControlDevice');\ngizWifiCentralControlDevice.addSubDevice({\n        \"device\": {\n                \"mac\": 'your_device_mac',\n        \"did\": 'your_device_id'\n        }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ndeleteSubDevice\n删除子设备。\ndeleteSubDevice({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：中控设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":    // 中控设备mac地址，字符串类型\n      \"did\":     // 中控设备did，字符串类型\n  }\n\n\nsubDid: \n\n类型： JSON对象\n默认值：无\n描述：要删除的子设备did\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device:{       // 执行成功的中控设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":    // 中控设备mac地址，字符串类型\n          \"did\":     // 中控设备did，字符串类型\n      }\n      subDevices:{        // 中控设备上报的子设备列表，对象数组类型\n          \"mac\":                     // 中控设备mac，字符串类型\n          \"did\":                    // 中控设备did，字符串类型\n          \"subDid\":                 // 子设备did，字符串类型\n          \"subProductKey\":        // 子设备类型标识，字符串类型\n          \"subProductName\":        // 子设备产品名称，字符串类型\n          \"type\":                    // 子设备类型，数字类型\n          \"netStatus\":            // 中控子设备是否在线（见枚举定义GizWifiDeviceNetStatus），数值类型\n          \"productKey\":            // 中控设备类型标识，字符串类型\n          \"productName\":            // 中控设备产品名称，字符串类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 执行失败的中控设备对象，对象类型\n          \"mac\":    // 中控设备mac地址，字符串类型\n          \"did\":     // 中控设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiCentralControlDevice = api.require('gizWifiCentralControlDevice');\ngizWifiCentralControlDevice.deleteSubDevice({\n        \"device\": {\n                \"mac\": 'your_device_mac',\n                \"did\": 'your_device_mac'\n        },\n    \"subDid\": 'your_sub_device_mac'\n }, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngizWifiSubDevice类接口\n机智云 Wi-Fi 的子设备类。该类提供了子设备控制、子设备状态上报功能。子设备类继承自GizWifiDevice类，可以使用GizWifiDevice类的所有接口。\nregisterNotifications\n注册子设备状态变化通知。\nregisterNotifications({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要注册通知的子设备对象，设备对象信息可以在获取子设备列表时得到\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n      \"subDid\":     // 子设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device:{       // 注册成功的子设备对象，对象类型\n          \"mac\":        // 中控设备mac地址，字符串类型\n          \"did\":         // 中控设备did，字符串类型\n          \"subDid\":     // 子设备did，字符串类型\n      }\n      netStatus:        // 子设备是否在线（见GizWifiDeviceNetStatus），数值类型\n      \"data\": {                    // 设备状态，对象类型\n          \"attrName\":\"attrValue\",    // 数据点名称: 操作值。如果数据点是扩展类型，操作值需为base64编码字符串\n      }\n      \"alerts\": {                    // 报警，对象类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 报警内容\n      }\n      \"faults\": {                     // 故障，对象类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 故障内容\n      }\n      \"binary\":         // 二进制透传数据，base64编码字符串，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device: {   // 注册失败的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":      // 设备mac地址，字符串类型\n          \"did\":      // 设备did，字符串类型\n          \"subDid\":     // 子设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiSubDevice = api.require('gizWifiSubDevice');\ngizWifiSubDevice.registerNotifications({\n        \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac',\n        \"subDid\": 'your_subDevice_id'\n        }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetDeviceStatus\n获取设备状态。已订阅的设备变为可控状态后才能获取到状态，包括设备的运行状态、报警、故障、透传数据等。\ngetDeviceStatus({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要查询的设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n      \"subDid\":     // 子设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device:{       // 执行成功的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":      // 设备mac地址，字符串类型\n          \"did\":      // 设备did，字符串类型\n          \"subDid\":     // 子设备did，字符串类型\n      }\n      \"data\": {                    // 设备状态，对象类型\n          \"attrName\":\"attrValue\",    // 数据点名称: 操作值。如果数据点是扩展类型，操作值需为base64编码字符串\n      }\n      \"alerts\": {                    // 报警，对象类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 报警内容\n      }\n      \"faults\": {                     // 故障，对象类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 故障内容\n      }\n      \"binary\":     // 二进制透传数据，base64编码字符串，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 请求查询状态的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":      // 设备mac地址，字符串类型\n          \"did\":      // 设备did，字符串类型\n          \"subDid\":     // 子设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiSubDevice = api.require('gizWifiSubDevice');\ngizWifiSubDevice.getDeviceStatus({\n    \"device\": {\n        \"mac\": 'your_device_mac',\n        \"did\": 'your_device_id',\n        \"subDid\": 'your_subDevcie_id'\n    }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nwrite\n子设备控制。同普通设备控制一样。\nwrite({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要发送操作指令的设备对象，设备对象信息可以在获取设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n      \"subDid\":     // 子设备did，字符串类型\n  }\n\n\nsn: \n\n类型： JSON对象\n默认值：无\n描述：要发送的操作指令的指令序号，由App生成并维护\n\ndata: \n\n类型： JSON对象\n默认值：无\n描述：要发送的操作指令，格式与普通设备相同\n内部字段\n  {\n      \"data\": {        // 设备状态，字符串类型\n          \"attrName\":\"attrValue\",    // 数据点名称: 操作值。如果数据点是扩展类型，操作值需为base64编码字符串\n      }\n      \"alerts\": {                    // 报警，数组类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 报警内容\n      }\n      \"faults\": {                     // 故障，数组类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 故障内容\n      }\n      \"binary\":         // 二进制透传数据，base64编码字符串，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device: {       // 执行成功的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":        // 设备mac地址，字符串类型\n          \"did\":         // 设备did，字符串类型\n          \"subDid\":     // 子设备did，字符串类型\n      }\n      \"sn\":         // 命令序号，与App下发的序号对应，数字类型\n      \"data\": {                    // 设备状态，对象类型\n          \"attrName\":\"attrValue\",    // 数据点名称: 操作值。如果数据点是扩展类型，操作值需为base64编码字符串\n      }\n      \"alerts\": {                    // 报警，对象类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 报警内容\n      }\n      \"faults\": {                     // 故障，对象类型\n          \"attrName\": \"attrValue\"    // 数据点名称: 故障内容\n      }\n      \"binary\":     // 二进制透传数据，base64编码字符串，字符串类型\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device: {       // 执行失败的设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":        // 设备mac地址，字符串类型\n          \"did\":         // 设备did，字符串类型\n          \"subDid\":     // 子设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiSubDevice = api.require('gizWifiSubDevice');\ngizWifiSubDevice.write({\n    \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac',\n        \"subDid\": 'your_subDevice_id'\n        },\n    \"sn\": 5,\n    \"data\": {\n        \"LED_G\": 127,\n               \"LED_B\": 254,\n               \"LED_R\": 127,\n               \"LED_OnOff\": true,\n               \"Motor_Speed\": 2\n         }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetDeviceInfo\n获取子设备基本信息。\ngetDeviceInfo({params}, callback(ret, err))\nparams\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：子设备对象，设备mac和did可以在获取分组设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 中控设备mac地址，字符串类型\n      \"did\":         // 中控设备did，字符串类型\n      \"subDid\":     // 子设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      device: {       // 子设备对象（以下字段是子设备信息），对象类型\n          \"mac\":                    // 中控设备mac地址，字符串类型\n          \"did\":                     // 中控设备did，字符串类型\n          \"subDid\":                 // 子设备did，字符串类型\n          \"subProductKey\":        // 子设备类型标识，字符串类型\n          \"subProductName\":        // 子设备产品名称，字符串类型\n          \"type\":             // 子设备类型（见GizWifiDeviceType），数值类型\n          \"netStatus\":        // 子设备是否在线（见GizWifiDeviceNetStatus），数值类型\n          \"productKey\":            // 中控设备类型标识，字符串类型\n          \"productName\":            // 中控设备产品名称，字符串类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      device:{       // 设备对象（以下字段是设备对象信息），对象类型\n          \"mac\":        // 设备mac地址，字符串类型\n          \"did\":         // 设备did，字符串类型\n          \"subDid\":     // 子设备did，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiSubDevice = api.require('gizWifiSubDevice');\ngizWifiSubDevice.getDeviceInfo({\n    \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac',\n        \"subDid\": 'your_subDevice_id'\n    }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngizWifiGroup类接口\n机智云 Wi-Fi 的设备分组类。该类提供了中控子设备分组功能。\ngetDevices\n获取分组设备列表。\ngetDevices({params}, callback(ret, err))\nparams\ngroup: \n\n类型： JSON对象\n默认值：无\n描述：组对象，组对象信息可以在获取分组列表时得到。\n内部字段\n  {\n      \"gid\":        // 组ID，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      group: {       // 获取组设备成功的组对象，对象类型\n          \"gid\":     // 组ID，字符串类型\n      }\n      devices: [{       // 分组子设备列表，对象数组类型\n          \"mac\":         // 设备mac，字符串类型\n          \"did\":        // 设备did，字符串类型\n          \"subDid\":    // 子设备did，字符串类型\n      }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      group:{       // 获取组设备失败的组对象，对象类型\n          \"gid\":    // 组ID，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiGroup = api.require('gizWifiGroup');\ngizWifiGroup.getDevices({\n    \"group\": {\n               \"gid\": 'your_group_id'\n    }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\naddDevice\n向组中添加设备。添加后，返回添加后的设备列表。\naddDevice({params}, callback(ret, err))\nparams\ngroup: \n\n类型： JSON对象\n默认值：无\n描述：组对象，组对象信息可以在获取分组列表时得到。\n内部字段\n  {\n      \"gid\":        // 组ID，字符串类型\n  }\n\n\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要添加的设备对象，设备对象信息可以在获取分组设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 设备mac地址，字符串类型\n      \"did\":         // 设备did，字符串类型\n      \"subDid\":     // 子设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      group: {           // 添加组设备成功的组对象，对象类型\n          \"gid\":         // 组ID，字符串类型\n      }\n      devices: [{       // 分组子设备列表，对象数组类型\n          \"mac\":         // 设备mac，字符串类型\n          \"did\":        // 设备did，字符串类型\n          \"subDid\":    // 子设备did，字符串类型\n      }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      group: {       // 添加组设备失败的组对象，对象类型\n          \"gid\":    // 组ID，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiGroup = api.require('gizWifiGroup');\ngizWifiGroup.addDevice({\n        \"group\": {\n            \"gid\": 'your_group_id'\n        },\n       \"device\": {\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac',\n        \"subDid\": 'your_subDevice_id'\n       }\n}, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\nremoveDevice\n删除分组内的设备。删除后，返回删除后的设备列表。\nremoveDevice({params}, callback(ret, err))\nparams\ngroup: \n\n类型： JSON对象\n默认值：无\n描述：组对象，组对象信息可以在获取分组列表时得到。\n内部字段\n  {\n      \"gid\":        // 组ID，字符串类型\n  }\n\n\ndevice: \n\n类型： JSON对象\n默认值：无\n描述：要删除的设备对象，设备对象信息可以在获取分组设备列表时得到。\n内部字段\n  {\n      \"mac\":        // 中控设备mac地址，字符串类型\n      \"did\":         // 中控设备did，字符串类型\n      \"subDid\":     // 子设备did，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      group: {           // 删除组设备成功的组对象，对象类型\n          \"gid\":         // 组ID，字符串类型\n      }\n      devices: [{       // 分组子设备列表，对象数组类型\n          \"mac\":         // 设备mac，字符串类型\n          \"did\":        // 设备did，字符串类型\n          \"subDid\":    // 子设备did，字符串类型\n      }]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      group:{       // 删除组设备失败的组对象，对象类型\n          \"gid\":    // 组ID，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiGroup = api.require('gizWifiGroup');\ngizWifiGroup.removeDevice({\n        \"group\": {\n            \"gid\": 'your_group_id'\n        },\n        \"device\":{\n        \"did\": 'your_device_id',\n        \"mac\": 'your_device_mac',\n        \"subDid\": 'your_subDevice_id'\n        }\n }, function(ret, err) {\n        alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngetGroupInfo\n获取分组设备列表。\ngetGroupInfo({params}, callback(ret, err))\nparams\ngroup: \n\n类型： JSON对象\n默认值：无\n描述：组对象，组对象信息可以在获取分组列表时得到。\n内部字段\n  {\n      \"gid\":        // 组ID，字符串类型\n  }\n\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      group: {       // 组对象，对象类型\n          \"gid\":             // 组ID，字符串类型\n          \"groupName\":     // 组名称，字符串类型\n          \"productKey\":     // 组类型标识，字符串类型\n      }\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n      group:{       // 组对象，对象类型\n          \"gid\":    // 组ID，字符串类型\n      }\n  }\n\n\n示例代码\nvar gizWifiGroup = api.require('gizWifiGroup');\ngizWifiGroup.getGroupInfo({\n    \"group\": {\n            \"gid\": 'your_group_id'\n    }\n}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret) + \"err = \" + JSON.stringify(err))\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ngizWifiBinary类接口\n二进制数据base64编解码类。\nencode\nbase64编码函数。\nencode({params}, callback(ret, err))\nparams\nbinaryData: \n\n类型： JSON数组\n默认值：无\n描述：需要做base64编码的数据\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      binary:        // 经过base64编码之后的字符串，例如：AQIDBA==\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar GizWifiBinary = api.require(\"gizWifiBinary\");\n\n//数组编码字符串\nvar src = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18];\nGizWifiBinary.encode({\"binaryData\": src}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret));\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\ndecode\nbase64解码函数。\ndecode({params}, callback(ret, err))\nparams\nbinary: \n\n类型： 字符串\n默认值：无\n描述：需要做base64解码的字符串\n\ncallback(ret, err)\nret\n\n类型：JSON对象\n内部字段\n  {\n      binaryData:        // 经过base64解码之后的数值数组，例如：[1, 2, 3, 4]\n  }\n\n\nerr\n\n类型：JSON对象\n内部字段\n  {\n      errorCode:    // 错误代码（见枚举定义GizWifiErrorCode），数字类型\n      msg:        // 错误描述，字符串类型\n  }\n\n\n示例代码\nvar GizWifiBinary = api.require(\"gizWifiBinary\");\n\n//数组编码字符串\nvar src2 = \"AQIDBAUGBwgJCgsMDQ4PEBES\";\nGizWifiBinary.decode({\"binary\": src2}, function(ret, err) {\n    alert(\"ret = \" + JSON.stringify(ret));\n});\n可用性\niOS系统，Android系统\n可提供的1.0.0及更高版本\n"},{"title":"Android SDK 2.0集成指南","url":"/zh-cn/AppDev/AndroidSDKA2.html","content":"SDK_API参考手册\n附件：Android_SDK2.0_API参考手册\n设备接入SDK概述\n1.    SDK目的与功能\n机智云的设备接入SDK（以下简称SDK）封装了手机（包括PAD等设备）与机智云智能硬件的通讯过程，以及手机与云端的通讯过程。这些过程包括配置入网、发现、连接、控制、心跳、状态上报、报警通知等。使用SDK，可以使得开发者快速完成APP开发，开发者仅需关注APP的UI和UE设计即可，而相对复杂的协议与错误处理等事项可忽略。\n2.    机智云物联方案概况\n \n3.    找到最合适的SDK\n机智云目前提供3套SDK：iOS平台原生SDK、Android平台原生SDK、APICloud跨平台SDK。开发者可以根据项目需要自行选择，其中APICloud版本SDK可以用H5技术一次开发，同时适配iOS和Android两个平台，具体内容请参考：《APICloud SDK 集成指南》。\n4.    相关名词定义\n4.1.    GAgent\n全称Gizwits Agent，运行于Wi-Fi模块中，设备通过GAgent接入机智云服务器。 目前已兼容国内主流的Wi-Fi模块， 开发者也可以通过获取GAgent二次开发包实现自定义的模块接入机智云。\n4.2.    小循环\n智能设备与手机、智能设备与智能设备之间，通过连接同一个路由器实现局域网内部的通信（查看状态或控制），我们称之为小循环。\n4.3.    大循环\n智能设备通过路由器或直接接入互联网以实现用户的远程监测与控制，我们称为大循环。\n4.4.    ProductKey\n产品标识码，开发者通过机智云后台创建新产品后，自动生成的一个32位字符串。在机智云的数据库中是一个唯一的号码，开发者完成开发写入设备主控MCU后，机智云通过此标识码对设备进行识别并自动完成注册。\n4.5.    DID\n设备号，当一个设备初次接入机智云时，机智云自动根据ProductKey以及设备Wi-Fi模块MAC地址为此设备注册一个did，此did全网唯一，用于与用户的绑定及后续操作。\n4.6.    PassCode\n设备通行证，用于校验用户的绑定/控制权限。当用户发起设备绑定时，只要是合法操作即可拿到此通行证，通过此通行证绑定设备并对设备进行有效期内的查看、控制等操作。GAgent首次运行时生成随机数作为设备通行证，生成后保存在非易失性存储器上。设备上线时需要上报给服务器。\n4.7.    AppID\n应用标识码，当开发者需要为一款智能产品开发应用（包括iOS、Android、Web应用等）时，后台会自动生成一个AppID，并与此设备进行关联。应用开发时需要填入此AppID。\n4.8.    Onboarding\n也叫配置入网，用户将一款基于Wi-Fi的物联网设备配置连接上路由器的过程称为Onboarding。新设备第一次使用时需要知道路由器的账号和密码，以通过路由器连接互联网。由于大多数的物联网设备没有自带的屏幕和键盘，所以需要通过智能手机向设备发送路由器的SSID和密码，这个过程机智云称为Onboarding。机智云提供的Wi-Fi设备接入SDK中已经内置了此配置的功能。\n4.9.    AirLink\n机智云对各种SmartConfig、SmartLink这种UDP广播报方式对设备配置入网的技术统称，兼容了多个Wi-Fi模块厂商的配置协议，总结了一套良好用户体验的标准Onboarding操作流程，机智云的Wi-Fi 设备接入SDK已经内置AirLink技术。\n4.10.    SoftAP\n由于目前各个Wi-Fi模块厂商的Smart Config协议均未完全成熟，也不支持5G路由器信号。机智云在提供了AirLink配置模式的同时也支持SoftAP模式配置设备接入路由器。当设备进入SoftAP配置模式时，设备本身将成为一个AP，智能手机可直接与设备进行连接，然后在手机上的界面上输入路由器的SSID和密码，设备接收到信息的时候会自动尝试连接路由器，连接成功则自动切换到正常使用的模式。\n5.    集成准备\n5.1.    注册机智云账号\n在使用机智云服务前，你需要通过site.gizwits.com注册一个开发者账号。请完整填写你的注册信息。此部分请参考《快速入门》。\n5.2.    新建设备接入\n此部分请参考《快速入门》。\n5.3.    获得 app ID 和产品标识码（productkey）\n此部分请参考《快速入门》。\n5.4.    下载SDK\n \n5.5.    导入SDK\n第一步，双击解开压缩包 GizWifiSDK-Android-xxx.zip。\n第二步，将解压后的libs目录下所有内容拷贝到指定工程的libs目录，保证下图红框中的文件都加载到了工程中：\n \n5.6.    配置AndroidManifest.xml\n请将下面权限配置代码复制到 AndroidManifest.xml 文件中：\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" />\n<uses-permission android:name=\"android.permission.CHANGE_WIFI_MULTICAST_STATE\" />\n权限说明：\n\n\n\n权限\n用途\n\n\n\n\nACCESS_NETWORK_STATE\n允许程序访问有关GSM网络信息\n\n\nACCESS_WIFI_STATE\n允许程序访问WiFI网络状态信息\n\n\nREAD_PHONE_STATE\n允许程序访问手机状态信息\n\n\nACCESS_COARSE_LOCATION\n允许程序访问CellID或WiFi热点来获取粗略的位置\n\n\nACCESS_FINE_LOCATION\n允许程序访问精良位置（如GPRS）\n\n\nWRITE_EXTERNAL_STORAGE\n允许程序写入外部SD卡\n\n\nINTERNET\n允许程序打开网络接口\n\n\nCHANGE_WIFI_STATE\n允许程序改变WiFi连接状态\n\n\nCHANGE_WIFI_MULTICAST_STATE\n允许程序改变WiFi多播状态\n\n\n\n5.7.    Android6.0系统文件读写权限设置\nAndroid 6.0新增了运行时权限动态检测，GizWifiSDK中使用的以下权限需要在运行时判断：ACCESS_FINE_LOCATION，通过这个权限可以检测到手机当前wifi和可连接的wifi列表。\n下面以这个权限申请举例说明如何编写动态检测代码：\nAndroid6.0系统为targetSdkVersion小于23的应用默认授予了所申请的所有权限，所以如果App使用的targetSdkVersion低于23，可以正常运行。但如果用户在设置中取消了授予的权限，或者App使用的targetSdkVersion为23以上，需要在App代码中处理。以下以Android Studio举例：\n\n目标SDK版本\n\n在build.gradle中设置targetSdkVersion为23：\nandroid {\n    compileSdkVersion 23\n    buildToolsVersion \"23.0.1\"\n    defaultConfig {\n        applicationId \"com.yourcomany.app     \n        minSdkVersion 18     \n        targetSdkVersion 23     \n        versionCode 1     \n        versionName \"1.0\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\n检查并申请权限\n需要检查APP是否已经拥有ACCESS_FINE_LOCATION权限，没有则申请权限：\n\nif(ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {          \n    ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.ACCESS_FINE_LOCATION }, ACCESS_FINE_LOCATION_REQUEST_CODE);      \n}\n\n请求权限后，系统会弹出请求权限的对话框：\n\n\n\n用户选择允许后，会回调onRequestPermissionsResult方法, 该方法可类似如下处理：\n\nonActivityResult  \nOverride  \npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {      \n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);      \n    doNext(requestCode,grantResults);  \n}\n\n// 接着根据requestCode和grantResults(授权结果)做相应的后续处理：\nprivate void doNext(int requestCode, int[] grantResults) {\n    if (requestCode == ACCESS_FINE_LOCATION_REQUEST_CODE) {\n        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                      // Permission Granted          \n        } else {\n                      // Permission Denied\n        }\n    }\n}\nFragment中运行时权限的特殊处理\n\n在Fragment中申请权限，不要使用ActivityCompat.requestPermissions, 直接使用Fragment的requestPermissions方法，否则会回调到Activity onRequestPermissionsResult\n\n如果在Fragment中嵌套Fragment，在子Fragment中使用requestPermissions方 法，onRequestPermissionsResult不会回调回来，建议使用getParentFragment().requestPermissions方法。这个方法会回调到父Fragment中的onRequestPermissionsResult，在回调中加入以下代码可以把回调透传到子Fragment：\n\n\nOverride  \npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    List<Fragment> fragments = getChildFragmentManager().getFragments();      \n    if (fragments != null) {\n        for (Fragment fragment : fragments) {\n            if (fragment != null) {\n                fragment.onRequestPermissionsResult(requestCode,permissions,grantResults);    \n            }          \n          }      \n     }  \n}\n5.8.    如何在AndroidStudio上使用GizWifiSDK\n第一步、下载sdk 下载地址\n下载完成以后请自行解压。\n \n第二步、导入jar包到Android Studio\n \n第三步、把jar包导成库文件\n \n第四步、导入so文件\n请在main文件加下创建文件夹jniLibs,将armeabi粘贴到对应的文件夹下：\n \n第五步、导入完成以后查看对应的build.gradle\n下图中可以看到已经关联库成功：\n \n第六步、测试是否成功\n\n如果有下面图片中的log的话代表成功：\n \nSDK流程简介\n1.    通用流程图\n \n2.    关键点说明\n1)SDK已经封装了所有的用户、配置、发现、连接、控制的过程，开发者使用这些API可以完成上述流程中的功能开发，不需要再自行实现通讯协议。\n2)SDK采取回调的工作方式，所以必须设置必要的监听，比如通用监听和设备监听，具体请参见流程详解。SDK在主线程中给APP回调。\n3)SDK支持APP在Activity之间以及在Activity和Service之间传递对象。\n\n如果是在activity之间传递对象的话可以用intent来传递\n\n（传递）\nIntent intent = new Intent(Context, A.class);\n    Bundle bundle = new Bundle();\n    bundle.putParcelable(“参数名”, 设备类对象);\n    intent.putExtras(bundle);\n    startActivity(intent);\n（接收）\nIntent intent = getIntent();\n    intent.getParcelableExtra(\"参数名\");\n\n在activity和service之间传递对象\n可以通过广播来传递数据，由一方发送数据另一方接收。\n\n（注册广播）\nIntentFilter filter = new IntentFilter();//创建IntentFilter对象\n    //注册一个广播，用于接收Activity传送过来的命令，控制Service的行为，如：发送数据，停止服务等\n    filter.addAction(\"AAAAAAA\");\n    //注册Broadcast Receiver\n    registerReceiver(cmdReceiver, filter);  \n（发送广播）\nIntent intent = new Intent();  \n    intent.setAction(\"AAAAAAA\");  \n    Bundle bundle = new Bundle();\n    bundle.putParcelable(“参数名”,  设备类对象);\n    intent.putExtras(bundle);\n    sendOrderedBroadcast(intent, null);\n\n另外一种，是在Activity中通过bindService获取到Service对象，直接调用Service方法获取想要的设备对象3.    混淆打包配置\n\n\n如果您的项目使用了Proguard混淆打包，为了避免SDK被二次混淆导致无法正常使用SDK，请务必在 proguard-project.txt中添加以下代码：\n-libraryjars libs/GizWifiSDK.jar\n-dontwarn com.gizwits.**\n-keep class com.gizwits.**{\n    *;\n}\n并在project.properties中指向Android混淆文件：\nproguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt\nSDK流程详解\n1.    初始化部分\n1.1.    初始化部分流程图\n\n1.2.    注册SDK通用监听器\n注册SDK通用监听器是为了能让APP收到来自GizWifiSDK类的响应事件，包含了注册、登录、配置设备、绑定设备等回调接口。该监听器是SDK使用中十分重要的一个监听器，与GizWifiSDK类相关的操作都会在这里会回调。如果没有正确注册通用监听器，将无法正常使用SDK。注册监听时，APP可以根据自己的需求实现回调接口。建议两种设置方式：\n1)在每一个使用到的Activity中都实例化一次监听器并注册一次，且只实现需要的回调接口。该种方式比较灵活，可在service中使用。但要注意必须每次打开activity都监听一次， 且无法多个Activity同时收到回调。\n【示例代码】\n// 实例化监听器\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n\n    // 实现手机号注册用户回调\nOverride\npublic void didRegisterUser(GizWifiErrorCode result, String uid, String token){\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 注册成功，处理注册成功的逻辑\n} else {\n// 注册失败，处理注册失败的逻辑\n}\n}\n};\n\npublic void onCreate() {\nsuper.onCreate();\n\n// 注册监听器\nGizWifiSDK.sharedInstance().setListener(mListener);\n// 调用SDK的手机号注册接口\nGizWifiSDK.sharedInstance().registerUser(\"HelloGizwits\", \"12345678\");\n}\n2)在一个基类中实例化一次监听器，并把回调抛出，子类继承基类，这就不需要每个子类都实例化一次监听器。该种方式通过继承的方式，可以多个Activity都收到回调。但该种方式无法在Service中使用。如无特别说明，文档中的范例都是使用该方法注册监听器。\n【示例代码】\n// 创建基类，在基类中实例化和注册监听器\npublic class BaseActivity extends Activity {\nprivate GizWifiSDKListener mListener = new GizWifiSDKListener() {\nOverride\npublic void didRegisterUser(GizWifiErrorCode result, String uid, String token) {\nBaseActivity.this.didRegisterUser(result, uid, token);\n}\n};\n\npublic void didRegisterUser(GizWifiErrorCode result, String uid, String token)\n{\n// 实现逻辑\n}\n\nOverride\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\n\n//每次启动activity都要注册一次sdk监听器，保证sdk状态能正确回调\nGizWifiSDK.sharedInstance().setListener(mListener);\n}\n}\n\n//子类继承基类，实现基类的回调接口。\npublic class TestActivity extends BaseActivity {\n    protected void onCreate(android.os.Bundle savedInstanceState) {\n        //调用父类方法\n        super.onCreate(savedInstanceState);\n        //调用用户注册方法\nGizWifiSDK.sharedInstance().registerUser (\"your_phone_number\", \"your_ password\", “your_verify_code”, GizUserAccountType.GizUserPhone);\n}\n\n@Override\npublic void didRegisterUser(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 注册成功\n} else {\n// 注册失败\n}\n}\n}\n1.3    初始化 sdk\nSDK启动前，任何功能都是无法正常使用的。SDK启动时，会进行SDK初始化，并自动发现当前局域网设备。SDK将通过通用监听，上报已发现的设备以及相应的事件。APP可以先设置SDK的通用监听，再启动SDK，以便处理这些事件通知。\nSDK启动时需要指定应用程序的AppID，开发者需要先在机智云网站上为自己的APP申请一个AppID，请在应用的Application或者第一个启动的Activity的onCreate中调用该方法指定应用的APPID。该方法只需要调用一次。\nSDK的日志可以帮助开发者发现APP运行时发生的问题，SDK默认将所有日志信息输出到调试终端和日志文件中。如果手机有SD卡，则日志文件会保存在SD卡上，如果没有SD卡，就只保存在应用程序路径下。SD卡上的日志文件目录为手机SD卡路径下的GizWifiSDK/app_package_name/GizSDKLog。APP如果不希望在调试终端输出日志，可以通过日志级别设置接口，把日志输出级别修改为GizLogPrintNone。\n【示例代码】\npublic void onCreate() {\nsuper.onCreate();\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().startWithAppID(getApplicationContext(), \"your_app_id\");\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didNotifyEvent(GizEventType eventType, Object eventSource, GizWifiErrorCode eventID, String eventMessage) {\nif (eventType == GizEventType.GizEventSDK) {\n// SDK的事件通知\n                Log.i(\"GizWifiSDK\", \"SDK event happened: \" + eventID + \", \" + eventMessage);\n} else if (eventType == GizEventType.GizEventDevice) {\n                // 设备连接断开时可能产生的通知\n                GizWifiDevice mDevice = (GizWifiDevice)eventSource;\n                Log.i(\"GizWifiSDK\", \"device mac: \" + mDevice.getMacAddress() + \" disconnect caused by eventID: \" + eventID + \", eventMessage: \" + eventMessage);\n} else if (eventType == GizEventType.GizEventM2MService) {\n                // M2M服务返回的异常通知\n                Log.i(\"GizWifiSDK\", \"M2M domain \" + (String)eventSource + \" exception happened, eventID: \" + eventID + \", eventMessage: \" + eventMessage);\n} else if (eventType == GizEventType.GizEventToken) {\n                // token失效通知\n                Log.i(\"GizWifiSDK\", \"token \" + (String)eventSource + \" expired: \" + eventMessage);\n}\n}\n};\n2.    用户部分\n机智云的用户系统包含了用户的注册、登录、重置密码、修改个人信息等功能，机智云以APPID区分用户系统，不同APPID的用户系统相互独立。更换APPID后，需要重新注册用户。\n以下流程中涉及到的监听器注册方法是用子类继承基类的方式实现的。\n2.1.    用户部分主要流程图\n \n用户的注册方式有多种，比如手机号、普通用户名、邮箱等，APP可以根据需要采取不同的方式。其他流程比如登录、密码修改、个人信息修改等部分，请直接阅读下面的流程文档。\n2.2.    用户注册\n机智云提供三种用户注册方式：手机注册、普通用户注册、邮箱注册。\n2.2.1.    注册手机用户\n通过手机注册账号，需要一个有效的手机号。注册时需要两步操作：获取短信验证码、用短信验证码注册用户。\n第一步：APP获取短信验证码时，SDK向云端发送短信验证码请求，如果请求成功，云端会给手机发送短信验证码。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().requestSendPhoneSMSCode (\"your_app_secret\", \"your_phone_number\");\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRequestSendPhoneSMSCode(GizWifiErrorCode result, String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 请求成功\n} else {\n// 请求失败\n}\n}\n}\n第二步：用短信验证码注册时，APP把手机收到的短信验证码传给SDK，填上手机号和密码就可以注册了。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().registerUser(\"your_phone_number\", \"your_password\", \"your_verify_code\", GizUserAccountType.GizUserPhone);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRegisterUser(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 注册成功\n} else {\n// 注册失败\n}\n}\n}\n2.2.2.    注册普通用户\n注册普通用户，使用用户名、密码即可创建一个账号。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().registerUser(\"your_user_name\", \"your_password\", null, GizUserAccountType.GizUserNormal);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRegisterUser(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 注册成功\n} else {\n// 注册失败\n}\n}\n}\n2.2.3.    注册邮箱用户\n通过有效的电子邮箱地址，注册一个账号。注册成功后，云端会给指定邮箱发送注册成功的邮件。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().registerUser(\"your_email_address\", \"your_password\", null, GizUserAccountType.GizUserEmail);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRegisterUser(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 注册成功\n} else {\n// 注册失败\n}\n}\n}\n2.3.    用户登录\n机智云提供三种用户登录方式：实名登录、匿名登录、第三方账号登录。实名登录适用于设计了登录界面，必须使用用户名密码注册登录以后才能使用的APP。匿名登录适用于没有设计登录界面，由后台自动生成用户账号的APP。登录后获取到的token有效期为7天。\n2.3.1.    实名登录\n实名用户登录时，用户名可以是注册过的手机号、邮箱、普通用户名。登录账号要先注册好，如果更换了AppID，登录账号需要重新注册。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().userLogin(\"your_user_name\", \"your_password\");\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didUserLogin(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 登录成功\n} else {\n// 登录失败\n}\n}\n}\n2.3.2.    匿名登录\n用户每次匿名登录时，获取到的uid是相同的。Android SDK使用Android ID生成登录账号。每个Android系统都有一个独立的Android ID，系统刷机后将改变。因此，系统刷机后匿名登录的用户信息将无法保留。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().userLoginAnonymous();\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didUserLogin(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 登录成功\n} else {\n// 登录失败\n}\n}\n}\n2.3.3.    第三方账号登录\n目前支持的第三方账号有百度、新浪、腾讯。用户可以使用这三者的API获取到uid和token登录机智云，使用第三方账号登录时无需在机智云上注册，可直接登录。\n开发者可通过新浪、百度或腾讯api获取uid和token, 具体方法请参考各第三方平台的开发者文档。\n【示例代码】\n// 以新浪账号为例\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().loginWithThirdAccount(GizThirdAccountType.GizThirdSINA, \"your_third_uid\", \"your_third_token\");\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didUserLogin(GizWifiErrorCode result, String uid,  String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 登录成功\n} else {\n// 登录失败\n}\n}\n}\n2.4.    重置密码\n如果忘记了用户密码，可以通过手机验证码或邮箱设置新的密码。SDK支持手机号重置密码和邮箱重置密码两种，手机号重置需要接收验证码，邮箱重置需要进⼊邮箱，根据链接提示进行重置。\n2.4.1.    手机号重置密码\n手机号重置密码时，需要先获取短信验证码再重置。获取短信验证码方式与手机注册时相同。\n第一步：获取短信验证码\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().requestSendPhoneSMSCode(\"your_app_secret\", \"your_phone_number\");\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didRequestSendPhoneSMSCode(GizWifiErrorCode result, String token) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 请求成功\n} else {\n// 请求失败\n}\n}\n}\n第二步：用短信验证码重置密码\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().resetPassword(\"your_phone_number\", \"your_verify_code\", \"your_new_password\", GizUserAccountType.GizUserPhone);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 修改成功\n} else {\n// 修改失败\n}\n}\n}\n2.4.2.    邮箱重置密码\n邮箱重置密码时，云端会给指定邮箱发送安全链接。用户需要到邮箱中查收邮件，并按邮件指示执行重置操作。重置密码邮件有可能进入用户的邮箱的垃圾箱中，需提醒用户。\n邮件发送成功回调与密码修改成功回调一致，因此需要注意在回调的时候区分。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().resetPassword(\"your_email_address\", null, \"your_new_password\", GizUserAccountType.GizUserEmail);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n                //重置密码邮件发送成功，提示用户查收\n} else {\n                //重置密码邮件发送失败，弹出错误信息\n}\n}\n}\n2.5.    修改密码\n用户登录后可以修改密码。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().changeUserPassword(\"your_token\", \"your_old_password\", \"your_new_password\");\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 修改成功\n} else {\n// 修改失败\n}\n}\n}\n2.6.    匿名用户转换\n匿名注册的用户可以转换为普通用户或者手机用户，转换后匿名用户的信息会转移到实名用户下，原匿名账号失效。但普通用户和手机用户必须是还未注册过的，已注册的用户名是无法转换的。\n2.6.1.    匿名用户转普通用户\n转普通用户时，填入待转换的用户名、密码，以及登录的token就可以了。\n【示例代码】\n// 匿名转普通用户\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().transAnonymousUser(\"your_token\", \"your_user_name\", \"your_password\", null, GizUserAccountType.GizUserNormal);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didTransAnonymousUser(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 转换成功\n} else {\n// 转换失败\n}\n}\n}\n2.6.2.    匿名用户转手机用户\n转手机用户时，需要填入待转换的手机号、密码、短信验证码，登录的token。获取短信验证码的过程与手机注册时一样。\n【示例代码】\n// 匿名转手机用户\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().transAnonymousUser(\"your_token\", \"your_phone_number\", \"your_password\", \"your_verify_code\", GizUserAccountType. GizUserPhone);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didTransAnonymousUser(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 转换成功\n} else {\n// 转换失败\n}\n}\n}\n2.7.    修改用户信息\n实名用户不支持修改普通用户名，可以修改邮箱、手机号，可以补充个人信息。实名用户必须登录后才能修改这些信息，并且待修改的邮箱或手机号必须是已经注册过的。\n实名用户修改邮箱或手机号成功后，可以使用修改后的邮箱或手机号登录。登录后获得的绑定设备列表与原实名用户一致。\n修改邮箱或手机号时，可以同时补充个人信息。不想修改个人信息时，对应参数可以传null。同时修改个人信息时，如果邮箱或用户名修改成功而个人信息修改失败，回调会返回成功并在errorMessage中提示个人信息修改失败的原因。\n2.7.1.    修改用户邮箱\n只修改用户邮箱时，个人信息的参数传null，用户类型可以指定为邮箱用户。以下为修改用户邮箱的示例代码。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", \"your_email_address\", null, GizUserAccountType.GizUserEmail, null);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 修改成功\n} else {\n// 修改失败\n}\n}\n}\n2.7.2.    修改用户手机号\n只修改用户手机号时，个人信息参数传null，用户类型可以指定为手机用户。修改手机号之前，需要先获取手机验证码。以下示例代码为修改用户手机号的代码，获取短信验证码的代码请参考手机号注册。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", \"your_phone_number\", \"your_verify_code\", GizUserAccountType.GizUserPhone, null);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 修改成功\n} else {\n// 修改失败\n}\n}\n}\n2.7.3.    修改用户个人信息\n只修改用户个人信息时，手机号或邮箱参数传null，用户类型可以指定为普通用户。个人信息包含多项内容，通过GizUserInfo类指定。其中不想修改的信息填null，云端会保留上次修改过的值。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\n\nGizUserInfo additionalInfo = new GizUserInfo();\nadditionalInfo.setName(\"nickname\");\nadditionalInfo.setGender(GizUserGenderType.Male);\nadditionalInfo.setBirthday(\"1990-1-1\");\nadditionalInfo.setAddress(\"Beijing\");\nadditionalInfo.setRemark(\"home\");\n\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", null, null, GizUserAccountType.GizUserNormal, additionalInfo);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 修改成功\n} else {\n// 修改失败\n}\n}\n}\n2.7.4.    同时修改邮箱和个人信息\n修改邮箱同时修改个人信息时，用户类型需指定为邮箱用户。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\n\nGizUserInfo additionalInfo = new GizUserInfo();\nadditionalInfo.setName(\"nickname\");\nadditionalInfo.setGender(GizUserGenderType.Male);\nadditionalInfo.setBirthday(\"1990-1-1\");\nadditionalInfo.setAddress(\"Beijing\");\nadditionalInfo.setRemark(\"home\");\n\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", \"your_email_address\", null, GizUserAccountType.GizUserEmail, additionalInfo);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 修改成功\n} else {\n// 修改失败\n}\n}\n}\n2.7.5.    同时修改手机号和个人信息\n修改手机号同时修改个人信息时，用户类型需指定为手机用户。修改手机号同样需要先获取手机验证码，获取短信验证码的代码请参考手机号注册。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\n\nGizUserInfo additionalInfo = new GizUserInfo();\nadditionalInfo.setName(\"nickname\");\nadditionalInfo.setGender(GizUserGenderType.Male);\nadditionalInfo.setBirthday(\"1990-1-1\");\nadditionalInfo.setAddress(\"Beijing\");\nadditionalInfo.setRemark(\"home\");\n\nGizWifiSDK.sharedInstance().changeUserInfo(\"your_token\", \"your_phone_number\", \"your_verify_code\", GizUserAccountType.GizUserPhone, additionalInfo);\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didChangeUserPassword(GizWifiErrorCode result) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 修改成功\n} else {\n// 修改失败\n}\n}\n}\n3.    配置设备入网部分\n控制设备前，需要先让设备连到路由器上。连上路由器的设备，如果路由器能接入外网，设备会自动注册到机智云。\n有两种配置方式能够让设备连到路由器上，一种是Airlink方式，一种是Softap方式，APP可以根据产品需求采取相应的配置方式。在开始配置前，设备要先进入配置模式，然后APP调用配置接口发送要配置的路由器ssid和密码。设备配置成功后，SDK给APP返回已配置成功的设备mac地址和产品类型标识，便于APP做下一步的操作。如果设备是重置后进入的配置模式，如果配置成功时设备还来不及从云端获取到DID，则APP得到的DID为空。\nSDK的设备配置接口如果超时时间还未结束，无法进行下一次配置。此外，因为设备配置成功的广播包只有APP连到同一路由上才能收取，因此这个超时时间应该预留出APP连接路由器的时间。\n需要注意的是，如果配置上线的设备不是APP要获取的产品类型，该设备就不会出现在设备列表中。\n3.1.    设备配置流程图\n \n3.2.    AirLink配置\nAirLink使用UDP广播方式，由手机端发出含有目标路由器名称和密码的广播，设备上的Wifi模块接收到广播包后自动连接目标路由器，连上路由器后发出配置成功广播，通知手机配置已完成。\n模块开启AirLink模式后，如果一分钟内未收到AirLink广播或无法正确连上路由器，将进入SoftAP模式。\n【示例代码】\n// 让手机连上目标Wifi\n// MCU发出开启AirLink串口指令，通知模组开启AirLink模式。\n详情请参考《智能云空调-机智云接入串口通信协议文档》\n\n//配置设备入网，发送要配置的wifi名称、密码\nGizWifiSDK.sharedInstance().setListener(mListener);\nList<GizWifiGAgentType> types = new ArrayList<GizWifiGAgentType> ();\ntypes.add(GizWifiGAgentType.GizGAgentESP); \n// 此代码示例使用最新的配网接口（乐鑫或汉枫固件要求04020027以上，其他模组类型不要求最低版本号）\nGizWifiSDK.sharedInstance().setDeviceOnboardingDeploy(\"your_ssid\", \"your_key\", GizWifiConfigureMode.GizWifiAirLink, null, 60, types, false);\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n//等待配置完成或超时，回调配置完成接口\n@Override\npublic  void didSetDeviceOnboarding (GizWifiErrorCode result, String mac, String did, String productKey) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 配置成功\n        } else if (result == GIZ_SDK_DEVICE_CONFIG_IS_RUNNING) {\n        // 正在配置\n} else {\n            // 配置失败\n}\n}\n};\n3.3.    SoftAP配置\n设备进入SoftAP模式后，会产生一个Wifi热点。手机连上此热点后，将要配置的SSID和密码发给设备。设备上的Wi-Fi模块接收到SoftAP配置包后自动连接目标路由器，与airlink一样，连上路由器后发出配置成功广播，通知手机配置已完成。\n使用机智云提供的模组固件，设备产生的Wifi热点以“XPG-GAgent-”开头，密码为” 123456789”。其他厂商提供的模组，SoftAP热点名称由各自厂商指定。APP可以根据需要传入正确的热点前缀。\n【示例代码】\n// MCU发出进入SoftAP串口指令，通知模组开启SoftAP模式。\n详情请参考《智能云空调-机智云接入串口通信协议文档》\n//让手机连接模组的SoftAP热点\n\n//配置设备入网，发送要配置的wifi名称、密码\nGizWifiSDK.sharedInstance().setListener(mListener);\n// 此代码示例使用最新的配网接口（乐鑫或汉枫固件要求04020027以上，其他模组类型不要求最低版本号）\nGizWifiSDK.sharedInstance().setDeviceOnboardingDeploy(\"your_ssid\", \"your_key\", GizWifiConfigureMode.GizWifiSoftAP, \"your_gagent_hotspot_prefix\", 60, null, false);\n\n//模块收到配置信息，尝试连接路由器并自动关闭热点\n//让手机连接到配置的wifi上\n\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n//等待配置完成或超时，回调配置完成接口\n@Override\npublic  void didSetDeviceOnboarding (GizWifiErrorCode result, String mac, String did, String productKey) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 配置成功\n} else {\n            // 配置失败\n}\n}\n};\n4.    设备发现和订阅部分\n4.1.    设备发现和订阅流程图\n \n4.2.    设备发现\nAPP设置好监听，启动SDK后，就可以收到SDK的设备列表推送。每次局域网设备或者用户绑定设备发生变化时，SDK都会主动上报最新的设备列表。设备断电再上电、有新设备上线等都会触发设备列表发生变化。用户登录后，SDK会主动把用户已绑定的设备列表上报给APP，绑定设备在不同的手机上登录帐号都可获取到。\n如果APP想要刷新绑定设备列表，可以调用绑定设备列表接口，同时可以指定自己关心的产品类型标识，SDK会把筛选后的设备列表返回给APP。\nSDK提供设备列表缓存，设备列表中的设备对象在整个APP生命周期中一直有效。缓存的设备列表会与当前最新的已发现设备同步更新。\n【示例代码】\n// 使用缓存的设备列表刷新UI\nList<GizWifiDevice> devices = GizWifiSDK.sharedInstance().getDeviceList();\n\n// 接收设备列表变化上报，刷新UI\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic  void didDiscovered(GizWifiErrorCode result, List<GizWifiDevice> deviceList) {\n        // 提示错误原因\n        if(result != GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            Log.d(\"\", \"result: \" + result.name());\n        }\n        // 显示变化后的设备列表\n        Log.d(\"\", \"discovered deviceList: \" + deviceList);\ndevices = deviceList;\n}\n};\n\n// 主动刷新绑定设备列表、指定筛选的设备productKey\nList<String> pks = new ArrayList<String> ();\npks.add(\"your_productKey\");\nGizWifiSDK.sharedInstance().getBoundDevices(\"your_uid\", \"your_token\", pks);\n4.3.    设置设备的监听器\n在设备列表中得到设备对象，为其设置设备监听器，以便于刷新设备UI。APP根据自己的需要实现相应的回调。\n4.4.    设备订阅和绑定\nAPP得到设备列表后，给设备设置监听后，可以订阅设备。已订阅的设备将被自动绑定和自动登录，设备登录成功后会主动上报最新状态。\n自动绑定仅限于局域网设备。对于无法在局域网内发现的设备，APP可以通过手动绑定的方式完成绑定。绑定成功的设备，需要订阅后才能使用。\n无论是手动绑定还是自动绑定，设备的remark和alias信息，都需要在设备绑定成功后再设置。\n解除订阅的设备，连接会被断开，不能再继续下发控制指令了。\n4.4.1.    设备订阅\n所有通过SDK得到的设备，都可以订阅，订阅结果通过回调返回。订阅成功的设备，要在其网络状态变为可控时才能查询状态和下发控制指令。\n【示例代码】\n// 以设备列表中的第一个设备实例为例，为其设置监听\nGizWifiDevice mDevice = null;\nfor (int i = 0; i < deviceList.size(); i++) {\n    mDevice = deviceList[0];\nmDevice.setListener(mListener);\nmDevice.setSubscribe(true);\nbreak;\n}\n\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic  void didSetSubscribe(GizWifiErrorCode result, GizWifiDevice device, boolean isSubscribed) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 订阅或解除订阅成功\n} else {\n// 失败\n}\n}\n};\n4.4.2.    非局域网设备绑定（Wifi设备不需要远程绑定）\nAPP可以通过设备的mac、productKey、productSecret完成非局域网设备的绑定,可以用上述信息生成二维码，APP通过扫码方式绑定。GPRS设备、蓝牙设备等都是无法通过Wifi局域网发现的设备，都属于非局域网设备。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().bindRemoteDevice (\"your_uid\", \"your_token\", \"your_device_mac\", \"your_device_product_key\", \"your_product_secret\");\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didBindDevice(GizWifiErrorCode result, String did) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 绑定成功\n} else {\n            // 绑定失败\n}\n}\n};\n4.4.3.    设置设备的绑定信息\n不订阅设备也可以设置设备的绑定信息。在设备列表中找到要修改的设备，如果是已绑定的，可以修改remark和alias信息。\n【示例代码】\n// mDevice是从设备列表中获取到的设备实体对象，设置监听\nmDevice.setCustomInfo(\"your_remark\", \"your_alias\");\n\n// 实现回调\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic void didSetCustomInfo(GizWifiErrorCode result, GizWifiDevice device) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n// 修改成功\n} else {\n// 修改失败\n}\n}\n};\n4.5.    设备解绑\n已绑定的设备可以解绑，解绑需要APP调用接口完成操作，SDK不支持自动解绑。对于已订阅的设备，解绑成功时会被解除订阅，同时断开设备连接，设备状态也不会再主动上报了。设备解绑后，APP刷新绑定设备列表时就得不到该设备了。\n【示例代码】\nGizWifiSDK.sharedInstance().setListener(mListener);\nGizWifiSDK.sharedInstance().unbindDevice(\"your_uid\", \"your_token\", \"your_device_did\");\n\n// 实现回调\nGizWifiSDKListener mListener = new GizWifiSDKListener() {\n@Override\npublic void didUnbindDevice(GizWifiErrorCode result, String did) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 解绑成功\n} else {\n            // 解绑失败\n}\n}\n};\n4.6.    获取设备硬件信息\n不订阅设备也可以获取到硬件信息。APP可以获取模块协议版本号，mcu固件版本号等硬件信息，但是只能在小循环下才能获取。\n【示例代码】\n// mDevice是从设备列表中获取到的设备实体对象，设置监听\nmDevice.setListener(mListener);\nmDevice.getHardwareInfo();\n\n// 实现回调\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic  void didGetHardwareInfo(GizWifiErrorCode result, GizWifiDevice device, ConcurrentHashMap<String, String> hardwareInfo) {\nStringBuilder sb = new StringBuilder();\nif(result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\nsb.append(\"Wifi Hardware Version:\" + hardwareInfo.get(\"wifiHardVersion\")\n                        + \"\\r\\n\");\nsb.append(\"Wifi Software Version:\" + hardwareInfo.get(\"wifiSoftVersion\")\n                        + \"\\r\\n\");\nsb.append(\"MCU Hardware Version:\" + hardwareInfo.get(\"mcuHardVersion\")\n                        + \"\\r\\n\");\nsb.append(\"MCU Software Version:\" + hardwareInfo.get(\"mcuSoftVersion\")\n                        + \"\\r\\n\");\nsb.append(\"Firmware Id:\" + hardwareInfo.get(\"wifiFirmwareId\") + \"\\r\\n\");\nsb.append(\"Firmware Version:\" + hardwareInfo.get(\"wifiFirmwareVer\")\n                        + \"\\r\\n\");\nsb.append(\"Product Key:\" + hardwareInfo.get(\"productKey\") + \"\\r\\n\");\nsb.append(\"Device ID:\" + device.getDid() + \"\\r\\n\");\nsb.append(\"Device IP:\" + device.getIPAddress() + \"\\r\\n\");\nsb.append(\"Device MAC:\" + device.getMacAddress() + \"\\r\\n\");\n\n}else{\nsb.append(\"获取失败，错误号：\" + result);\n}\n\nMessage msg = new Message();\nmsg.what = HARDWARE;\nmsg.obj = sb.toString();\nhandler.sendMessage(msg);\n}\n};\n5.    设备控制部分\nSDK通过字典键值对方式进行设备控制和状态接收。SDK接收到APP下发的指令字后，对应解析为设备可识别的数据，发送给设备。反之，SDK收到设备回复或上报的数据后，对应解析为字典键值对上报给APP。\n智能设备需正确烧写了GAgent固件和机智云串口通讯协议。如果设备定义了数据点，APP发送的指令必须符合数据点定义。如果设备没有定义数据点，设备指令可以按照透传数据以自定义格式下发。\n5.1.    设备控制流程图\n \n5.2.    发送控制指令\n设备订阅变成可控状态后，APP可以发送操作指令。操作指令是字典格式，键值对为数据点名称和值。操作指令的确认回复，通过didReceiveData回调返回。\nAPP下发操作指令时可以指定sn，通过回调参数中的sn能够对应到下发指令是否发送成功了。但回调参数dataMap有可能是空字典，这取决于设备回复时是否携带当前数据点的状态。\n如果APP下发指令后只关心是否有设备状态上报，那么下发指令的sn可填0，这时回调参数sn也为0。\n【示例代码】\n// mDevice是从设备列表中获取到的设备实体对象，设置监听\nmDevice.setListener(mListener);\n\n// 订阅设备并变为可控状态后，执行开灯动作\nint sn = 5;\nConcurrentHashMap<String, Object> command = new ConcurrentHashMap<String, Object> ();\ncommand.put(\"LED_OnOff\", true);\nmDevice.write(command, sn);\n\n// 实现回调\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic  void didReceiveData(GizWifiErrorCode result, GizWifiDevice device, ConcurrentHashMap<String, Object> dataMap, int sn) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\nif (sn == 5) {\n            // 命令序号相符，开灯指令执行成功\n} else {\n        // 其他命令的ack或者数据上报\n}\n} else {\n// 操作失败\n}\n}\n};\n5.3.    接收设备状态\n设备订阅变成可控状态后，APP可以随时收到设备状态的主动上报，仍然通过didReceiveData回调返回。设备上报状态时，回调参数sn为0，回调参数dataMap为设备上报的状态。\n【示例代码】\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n@Override\npublic void didReceiveData(GizWifiErrorCode result, GizWifiDevice device, ConcurrentHashMap<String, Object> dataMap, int sn) {\nif (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n\n    // 已定义的设备数据点，有布尔、数值和枚举型数据\n    if (dataMap.get(\"data\") != null) {\n    ConcurrentHashMap<String, Object> map = (ConcurrentHashMap<String, Object>) dataMap.get(\"data\");\n\n        // 普通数据点，打印对应的key和value\n        StringBuilder sb = new StringBuilder();\n        for (String key : map.keySet()) {\n            sb.append(key + \"  :\" + map.get(key) + \"\\r\\n\");\n            Toast.makeText(DeviceControlActivity.this,\n                    sb.toString(), Toast.LENGTH_SHORT).show();\n        }\n\n        // 扩展数据点，key如果是“BBBB”\n        byte[] bytes = (byte[]) map.get(\"BBBB\");\n        String string = Arrays.toString(bytes);\n        Toast.makeText(DeviceControlActivity.this,\n                string, Toast.LENGTH_SHORT).show();\n    }\n\n        // 已定义的设备故障数据点，设备发生故障后该字段有内容，没有发生故障则没内容\n    if (dataMap.get(\"faults\") != null) {\n    ConcurrentHashMap<String, Object> map =  (ConcurrentHashMap<String, Object>)dataMap.get(\"faults\");\n        StringBuilder sb = new StringBuilder();\n\n        for (String key : map.keySet()) {\n            sb.append(key + \"  :\" +  map.get(key) + \"\\r\\n\");\n            Toast.makeText(DeviceControlActivity.this,\n                    sb.toString(), Toast.LENGTH_SHORT).show();\n        }\n    }\n\n        // 已定义的设备报警数据点，设备发生报警后该字段有内容，没有发生报警则没内容\n    if (dataMap.get(\"alerts\") != null) {\n    ConcurrentHashMap<String, Object> map =  (ConcurrentHashMap<String, Object>)dataMap.get(\"alerts\");\n        StringBuilder sb = new StringBuilder();\n\n        for (String key : map.keySet()) {\n                    sb.append(key + \"  :\" +  map.get(key) + \"\\r\\n\");\n                    Toast.makeText(DeviceControlActivity.this,\n                    sb.toString(), Toast.LENGTH_SHORT).show();\n        }\n    }\n\n        // 透传数据，无数据点定义，适合开发者自行定义协议自行解析\n    if (dataMap.get(\"binary\") != null) {\n        byte[] binary = (byte[]) dataMap.get(\"binary\");\n        Log.i(\"\", \"Binary data:\"\n                + bytesToHex(binary, 0, binary.length));\n    }\n    }\n}\n};\n5.4.    设备状态查询\n设备订阅变成可控状态后，APP可以查询设备状态。设备状态查询结果也通过didReceiveData回调返回，回调参数sn为0。回调参数dataMap为设备回复的状态。\n【示例代码】\n// mDevice是从设备列表中获取到的设备实体对象，设置监听\nmDevice.setListener(mListener);\nmDevice.getDeviceStatus();\n\n// 实现回调\nGizWifiDeviceListener mListener = new GizWifiDeviceListener() {\n    @Override\n    public  void didReceiveData(GizWifiErrorCode result, GizWifiDevice device, ConcurrentHashMap<String, Object> dataMap, int sn) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 数据解析与3.5.3相同\n        } else {\n            // 查询失败\n        }\n    }\n};\n6. 设备定时任务\n通过给设备设置定时任务，可以让设备在预定的日期和时间执行某些操作。这些操作可以在一个月内的某几天重复，也可以在一周内的某几天重复。\n定时任务可以先设定好，然后在任何时候开始执行或停止执行。定时任务创建时默认开启。\n6.1. 流程图\n \n6.2. 创建定时任务\n定时任务可以重复执行，也可以只执行一次，重复执行分为按月重复和按周重复。但同时只能指定一种重复方式，即或者不重复或者按周重复或者按月重复。\n使用SDK接口时，按周重复时给变量weekDays传值，按月重复时给monthDays传值，但如果两个变量都传值则只会处理weekDays。\n下面分别以这三种情况举例说明。\n6.2.1. 创建一次性定时任务\n假设我们需要在2017年1月16日早上6点30分开灯。如下代码中，日期和时间想要设置为几月几日几时几分，就设定为对应的值。\n比如我们希望设定的是2017年1月16日早上6点30分，那么date为2017-01-16，time为06:30，其中time是24小时制，date按照示例代码格式传值即可。\n【示例代码】\n// 设置定时任务监听\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// 一次性定时任务，在2017年1月16日早上6点30分开灯\nGizDeviceScheduler scheduler = new GizDeviceScheduler();\nscheduler.setDate(\"2017-01-16\");\nscheduler.setTime(\"06:30\");\nscheduler.setRemark(\"开灯任务\");\nConcurrentHashMap<String, Object> attrs = new ConcurrentHashMap<String, Object>();\nattrs.put(\"LED_OnOff\", true);\nscheduler.setAttrs(attrs);\n\n// 创建设备的定时任务，mDevice为在设备列表中得到的设备对象\nGizDeviceSchedulerCenter.createScheduler(\"your_uid\", \"your_token\", mDevice, scheduler);\n\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 定时任务创建成功\n        } else {\n            // 创建失败\n        }\n    }\n};\n6.2.2. 创建按周重复的定时任务\n我们现在让定时任务按周重复执行，现在要每周的周一至周五早上6点30分都开灯。\n【示例代码】\n// 设置定时任务监听\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// 每周一到周五重复执行的定时任务\nGizDeviceScheduler scheduler = new GizDeviceScheduler();\nscheduler.setDate(\"2017-01-16\");\nscheduler.setTime(\"06:30\");\nscheduler.setRemark(\"开灯任务\");\nConcurrentHashMap<String, Object> attrs = new ConcurrentHashMap<String, Object>();\nattrs.put(\"LED_OnOff\", true);\nscheduler.setAttrs(attrs);\nList<GizScheduleWeekday> weekDays = new ArrayList<GizScheduleWeekday>();\nweekDays.add(GizScheduleWeekday.GizScheduleMonday);\nweekDays.add(GizScheduleWeekday.GizScheduleTuesday);\nweekDays.add(GizScheduleWeekday.GizScheduleWednesday);\nweekDays.add(GizScheduleWeekday.GizScheduleThursday);\nweekDays.add(GizScheduleWeekday.GizScheduleFriday);\nscheduler.setMonthDays(monthDays);\n\n// 创建设备的定时任务，mDevice为在设备列表中得到的设备对象\nGizDeviceSchedulerCenter.createScheduler(\"your_uid\", \"your_token\", mDevice, scheduler);\n\n// 实现回调\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 定时任务创建成功\n        } else {\n            // 创建失败\n        }\n    }\n};\n6.2.3. 创建按月重复的定时任务\n我们现在让定时任务按周重复执行，现在要每个月的1号、15号早上6点30分都开灯。\n注意不要同时设置按周重复，如果同时设置了按周重复，按月重复会被忽略。\n【示例代码】\n// 设置定时任务监听\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// 每月1号和15号重复执行的定时任务\nGizDeviceScheduler scheduler = new GizDeviceScheduler();\nscheduler.setDate(\"2017-01-16\");\nscheduler.setTime(\"06:30\");\nscheduler.setRemark(\"开灯任务\");\nConcurrentHashMap<String, Object> attrs = new ConcurrentHashMap<String, Object>();\nattrs.put(\"LED_OnOff\", true);\nscheduler.setAttrs(attrs);\nList<Integer> monthDays = new ArrayList<Integer>();\nmonthDays.add(1);\nmonthDays.add(15);\nscheduler.setMonthDays(monthDays);\n\n// 创建设备的定时任务，mDevice为在设备列表中得到的设备对象\nGizDeviceSchedulerCenter.createScheduler(\"your_uid\", \"your_token\", mDevice, scheduler);\n\n// 实现回调\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 定时任务创建成功\n        } else {\n            // 创建失败\n        }\n    }\n};\n6.3. 获取定时任务列表\n创建好定时任务后，可以通过查询得到已经创建好的所有定时任务列表。得到定时任务列表后，可以对已经创建好的定时任务做修改或删除。\n【示例代码】\n// 设置定时任务监听\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// 同步更新设备的定时任务列表，mDevice为在设备列表中得到的设备对象\nGizDeviceSchedulerCenter.updateSchedulers(\"your_uid\", \"your_token\", mDevice);\n\n// 实现回调\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 定时任务列表获取成功\n        } else {\n            // 获取失败\n        }\n    }\n};\n6.4. 修改定时任务\n可以修改已经创建好的定时任务。修改时，从获取到的定时任务列表中取出定时任务对象，编辑好要修改的内容。\n注意，一旦定时任务创建好之后，就被分配了一个ID，这个ID是不能被修改的。\n【示例代码】\n// 设置定时任务监听\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// 把之前创建好的一次性定时任务修改成每月1号和15号重复执行的定时任务，scheduler是定时任务列表中要修改的定时任务对象\nscheduler.setTime(\"06:30\");\nscheduler.setRemark(\"开灯任务\");\nConcurrentHashMap<String, Object> attrs = new ConcurrentHashMap<String, Object>();\nattrs.put(\"LED_OnOff\", true);\nscheduler.setAttrs(attrs);\nList<Integer> monthDays = new ArrayList<Integer>();\nmonthDays.add(1);\nmonthDays.add(15);\nscheduler.setMonthDays(monthDays);\n\n// 修改设备的定时任务，mDevice是设备列表中要创建定时任务的设备对象\nGizDeviceSchedulerCenter.editScheduler(\"your_uid\", \"your_token\", mDevice, scheduler);\n\n// 实现回调\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 定时任务修改成功\n        } else {\n            // 修改失败\n        }\n    }\n};\n6.5. 删除定时任务\n在得到的定时任务列表中，找到要删除的定时任务ID，删除定时任务。\n【示例代码】\n// 设置定时任务监听\nGizDeviceSchedulerCenter.setListener(mListener);\n\n// 删除设备的定时任务列表，mDevice为在设备列表中得到的设备对象，your_scheduler_id是要删除的定时任务ID\nGizDeviceSchedulerCenter.deleteScheduler(\"your_uid\", \"your_token\", mDevice, \"your_scheduler_id\");\n\n// 实现回调\nGizDeviceSchedulerCenterListener mListener = new GizDeviceSchedulerCenterListener() {\n    @Override\n    public void didUpdateSchedulers(GizWifiErrorCode result, GizWifiDevice schedulerOwner, List<GizDeviceScheduler> schedulerList) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 定时任务删除成功\n        } else {\n            // 删除失败\n        }\n    }\n};\n7. 设备分享\n用户绑定设备后，可以通过设备分享的方式让其他人使用设备。设备分享提供了更好的设备权限管理，在多用户使用同一个设备时提供了更安全、更便捷的设备绑定方式。设备绑定权限分为四种：\n\nOwner：设备的主账号，可以分享设备；\nGuest：设备的分享账号，可以接受分享邀请，不能再分享设备给其他人；\nSpecial：最早绑定设备但还未分享设备的账号，分享设备后即成为设备的主账号；\nNormal：其他已绑定了设备的账号，不能分享设备，也不能成为设备的主账号；\n\n只有最早绑定设备的账号或设备的主账号才能分享设备。一旦设备有了主账号，其他人就无法再绑定了。主账号可以查看设备的当前已绑定用户，可以解绑其他用户。在设备没有主账号时，其他用户仍然可以绑定这个设备。\n7.1. 流程图\n \n7.2. 创建设备分享邀请\n分享设备之前，先检查自己有哪些可以分享的设备。App可以遍历查找SDK提供的设备列表，找到那些绑定权限为GizDeviceSharingSpecial或者GizDeviceSharingOwner的，就可以创建分享邀请了。\n有两种方式可以创建分享邀请：账号分享和二维码分享。只有Owner和Special账号可以创建分享邀请。\n7.2.1. 账号分享\n账号分享时，对方账号可以是手机号、邮箱、普通用户名或者匿名账号，但必须是已经在机智云注册过的用户。如果该用户已经是这个设备的Guest账号或者已经绑定了这个设备，分享邀请会创建失败。账号分享邀请的有效期为24小时，即对方必须在24小时内作出响应，否则账号邀请会过期失效。\n账号分享时要指定账号类型，匿名账号的guestUser参数填匿名账号的uid。账号分享创建成功时，回调参数中会返回sharingID，但不会返回QRCodeImage。下面仅以手机号分享举例：\n【示例代码】\n// 设置设备分享监听\nGizDeviceSharing.setListener(mListener);\n\n// 在设备列表中找到可以分享的设备\n\n// 通过手机号分享设备\nGizDeviceSharing.sharingDevice(\"your_token\", \"your_device_id\", GizDeviceSharingWay.GizDeviceSharingByNormal, \"guest_phone_number\", GizUserAccountType.GizUserPhone);\n\nGizDeviceSharingListener mListener = new GizDeviceSharingListener() {\n    // 实现设备分享的回调\n    @Override\n    public void didSharingDevice(GizWifiErrorCode result, String deviceID, int sharingID, Bitmap QRCodeImage) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 分享成功\n        } else {\n            // 分享失败\n        }\n    }\n};\n\n7.2.2. 二维码分享\n二维码分享时，二维码有效期为15分钟，即对方必须在15分钟内扫描生成的二维码并作出响应，否则二维码邀请会过期失效。二维码分享邀请创建成功时，回调参数中会返回sharingID，同时还会返回对应的二维码图片QRCodeImage，App直接加载图片即可。\n【示例代码】\n// 设置设备分享监听\nGizDeviceSharing.setListener(mListener);\n\n// 在设备列表中找到可以分享的设备\n\n// 二维码分享设备\nGizDeviceSharing.sharingDevice(\"your_token\", \"your_device_id\", GizDeviceSharingWay.GizDeviceSharingByQRCode, null, null);\n\nGizDeviceSharingListener mListener = new GizDeviceSharingListener() {\n    // 实现设备分享的回调\n    @Override\n    public void didSharingDevice(GizWifiErrorCode result, String deviceID, int sharingID, Bitmap QRCodeImage) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 分享成功\n        } else {\n            // 分享失败\n        }\n    }\n};\n\n7.3. 接受分享邀请\nGuest账号可以查询发给自己的设备分享邀请，只有Guest账号可以接受分享邀请。\n7.3.1. 接受账号分享邀请\nGuest查询到的分享邀请如果是还未接受的状态，可以接受或者拒绝邀请。\n【示例代码】\n// 设置设备分享监听\nGizDeviceSharing.setListener(mListener);\n\n// 查询发给自己的分享邀请列表\nGizDeviceSharing.getDeviceSharingInfos(\"your_token\", GizDeviceSharingType.GizDeviceSharingToMe, \"your_device_id\");\n\nGizDeviceSharingListener mListener = new GizDeviceSharingListener() {\n\n    // 实现获取分享邀请列表的回调\n    @Override\n    public void didGetDeviceSharingInfos(GizWifiErrorCode result, String deviceID, List<GizDeviceSharingInfo> deviceSharingInfos) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n\n            // 获取成功。找到deviceSharingInfos中状态为未接受的分享邀请，your_sharing_id为要接受的分享邀请\n            int your_sharing_id = -1;\n            for (int i = 0; i < deviceSharingInfos.size(); i++) {\n                GizDeviceSharingInfo mDeviceSharing = deviceSharingInfos.get(i);\n                if (mDeviceSharing.getStatus() == GizDeviceSharingStatus.GizDeviceSharingNotAccepted) {\n                    your_sharing_id = mDeviceSharing.getId();\n                    break;\n                }\n            }\n\n            // 接受邀请\n            if (your_sharing_id != -1) {\n                GizDeviceSharing.acceptDeviceSharing(\"your_token\", your_sharing_id, true);\n            }\n\n        } else {\n            // 获取失败\n        }\n    }\n\n    // 实现接受分享邀请的回调\n    @Override\n    public void didAcceptDeviceSharing(GizWifiErrorCode result, int sharingID) {\n        if (result == GizWifiErrorCode.GIZ_SDK_SUCCESS) {\n            // 接受成功\n        } else {\n            // 接受失败\n        }\n    }\n};\n\n重要提示\n查阅《APP代码自动生成服务介绍》，可了解自动生成的APP代码模块具备哪些功能\n查阅《APP开源框架》，可了解\n\niOS开源框架使用指南\n\niOS App消息推送集成指南\n\niOS App集成第三方登录与换肤指南\n\niOS App快速开发实例\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送集成指南\nAndroid App集成第三方登录与换肤指南\nAPICloud开源框架使用指南\n\n查阅《APP开发SDK》，可随心开发IoT APP（很多细节设计，均可在里面找到应用案例）\n\niOS SDK 2.0集成指南\nAndroid SDK 2.0集成指南\nAPICloud SDK使用指南\nSDK数据透传方法解析\nSDK调试日志抓取教程\nSDK错误码表\n\n更多应用开发\n\n应用开发FAQ\n设备分享功能使用流程\n第三方登录平台申请流程\n\n"},{"title":"企业API","url":"/zh-cn/Cloud/enterprise_api.html","content":"概述\n企业API是机智云为接入机智云平台 的企业开发者提供的开放API服务，使用企业API的企业将设备接入到机智云平台后，通常还有进一步基于接入机智云设备数据开展企业某个垂直领域的业务需求。企业API为企业提供企业视角全局的设备管理、数据分析等功能，让企业更关注业务管理系统本身，减少不必要的开发成本。\n企业API接口列表\n根据机智云提供的服务，企业 API 提供如下功能:\n\n授权：企业开发者获取token的功能。\n\n\n\n\nAPI列表\n描述\n\n\n\n\npost_v1_products_product_key_access_token\n获取企业API接口访问权限的功能\n\n\n\n\n产品管理：提供了获取产品数据点等功能。\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_v1_products_product_key_datapoint\n获取某个产品的数据点信息\n\n\n\n\n用户管理：提供了搜索注册用户、搜索绑定用户等功能。\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_v1_products_product_key_users_search\n该接口查询的是注册用户信息\n\n\nget_v1_users_search\n该接口查询的是绑定用户信息\n\n\n\n\n设备管理：提供了获取设备did、获取设备详情、搜索设备、远程控制设备、查看设备上下线记录、通信日志以及默认查询2天的历史数据等功能。\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_v1_products_product_key_devices\n获取设备did\n\n\nget_v1_products_product_key_device_detail\n获取设备详情\n\n\nget_v1_products_product_key_devices_search\n搜索设备\n\n\nget_v1_products_product_key_devices_did_data\n默认查询两天内的设备KV值\n\n\nget_v1_products_product_key_devices_did_online\n获取设备上下线记录\n\n\nget_v1_products_product_key_devices_did_cmd\n默认查询两天内的设备原始指令\n\n\npost_v1_products_product_key_devices_did_control\n远程控制设备\n\n\n\n\n设备组管理：提供了创建设备组、查询设备组列表、删除设备组、更新设备组、获取设备组下mac列表等功能。\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_v1_products_product_key_device_groups\n获取设备组树形结构\n\n\npost_v1_products_product_key_device_groups\n创建设备组\n\n\ndelete_v1_products_product_key_device_groups_gid\n删除设备组\n\n\nget_v1_products_product_key_device_groups_gid\n获取设备组下的mac列表\n\n\nput_v1_products_product_key_device_groups_gid\n更新设备组\n\n\n\n\n绑定管理：提供了设备绑定、解绑功能。\n\n\n\n\nAPI列表\n描述\n\n\n\n\npost_v1_products_product_key_devices_bindings\n设备绑定\n\n\ndelete_v1_products_product_key_devices_bindings\n解除设备绑定\n\n\n\n\n设备报表：提供了查询设备激活报表、地理位置分布、概览、激活详情、活跃详情、设备故障、设备报警报表等功能\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_v1_products_product_key_devices_report_activation\n获取激活设备统计报表\n\n\nget_v1_products_product_key_devices_locations\n获取设备地理位置分布\n\n\nget_v1_products_product_key_summary\n最近的激活和活跃设备数\n\n\nget_v1_products_product_key_incr_devices\n自定义查询激活设备详情\n\n\nget_v1_products_product_key_active_devices\n自定义查询活跃设备详情\n\n\nget_v1_products_product_key_devices_report_liveness_history\n可以获取以日、周、月为时间维度的活跃设备历史报表\n\n\nget_v1_products_product_key_devices_report_rt\n查询设备状态表\n\n\nget_v1_products_product_key_fault_report_devices\n获取故障设备台数报表\n\n\nget_v1_products_product_key_alert_report_devices\n获取报警设备台数报表\n\n\nget_v1_products_product_key_fault_report_events\n获取故障次数报表\n\n\nget_v1_products_product_key_fault_alert_events\n获取报警次数报表\n\n\n\n\n用户报表：提供了查询用户新增报表、企业活跃用户人数、用户地理分布、用户总数报表等功能。\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_v1_products_product_key_users_report_new\n这里指的是绑定了该 PK 下产品的新增用户\n\n\nget_v1_users_liveness_total\n企业活跃用户人数\n\n\nget_v1_users_location\n用户地理分布\n\n\nget_v1_products_product_key_users_report_total\n用户总数\n\n\n\n协议约定\n1、请求方式\n本文档所定义接口基于HTTP/HTTPS协议进行传输，需要注意协议中标注的请求方式，通过GET、PUT、DELETE等进行不同的操作。\n2、接口地址\n接口地址中用${ }号包含的为变量，需要使用者通过对应的变量替换。例如${product_key}表示需要将获取的product_key值赋予到接口地址中，${token值}表示是需要替换为通过授权接口获取的token，${did} 表示是需要替换为具体的did。\n3、请求参数\nHTTP请求参数的类型一般分为三种。Header表示该参数是在HTTP请求头中；URL表示是通过url传参；Body表示是Request Body，通常Body中都是JSON格式\n4、HTTP请求头部\n本文档协议中设备管理类、设备报表查询类的接口在进行接口访问时，都需要在请求头增加token值，以此校验访问者是否有权访问该接口。token值是通过获取授权接口获得。\n请求头格式如下：\nContent-Type: application/json\nAuthorization: token ${token值}\n注意：${token值}是不包括${}号，只需将从获取token接口获得token值放到token之后。例如：Authorization: token  efbekskdklllsF\n5、HTTP响应头部\n本协议中的接口在返回报文头部会输出如下信息：\nX-RateLimit-Limit: 60     //接口允许访问总量\nX-RateLimit-Remaining: 56 //接口剩余访问次数\nX-RateLimit-Reset: 1372700873 //调用频率限制重置时间，TS类型\n6、Token值的生命周期\nToken值有效期为7天， 调用获取token接口返回的expired_at为失效日期时间戳。若现在时间戳 > expired_at时间戳，则需要重新获取token, token调用请见\"获取Token\"\n7、接口请求配额说明\n企业API每小时默认允许企业API接口每小时调用3600次，超过阈值则抛错，1小时后恢复接口调用。具体抛错请查看5.2错误信息表系统编码5013的相关说明\n在线调试 企业 API\n我们提供了在线 API 调试工具，在每个接口描述中，都会给出对应的调试接口链接。\n下面以用户管理为例，说明 企业 API 调试工具的使用：\n\n点击 用户管理 进入接口调试页面\n接口右边有个红色叹号，点击后弹出对话框，提示需要输入的头部信息\n该接口需要输入 X-Gizwits-Application-Id，根据前面的说明获取 AppID 并填入，点击 \"Authorize\" 进行授权\n页面自动刷新，并且叹号变成蓝色，表示需要输入的头部信息已填写（已填写并不一定表示值是正确的，如果值错误，会反应在接口返回内容中）\n在参数输入框中输入参数值（点击参数右边的 Example Value 黄色框框，可以快速输入示例 JSON）\n点击 \"试一下\" 按钮，即可完成接口调用\n接口调用完成，会显示本地调用等效的 curl 语句，请求 URL，响应体，响应码和响应头\n\n授权\n获取token\n调试接口\n请求类型及地址\n  POST\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/access_token\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识符\n\n\nenterprise_id\nstring\n是\nbody\n企业id\n\n\nenterprise_secret\nstring\n是\nbody\n企业id 密码\n\n\nproduct_secret\nstring\n是\nbody\n产品密匙\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ntoken\nstring\n用户token\n\n\nexpire_at\ninteger\ntoken过期时间（时间戳）\n\n\n\n返回例子\n{\n  \"token\": \"89d753a234ef42cd90f75da7489e78a4\",\n  \"expired_at\": 1517897923\n}\n\n产品管理\n获取产品数据点\n该接口查询的是产品的数据点定义 \n\n\b数值型数据点真实范围需要通过计算获得最大值 = max * ratio + addition\n最小值 = min * ratio + addition\n\n\n调试接口\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/datapoint\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nname\nstring\n产品名称\n\n\nentities\nArray\n[EntitiyList]\n\n\nprotocolType\nstring\n固定值：standard\n\n\nproduct_key\nstring\n产品product_key\n\n\npacketVersion\nstring\n固定值：0x00000004\n\n\nui\ninline_model_7\n手机客户端 UI 定义\n\n\nEntitiyList\n——————\n——————\n\n\nid\ninteger\n固定值：0\n\n\nname\nstring\n固定值：entity0\n\n\ndisplay_name\nstring\n固定值：机智云开发套件\n\n\nattrs\nArray\n[AttrItem]\n\n\ninline_model_7\n——————\n——————\n\n\nobject\ninline_model_1\n\n\n\nsections\nArray\nUI 片段列表:[SectionItem]\n\n\nAttrItem\n——————\n——————\n\n\nid\ninteger\n数据点顺序\n\n\nname\nstring\n数据点标示名\n\n\ndisplay_name\nstring\n数据点显示名\n\n\ndesc\nstring\n固定值：.....\n\n\ntype\nstring\n读写类型，W: 读写,R: 只读,N: 报警,E: 故障\n\n\ndata_type\nstring\n数据类型，bool：布尔;'uint8','uint16','uint32'：数值型;enum：枚举;binary:扩展型]\n\n\nuint_spec\ninline_model_4\n当 data_type 为 uint8/uint16/uint32 时，有该字段\n\n\nenum\nArray\n当 data_type 为 enum 时，有该字段\n\n\nposition\ninline_model_5\n字节与比特位描述\n\n\ninline_model_1\n——————\n——————\n\n\nversion\ninteger\n固定值：4\n\n\nshowEditButton\nboolean\n固定值：false\n\n\nSectionItem\n——————\n——————\n\n\nelements\nArray\n[ElementItem]\n\n\ninline_model_4\n——————\n——————\n\n\nmin\ninteger\n最少值\n\n\nmax\ninteger\n最大值\n\n\nratio\nnumber\n分辨率k\n\n\naddition\ninteger\n增量\n\n\ninline_model_5\n——————\n——————\n\n\nbit_offset\ninteger\n位索引，如果为变长协议，固定为 0\n\n\nlen\ninteger\n长度\n\n\nunit\nstring\n单位，'bit', 'byte'\n\n\nbyte_offset\ninteger\n字节索引，如果为变长协议，固定为 0\n\n\nElementItem\n——————\n——————\n\n\ntitle\nstring\n数据点显示名\n\n\nkey\nstring\nentity0.{数据点标示名}\n\n\ntype\nstring\n'QBooleanElement', 'QFloatElement', 'QRadioElement', 'QMultilineElement', 'QLabelElement'\n\n\nkeyboardType\nstring\n键盘类型，固定值，\"NumbersAndPunctuation\"\n\n\nmaxLength\ninteger\ntype 为 QMultilineElement 才有该字段，最大长度，为数据点定义长度的 2 倍\n\n\nitems\nArray\ntype 为 QRadioElement 才有该字段，枚举值列表\n\n\nboolValue\nboolean\ntype 为 QBooleanElement 才有该字段，固定值：false\n\n\nbind\nstring\ntype 为 QFloatElement 才有该字段，固定值：floatValue:float\n\n\nmaximumValue\nnumber\ntype 为 QFloatElement 才有该字段，最大值\n\n\nminimumValue\nnumber\ntype 为 QFloatElement 才有该字段，最少值\n\n\nvalue\ninteger\ntype 为 QFloatElement 才有该字段，固定值：0\n\n\nobject\ninline_model_6\n\n\n\ninline_model_6\n——————\n——————\n\n\naction\nstring\n固定值:entity0\n\n\nbind\nArray[string]\n固定值:entity0.{数据点标示名}\n\n\nperm\nstring\n读写类型：W: 读写,R: 只读,N: 报警,E: 故障\n\n\nunit_spec\ninline_model_2\ntype 为 QFloatElement 才有该字段\n\n\ninline_model_2\n——————\n——————\n\n\nmax\ninteger\n最大值\n\n\nstep\ninteger\n步进\n\n\nmin\ninteger\n最小值\n\n\n\n返回例子\n{\n  \"name\": \"微信宠物屋\",\n  \"entities\": [\n    {\n      \"id\": 0,\n      \"display_name\": \"机智云开发套件\",\n      \"attrs\": [\n        {\n          \"display_name\": \"开关\",\n          \"name\": \"switch\",\n          \"data_type\": \"bool\",\n          \"position\": {\n            \"bit_offset\": 0,\n            \"len\": 1,\n            \"unit\": \"bit\",\n            \"byte_offset\": 0\n          },\n          \"type\": \"status_writable\",\n          \"id\": 0,\n          \"desc\": \".....\"\n        }\n      ],\n      \"name\": \"entity0\"\n    }\n  ],\n  \"protocolType\": \"standard\",\n  \"product_key\": \"4244bf2d79694a259232431b6f2ef46a\",\n  \"packetVersion\": \"0x00000004\",\n  \"ui\": {\n    \"object\": {\n      \"version\": 4,\n      \"showEditButton\": false\n    },\n    \"sections\": [\n      {\n        \"elements\": [\n          {\n            \"boolValue\": false,\n            \"object\": {\n              \"action\": \"entity0\",\n              \"bind\": [\n                \"entity0.switch\"\n              ],\n              \"perm\": \"W\"\n            },\n            \"type\": \"QBooleanElement\",\n            \"key\": \"entity0.switch\",\n            \"title\": \"开关\"\n          }\n        ]\n      }\n    ]\n  }\n}\n\n\n用户管理\n搜索注册用户\n该接口查询的是注册用户信息\n调试接口\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/users/search\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Enterprise-ID\nstring\n是\nheader\nenterprise id\n\n\nX-Gizwits-Enterprise-Secret\nstring\n否\nheader\nenterprise secret\n\n\nproduct_key\nstring\n是\nquery\n产品名称  product_key\n\n\nappid\nstring\n否\nquery\n应用id\n\n\nusername\nstring\n否\nquery\n用户名称\n\n\nphone\nstring\n否\nquery\n手机号码\n\n\nemail\nstring\n否\nquery\n邮件\n\n\nlimit\ninteger\n否\nquery\n返回的条数，默认:20\n\n\nskip\ninteger\n否\nquery\n跳过的条数，default:0\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ntotal\ninteger\n消息总数\n\n\nlimit\ninteger\n返回的结果条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\nuid\nstring\n用户 id\n\n\nusername\nstring\n用户名称\n\n\nphone\nstring\n手机号码\n\n\nemail\nstring\n邮箱\n\n\nbirthday\nstring\n生日日期\n\n\nis_anonymous\nboolean\n是否为匿名用户\n\n\ngender\nstring\n性别\n\n\naddress\nstring\n地址\n\n\nremark\nstring\n备注\n\n\ncreated_at\ninteger\n创建时间\n\n\nupdated_at\ninteger\n更新时间\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 20,\n    \"limit\": 20,\n    \"next\":null\n  },\n  \"objects\": [\n    {\n      \"username\": null,\n      \"remark\": null,\n      \"uid\": \"25a5324c807842348f63ade277eb413a\",\n      \"is_anonymous\": true,\n      \"gender\": null,\n      \"created_at\": 1513135417,\n      \"updated_at\": 1513135417,\n      \"phone\": null,\n      \"birthday\": null,\n      \"address\": null,\n      \"email\": null\n    }\n  ]\n}\n\n搜索绑定用户\n调试接口\n该接口用于查询的是绑定用户信息\n\n只有当搜索设备 did 时会返回该设备的 owner 权限情况，true：拥有 owner 权限，false：没有 owner 权限\n\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/users/search\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ngid\nstring\n否\nquery\n组ID\n\n\ntype\nstring\n否\nquery\n密码\n\n\nval\nstring\n否\nquery\n查询条件值\n\n\nlimit\ninteger\n否\nquery\n每次返回的条数\n\n\nskip\ninteger\n否\nquery\n每次跳过的条数\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ntotal\ninteger\n消息总数\n\n\nlimit\ninteger\n返回的结果条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\nuid\nstring\n用户 id\n\n\nusername\nstring\n用户名称\n\n\nphone\nstring\n手机号码\n\n\nemail\nstring\n邮箱\n\n\nbirthday\nstring\n生日日期\n\n\naddress\nstring\n地址\n\n\nremark\nstring\n备注\n\n\ncreated_at\ninteger\n创建时间\n\n\nis_anonymous\nboolean\n是否为匿名用户\n\n\nauth_src\nobject\n用户第三方信息\n\n\nis_owner\nboolean\n只有当搜索设备 did 时会返回该设备的 owner 权限情况，true：拥有 owner 权限，false：没有 owner 权限\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 30,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"username\": null,\n      \"remark\": null,\n      \"uid\": \"2ac80784a695a5f88f63ade277eb413a\",\n      \"is_anonymous\": true,\n      \"gender\": null,\n      \"created_at\": 1513135417,\n      \"auth_src\": null,\n      \"phone\": null,\n      \"birthday\": null,\n      \"address\": null,\n      \"email\": null,\n      \"name\": null\n    }\n  ]\n}\n\n设备管理\n获取设备did\n调试接口\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\nmac\nstring\n是\nquery\nmac 地址\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ndid\nstring\n设备id\n\n\n\n返回例子\n{\n  \"did\": \"cBYkSjoE2xspYMhaUHdk5k\",\n  \"passcode\": \"123456\"\n}\n\n获取设备详情\n调试接口\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/device_detail\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\nmac\nstring\n是\nquery\nmac 地址\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\nproduct_key\nstring\n产品名称\n\n\nmac\nstring\nmac 地址\n\n\ndid\nstring\n设备 ID\n\n\nis_online\nboolean\n设备是否在线，True 代表在线，False 代表离线\n\n\nis_disabled\nboolean\n设备是否注销，True 代表已注销，False 代表未注销\n\n\ntype\nstring\n设备类型\n\n\n\n返回例子\n{\n  \"did\": \"dE2xjocBhaUHkYkSspYM5k\",\n  \"is_disabled\": false,\n  \"product_key\": \"6f2e214bf2d79649232431b94a25f46a\",\n  \"mac\": \"virtual:site\",\n  \"is_online\": false,\n  \"type\": \"normal\"\n}\n\n搜索设备\n调试接口\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/search\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ngid\nstring\n否\nquery\n设备组 id\n\n\ncountry\nstring\n否\nquery\n国家\n\n\nregion\nstring\n否\nquery\n省\n\n\ncity\nstring\n否\nquery\n城市\n\n\nis_online\ninteger\n否\nquery\n是否在线,在线为1,不在线为0\n\n\nis_faulty\ninteger\n否\nquery\n是否故障,故障为1,无故障为0\n\n\nis_alert\ninteger\n否\nquery\n是否报警,报警为1,无报警为0\n\n\nshow_disabled\ninteger\n否\nquery\n显示注销为1，过滤注销为0\n\n\nliveness_start\nstring\n否\nquery\n最近活跃时间戳\n\n\ntype\nstring\n否\nquery\n可以为 did、mac、uid\n\n\nval\nstring\n否\nquery\n查询条件值\n\n\nlimit\ninteger\n否\nquery\n每次返回的条数\n\n\nskip\ninteger\n否\nquery\n每次跳过的条数\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ntotal\ninteger\n消息总数\n\n\nlimit\ninteger\n返回的结果条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\ndid\nstring\n设备 id\n\n\nmac\nstring\nmac 地址\n\n\nis_online\ninteger\n是否设备在线\n\n\ncountry\nstring\ncountry\n\n\nregion\nstring\n省\n\n\ncity\nstring\n市\n\n\nlongitude\nstring\n经度\n\n\nlatitude\ninteger\n纬度\n\n\nis_faulty\ninteger\n是否发生故障\n\n\nis_alert\ninteger\n是否发生报警\n\n\nonline_latest\ninteger\n设备最近上线时间\n\n\ncreated_at\ninteger\n设备创建时间\n\n\nmcu_hard_version\nstring\nmcu 硬件版本\n\n\nmcu_soft_version\nstring\nmcu 软件件版本\n\n\nwifi_hard_version\nstring\nwifi 硬件版本\n\n\nwifi_soft_version\nstring\nwifi 软件件版本\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 3,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"city\": \"Guangzhou\",\n      \"mcu_hard_version\": null,\n      \"mcu_soft_version\": null,\n      \"did\": \"kYkSE2xspYjocBhaUHdM5k\",\n      \"country\": \"China\",\n      \"region\": \"Guangdong\",\n      \"mac\": \"virtual:site\",\n      \"longitude\": 113.280637,\n      \"wifi_hard_version\": null,\n      \"online_latest\": 1517296665,\n      \"wifi_soft_version\": null,\n      \"is_online\": false,\n      \"latitude\": 23.125178,\n      \"is_alert\": false,\n      \"created_at\": 1505789918,\n      \"is_faulty\": false\n    }\n  ]\n}\n\n设备远程控制\n调试接口\n原始指令(raw):\n默认格式为十进制数组，设置 binary_coding 参数可使用 hex 和 base64，\n如要发送 payload 为二进制 011000010110001001100011 ，每组byte换成一个十进制数组的值得就是：[97,98,99]；\n如要发送 payload 为16进制 616263 ，每组byte换成一个十进制数组的值得就是：[97,98,99]。\n{\n  \"raw\": [97,98,99]\n}\n\n数据点方式(attrs):\n设备产品必须定义了数据点。如要设置扩展类型的字段 binary 为16进制 1234567 ，需要补齐扩展型长度：\n{\n  \"attrs\": {\n    \"binary\": \"1234567000\"\n  }\n}\n\n请求类型及地址\n  POST\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/{did}/control\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ndid\nstring\n是\npath\n设备 id\n\n\nraw\nArray[integer]\n是\nbody\n原始指令\n\n\nattrs\nobject\n是\nbody\n数据点方式\n\n\n\n响应参数\n   无\n设备上下线记录\n调试接口\n用于查询最近7天内任意两天的上下线记录。\n时间&排序：\n\nstart_ts 和 end_ts不填，默认查询过去到现在两天以内的通信日志记录\nstart_ts 与 end_ts之间的间隔秒必须在两天范围以内\n增加sort排序，默认为降序，asc代表升序，desc代表降序\n\n设备的下线原因（reason）\n\nmqtt_disconnect：设备主动断开与mqtt的连接\nno_heartbeat：m2m在KeepAlive时段内，没有收到设备心跳\ntcp_closed：设备主动断开tcp连接\nssl_closed：设备主动断开ssl连接\noffline_force：设备重复上线，原有的连接断开\noffline_reset：设备注销，断开连接\noffline_exception：异常断开连接\noffline_sending_density_overflow：客户端发送信息的频率过大，断开链接\noffline_sending_data_size_overflow：客户端发送信息的流量过大，断开链接\n\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/{did}/online\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ndid\nstring\n是\npath\n设备did\n\n\nstart_ts\ninteger\n否\nquery\n开始时间戳\n\n\nend_ts\ninteger\n否\nquery\n结束时间戳\n\n\nsort\nsort\n否\nquery\n可以是desc和asc\n\n\nlimit\ninteger\n否\nquery\n返回的结果条数\n\n\nskip\ninteger\n否\nquery\n跳过的条数\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ntotal\ninteger\n消息总数\n\n\nlimit\ninteger\n返回的结果条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\ntimestamp\ninteger\n设备上下线指令时间\n\n\ntype\nstring\n设备日志类型，如： dev_offline/dev_offline 等\n\n\npayload\nstring\n设备原始日志信息\n\n\nKeepAlive\ninteger\n设备指定的心跳时间间隔（单位:秒）\n\n\nduration\ninteger\n设备的在线时长 （单位:秒）\n\n\ncount\ninteger\n在线时发送的心跳次数\n\n\nmax\ninteger\n最大间隔时间\n\n\nmin\ninteger\n最小间隔时间\n\n\navg\ninteger\n平均间隔时间\n\n\nlast\ninteger\n最后一次收到心跳时刻与下线时刻的间隔时间\n\n\nreason\nstring\n下线原因\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 5,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"timestamp\": 1517384124.229,\n      \"type\": \"dev_online\",\n      \"payload\": {\n        \"keep_alive\": 130\n      }\n    },\n    {\n      \"timestamp\": 1517298056.201,\n      \"type\": \"dev_offline\",\n      \"payload\": {\n        \"duration\": 1391,\n        \"heartbeat\": {\n          \"count\": 21,\n          \"max\": 60,\n          \"avg\": 60,\n          \"last\": 130,\n          \"min\": 60\n        },\n        \"reason\": \"no_heartbeat\"\n      }\n    }\n  ]\n}\n\n设备通信日志\n调试接口\n用于查询最近7天内任意两天的设备通讯日志（原始数据）。\n时间&排序：\n\nstart_ts 和 end_ts不填，默认查询过去到现在两天以内的通信日志记录\nstart_ts与end_ts之间的间隔秒必须在两天范围以内\n增加sort排序，默认为降序，asc代表升序，desc代表降序\n\npayload：\n\npayload 为二进制进行 base64 编码后的结果。\n\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/{did}/cmd\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ndid\nstring\n是\npath\n设备did\n\n\nstart_ts\ninteger\n否\nquery\n开始时间戳\n\n\nend_ts\ninteger\n否\nquery\n结束时间戳\n\n\nsort\nsort\n否\nquery\n可以是desc和asc\n\n\nlimit\ninteger\n否\nquery\n返回的结果条数\n\n\nskip\ninteger\n否\nquery\n跳过的条数\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ntotal\ninteger\n消息总数\n\n\nlimit\ninteger\n返回的结果条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\ntimestamp\ninteger\n设备上下线指令时间\n\n\ntype\nstring\n设备日志类型，如： dev2app/app2dev 等\n\n\npayload\nstring\n设备原始日志信息\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 6,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"timestamp\": 1517384252.294,\n      \"type\": \"app2dev\",\n      \"payload\": \"0000000309000090010101000010\"\n    },\n    {\n      \"timestamp\": 1517384243.044,\n      \"type\": \"dev2app\",\n      \"payload\": \"000000030b0000910401000010000000\"\n    }\n  ]\n}\n\n获取设备历史数据\n调试接口\n用于查询最近7天内任意两天的设备通讯日志（Json格式）。\n\nstart_ts 和 end_ts不填，默认查询过去到现在两天以内的通信日志记录\nstart_ts与end_ts之间的间隔秒必须在两天范围以内\n增加sort排序，默认为降序，asc代表升序，desc代表降序\n\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/{did}/data\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ndid\nstring\n是\npath\n设备did\n\n\nstart_ts\ninteger\n否\nquery\n开始时间戳\n\n\nend_ts\ninteger\n否\nquery\n结束时间戳\n\n\nsort\nsort\n否\nquery\n可以是desc和asc\n\n\nlimit\ninteger\n否\nquery\n返回的结果条数\n\n\nskip\ninteger\n否\nquery\n跳过的条数\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ntotal\ninteger\n消息总数\n\n\nlimit\ninteger\n返回的结果条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\nts\ninteger\n设备指令时间\n\n\nattrs\nobjects\n数据点\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 3,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"ts\": 1517384243,\n      \"attrs\": {\n        \"alert_full\": 0,\n        \"alert_shutdown\": 0,\n        \"mode\": \"制冷\",\n        \"fan_swing\": 0,\n        \"switch\": 1,\n        \"fan_speed\": \"低风\",\n        \"fault_roomtemp\": 0,\n        \"room_temp\": -10,\n        \"set_temp\": 16,\n        \"off_timing\": 0,\n        \"on_timing\": 0\n      }\n    }\n  ]\n}\n\n设备组管理\n获取设备组树形结构\n调试接口\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组ID\n\n\n\n返回例子\n{\n  \"c8e4b5634b047dc495be4a05a39d02a3\": \"\"\n}\n\n创建设备组\n调试接口\n\nparent 为可选参数，如果有 parent 表示创建一个子设备组。\n一个产品只能有一个根设备组。\n\n请求类型及地址\n POST\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\nparent_gid\nstring\n否\nbody\n子设备组id\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组ID\n\n\n\n返回例子\n{\n  \"gid\": \"c8e4b5634b047dc495be4a05a39d02a3\"\n}\n\n删除设备组\n调试接口\n删除设备组需要先清空设备组下所有设备及子设备组。\n请求类型及地址\n DELETE\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups/{gid}\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ngid\nstring\n是\npath\n设备组id\n\n\n\n响应参数\n   无 \n获取设备组下的mac列表\n调试接口\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups/{gid}\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ngid\nstring\n是\npath\n设备组id\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\nmacs\nArray[string]\nmac列表\n\n\n\n返回例子\n{\n  \"macs\": [\n    \"virtual:site\"\n  ]\n}\n\n更新设备组\n调试接口\n\naction: 操作，\"assign\" | \"unassign\"\nmacs: MAC 列表，最多一次上传 1000 个 MAC\nreassign: 当 action 为 \"assign\" 时有效。当 reassgin 为 true，MAC 如果已经在某个设备组下面，会被移动到当前组；当 reassign 为 false，MAC 如果已经在某个设备组下面，则移动失败。\n\n请求类型及地址\n  PUT\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/device_groups/{gid}\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ngid\nstring\n是\npath\n设备组id\n\n\naction\nstring\n是\nbody\n设备组分配类型: assign,unassign\n\n\nreassign\nboolean\n是\nbody\n\n\n\nmacs\nArray[string]\n是\nbody\nMAC 列表\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\nfailed\nArray[string]\n更新失败的mac列表\n\n\nsuccess\nArray[string]\n更新成功的mac列表\n\n\n\n返回例子\n{\n  \"failed\": [],\n  \"success\": [\n    \"virtual:site\"\n  ]\n}\n\n绑定管理\n设备绑定功能\n调试接口\n请求类型及地址\n  POST\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/bindings\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\nuid\nstring\n是\nbody\n用户 id\n\n\nappid\nstring\n是\nbody\n应用  id\n\n\ndids\nstring\n是\nbody\ndid 列表\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\nsuccess\nArray[string]\n解绑成功MAC列表\n\n\nfailed\nArray[string]\n解绑失败MAC列表\n\n\n\n返回例子\n{\n  \"failed\": [],\n  \"success\": [\n    \"jaUHdkYkSocBhE2xspYM5k\"\n  ]\n}\n\n解除绑定\n调试接口\n请求类型及地址\n  DELETE\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/bindings\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\nuid\nstring\n是\nbody\n用户 id\n\n\nappid\nstring\n是\nbody\n应用  id\n\n\ndids\nstring\n是\nbody\ndid 列表\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\nsuccess\nArray[string]\n绑定成功MAC列表\n\n\nfailed\nArray[string]\n绑定失败MAC列表\n\n\n\n返回例子\n{\n  \"failed\": [],\n  \"success\": [\n    \"jaUHdkYkSocBhE2xspYM5k\"\n  ]\n}\n\n设备报表\n获取设备地理位置分布\n调试接口\n用于获取设备地理位置分布报表\n请求类型及地址\n  GET\n http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/locations\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\ngid\nstring\n否\nquery\n设备组id\n\n\nis_online\ninteger\n否\nquery\n是否在线\n\n\nis_faulty\ninteger\n否\nquery\n是否故障\n\n\nis_alert\ninteger\n否\nquery\n是否报警\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组 id\n\n\ntotal\ninteger\n设备总数\n\n\nlocation\nobject\n设备地理位置信息\n\n\n\n返回例子\n{\n  \"gid\": null,\n  \"total\": 4,\n  \"location\": {\n    \"China\": {\n      \"count\": 3,\n      \"Guangdong\": {\n        \"count\": 3,\n        \"Guangzhou\": 3\n      }\n    }\n  }\n}\n\n设备概览\n此接口仅可在国内环境使用\n调试接口\n用于获取最近的新增激活和活跃设备数报表\n请求类型及地址\n  GET\n http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/summary\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\nonline\ninteger\n设备在线数\n\n\ntotal\ninteger\n设备累计上线数\n\n\nactive\ninline_model\n活跃设备\n\n\nyesterday\ninteger\n昨日活跃设备数\n\n\n7_day\ninteger\n近7天活跃设备数\n\n\nnew\ninline_model\n新增设备\n\n\ntoday\ninteger\n今日新增设备数\n\n\nyesterday\ninteger\n昨日新增设备数\n\n\n7_day\ninteger\n近7天新增设备数\n\n\n30_day\ninteger\n近30天新增设备数\n\n\n\n返回例子\n{\n  \"active\": {\n    \"7_day\": 0,\n    \"yesterday\": 0\n  },\n  \"new\": {\n    \"7_day\": 0,\n    \"30_day\": 0,\n    \"yesterday\": 0,\n    \"today\": 0\n  },\n  \"total\": 3,\n  \"online\": 0\n}\n\n设备激活详情\n此接口仅可在国内环境使用\n调试接口\n用于获取设备激活详情报表\n日期查询说明\n\nstart,end 的格式是年-月-日，例如:2016-08-01,\n注意：蓝牙设备响应返回的结果为device_sn字段\n\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/incr_devices\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\nstart\nstring\n否\nquery\n字符串开始日期\n\n\nend\nstring\n否\nquery\n字符串结束日期\n\n\ncountry\nstring\n否\nquery\n国家\n\n\nregion\nstring\n否\nquery\n省\n\n\ncity\nstring\n否\nquery\n城市\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ntotal\ninteger\n消息总数\n\n\nlimit\ninteger\n返回的结果条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\nreport_date\nstring\n报表日期\n\n\nproduct_key\nstring\n产品标识码\n\n\nmac\nstring\nmac地址\n\n\ndevice_sn\nstring\n蓝牙设备的设备号\n\n\ncountry\nstring\n国家\n\n\nregion\nstring\n省\n\n\ncity\nstring\n城市\n\n\ncreated_at\nstring\n设备创建时间\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 4,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"city\": \"Guangzhou\",\n      \"country\": \"China\",\n      \"region\": \"Guangdong\",\n      \"report_date\": \"2017-12-07\",\n      \"product_key\": \"4bd8778c5aa4602e5c9a5a208a1fdcc3\",\n      \"mac\": \"virtual:site\",\n      \"created_at\": \"2017-12-07 10:12:45\"\n    }\n  ]\n}\n\n设备活跃详情\n此接口仅可在国内环境使用\n调试接口\n用于获取设备活跃详情报表\n日期查询说明\n\nstart,end 的格式是年-月-日，例如:2016-08-01,\n注意：蓝牙设备响应返回的结果为device_sn字段\n\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/active_devices\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\nstart\nstring\n否\nquery\n字符串开始日期\n\n\nend\nstring\n否\nquery\n字符串结束日期\n\n\ncountry\nstring\n否\nquery\n国家\n\n\nregion\nstring\n否\nquery\n省\n\n\ncity\nstring\n否\nquery\n城市\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ntotal\ninteger\n消息总数\n\n\nlimit\ninteger\n返回的结果条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\nreport_date\nstring\n报表日期\n\n\nproduct_key\nstring\n产品标识码\n\n\nmac\nstring\nmac地址\n\n\ndevice_sn\nstring\n蓝牙设备的设备号\n\n\ncountry\nstring\n国家\n\n\nregion\nstring\n省\n\n\ncity\nstring\n城市\n\n\ncreated_at\nstring\n设备创建时间\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 19,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"city\": \"Guangzhou\",\n      \"country\": \"China\",\n      \"region\": \"Guangdong\",\n      \"report_date\": \"2017-12-28\",\n      \"product_key\": \"ea202c9a5bd8708a145a4678c5afdcc3\",\n      \"mac\": \"virtual:site\",\n      \"created_at\": \"2017-12-28 18:45:33\"\n    }\n  ]\n}\n\n获取活跃历史报表\n此接口仅可在国内环境使用\n调试接口\n活跃设备指：一天之内有数据上报的设备\n查询范围\n\n日报表最多查询 30 天。\n周报表最多查询 53 周。\n月报表最多查询 12 月。日期查询说明\n\ncycle 为 date 时，start,end 的格式是年-月-日，example:2016-08-01,\ncycle 为 week 时，start,end 的格式是年-周，example:2016-51\ncycle 为 month 时，start,end 的格式为年-月，example:2016-12\n\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/report/liveness/history\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\ngid\nstring\n否\nquery\n设备组 id\n\n\ncycle\nstring\n否\nquery\n统计周期，可以是日(date)、周(week)、月(month)\n\n\nstart\nstring\n是\nquery\n开始日期\n\n\nend\nstring\n是\nquery\n结束日期\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组 id\n\n\ncycle\nstring\n周期，分为 month,week,date\n\n\nstart\nstring\n开始日期\n\n\nend\nstring\n结束日期\n\n\ndate\nstring\n日期\n\n\ncount\ninteger\n数量\n\n\nlocation\nobject\n地理位置信息\n\n\n\n返回例子\n{\n  \"start\": \"2017-12\",\n  \"gid\": null,\n  \"end\": \"2017-12\",\n  \"data\": [\n    {\n      \"count\": 2,\n      \"location\": {\n        \"China\": {\n          \"count\": 1,\n          \"Guangdong\": {\n            \"count\": 1,\n            \"Guangzhou\": {\n              \"count\": 1\n            }\n          }\n        }\n      },\n      \"month\": \"2017-12\"\n    }\n  ],\n  \"cycle\": \"month\"\n}\n\n设备实时统计报表\n调试接口\n用于获取设备实时统计报表\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/devices/report/devices/report/rt\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\ngid\nstring\n否\nquery\n设备组 id\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组 id\n\n\nactivated\ninteger\n激活数\n\n\nfaulty\ninteger\n故障数\n\n\nalert\ninteger\n报警数\n\n\nlocation\nobject\n设备地理位置分布\n\n\n\n返回例子\n{\n  \"count\": {\n    \"faulty\": 0,\n    \"activated\": 4,\n    \"alert\": 1\n  },\n  \"gid\": null,\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"activated\": 2,\n        \"alert\": 1\n      },\n      \"Guangdong\": {\n        \"count\": {\n          \"faulty\": 1,\n          \"activated\": 1,\n          \"alert\": 1\n        },\n        \"Guangzhou\": {\n          \"count\": {\n            \"activated\": 3\n          }\n        }\n      }\n    }\n  }\n}\n\n获取故障设备台数报表\n此接口仅可在国内环境使用\n调试接口\n获取故障设备台数报表\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/fault/report/devices\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\ngid\nstring\n否\nquery\n设备组 id\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组 id\n\n\ntotal\ninteger\n故障设备总数\n\n\nresolved\ninteger\n故障设备已解决数\n\n\nunresolved\ninteger\n故障设备未解决数\n\n\nlocation\nobject\n故障设备地理位置分布\n\n\n\n返回例子\n{\n  \"gid\": null,\n  \"count\": {\n    \"total\": 2,\n    \"resolved\": 1,\n    \"unresolved\": 1\n  },\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"total\": 2,\n        \"resolved\": 1,\n        \"unresolved\": 1\n      },\n      \"Guangdong\": {\n        \"count\": {\n          \"total\": 2,\n          \"resolved\": 1,\n          \"unresolved\": 1\n        },\n        \"Guangzhou\": {\n          \"count\": {\n            \"total\": 2,\n            \"resolved\": 1,\n            \"unresolved\": 1\n          }\n        }\n      }\n    }\n  }\n}\n\n获取报警设备台数报表\n此接口仅可在国内环境使用\n调试接口\n用于获取报警设备台数报表\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/alert/report/devices\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\ngid\nstring\n否\nquery\n设备组 id\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组 id\n\n\ntotal\ninteger\n报警设备总数\n\n\nresolved\ninteger\n报警设备已解决数\n\n\nunresolved\ninteger\n报警设备未解决数\n\n\nlocation\nobject\n报警设备地理位置分布\n\n\n\n返回例子\n{\n  \"gid\": null,\n  \"count\": {\n    \"total\": 2,\n    \"resolved\": 1,\n    \"unresolved\": 1\n  },\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"total\": 2,\n        \"resolved\": 1,\n        \"unresolved\": 1\n      },\n      \"Guangdong\": {\n        \"count\": {\n          \"total\": 2,\n          \"resolved\": 1,\n          \"unresolved\": 1\n        },\n        \"Guangzhou\": {\n          \"count\": {\n            \"total\": 2,\n            \"resolved\": 1,\n            \"unresolved\": 1\n          }\n        }\n      }\n    }\n  }\n}\n\n获取故障次数报表\n此接口仅可在国内环境使用\n调试接口\n用于获取故障次数报表\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/fault/report/events\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\ngid\nstring\n否\nquery\n设备组 id\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组 id\n\n\ndetail\nobject\n详情故障类数据点统计\n\n\nlocation\nobject\n故障地理分布统计\n\n\ntotal\ninteger\n故障设备总数\n\n\nresolved\ninteger\n故障已解决数\n\n\nunresolved\ninteger\n故障未解决数\n\n\n\n返回例子\n{\n  \"count\": {\n    \"resolved\": 1,\n    \"total\": 1,\n    \"unresolved\": 0\n  },\n  \"gid\": null,\n  \"detail\": {\n    \"fault_roomtemp\": {\n      \"resolved\": 1,\n      \"total\": 1,\n      \"unresolved\": 0\n    }\n  },\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"resolved\": 1,\n        \"total\": 1,\n        \"unresolved\": 0\n      },\n      \"detail\": {\n        \"fault_roomtemp\": {\n          \"resolved\": 1,\n          \"total\": 1,\n          \"unresolved\": 0\n        }\n      }\n    }\n  }\n}\n\n获取报警次数报表\n用于获取报警次数报表\n此接口仅可在国内环境使用\n调试接口\n请求类型及地址\n  GET  \n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/alert/report/devices\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\ngid\nstring\n否\nquery\n设备组 id\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组 id\n\n\ndetail\nobject\n详情故障类数据点统计\n\n\nlocation\nobject\n报警地理分布统计\n\n\ntotal\ninteger\n报警设备总数\n\n\nresolved\ninteger\n报警已解决数\n\n\nunresolved\ninteger\n报警未解决数\n\n\n\n返回例子\n{\n  \"count\": {\n    \"resolved\": 1,\n    \"total\": 1,\n    \"unresolved\": 0\n  },\n  \"gid\": null,\n  \"detail\": {\n    \"alert_full\": {\n      \"resolved\": 1,\n      \"total\": 1,\n      \"unresolved\": 0\n    }\n  },\n  \"location\": {\n    \"China\": {\n      \"count\": {\n        \"resolved\": 1,\n        \"total\": 1,\n        \"unresolved\": 0\n      },\n      \"detail\": {\n        \"alert_full\": {\n          \"resolved\": 1,\n          \"total\": 1,\n          \"unresolved\": 0\n        }\n      }\n    }\n  }\n}\n\n用户报表\n用户新增报表\n此接口仅可在国内环境使用\n调试接口\n这里指的是绑定了该 PK 下产品的新增用户\n日期查询说明：\n\ncycle 为 date 时，start,end的格式是年-月-日，example:2016-08-01,\ncycle 为 week 时，start,end的格式是年-周，example:2016-51\ncycle 为 month 时，start,end的格式为年-月，example:2016-12\n\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/products/{product_key}/users/report/new\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品名称\n\n\ngid\nstring\n是\nquery\n设备组id\n\n\ncycle\nstring\n否\nquery\n统计周期，可以为 date、week、month\n\n\nstart\nstring\n是\nquery\n起始周期，为起始日期、起始周或起始月\n\n\nend\nstring\n是\nquery\n结束周期，为结束日期、结束周或结束月\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ndid\nstring\n设备组 id\n\n\ncycle\nstring\n周期，分为 month,week,date\n\n\nstart\nstring\n开始日期\n\n\ndata\nstring\n日期\n\n\ncount\nstring\n数量\n\n\n\n返回例子\n{\n  \"start\": \"2017-12\",\n  \"gid\": null,\n  \"end\": \"2017-12\",\n  \"data\": [\n    {\n      \"count\": 3,\n      \"month\": \"2017-12\"\n    }\n  ],\n  \"cycle\": \"month\"\n}\n\n企业活跃用户人数\n调试接口\n用于查询的是企业活跃用户人数\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/users/liveness_total\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Enterprise-ID\nstring\n是\nheader\nenterprise id\n\n\nX-Gizwits-Enterprise-Secret\nstring\n是\nheader\nenterprise secret\n\n\nproduct_secret\nstring\n是\nquery\n产品标识码 product_key\n\n\nappid\nstring\n否\nquery\n应用id\n\n\nstart_date\nstring\n是\nquery\n开始日期，如：2015-01-02\n\n\nend_date\nstring\n是\nquery\n结束日期，如：2015-01-03\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ndate\nstring\n日期\n\n\ncount\ninteger\n数量\n\n\n\n返回例子\n{\n  \"data\": [\n    {\n      \"count\": 2,\n      \"date\": \"2017-12-13\"\n    }\n  ]\n}\n\n用户地理分布\n调试接口\n该接口用于查询的是企业用户地理分布\n请求类型及地址\n  GET\n  http://enterpriseapi.gizwits.com/v1/users/location\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Enterprise-ID\nstring\n是\nheader\nenterprise id\n\n\nX-Gizwits-Enterprise-Secret\nstring\n是\nheader\nenterprise secret\n\n\nproduct_secret\nstring\n是\nquery\n产品标识码 product_key\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ncount\ninteger\n数 量\n\n\n\n返回例子\n{\n  \"China\": {\n    \"count\": 18,\n    \"Beijing\": {\n      \"count\": 14,\n      \"Beijing\": {\n        \"count\": 14\n      }\n    },\n    \"Guangdong\": {\n      \"count\": 4,\n      \"Guangzhou\": {\n        \"count\": 4\n      }\n    }\n  }\n}\n\n用户总数报表\n用于查询用户空间表，获取曾经绑定过该 pk 设备的用户总数\n调试接口\n请求类型及地址\n  GET\n http://enterpriseapi.gizwits.com/v1/products/{product_key}/users/report/total\n请求参数\n\n\n\n参数\n数据类型\n必填\n参数类型\n描述\n\n\n\n\nproduct_key\nstring\n是\npath\n产品标识码\n\n\ngid\nstring\n否\nquery\n设备组id\n\n\n\n响应参数\n\n\n\n参数\n数据类型\n描述\n\n\n\n\ngid\nstring\n设备组 id\n\n\ntotal\ninteger\n用户总数\n\n\n\n返回例子\n{\n  \"gid\": null,\n  \"total\": 31,\n}\n\n错误信息表\n\n\n\n响应码\n系统错误码\n错误信息描述\n解决办法\n\n\n\n\n400\n5001\nbody json invalid\n核对json字串\n\n\n400\n5002\nform invalid\n输入数据不对\n\n\n404\n5003\nenterprise id not exist\nEid不存在，检查是否申请或者Eid输入错误\n\n\n400\n5004\nenterprise secret error\nEsecret校验失败，检查是否是正确的\n\n\n400\n5005\nproduct secret error\nProduct Secret校验失败，检查是否是正确的\n\n\n400\n5006\nproduct exist devicegroups\n\n\n\n404\n5007\nassociation not exist\n需要先开通企业API服务\n\n\n400\n5008\nassociation existed\nEid没有与对应的Product Key 关联，请联系客服\n\n\n400\n5009\ntoken invalid\n请携带token或检查token字段格式\n\n\n400\n5010\ntoken not match product_key\n\n\n\n400\n5011\ntoken has expired\n请再次获取token\n\n\n400\n5012\nip not in white list\n添加ip到ip企业数据访问白名单中\n\n\n403\n5013\nAPI call rate limit execeed quota\n等待一定时间后再次使用此接口\n\n\n400\n5014\nReport has not been generated!\n\n\n\n404\n5015\nProduct key not exist!\n核对产品Product Key是否正确\n\n\n404\n5016\nAppid not exist!\n\n\n\n404\n5016\nAppid not exist!\n\n\n\n404\n5017\nUid not exist!\n\n\n\n403\n5018\nproduct operation not allowed\n\n\n\n404\n5019\norganization does not exist\n\n\n\n400\n5020\ncan not delete published product!\n\n\n\n400\n5021\nenterprise is exist\n\n\n\n404\n5022\nenterprise does not exist\n\n\n\n403\n5023\nenterprise is creating\n\n\n\n403\n5024\napi deny to visit!\n\n\n\n404\n5025\nproduct does not exist\n\n\n\n403\n5201\ndevice group not belong to this product\n\n\n\n404\n5202\nparent group not exist\n\n\n\n400\n5203\nalready has one root group\n\n\n\n400\n5204\ngroup has subgroup\n\n\n\n400\n5205\ngroup has device item\n\n\n\n404\n5206\ngroup not exist\n\n\n\n400\n5207\nproduct key not in pre assignment!\n\n\n\n400\n5208\ncreate assign device in progress!\n\n\n\n404\n5301\ndevice not exist\n核对设备ID\n\n\n403\n5302\ndevice not belong to this product\n请先将设备绑定到产品\n\n\n400\n5303\ndevice not bound\n\n\n\n400\n5304\ndevice is disabled\n激活设备\n\n\n400\n5305\ndevice offline!\n上线设备\n\n\n400\n5401\nattr invalid!\n核对数据点信息\n\n\n404\n5402\ndatapoint data not found!\n先定义数据点,然后再次尝试\n\n\n400\n5403\nsend command failed!\n请再次使用此接口\n\n\n403\n5404\nremote control not allowed!\n远程控制操作需要后台开启\n\n\n404\n5405\nattrs not exist!\n\n\n\n500\n5406\nDatapoints malformed\n\n\n\n500\n5407\ngenerate meta failed\n\n\n\n400\n5408\nraw data error!\n\n\n\n500\n5409\ncall innerapi failed!\n\n\n\n404\n5501\nfirmware does not exist\n\n\n\n400\n5502\nfirmware version has created\n\n\n\n403\n5503\nfirmware operation not allowed\n\n\n\n500\n5601\nkairosdb query error!\n\n\n\n403\n5701\nThis eid has no permission to reset pwd.\n\n\n\n403\n5702\nThis eid has no permission to reset pwd for this appid.\n\n\n\n400\n5703\nCannot reset pwd for anonymous user\n\n\n\n400\n5801\nthe pks has not associate with enterprise!\n\n\n\n400\n5901\nx-service secret key invalid!\n\n\n\n"},{"title":"iOS App消息推送集成指南","url":"/zh-cn/AppDev/iOS消息推送.html","content":"概述\n机智云APP开源框架集成了百度推送与极光推送功能，只需修改部分代码即可快速使用。本文档就如何基于机智云APP开源框架快速集成消息推送功能，如需了解开源框架，请参考快速入门的文档。\n快速集成极光推送\n1. 申请极光AppKey与Master Secret\n1.1 创建极光应用\n点击链接https://www.jiguang.cn/app/form创建极光应用\n\n如图，需要上传苹果开发者证书，包括开发证书和生产证书以及证书的密码。\n1.2 申请苹果证书\n登陆苹果开发者中心：https://developer.apple.com， 申请并下载cer证书，双击证书从钥匙串打开，选中证书，并选择《登陆》和《我的证书》，右击证书，导出P12证书。\n\n点击《导出》会弹出以下弹框，设置证书名称及存储路径\n\n点击存储，弹出密码输入框，设置证书密码\n\n1.3 导入证书到极光\n成功导入证书如下图，会显示《已验证》\n\n至此极光应用已经创建完成，应用生成的AppKey和Master Secret也可以正常使用\n\n2. 在云端绑定第三方推送\n2.1 申请开通D3 Engine\n\n\n开通D3 Engine需要机智云审核通过，点击开通服务后需要联系机智云FAE协助审核开通。\n2.2 云端绑定极光推送\n通过审核后，可以在服务一栏看到D3 Engine，依次点击“配置”->” 编辑推送平台”\n\n将从极光申请到的应用App Key和 Master Secret填写到下图，并选择测试环境。\n注意：选择证书类型为《开发》时，只有在开发环境APP才能收到推送消息\n\n\n2.3 利用D3 Engine创建推送规则\n\n点击项目列表->新建项目，下面将演示创建一个设备上线后给APP推送消息的规则。\n\n拖动“设备数据”框到右边空白处，并双击该栏目。\n\n将触发方式设为“设备上线”，点击确定。\n\n双击“APP推送”，并设置推送的内容。\n\n\n\n\n3. 修改UIConfig.json代码\n填写jpush_app_key，以及将push_type设为1，表示选择极光推送，并且填写绑定了该极光应用的机智云应用于app_id、app_secret、product_key的值中。\n\n4. XCode配置推送\n打开项目，选择Targets –> Capabilities，开启Push Notifications的按钮，即开启了项目的远程推送功能。\n\n开启推送按钮后，会自动生成一个.entitlements文件，如下，其中的红框中的值表示推送环境，development表示开发环境，distribution表示生产环境。设置值为development时推送只在开发环境生效，distribution时推送只在生产环境生效。\n\n5. 启动虚拟设备\n\n6. 部署APP运行\n通过以上步骤，该APP已具备了极光推送功能，部署到手机上后，申请帐号并登录，通过扫码即可绑定云端的虚拟设备。\n\n7. 测试推送功能\n关闭虚拟设备后，再次开启，即可看到手机收到了推送消息。\n\n8. 极光自定义推送声音\n D3引擎支持向每条规则设置特定的推送声音，主要需要做两个地方的修改。\n8.1 设置推送声音\n  打开某条推送规则如下：\n  \n选择APP推送方块（上图红框部分）：\n\n点击《显示json样例》:\n\nExample的具体内容如下：\n{\n  \"baidu\": {\n    \"aps\": {\n      \"badge\": 0,\n      \"sound\": \"default\"\n    },\n    \"notification_builder_id\": 0,\n    \"notification_basic_style\": 0\n  },\n  \"jiguang\": {\n    \"ios\": {\n      \"sound\": \"sound.caf\",\n      \"badge\": 1\n    },\n    \"android\": {\n      \"builder_id\": 0,\n      \"alert_type\": 1,\n      \"style\": 1\n    }\n  }\n}\n这里做的是iOS的极光推送，假如推送声音名称为《pushMusic.caf》，则高级参数需要填写的内容如下：\n{\n  \"jiguang\": {\n    \"ios\": {\n      \"sound\": \"pushMusic.caf\",\n      \"badge\": 1\n    }\n  }\n}\n具体如图：\n\n点击《确定》保存设置即完成推送声音的设置\n注意：\"badge\"这个参数是设置推送后APP显示的角标内容，当设置为1时，APP收到推送显示的角标为1，不过按照正常的逻辑应该是APP收到多条推送会自动累加角标数，如果这里填1，那不管推送多少条通知，角标一直都为1。\n如果要角标根据消息数量累加，即把\"badge\": 1去掉即可，没有设置的话，极光会默认做累加操作。\n8.2 添加推送声音文件到项目\n当在D3成功设置自定义推送声音之后，每当有推送消息推到APP中，系统会先去APP中查找是否有相关名称的声音文件，有：则播放该声音，没有：则播放系统默认的声音。\n推送声音的音频格式包括aiff，wav，caf 文件，并且播放时间必须在30s内，文件也必须放到 app 的 mainBundle 目录中，有其中一个条件不满足，系统都会播放默认通知声音来替代。\n添加音频文件到项目如下：\n\n至此自定义推送声音设置结束，推送相关消息APP将播放设置的音频。\n快速集成百度推送\n1. 申请百度API KEY\n1.1 创建百度应用\n进入百度云推送平台：http://push.baidu.com，创建应用并配置证书\n\n如上图，需要上传苹果pem格式的开发证书和生产证书。\n1.2 申请苹果证书\n申请cer证书并导出p12的过程见《快速集成极光推送》的1.2部分，下图示范如何从p12证书导出pem证书\n进入《终端》，输入如下命令即可导出pem证书。\nopenssl pkcs12 -in  <p12证书名称>  -out  <pem证书名称>  -nodes\n\n1.3 导入证书到百度推送\n上传pem证书到《1.1 创建百度应用》所示图中，上传证书成功，会显示《已验证》，并且生成百度推送的API KEY 和 SECRET KEY。\n\n2. 在云端绑定第三方登陆\n2.1 申请开通D3 Engine\n  该步骤可参考《快速集成极光推送》的2.1部分\n2.2 云端绑定百度推送\n\n将从百度云推送平台申请到的应用API Key和Secret Key填写到下图，并选择测试环境。\n注意：选择证书类型为《开发》时，只有在开发环境APP才能收到推送消息\n\n\n2.3 利用D3 Engine创建推送规则\n该步骤可参考《快速集成极光推送》的2.3部分\n3. 修改UIConfig.json代码\n填写bpush_app_key，修改push_type为2，表示选择百度推送, 并且填写绑定了该百度应用的机智云应用于app_id、app_secret、product_key的值中。\n\n注意：这里也需要设置XCode推送，详情看《快速集成极光推送》的《4 XCode配置推送》\n4. 修改百度推送的启动接口\n百度推送的启动接口有一个pushMode参数，分别有两个值BPushModeDevelopment 和 BPushModeProduction。\nBPushModeDevelopment：设置百度推送环境为开发环境\n当设置的环境与当前APP的运行环境相符合是，推送才会生效。\n\n5. 启动虚拟设备\n该步骤可参考《快速集成极光推送》的第5部分\n6. 部署APP运行\n通过以上步骤，该APP已具备了百度推送功能，部署到手机上后，申请帐号并登录，通过扫码即可绑定云端的虚拟设备。\n\n7. 测试推送功能\n关闭虚拟设备后，再次开启，即可看到手机收到了推送消息。\n\n8. 百度自定义推送声音\n8.1 设置推送声音\n  进入到推送声音设置界面如下，如何进入请参考极光的《极光自定义推送声音的8.1部分》\n\n获取Example的具体内容如下：\n{\n  \"baidu\": {\n    \"aps\": {\n      \"badge\": 0,\n      \"sound\": \"default\"\n    },\n    \"notification_builder_id\": 0,\n    \"notification_basic_style\": 0\n  },\n  \"jiguang\": {\n    \"ios\": {\n      \"sound\": \"sound.caf\",\n      \"badge\": 1\n    },\n    \"android\": {\n      \"builder_id\": 0,\n      \"alert_type\": 1,\n      \"style\": 1\n    }\n  }\n}\n这里做的是iOS的百度推送，假如推送声音名称为《pushMusic.caf》，则高级参数需要填写的内容如下：\n{\n  \"baidu\": {\n    \"aps\": {\n      \"badge\": 0,\n      \"sound\": \"pushMusic.caf\"\n    }\n  }\n}\n设置完成如下：\n\n点击《确定》保存，即完成推送声音的设置\n8.2 添加推送声音文件到项目\n这部分请参考文档上方《极光自定义推送声音的8.2部分》\n常见问题FAQ\n1、开发者一定要开通D3 Engine才能使用消息推送吗？\n解答：是的，目前D3 Engine只针对于企业开发者用户。所以，只有企业开发者才能申请开通使用。\n2、使用极光推送按照以上步骤完成代码修改，但是却无法收到推送消息。\n解答：\n步骤一：查看XCode的推送开关是否被开启，详情看《2.4 XCode配置推送》。\n步骤二：查看项目的.entitlements文件的key值是否与当前的测试环境相符合\ndistribution表示生产环境，\ndevelopment表示开发环境\n步骤三：确定项目的BundleID是否与证书的Bundle ID一致\n注意：若是百度推送，还需要确定启动百度推送方法所设置的pushMode是否与当前的测试环境一致，详情查看《快速集成百度推送》的《4 修改百度推送的启动接口》\n如经过以上三个步骤，还是无法推送，则需要通过推送平台推送来确认问题\n步骤四：登陆极光/百度平台的应用，测试一下直接从推送平台上推送通知是否能够到达APP。\n推送平台单推不可以推的情况：\n1）确定证书是否已经失效，考虑更换证书。\n推送平台单推可以推的情况：\n1）    确认在机智云D3  Engine设置的推送环境是否与当前测试环境一致，如下图的《证书类型》\n2）    确认机智云应用绑定的推送APPID和Secret是否与APP中所使用的相对应，如下图\n\n3）    若依然失败，则在如下图位置打断点，打印result的值，确定具体的错误码，根据错误码提示来确认问题并修正。\n\n通常result有错，需要从下图所示代码来进一步确认。\n\n3、极光推送如何设置角标的值\n解答：[JPUSHService setBadge:0];  \n"},{"title":"iOS开源框架使用指南（含源码）","url":"/zh-cn/AppDev/iosframe.html","content":"开源框架简介\n机智云APP开源框架是使用机智云SDK开发的APP模板，实现了SDK的加载、初始化、用户注册、用户登陆、设备配置、设备发现、设备连接、设备列表等基本的功能。APP开源框架是一个可以编译的源码工程，对所有开发者开源，目前提供iOS和Android版本。APP开发者可以在框架上实现具体产品的控制页面就可以生成一个完整的APP。\n本文档为机智云物联网开源基础App套件使用说明，旨在为机智云物联网开发者提供一个快速开发模板，可在此工程基础上进行快速开发或参考相关代码进行开发。\niOS开源框架工程源码链接：\nhttps://git.oschina.net/dantang/GizOpenSource_AppKit_iOS\niOS Gokit App是使用开源框架工程的源码范例，源码链接：\nhttps://git.oschina.net/dantang/GoKit_Demo_iOS\n也可在下载中心下载：\n\n框架目录结构说明\nA. Library: 包括 GizWifiSDK 在内的的第三方库目录\nB. GizOpenSourceModules: 组成模块\n\nCommonModule: 公共方法类、资源文件 及 自定义 Cell\nConfigModule: 设备配置模块，包含 AirLink 及 SoftAP\nUserModule: 用户模块，包含 用户登录、用户注册、找回密码\nDeviceModule: 设备模块，包含 设备列表\nSettingsModule: 设置模块，包含 设置菜单 及其 包含的子菜单项（关于等）\nPushModule: 推送模块，包含 百度和极光的推送SDK 集成封装\n\n快速集成指南\n1.设定初始化参数\n默认程序入口在 UserModule 中的 LoginViewController。在工程的GOpenSourceModules/CommonModule/UIConfig.json 文件中可填写机智云AppID及AppSecret以及程序样式。\n如果使用第三方登录或推送，需要填写相应的从其他资源平台申请的参数；如果使用推送需要打开当前需要使用推送的类型的宏注释，如果都为注释状态则表示当前不使用第三方推送，同时只支持一种第三方推送，不可打开多个第三方推送宏定义的注释。\n可配置参数有：\n\napp_id：机智云 app id\napp_secret：机智云 app secret\nproduct_key：机智云 product key\nwifi_type_select：默认配置模块wifi模组选择功能是否开启\ntencent_app_id：qq登录 app id\nwechat_app_id：微信登录 app id\nwechat_app_secret：微信登录 app secret\npush_type：推送类型 【0：关闭，1：极光，2：百度】\njpush_app_key：极光推送 app key\nbpush_app_key：百度推送 app key\nopenAPIDomain：openAPI 域名及端口，格式：“api.gizwits.com”。要指定端口，格式为：”xxx.xxxxxxx.com:81&8443”\nsiteDomain：site 域名及端口，格式：“site.gizwits.com”。要指定端口，格式为：”xxx.xxxxxxx.com:81&8443”\npushDomain：推送绑定服务器 域名及端口，格式：“push.gizwits.com”。要指定端口，格式为：”xxx.xxxxxxx.com:81&8443”\nbuttonColor：按钮颜色\nbuttonTextColor：按钮文字颜色\nnavigationBarColor：导航栏颜色\nnavigationBarTextColor：导航栏文字颜色\nconfigProgressViewColor：配置中界面 progress view 颜色\nstatusBarStyle：状态文字栏颜色 【0：黑色，1：白色】\naddDeviceTitle：添加设备界面 导航栏标题文字\nqq：是否打开QQ登录【true：打开】\nwechat：是否打开微信登录【true：打开】\nanonymousLogin：是否打开匿名登录【true：打开】\n\n2.加载控制界面\n1）框架工程内提供的代码已经可以在不修改任何代码的前提下，进行到控制界面的跳转操作，开发者只需要关心操作界面的逻辑即可。如果需要在设备列表界面中点击某设备后，跳转到自己创建的控制器视图中，请在 AppDelegate.m 文件中修改相应跳转参数。请按图所示修改引入的头文件及跳转视图的类定义，如果使用默认提供的空白界面（GosDeviceController）来进行编写控制界面，可略过此步骤。\n2）在控制界面中设置 GizWifiDeviceDelegate 委托的代理，例如：\nself.device.delegate = self;\n3）在控制界面中定义类的委托回调，实现 SDK的GizWifiDeviceDelegate 委托的方法：\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)data withSN:(NSNumber *)sn;\n用于接收SDK上报的设备状态变化通知，将接收到的上报数据解析并更新界面。\n4）实现控制命令下发，需要调用SDK中GizWifiDevice类实例的接口方法：\n\n(void)write:(NSDictionary *)data withSN:(int)sn;\n具体参数解释，请参考SDK使用文档。\n\n5）退出控制界面时，需要取消当前设备订阅，调用SDK中GizWifiDevice类实例的接口方法，将参数设为NO：\n- (void)setSubscribe:(BOOL)subscribed;\n3.设置界面增加菜单项及点击处理\n如果需要在设置界面进行列表项的增加或修改，需要操作设置模块（SettingsModule）中的GosSettingsViewController类文件，在 .m 文件中找到 UITableView 的委托方法，进行修改。\n常见问题\nA、支持哪些iOS版本？\n目前支持iOS 7及更高版本系统。\nB、如何更改关于界面中的版本号？\n关于版本号由两部分构成，格式为：工程版本号.程序编译时间，其中程序版本号是在info里设置的版本号，程序编译时间为年份后两位、月、日，共6位组成。如果需要修改显示效果，需要到设置模块（SettingsModule）的关于界面（GosAboutViewController）的viewDidLoad 方法中修改属性appVersionLabel的赋值。\n重要提示\n查阅《APP代码自动生成服务介绍》，可了解自动生成的APP代码模块具备哪些功能\n查阅《APP开源框架》，可了解\n\niOS开源框架使用指南\n\niOS App消息推送集成指南\n\niOS App集成第三方登录与换肤指南\n\niOS App快速开发实例\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送集成指南\nAndroid App集成第三方登录与换肤指南\nAPICloud开源框架使用指南\n\n查阅《APP开发SDK》，可随心开发IoT APP（很多细节设计，均可在里面找到应用案例）\n\niOS SDK 2.0集成指南\nAndroid SDK 2.0集成指南\nAPICloud SDK使用指南\nSDK数据透传方法解析\nSDK调试日志抓取教程\nSDK错误码表\n\n更多应用开发\n\n应用开发FAQ\n设备分享功能使用流程\n第三方登录平台申请流程\n\n"},{"title":"iOS SDK 2.0集成指南","url":"/zh-cn/AppDev/iOSSDKA2.html","content":"SDK_API参考手册\n附件：iOS_SDK2.0_API参考手册\n设备接入SDK概述\n1.    SDK目的与功能\n机智云的设备接入SDK（以下简称SDK）封装了手机（包括PAD等设备）与机智云智能硬件的通讯过程，以及手机与云端的通讯过程。这些过程包括配置入网、发现、连接、控制、心跳、状态上报、报警通知等。使用SDK，可以使得开发者快速完成APP开发，开发者仅需关注APP的UI和UE设计即可，而相对复杂的协议与错误处理等事项可忽略。\n相比之下，SDK在新接口定义上做了进一步的简化，使用流程更加简单了。APP已经完全不需要了解设备连接方面的概念，可以更专注于APP用户体验的优化设计。\n2.    机智云物联方案概况\n\n3.    找到最合适的SDK\n机智云目前提供3套SDK：iOS平台原生SDK、Android平台原生SDK、APICloud跨平台SDK。开发者可以根据项目需要自行选择，其中APICloud版本SDK可以用H5技术一次开发，同时适配iOS和Android两个平台，具体内容请参考：《APICloud SDK 集成指南》。\n4.    相关名词定义\n4.1.    GAgent\n全称Gizwits Agent，运行于Wi-Fi模块中，设备通过GAgent接入机智云服务器。 目前已兼容国内主流的Wi-Fi模块， 开发者也可以通过获取GAgent二次开发包实现自定义的模块接入机智云。\n4.2.    小循环\n智能设备与手机、智能设备与智能设备之间，通过连接同一个路由器实现局域网内部的通信（查看状态或控制），我们称之为小循环。\n4.3.    大循环\n智能设备通过路由器或直接接入互联网以实现用户的远程监测与控制，我们称为大循环。\n4.4.    ProductKey\n产品标识码，开发者通过机智云后台创建新产品后，自动生成的一个32位字符串。在机智云的数据库中是一个唯一的号码，开发者完成开发写入设备主控MCU后，机智云通过此标识码对设备进行识别并自动完成注册。\n4.5.    DID\n设备号，当一个设备初次接入机智云时，机智云自动根据ProductKey以及设备Wi-Fi模块MAC地址为此设备注册一个did，此did全网唯一，用于与用户的绑定及后续操作。\n4.6.    PassCode\n设备通行证，用于校验用户的绑定/控制权限。当用户发起设备绑定时，只要是合法操作即可拿到此通行证，通过此通行证绑定设备并对设备进行有效期内的查看、控制等操作。GAgent首次运行时生成随机数作为设备通行证，生成后保存在非易失性存储器上。设备上线时需要上报给服务器。\n4.7.    AppID\n应用标识码，当开发者需要为一款智能产品开发应用（包括iOS、Android、Web应用等）时，后台会自动生成一个AppID，并与此设备进行关联。应用开发时需要填入此AppID。\n4.8.    Onboarding\n也叫配置入网，用户将一款基于Wi-Fi的物联网设备配置连接上路由器的过程称为Onboarding。新设备第一次使用时需要知道路由器的账号和密码，以通过路由器连接互联网。由于大多数的物联网设备没有自带的屏幕和键盘，所以需要通过智能手机向设备发送路由器的SSID和密码，这个过程机智云称为Onboarding。机智云提供的Wi-Fi设备接入SDK中已经内置了此配置的功能。\n4.9.    AirLink\n机智云对各种SmartConfig、SmartLink这种UDP广播报方式对设备配置入网的技术统称，兼容了多个Wi-Fi模块厂商的配置协议，总结了一套良好用户体验的标准Onboarding操作流程，机智云的Wi-Fi 设备接入SDK已经内置AirLink技术。\n4.10.    SoftAP\n由于目前各个Wi-Fi模块厂商的Smart Config协议均未完全成熟，也不支持5G路由器信号。机智云在提供了AirLink配置模式的同时也支持SoftAP模式配置设备接入路由器。当设备进入SoftAP配置模式时，设备本身将成为一个AP，智能手机可直接与设备进行连接，然后在手机上的界面上输入路由器的SSID和密码，设备接收到信息的时候会自动尝试连接路由器，连接成功则自动切换到正常使用的模式。\n5.    集成准备\n5.1.    注册机智云账号\n在使用机智云服务前，你需要通过site.gizwits.com\n注册一个开发者账号。请完整填写你的注册信息。\n此部分请参考《快速入门》。\n5.2.    新建设备接入\n此部分请参考《快速入门》。\n5.3.    获得 app ID 和产品标识码（productkey）\n此部分请参考《快速入门》。\n5.4.    下载SDK\n \n5.5.    导入SDK\n首先双击解开压缩包 GizWifiSDK-iOS-xxx.zip。按照App开发的需要，可以选择使用动态库或者静态库。以下分别为动态库和静态库的加载方式：\n5.5.1.    导入动态SDK\n动态库在解压后的DynamicLibrary目录下。动态库加载请注意按照下图进行设置，否则应用运行后会立即崩溃：\n\n5.5.2.    导入静态SDK\n第一步，解压后，将StaticLibrary目录下的文件添加到指定的工程中：\n\n第二步，下载并添加依赖库OpenSSL。下载完成双击解压后，将lib-ios拷贝到项目目录，并添加到指定的工程中。\n\n\n第三步，如果使用的是Xcode7.2以下版本，需要添加AudioToolbox、SystemConfiguration、CoreTelephony库。\n\n第四步，一定要记得在Info.plist设置支持ATS特性，否则iOS9下某些功能无法正常使用\n\n最后，确保工程里面有这些链接库，SDK就添加完成了:\n \n5.6.    通过cocoapods使用GizWifiSDK（可选）\n第一步：确认本机安装的cocoapods能正常工作\npod --help\n第二步：编辑工程对应的Podfile文件\n\n #Uncomment this line to define a global platform for your project  #\nplatform :ios, '6.0'\n #source 'https://github.com/gizwits/PodSpecs.git' \n Source ‘https://git.oschina.net/dantang/PodSpecs.git’  \n #以上两个源选一个即可\ntarget 'cocoapodsTest' do   pod 'GizWifiSDK', '2.04.04' end\n\n第三步：安装\npod install --no-repo-update\n第四步：打开workspace工程即可\nSDK流程简介\n1.    通用流程图\n \n2.    关键点说明\n1)    SDK已经封装了所有的用户、配置、发现、连接、控制的过程，开发者使用这些API可以完成上述流程中的功能开发，不需要再自行实现通讯协议。\n2)    SDK采取回调的工作方式，所以必须设置必要的委托，比如通用委托和设备委托，具体请参见流程详解。SDK在主线程中给APP回调。\nSDK流程详解\n1.    初始化部分\n1.1.    初始化部分流程图\n \n1.2.    引用头文件\nimport <GizWifiSDK/GizWifiSDK.h>\n1.3.    设置SDK通用委托\n注册SDK通用委托是为了能让APP收到来自GizWifiSDK类的响应事件，包含了注册、登录、配置设备、绑定设备等回调接口。这是SDK使用中十分重要的一个委托，与GizWifiSDK类相关的操作都会在这里会回调。如果没有正确注册通用委托，将无法正常使用SDK。注册委托时，APP可以根据自己的需求实现回调接口。\n1.4.    初始化SDK\nSDK启动前，任何功能都是无法正常使用的。SDK启动时，会进行SDK初始化，并自动发现当前局域网设备。SDK将通过通用委托，上报已发现的设备以及相应的事件。APP可以先设置SDK的通用委托，再启动SDK，以便处理这些事件通知。\nSDK启动时需要指定应用程序的AppID，开发者需要先在机智云网站上为自己的APP申请一个AppID，请在应用的AppDelegate中调用该方法指定应用的AppID。该方法只需要调用一次。\nSDK的日志可以帮助开发者发现APP运行时发生的问题。SDK默认将所有日志信息输出到调试终端和日志文件中，日志文件保存在应用程序的Documents\\GizWifiSDK\\GizSDKLog目录下。APP如果不希望在调试终端输出日志，可以通过日志级别设置接口，把日志输出级别修改为GizLogPrintNone。\n【示例代码】\n[GizWifiSDK shareInstance].delegate = self;\n[GizWifiSDK startWithAppID:@\"your_app_id\"];\n\n\n// 实现系统事件通知回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didNotifyEvent:(GizEventType)eventType eventSource:(id)eventSource eventID:(GizWifiErrorCode)eventID eventMessage: (NSString *)eventMessage {\nif(eventType == GizEventSDK) {\n// SDK发生异常的通知\nNSLog(@\"SDK event happened: [%@] = %@\", @(eventID), eventMessage);\n} else if(eventType == GizEventDevice) {\n// 设备连接断开时可能产生的通知\nGizWifiDevice* mDevice = (GizWifiDevice*)eventSource;\nNSLog(@\"device mac %@ disconnect caused by %@\", mDevice.macAddress, eventMessage);\n} else if(eventType == GizEventM2MService) {\n// M2M服务返回的异常通知\nNSLog(@\"M2M domain %@ exception happened: [%@] = %@\", (NSString*)eventSource, @(eventID), eventMessage);\n} else if(eventType == GizEventToken) {\n// token失效通知\nNSLog(@\"token %@ expired: %@\", (NSString*)eventSource, eventMessage);\n}\n}\n\n2.    用户部分\n机智云的用户系统包含了用户的注册、登录、重置密码、修改个人信息等功能，机智云以APPID区分用户系统，不同APPID的用户系统相互独立。更换APPID后，需要重新注册用户。\n以下流程中涉及到的监听器注册方法是用子类继承基类的方式实现的。\n2.1.    用户部分主要流程图\n \n用户的注册方式有多种，比如手机号、普通用户名、邮箱等，APP可以根据需要采取不同的方式。其他流程比如登录、密码修改、个人信息修改等部分，请直接阅读下面的流程文档。\n2.2.    用户注册\n机智云提供三种用户注册方式：手机注册、普通用户注册、邮箱注册。\n2.2.1.    注册手机用户\n通过手机注册账号，需要一个有效的手机号。注册时需要两步操作：获取短信验证码、用短信验证码注册用户。\n第一步：获取短信验证码。SDK向云端发送短信验证码请求，如果请求成功，云端会给手机发送短信验证码。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] requestSendPhoneSMSCode:@\"your_app_secret\" phone:@\"your_phone_number\"];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRequestSendPhoneSMSCode:(NSError *)result token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 请求成功\n    } else {\n        // 请求失败\n    }\n}\n\n第二步：用短信验证码注册。APP把手机收到的短信验证码传给SDK，填上手机号和密码就可以注册了。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] registerUser:@\"your_phone_number\" password:@\"your_password\" verifyCode:@\"your_verify_code\" accountType:GizUserPhone];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRegisterUser:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 注册成功\n    } else {\n        // 注册失败\n    }\n}\n\n2.2.2.    注册普通用户\n注册普通用户，使用用户名、密码即可创建一个账号。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] registerUser:@\"your_user_name\" password:@\"your_password\" verifyCode:nil accountType:GizUserNormal];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRegisterUser:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 注册成功\n    } else {\n        // 注册失败\n    }\n}\n\n2.2.3.    注册邮箱用户\n通过有效的电子邮箱地址，注册一个账号。注册成功后，云端会给指定邮箱发送注册成功的邮件。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] registerUser:@\"your_email_address\" password:@\"your_password\" verifyCode:nil accountType:GizUserEmail];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRegisterUser:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 注册成功\n    } else {\n        // 注册失败\n    }\n}\n\n2.3.    用户登录\n机智云提供三种用户登录方式：实名登录、匿名登录、第三方账号登录。实名登录适用于设计了登录界面，必须使用用户名密码注册登录以后才能使用的APP。匿名登录适用于没有设计登录界面，由后台自动生成用户账号的APP。登录后获取到的token有效期为7天。\n2.3.1.    实名登录\n实名用户登录时，用户名可以是注册过的手机号、邮箱、普通用户名。登录账号要先注册好，如果更换了AppID，登录账号需要重新注册。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] userLogin:@\"your_user_name\" password:@\"your_user_password\"]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didUserLogin:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 登录成功\n    } else {\n        // 登录失败\n    }\n}\n\n2.3.2.    匿名登录\n用户每次匿名登录时，获取到的uid是相同的。匿名用户登录时，如果账号不存在，系统会根据设备唯一标识码，生成一个匿名账号，并登录该账号。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] userLoginAnonymous];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didUserLogin:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 登录成功\n    } else {\n        // 登录失败\n    }\n}\n\n2.3.3.    第三方账号登录\n目前支持的第三方账号有百度、新浪、腾讯。用户可以使用这三者的API获取到uid和token登录机智云，使用第三方账号登录时无需在机智云上注册，可直接登录。\n开发者可通过新浪、百度或腾讯api获取uid和token, 具体方法请参考各第三方平台的开发者文档。也可以使用以下工具获取第三方账号uid、token：\nShareSDK http://mob.com/\nBaiduSDK http://developer.baidu.com/wiki/index.php?title=%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E9%A6%96%E9%A1%B5/%E7%99%BE%E5%BA%A6%E5%B8%90%E5%8F%B7%E8%BF%9E%E6%8E%A5\n【示例代码】\n// 以新浪账号为例\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] userLoginWithThirdAccount:GizThirdSINA uid:@\"your_third_uid\" token:@\"your_third_token\"]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didUserLogin:(NSError *)result uid:(NSString *)uid token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 登录成功\n    } else {\n        // 登录失败\n    }\n}\n\n2.4.    重置密码\n如果忘记了用户密码，可以通过手机验证码或邮箱设置新的密码。SDK支持手机号重置密码和邮箱重置密码两种，手机号重置需要接收验证码，邮箱重置需要进⼊邮箱，根据链接提示进行重置。\n2.4.1.    手机号重置密\n手机号重置密码时，需要先获取短信验证码再重置。获取短信验证码方式与手机注册时相同。\n第一步：获取短信验证码\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] requestSendPhoneSMSCode:@\"your_app_secret\" phone:@\"your_phone_number\"];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didRequestSendPhoneSMSCode:(NSError *)result token:(NSString *)token {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 请求成功\n    } else {\n        // 请求失败\n    }\n}\n\n第二步：用短信验证码重置密码\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] resetPassword:@\"your_phone_number\" verifyCode:@\"your_verify_code\" newPassword:@\"your_new_password\" accountType:GizUserPhone]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserPassword:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 修改成功\n    } else {\n        // 修改失败\n    }\n}\n\n2.4.2.    邮箱重置密码\n邮箱重置密码时，云端会给指定邮箱发送安全链接。用户需要到邮箱中查收邮件，并按邮件指示执行重置操作。重置密码邮件有可能进入用户的邮箱的垃圾箱中，需提醒用户。\n邮件发送成功回调与密码修改成功回调一致，因此需要注意在回调的时候区分。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] resetPassword:@\"your_email_address\" verifyCode:nil newPassword:@\"your_new_password\" accountType:GizUserEmail]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserPassword:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n            //重置密码邮件发送成功，提示用户查收\n    } else {\n            //重置密码邮件发送失败，弹出错误信息\n    }\n}\n\n2.5.    修改密码\n用户登录后可以修改密码。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] changeUserPassword:@\"your_token\" oldPassword:@\"your_old_password\" newPassword:@\"your_new_password\"]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserPassword:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 修改成功\n    } else {\n        // 修改失败\n    }\n}\n\n2.6.    匿名用户转换\n匿名注册的用户可以转换为普通用户或者手机用户，转换后匿名用户的信息会转移到实名用户下，原匿名账号失效。但普通用户和手机用户必须是还未注册过的，已注册的用户名是无法转换的。\n2.6.1.    匿名用户转普通用户\n转普通用户时，填入待转换的用户名、密码，以及登录的token就可以了。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] transAnonymousUser:@\"your_token\" username:@\"your_user_name\" password:@\"your_password\" verifyCode:nil accountType:GizUserNormal]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didTransAnonymousUser:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 转换成功\n    } else {\n        // 转换失败\n    }\n}\n\n2.6.2.    匿名用户转手机用户\n转手机用户时，需要填入待转换的手机号、密码、短信验证码，登录的token。获取短信验证码的过程与手机注册时一样。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] transAnonymousUser:@\"your_token\" username:@\"your_phone_number\" password:@\"your_password\" verifyCode:@\"your_verify_code\" accountType:GizUserPhone]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didTransAnonymousUser:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 转换成功\n    } else {\n        // 转换失败\n    }\n}\n\n2.7.    修改用户信息\n实名用户不支持修改普通用户名，可以修改邮箱、手机号，可以补充个人信息。实名用户必须登录后才能修改这些信息，并且待修改的邮箱或手机号必须是已经注册过的。\n实名用户修改邮箱或手机号成功后，可以使用修改后的邮箱或手机号登录。登录后获得的绑定设备列表与原实名用户一致。\n修改邮箱或手机号时，可以同时补充个人信息。不想修改个人信息时，对应参数可以传nil。同时修改个人信息时，如果邮箱或用户名修改成功而个人信息修改失败，回调会返回成功并在errorMessage中提示个人信息修改失败的原因。\n2.7.1.    修改用户邮箱\n只修改用户邮箱时，个人信息的参数传nil，用户类型可以指定为邮箱用户。以下为修改用户邮箱的示例代码。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:@\"your_email_address\" SMSVerifyCode:nil userType:GizUserEmail additionalInfo:nil]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 修改成功\n    } else {\n        // 修改失败\n    }\n}\n\n2.7.2.    修改用户手机号\n只修改用户手机号时，个人信息参数传nil，用户类型可以指定为手机用户。修改手机号之前，需要先获取手机验证码。以下示例代码为修改用户手机号的代码，获取短信验证码的代码请参考手机号注册。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:@\"your_phone_number\" SMSVerifyCode: @\"your_verify_code\" userType:GizUserPhone additionalInfo:nil]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 修改成功\n    } else {\n        // 修改失败\n    }\n}\n\n2.7.3.    修改用户个人信息\n只修改用户个人信息时，手机号或邮箱参数传nil，用户类型可以指定为普通用户。个人信息包含多项内容，通过GizUserInfo类指定。其中不想修改的信息填nil，云端会保留上次修改过的值。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n\nGizUserInfo* additialInfo = new GizUserInfo();\nadditialInfo.name = @\"nickname\";\nadditialInfo.userGender = GizUserGenderMale;\nadditialInfo.birthday = @\"1990-1-1\";\nadditialInfo.address = @\"Beijing\";\nadditialInfo.remark = @\"home\";\n\n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:nil SMSVerifyCode:nil userType:GizUserNormal additionalInfo:additialInfo]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 修改成功\n    } else {\n        // 修改失败\n    }\n}\n\n2.7.4.    同时修改邮箱和个人信息\n修改邮箱同时修改个人信息时，用户类型需指定为邮箱用户。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n\nGizUserInfo* additialInfo = new GizUserInfo();\nadditialInfo.name = @\"nickname\";\nadditialInfo.userGender = GizUserGenderMale;\nadditialInfo.birthday = @\"1990-1-1\";\nadditialInfo.address = @\"Beijing\";\nadditialInfo.remark = @\"home\";\n\n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:@\"your_email_address\" SMSVerifyCode:nil userType:GizUserEmail additionalInfo:additialInfo]; \n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 修改成功\n    } else {\n        // 修改失败\n    }\n}\n\n2.7.5.    同时修改手机号和个人信息\n修改手机号同时修改个人信息时，用户类型需指定为手机用户。修改手机号同样需要先获取手机验证码，获取短信验证码的代码请参考手机号注册。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n\nGizUserInfo* additialInfo = new GizUserInfo();\nadditialInfo.name = @\"nickname\";\nadditialInfo.userGender = GizUserGenderMale;\nadditialInfo.birthday = @\"1990-1-1\";\nadditialInfo.address = @\"Beijing\";\nadditialInfo.remark = @\"home\";\n\n[[GizWifiSDK sharedInstance] changeUserInfo:@\"your_token\" username:@\"your_phone_number\" SMSVerifyCode: @\"your_verify_code\" userType:GizUserPhone additionalInfo:additialInfo];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didChangeUserInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 修改成功\n    } else {\n        // 修改失败\n    }\n}\n\n3.    配置设备入网部分\n控制设备前，需要先让设备连到路由器上。连上路由器的设备，如果路由器能接入外网，设备会自动注册到机智云。\n有两种配置方式能够让设备连到路由器上，一种是Airlink方式，一种是Softap方式，APP可以根据产品需求采取相应的配置方式。在开始配置前，设备要先进入配置模式，然后APP调用配置接口发送要配置的路由器ssid和密码。设备配置成功后，SDK给APP返回已配置成功的设备mac地址和产品类型标识，便于APP做下一步的操作。如果设备是重置后进入的配置模式，如果配置成功时设备还来不及从云端获取到DID，则APP得到的DID为空。\nSDK的设备配置接口如果超时时间还未结束，无法进行下一次配置。此外，因为设备配置成功的广播包只有APP连到同一路由上才能收取，因此这个超时时间应该预留出APP连接到路由器的时间。\n需要注意的是，如果配置上线的设备不是APP要获取的产品类型，该设备就不会出现在设备列表中。\n3.1.    设备配置流程图\n \n3.2.    AirLink配置\nAirLink使⽤UDP广播方式，由手机端发出含有目标路由器名称和密码的广播，设备上的Wifi模块接收到广播包后自动连接目标路由器，连上路由器后发出配置成功广播，通知手机配置已完成。\n模块开启AirLink模式后，如果一分钟内未收到AirLink广播或无法正确连上路由器，将进入SoftAP模式。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] setDeviceOnboarding:@\"your_ssid\" key:@\"your_key\" mode:GizWifiAirLink softAPSSIDPrefix:nil timeout:60 wifiGAgentType:[NSArray arrayWithObjects: @(GizGAgentESP), nil]];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didSetDeviceOnboarding:(NSError *)result mac:(NSString *)mac did:(NSString *)did productKey:(NSString *)productKey {\nif(result.code == GIZ_SDK_SUCCESS) {\n// 配置成功\n} else {\n// 配置失败\n}\n}\n\n3.3.    SoftAP配置\n设备进入SoftAP模式后，会产生一个Wifi热点。手机连上此热点后，将要配置的SSID和密码发给设备。设备上的Wi-Fi模块接收到SoftAP配置包后自动连接目标路由器，与airlink一样，连上路由器后发出配置成功广播，通知手机配置已完成。\n使用机智云提供的模组固件，设备产生的Wifi热点以“XPG-GAgent-”开头，密码为” 123456789”。其他厂商提供的模组，SoftAP热点名称由各自厂商指定。APP可以根据需要传入正确的热点前缀。\n【示例代码】\n// MCU发出进入SoftAP串口指令，通知模组开启SoftAP模式。\n详情请参考《智能云空调-机智云接入串口通信协议文档》\n//让手机连接模组的SoftAP热点\n\n//配置设备入网，发送要配置的wifi名称、密码 \n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] setDeviceOnboarding:@\"your_ssid\" key:@\"your_key\" mode:GizWifiSoftAP softAPSSIDPrefix: @\"your_gagent_hotspot_prefix\" timeout:60 wifiGAgentType:nil]];\n\n//模块收到配置信息，尝试连接路由器并自动关闭热点\n//让手机连接到配置的wifi上\n\n//等待配置完成或超时，回调配置完成接口\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didSetDeviceOnboarding:(NSError *)result mac:(NSString *)mac did:(NSString *)did productKey:(NSString *)productKey {\n        if(result.code == GIZ_SDK_SUCCESS) {\n            // 配置成功\n        } else {\n            // 配置失败\n        }\n}\n\n4.    设备发现和订阅部分\n4.1.    设备发现和订阅流程图\n \n4.2.    设备发现\nAPP设置好委托，启动SDK后，就可以收到SDK的设备列表推送。每次局域网设备或者用户绑定设备发生变化时，SDK都会主动上报最新的设备列表。设备断电再上电、有新设备上线等都会触发设备列表发生变化。用户登录后，SDK会主动把用户已绑定的设备列表上报给APP，绑定设备在不同的手机上登录帐号都可获取到。\n如果APP想要刷新绑定设备列表，可以调用绑定设备列表接口，同时可以指定自己关心的产品类型标识，SDK会把筛选后的设备列表返回给APP。\nSDK提供设备列表缓存，设备列表中的设备对象在整个APP生命周期中一直有效。缓存的设备列表会与当前最新的已发现设备同步更新。\n【示例代码】\n// 使用缓存的设备列表刷新UI\nNSArray* devices = [GizWifiSDK sharedInstance].deviceList;\n\n// 接收设备列表变化上报，刷新UI\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didDiscovered:(NSError *)result deviceList:(NSArray *)deviceList {\n        // 提示错误原因\n        if(result.code != GIZ_SDK_SUCCESS) {\n            NSLog(@\"result: %@\", result.localizedDescription);\n        }\n        // 显示变化后的设备列表\n        NSLog(@\"discovered deviceList: %@\", deviceList);\n        devices = deviceList;\n}\n\n// 主动刷新绑定设备列表、指定筛选的设备productKey\n[GizWifiSDK sharedInstance].delegate = self; \n[[GizWifiSDK sharedInstance] getBoundDevices:@\"your_uid\" token:@\"your_token\" specialProductKeys:[NSArray arrayWithObjects: @\"your_product_key\", nil]];\n\n4.3.    设置设备的委托\n在设备列表中得到设备对象，为其设置设备委托，以便于刷新设备UI。APP根据自己的需要实现相应的回调。\n4.4.    设备订阅和绑定\nAPP得到设备列表后，给设备设置委托后，可以订阅设备。已订阅的设备将被自动绑定和自动登录，设备登录成功后会主动上报最新状态。\n自动绑定仅限于局域网设备。对于无法在局域网内发现的设备，APP可以通过手动绑定的方式完成绑定。绑定成功的设备，需要订阅后才能使用。\n无论是手动绑定还是自动绑定，设备的remark和alias信息，都需要在设备绑定成功后再设置。\n解除订阅的设备，连接会被断开，不能再继续下发控制指令了。\n4.4.1.    设备订阅\n所有通过SDK得到的设备，都可以订阅，订阅结果通过回调返回。订阅成功的设备，要在其网络状态变为可控时才能查询状态和下发控制指令。\n【示例代码】\n// 以设备列表中的第一个设备实例为例，为其设置委托 \nGizWifiDevice* mDevice = nil;\nfor (int i = 0; i < deviceList.count; i++) {\n    mDevice = deviceList[0];\nmDevice.delegate = self;\n[mDevice setSubscribe:YES];\nbreak;\n}\n\n// 实现回调\n- (void)device:(GizWifiDevice *)device didSetSubscribe:(NSError *)result isSubscribed:(BOOL)isSubscribed {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 订阅或取消订阅成功\n    }\n}\n\n4.4.2.    非局域网设备绑定\nAPP可以通过设备的mac、productKey、productSecret完成非局域网设备的绑定,可以用上述信息生成二维码，APP通过扫码方式绑定。GPRS设备、蓝牙设备等都是无法通过Wifi局域网发现的设备，都属于非局域网设备。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self;\n[[GizWifiSDK sharedInstance] bindRemoteDevice:@\"your_uid\" token:@\"your_token\" mac:@\"your_mac\" productKey:@\"your_product_key\" productSecret:@\"your_product_secret\"];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didBindDevice:(NSError *)result did:(NSString *)did {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 绑定成功\n    } else {\n        // 绑定失败\n    }\n}\n\n4.4.3.    设置设备绑定信息\n不订阅设备也可以设置设备的绑定信息。在设备列表中找到要修改的设备，如果是已绑定的，就可以修改remark和alias信息。\n【示例代码】\n// mDevice是从设备列表中获取到的设备实体对象，为其设置委托\nmDevice.delegate = self;\n[mDevice setCustomInfo:@\"your_remark\" alias:@\"your_alias\"]; \n\n// 实现回调\n- (void)device:(GizWifiDevice *)device didSetCustomInfo:(NSError *)result {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 修改成功\n    } else {\n        // 修改失败\n    }\n}\n\n4.5.    设备解绑\n已绑定的设备可以解绑，解绑需要APP调用接口完成操作，SDK不支持自动解绑。对于已订阅的设备，解绑成功时会被解除订阅，同时断开设备连接，设备状态也不会再主动上报了。设备解绑后，APP刷新绑定设备列表时就得不到该设备了。\n【示例代码】\n[GizWifiSDK sharedInstance].delegate = self;\n[[GizWifiSDK sharedInstance] unbindDevice:@\"your_uid\" token:@\"your_token\" did:@\"your_did\"];\n\n// 实现回调\n- (void)wifiSDK:(GizWifiSDK *)wifiSDK didUnbindDevice:(NSError *)result did:(NSString *)did {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 解绑成功\n    } else {\n        // 解绑失败\n    }\n}\n\n4.6.    获取硬件信息\n不订阅设备也可以获取硬件信息。APP可以获取模块协议版本号，mcu固件版本号等硬件信息，但只有局域网设备才支持该功能。\n【示例代码】\n// mDevice是从设备列表中获取到的设备实体对象，为其设置委托\nmDevice.delegate = self;\n[mDevice getHardwareInfo]; \n\n// 实现回调\n- (void)device:(GizWifiDevice *)device didGetHardwareInfo:(NSError *)result hardwareInfo:(NSDictionary *)hardwareInfo {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 获取成功\n        NSString *hardWareInfo = [NSString stringWithFormat:@\"WiFi Hardware Version: %@,\\\nWiFi Software Version: %@,\\\nMCU Hardware Version: %@,\\\nMCU Software Version: %@,\\\nFirmware Id: %@,\\\nFirmware Version: %@,\\\nProduct Key: %@“\n, [hwInfo valueForKey: @\"wifiHardVersion\"]\n, [hwInfo valueForKey: @\"wifiSoftVersion\"]\n, [hwInfo valueForKey: @\"mcuHardVersion\"]\n, [hwInfo valueForKey: @\"mcuSoftVersion\"]\n, [hwInfo valueForKey: @\"wifiFirmwareId\"]\n, [hwInfo valueForKey: @\"wifiFirmwareVer\"]\n, [hwInfo valueForKey: @\"productKey\"];\n    } else {\n        // 获取失败\n    }\n}\n\n5.    设备控制部分\nSDK通过字典键值对方式进行设备控制和状态接收。SDK接收到APP下发的指令字典后，对应解析为设备可识别的数据，发送给设备。反之，SDK收到设备回复或上报的数据后，对应解析为字典键值对上报给APP。\n智能设备需正确烧写了GAgent固件和机智云串口通讯协议。如果设备定义了数据点，APP发送的指令必须符合数据点定义。如果设备没有定义数据点，设备指令可以按照透传数据以自定义格式下发。\n5.1.    设备控制流程图\n \n5.2.    发送控制指令\n设备订阅变成可控状态后，APP可以发送控制指令。控制指令是字典格式，键值对为数据点名称和值。操作指令的确认回复，通过didReceiveData回调返回。\nAPP下发操作指令时可以指定sn，通过回调参数中的sn能够对应到下发指令是否发送成功了。但回调参数dataMap有可能是空字典，这取决于设备回复时是否携带当前数据点的状态。\n如果APP下发指令后只关心是否有设备状态上报，那么下发指令的sn可填0，这时回调参数sn也为0。\n【示例代码】\n//在设备列表中得到设备对象，设置委托\nmDevice.delegate = self;\n\n// 对已订阅变为可控状态的设备，发送开灯指令\nint sn = 5;\n[self write: @{@\"LED_OnOff\": @(YES)} sn:@(sn)];\n\n// 实现回调\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)data withSN:(NSNumber *)sn {\nif(result.code == GIZ_SDK_SUCCESS) {\n    // 命令序号相符，开灯指令执行成功\nif (sn == 5) {\n}\n    } else {\n        // 执行失败\n    }\n}\n\n5.3.    接收设备状态\n设备订阅变成可控状态后，APP可以随时收到设备状态的主动上报，仍然通过didReceiveData回调返回。设备上报状态时，回调参数sn为0，回调参数dataMap为设备上报的状态。\n【示例代码】\n(void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)data withSN:(NSNumber *)sn {\n    //基本数据，与发送的数据格式⼀一致\n    NSDictionary *_data = [data valueForKey:@\"data\"];\n\n    // 报警\n    NSArray *alarms = [data valueForKey:@\"alerts\"];\n\n    // 故障\n    NSArray *faults = [data valueForKey:@\"faults\"];\n\n    //透传数据\n    NSDictionary *binary = [data valueForKey:@“binary\"];\n\n    //处理这些类型的数据\n}\n\n5.4.    设备状态查询\n设备订阅变成可控状态后，APP可以查询设备状态。设备状态查询结果也通过didReceiveData回调返回，回调参数sn为0。回调参数dataMap为设备回复的状态。\n【示例代码】\n// mDevice是从设备列表中获取到的设备实体对象，为其设置委托\nmDevice.delegate = self;\n[mDevice getDeviceStatus];\n\n- (void)device:(GizWifiDevice *)device didReceiveData:(NSError *)result data:(NSDictionary *)data withSN:(NSNumber *)sn {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 数据解析与3.5.3相同\n    } else {\n        // 查询失败\n    }\n}\n\n6. 设备定时任务\n通过给设备设置定时任务，可以让设备在预定的日期和时间执行某些操作。这些操作可以在一个月内的某几天重复，也可以在一周内的某几天重复。\n定时任务可以先设定好，然后在任何时候开始执行或停止执行。定时任务创建时默认开启。\n6.1. 流程图\n \n6.2. 创建定时任务\n定时任务可以重复执行，也可以只执行一次，重复执行分为按月重复和按周重复。但同时只能指定一种重复方式，即或者不重复或者按周重复或者按月重复。\n使用SDK接口时，按周重复时给变量weekDays传值，按月重复时给monthDays传值，但如果两个变量都传值则只会处理weekDays。\n下面分别以这三种情况举例说明。\n6.2.1. 创建一次性定时任务\n假设我们需要在2017年1月16日早上6点30分开灯。如下代码中，日期和时间想要设置为几月几日几时几分，就设定为对应的值。\n比如我们希望设定的是2017年1月16日早上6点30分，那么date为2017-01-16，time为06:30，其中time是24小时制，date按照示例代码格式传值即可。\n【示例代码】\n// 设置定时任务委托\n[GizDeviceSchedulerCenter setDelegate:self];\n\n// 一次性定时任务，在2017年1月16日早上6点30分开灯\nGizDeviceScheduler *scheduler = [[GizDeviceScheduler alloc] init];\nscheduler.date = @\"2017-01-16\";\nscheduler.time = @\"06:30\";\nscheduler.remark = @\"一次性开灯任务\";\nscheduler.attrs = @{@\"LED_OnOff\": @YES};\n\n// 创建设备定时任务，mDevice为在设备列表中得到的设备对象\n[GizDeviceSchedulerCenter createScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice scheduler:scheduler]; \n\n// 实现回调\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 定时任务创建成功\n    } else {\n        // 创建失败\n    }\n}\n\n6.2.2. 创建按周重复的定时任务\n我们现在让定时任务按周重复执行，现在要每周的周一至周五早上6点30分都开灯。\n【示例代码】\n// 设置定时任务委托\n[GizDeviceSchedulerCenter setDelegate:self];\n\n// 每周一到周五重复执行的定时任务\nGizDeviceScheduler *scheduler = [[GizDeviceScheduler alloc] init];\nscheduler.time = @\"06:30\";\nscheduler.weekDays = @[@GizScheduleMonday, @GizScheduleTuesday, @GizScheduleWednesday, @GizScheduleThursday, @GizScheduleFriday];\nscheduler.remark = @\"按周重复执行的开灯任务\";\nscheduler.attrs = @{@\"LED_OnOff\": @YES};\n\n// 创建设备的定时任务，mDevice为在设备列表中得到的设备对象\n[GizDeviceSchedulerCenter createScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice scheduler:scheduler]; \n\n// 实现回调\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 定时任务创建成功\n    } else {\n        // 创建失败\n    }\n}\n\n6.2.3. 创建按月重复的定时任务\n我们现在让定时任务按周重复执行，现在要每个月的1号、15号早上6点30分都开灯。\n注意不要同时设置按周重复，如果同时设置了按周重复，按月重复会被忽略。\n【示例代码】\n// 设置定时任务委托\n[GizDeviceSchedulerCenter setDelegate:self];\n\n// 每月1号和15号重复执行的定时任务\nGizDeviceScheduler *scheduler = [[GizDeviceScheduler alloc] init];\nscheduler.time = @\"06:30\";\nscheduler.monthDays = @[@1, @15];\nscheduler.remark = @\"按月重复执行的开灯任务\";\nscheduler.attrs = @{@\"LED_OnOff\": @YES};\n\n// 创建设备的定时任务，mDevice为在设备列表中得到的设备对象\n[GizDeviceSchedulerCenter createScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice scheduler:scheduler]; \n\n// 实现回调\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 定时任务创建成功\n    } else {\n        // 创建失败\n    }\n}\n\n6.3. 获取定时任务列表\n创建定时任务后，可以通过查询得到已经创建好的所有定时任务列表。得到定时任务列表后，可以对已经创建好的定时任务做修改或删除。\n【示例代码】\n// 设置定时任务委托\n[GizDeviceSchedulerCenter setDelegate:self];\n\n// 同步更新设备的定时任务列表，mDevice为在设备列表中得到的设备对象\n[GizDeviceSchedulerCenter updateSchedulers:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice]; \n\n// 实现回调\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 定时任务列表同步更新成功\n    } else {\n        // 同步更新失败\n    }\n}\n\n6.4. 修改定时任务\n可以修改已经创建好的定时任务。修改时，从获取到的定时任务列表中取出定时任务对象，编辑好要修改的内容。\n注意，一旦定时任务创建好之后，就被分配了一个ID，这个ID是不能被修改的。\n【示例代码】\n// 设置定时任务委托\n[GizDeviceSchedulerCenter setDelegate:self];\n\n// 把之前创建好的一次性定时任务修改成每月1号和15号重复执行的定时任务，scheduler是定时任务列表中要修改的定时任务对象\nscheduler.time = @\"06:30\";\nscheduler.remark = @\"开灯任务\";\nscheduler.attrs = @{@\"LED_OnOff\": @YES};\nscheduler.monthDays = @[@1, @15];\n\n// 修改设备的定时任务，mDevice为在设备列表中得到的设备对象\n[GizDeviceSchedulerCenter editScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice scheduler:scheduler]; \n\n// 实现回调\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 定时任务修改成功\n    } else {\n        // 修改失败\n    }\n}\n\n6.5. 删除定时任务\n在得到的定时任务列表中，找到要删除的定时任务ID，删除定时任务。\n【示例代码】\n// 设置定时任务委托\n[GizDeviceSchedulerCenter setDelegate:self];\n\n// 删除设备的定时任务列表，mDevice为在设备列表中得到的设备对象，your_scheduler_id是要删除的定时任务ID\n[GizDeviceSchedulerCenter deleteScheduler:@\"your_uid\" token:@\"your_token\" schedulerOwner:mDevice schedulerID:@\"your_scheduler_id\"]; \n\n// 实现回调\n- (void)didUpdateSchedulers:(GizWifiDevice*)schedulerOwner result:(NSError*)result schedulerList:(NSArray*)schedulerList {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 定时任务删除成功\n    } else {\n        // 删除失败\n    }\n}\n\n7. 设备分享\n用户绑定设备后，可以通过设备分享的方式让其他人使用设备。设备分享提供了更好的设备权限管理，在多用户使用同一个设备时提供了更安全、更便捷的设备绑定方式。设备绑定权限分为四种：\n\nOwner：设备的主账号，可以分享设备；\nGuest：设备的分享账号，可以接受分享邀请，不能再分享设备给其他人；\nSpecial：最早绑定设备但还未分享设备的账号，分享设备后即成为设备的主账号；\nNormal：其他已绑定了设备的账号，不能分享设备，也不能成为设备的主账号；\n\n只有最早绑定设备的账号或设备的主账号才能分享设备。一旦设备有了主账号，其他人就无法再绑定了。主账号可以查看设备的当前已绑定用户，可以解绑其他用户。在设备没有主账号时，其他用户仍然可以绑定这个设备。\n7.1. 流程图\n \n7.2. 创建设备分享邀请\n分享设备之前，先检查自己有哪些可以分享的设备。App可以遍历查找SDK提供的设备列表，找到那些绑定权限为GizDeviceSharingSpecial或者GizDeviceSharingOwner的，就可以创建分享邀请了。\n有两种方式可以创建分享邀请：账号分享和二维码分享。\n7.2.1. 账号分享\n账号分享时，对方账号可以是手机号、邮箱、普通用户名或者匿名账号，但必须是已经在机智云注册过的用户。如果该用户已经是这个设备的Guest账号或者已经绑定了这个设备，分享邀请会创建失败。账号分享邀请的有效期为24小时，即对方必须在24小时内作出响应，否则账号邀请会过期失效。\n账号分享时要指定账号类型，匿名账号的guestUser参数填匿名账号的uid。账号分享创建成功时，回调参数中会返回sharingID，但不会返回QRCodeImage。下面仅以手机号分享举例：\n【示例代码】\n// 设置设备分享委托\n[GizDeviceSharing setDelegate:self];\n\n// 在设备列表中找到可以分享的设备\n\n// 通过手机号分享设备\n[GizDeviceSharing sharingDevice:@\"your_token\" deviceID: @\"your_device_id\" sharingWay:GizDeviceSharingByNormal guestUser:@\"guest_phone_number\" guestUserType:GizUserPhone]; \n\n// 实现回调\n- (void)didSharingDevice:(NSError*)result deviceID:(NSString*)deviceID sharingID:(NSInteger)sharingID QRCodeImage:(UIImage*)QRCodeImage {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 分享邀请创建成功\n    } else {\n        // 创建失败\n    }\n}\n\n7.2.2. 二维码分享\n二维码分享时，二维码有效期为15分钟，即对方必须在15分钟内扫描生成的二维码并作出响应，否则二维码邀请会过期失效。二维码分享邀请创建成功时，回调参数中会返回sharingID，同时还会返回对应的二维码图片QRCodeImage，App直接加载图片即可。\n【示例代码】\n// 设置设备分享委托\n[GizDeviceSharing setDelegate:self];\n\n// 在设备列表中找到可以分享的设备\n\n// 二维码分享设备\n[GizDeviceSharing sharingDevice:@\"your_token\" deviceID: @\"your_device_id\" sharingWay:GizDeviceSharingByQRCode guestUser:nil guestUserType:GizUserOther]; \n\n// 实现回调\n- (void)didSharingDevice:(NSError*)result deviceID:(NSString*)deviceID sharingID:(NSInteger)sharingID QRCodeImage:(UIImage*)QRCodeImage {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 分享邀请创建成功\n    } else {\n        // 创建失败\n    }\n}\n\n7.3. 接受分享邀请\nGuest账号可以查询发给自己的设备分享邀请，只有Guest账号可以接受分享邀请。\n7.3.1. 接受账号分享邀请\nGuest查询到的分享邀请如果是还未接受的状态，可以接受或者拒绝邀请。\n【示例代码】\n// 设置设备分享委托\n[GizDeviceSharing setDelegate:self];\n\n// 查询发给自己的分享邀请列表\n[GizDeviceSharing getDeviceSharingInfos:@\"your_token\" sharingType: GizDeviceSharingToMe deviceID: @\"your_device_id\"];\n\n// 实现获取分享邀请列表的回调\n- (void)didGetDeviceSharingInfos:(NSError*)result deviceID:(NSString*)deviceID deviceSharingInfos:(NSArray*)deviceSharingInfos {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 获取成功。找到deviceSharingInfos中状态为未接受的分享邀请，your_sharing_id为要接受的分享邀请\n        NSInteger your_sharing_id = -1;\n        for (int i = 0; i < deviceSharingInfos.count; i++) {\n            GizDeviceSharingInfo* mDeviceSharing = [deviceSharingInfos objectAtIndex:i];\n            if (mDeviceSharing.status == GizDeviceSharingNotAccepted) {\n                your_sharing_id = mDeviceSharing.id;\n                break;\n            }\n        }\n\n        // 接受邀请\n        if (your_sharing_id != -1) {\n            [GizDeviceSharing acceptDeviceSharing:@\"your_token\" sharingID:your_sharing_id accept:YES];\n        }\n    } else {\n        // 获取失败\n    }\n}\n\n// 实现接受分享邀请的回调    \n- (void)didAcceptDeviceSharing:(NSError*)result sharingID:(NSInteger)sharingID {\n    if(result.code == GIZ_SDK_SUCCESS) {\n        // 接受成功\n    } else {\n        // 接受失败\n    }\n}\n\n8. 重要提示\n查阅《APP代码自动生成服务介绍》，可了解自动生成的APP代码模块具备哪些功能\n查阅《APP开源框架》，可了解\n\niOS开源框架使用指南\n\niOS App消息推送集成指南\n\niOS App集成第三方登录与换肤指南\n\niOS App快速开发实例\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送集成指南\nAndroid App集成第三方登录与换肤指南\nAPICloud开源框架使用指南\n\n查阅《APP开发SDK》，可随心开发IoT APP（很多细节设计，均可在里面找到应用案例）\n\niOS SDK 2.0集成指南\nAndroid SDK 2.0集成指南\nAPICloud SDK使用指南\nSDK数据透传方法解析\nSDK调试日志抓取教程\nSDK错误码表\n\n更多应用开发\n\n应用开发FAQ\n设备分享功能使用流程\n第三方登录平台申请流程\n\n"},{"title":"Gizwits Open API（新）","url":"/zh-cn/Cloud/openapi_apps.html","content":"\nWindows 平台按 Ctrl + F 打开快捷搜索\nMac 平台按 command + F 打开快捷搜索\n\n概述\n机智云是一个开放的物联网设备平台，它为企业和个人开发者提供设备接入、用户账号管理、用户与设备绑定管理、设备远程监控、定时任务以及设备高级数据等服务。\n这些数据都是存储在机智云的数据库中的。那么作为开发者，如何去访问这些数据呢？\nOpen API 就是机智云对外提供这些数据的访问接口！\n接口列表\n根据机智云提供的服务，Open API 提供如下功能:\n\n用户管理：用户的注册、登录、密码重置等功能\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_users\n获取用户信息\n\n\npost_app_users\n创建新用户\n\n\nput_app_users\n修改用户信息\n\n\npost_app_login\n用户登录\n\n\npost_app_request_token\n获取APP Token\n\n\npost_app_reset_password\n请求重置密码\n\n\npost_app_sms_code\n验证码的获取和校验\n\n\nget_app_verify_codes\n获取图片验证码\n\n\npost_app_verify_codes\n校验图片验证码\n\n\nput_app_verify_codes\n校验短信验证码\n\n\n\n\n消息中心：用户查看消息、标记已读和删除系统消息等功能\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_messages\n查询消息列表\n\n\nput_app_messages\n标记消息已读和删除\n\n\n\n\n绑定管理：用户与设备的绑定、解绑等功能\n\n\n\n\nAPI列表\n描述\n\n\n\n\npost_app_bind_mac\n通过 MAC 地址绑定设备\n\n\ndelete_app_bindings\n解除设备\n\n\nget_app_bindings\n获取绑定列表\n\n\npost_app_bind_latest\n通过二维码绑定设备\n\n\nput_app_bindings_did\n修改绑定信息\n\n\nget_app_did_bindings\n解绑 Guest 用户\n\n\n\n\n设备远程监控:获取设备的当前状态、设备上报的原始数据、设备的上下线记录、设备的远程控制等功能\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_devdata_did_latest\n获取设备最新状态\n\n\nget_app_datapoint\n获取产品数据点定义\n\n\nget_app_devices_did\n获取设备详情\n\n\nget_app_devices_did_raw_data\n获取设备的通信日志和上下线记录\n\n\npost_app_control_did\n远程控制设备\n\n\n\n\n设备分享:比如用户把自己的绑定设备分享给其他用户，解绑其他用户对自己设备的绑定等\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_sharing\n查询分享邀请\n\n\npost_app_sharing\n创建分享邀请\n\n\ndelete_app_sharing_id\n取消/收回分享\n\n\nput_app_sharing_id\n接受/拒绝分享\n\n\nget_app_sharing_code\n获取二维码分享信息\n\n\npost_app_sharing_code\n接受二维码分享邀请\n\n\nput_app_sharing_idalias\n修改用户备注信息\n\n\npost_app_sharing_did_transfer\nowner 权限转移\n\n\n\n\n设备分组:对多个设备进行分组，发送一次指令就能控制分组下的多个设备\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_group\n查询用户所有的分组\n\n\npost_app_group\n创建分组\n\n\ndelete_app_group_id\n删除设备分组\n\n\nput_app_group_id\n修改分组信息\n\n\nget_app_group_id_devices\n查询分组的设备信息\n\n\npost_app_group_id_devices\n将设备列表添加到分组\n\n\ndelete_app_group_id_devices\n将设备列表从分组移除\n\n\npost_app_group_id_control\n对设备分组内的设备统一控制\n\n\n\n\n设备联动:通过创建设备间联动规则，当设备触发规则后，联动控制其他设备。\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_rules_params\n查询规则可用变量\n\n\nget_app_rules\n查询联动规则列表\n\n\npost_app_rules\n创建联动规则\n\n\ndelete_app_rules\n删除联动规则\n\n\nput_app_rules\n修改联动规则\n\n\n\n\n用户场景:用户可通过场景功能预设的一系列设备动作并在需要时触发。\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_scene\n查询用户所有的场景\n\n\npost_app_scene\n创建场景\n\n\ndelete_app_scene_id\n删除场景\n\n\nput_app_scene_id\n修改场景信息\n\n\nget_app_scene_id_task\n查询场景任务执行状态\n\n\npost_app_scene_id_task\n执行场景任务\n\n\n\n\n定时任务管理:设备定时任务的增删改查等\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_devices_scheduler\n获取定时任务\n\n\npost_app_devices_scheduler\n创建定时任务\n\n\ndelete_app_devices_scheduler\n删除定时任务\n\n\nput_app_devices_scheduler\n修改定时任务\n\n\n\n\n通用定时任务:可对单个设备、设备分组和场景设置定时任务。\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_common_scheduler\n获取定时任务\n\n\npost_app_common_scheduler\n创建定时任务\n\n\ndelete_app_common_scheduler\n删除定时任务\n\n\nput_app_common_scheduler\n修改定时任务\n\n\n\n\n高级数据接口:比如对设备上报的数据按天取最大值、平均值等\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_app_bindings\n获取设备聚合数据\n\n\n\n\n系统信息:比如查看当前 Open API 版本，获取所有可能的错误列表等\n\n\n\n\nAPI列表\n描述\n\n\n\n\nget_status\n查询服务状态信息\n\n\nget_errors\n错误状态码列表\n\n\n\n协议约定\n请求方式\n机智云 Open API 是 RESTful 风格的 HTTP API，您可以使用任何标准的 HTTP 客户端访问机智云 Open API。\n推荐 HTTP 客户端：\n\nGUI 客户端 PostMan\n命令行客户端 curl\n\nHTTP头部请求说明\nX-Gizwits-Application-Id\nX-Gizwits-Application-Id 简称 AppID，是一个应用在机智云平台中的唯一标识，所有 OpenAPI 接口都需要传入这个头部参数。\n在开发者中心的产品页面中，点击左边栏的\"应用配置\"菜单，创建一个应用即可获得一个 AppID:\n\nX-Gizwits-User-token\nX-Gizwits-User-token 简称 UserToken，它代表着接口调用中的用户上下文。\nUserToken 具有有效期，默认为 7 天。\n可以通过用户注册或者登录接口获取 UserToken，返回字段中的 token 就是 UserToken，expire_at 表示 UserToken 过期的时间戳：\n{\n  \"uid\": \"29db4f0d806e451a84264ba3da64d9de\",\n  \"token\": \"86a0ee91548f4971832e371811702316\",\n  \"expire_at\": 13894002020\n}\n\n每次登录可以获取一个新的 UserToken，新旧 UserToken 都可以使用。\n因为机智云 Open API 大多数的接口都是与用户相关的，所以一般的接口调用顺序如下：\n\n判断本地是否有 UserToken，以及 UserToken 是否过期\n如果不存在 UserToken 或者 UserToken 过期，调用用户登录接口，获取并保存 UserToken\n使用 UserToken 调用其它接口\n\n加密参数\n统一使用32位加密\nlower：小写\nUPPER：大写\n示例：\nlower(md5(product_secret + X-Gizwits-Timestamp ))\n选择md5，32位[小]进行加密，填入product_secret和X-Gizwits-Timestamp，无需“+”号，如下图所示\n\n在线调试 Open API\n我们提供了在线 API 调试工具，在每个接口描述中，都会给出对应的调试接口链接。\n下面以用户登录为例，说明 API 调试工具的使用：\n\n点击 用户登录 进入接口调试页面\n接口右边有个红色叹号，点击后弹出对话框，提示需要输入的头部信息\n该接口需要输入 X-Gizwits-Application-Id，根据前面的说明获取 AppID 并填入，点击 \"Authorize\" 进行授权\n页面自动刷新，并且叹号变成蓝色，表示需要输入的头部信息已填写（已填写并不一定表示值是正确的，如果值错误，会反应在接口返回内容中）\n在参数输入框中输入参数值（点击参数右边的 Example Value 黄色框框，可以快速输入示例 JSON）\n点击 \"试一下\" 按钮，即可完成接口调用\n接口调用完成，会显示本地调用等效的 curl 语句，请求 URL，响应体，响应码和响应头\n\n\n用户管理\n创建用户\n调试接口\n有以下几种方式可以创建新用户：\n\n匿名注册，通过唯一的 phone_id 创建用户\n用户名密码注册，通过 username 和 passowrd 创建用户\n手机注册，通过 phone, password 和 code（短信验证码）创建用户，短信验证码的获取参考下面章节\n邮箱注册，通过 email 和 password 创建用户\n第三方登录用户创建，通过authData内的 src、 uid 和 token 创建用户。目前支持腾讯QQ、新浪微博、百度、微信、Facebook、Twitter、Google+、Amazon\n\n第三方登录注意事项：\n\nGoogle 和 amazon 第三方登录，authData 里面的 token 需要带上 \"Bearer \" 开头\nQQ 和 Twitter 需要在开发者中心填写API_KEY和API_Secret\nFacebook、Twitter、Google、Amazon仅可在美东和欧洲环境使用\n\n密码强度要求：\n\n密码长度不小于 8 位\n必须由大写，小写，数字，特殊符号至少 3 种以上字符组合\n\n请求地址及地址\n  POST\n  http://api.gizwits.com/app/users\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nphone_id\nstring\n否\nbody\n匿名标识,匿名注册的请求参数\n\n\nusername\nstring\n否\nbody\n用户名,用户名密码注册的请求参数\n\n\npassword\nstring\n否\nbody\n密码,用户名密码注册、手机注册、邮箱注册的请求参数\n\n\nemail\nstring\n否\nbody\n邮件地址,邮箱注册的请求参数\n\n\nphone\nstring\n否\nbody\n手机号码,手机号码，手机注册的请求参数\n\n\ncode\nstring\n否\nbody\n验证码,短信验证码，手机注册的请求参数\n\n\nlang\nstring\n否\nbody\n语言:en，zh-cn\n\n\nsrc\nstring\n否\nbody\n平台类型:qq,sina,baidu,wechat,twitter,facebook,google, amazon\n\n\nuid\nstring\n否\nbody\n第三方登录平台返回的uid\n\n\ntoken\nstring\n否\nbody\n第三方登录平台返回的token\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nuid\nstring\n用户唯一id\n\n\ntoken\nstring\n用户token\n\n\nexpire_at\ninteger\ntoken过期时间（时间戳）\n\n\n\n返回例子\n{\n  \"token\": \"f8324047f20144f6914e7be19304f943\",\n  \"uid\": \"f082f4e235974cfeb6a1b40a6024f47e\",\n  \"expire_at\": 1504772734\n}\n\n\n获取用户信息\n调试接口\n请求地址及地址\n  GET\n  http://api.gizwits.com/app/users\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nusername\nstring\n用户名\n\n\nphone\nstring\n手机号码\n\n\nemail\nstring\n注册邮箱\n\n\nname\nstring\n姓名\n\n\ngender\nstring\n性别，M：男, F：女, N：未知\n\n\nbirthday\nstring\n生日，日期格式：YYYY-MM-DD or MM-DD\n\n\naddress\nstring\n地址\n\n\nlang\nstring\n语言版本en, zh-cn\n\n\nremark\nstring\n备注\n\n\nuid\nstring\n用户唯一id\n\n\nis_anonymous\nboolean\n是否匿名用户\n\n\n\n返回例子\n{\n    \"username\": \"gizwits\",\n    \"uid\": \"f082f4e235974cfeb6a1b40a6024f47e\",\n    \"phone\": \"18888888888\",\n    \"birthday\": \"2017-01-01\",\n    \"address\": \"guangzhou\",\n    \"lang\": \"zh-cn\",\n    \"remark\": \"remark\",\n    \"name\": \"gizwits\",\n    \"is_anonymous\": false,\n    \"gender\": \"M\",\n    \"email\": \"club@gizwits.com\"\n}\n\n修改用户信息\n调试接口\n有以下几种不同注册对应的修改方式\n\n匿名注册的用户转普通用户: 输入 username, password\n匿名注册的用户转手机用户: 输入 phone, password, code (通过获取验证码接口获取)\n修改密码: 输入 old_pwd, new_pwd\n修改手机号: 输入 phone, code (通过获取验证码接口获取)\n修改基本信息：姓名、性别、生日、地址、语言版本、备注\n\n请求地址及方式\n  PUT\n  http://api.gizwits.com/app/users\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nusername\nstring\n否\nbody\n用户名，用于匿名转普通用户\n\n\npassword\nstring\n否\nbody\n密码，用于匿名转普通用户\n\n\nphone\nstring\n否\nbody\n手机号码，用于匿名转手机注册用户\n\n\ncode\nstring\n否\nbody\n验证码，用于匿名转手机注册用户\n\n\nold_pwd\nstring\n否\nbody\n旧密码，用于修改密码\n\n\nnew_pwd\nstring\n否\nbody\n新密码，用于修改密码\n\n\nemail\nstring\n否\nbody\n注册邮箱，用于匿名转邮箱注册用户\n\n\nname\nstring\n否\nbody\n姓名\n\n\ngender\nstring\n否\nbody\n性别，M：男, F：女, N：未知\n\n\nbirthday\nstring\n否\nbody\n生日，日期格式：YYYY-MM-DD or MM-DD\n\n\naddress\nstring\n否\nbody\n地址\n\n\nlang\nstring\n否\nbody\n语言版本en, zh-cn\n\n\nremark\nstring\n否\nbody\n备注\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nupdatedAt\nstring\n修改时间(UTC时间)\n\n\n\n返回例子\n{\n  \"updatedAt\": \"2017-01-01T08:32:56.996638\"\n}\n\n用户登录\n调试接口\n匿名用户和第三方登录用户调用用户创建用户接口进行登录。\n请求地址及方式\n  POST\n  http://api.gizwits.com/app/login\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nusername\nstring\n是\nbody\n用户名，可以是用户的 username/email/phone\n\n\npassword\nstring\n是\nbody\n密码\n\n\nlang\nstring\n否\nbody\n语言版本\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nuid\nstring\n用户唯一id\n\n\ntoken\nstring\n用户token\n\n\nexpire_at\ninteger\ntoken过期时间（时间戳）\n\n\n\n返回例子\n{\n  \"token\": \"f8324047f20144f6914e7be19304f943\",\n  \"uid\": \"f082f4e235974cfeb6a1b40a6024f47e\",\n  \"expire_at\": 1504772734\n}\n\n获取APP Token\n调试接口\n该接口获取的token参数主要用于调用获取短信验证码和获取图片验证码接口时作为请求参数使用。\n请求地址及方式\nPOST  \nhttp://api.gizwits.com/app/request_token\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-Application-Auth\nstring\n是\nheader\nMD5_32位加密(appid + appsecret)\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nuid\nstring\n用户唯一id\n\n\nexpire_at\ninteger\ntoken过期时间（时间戳）\n\n\n\n返回例子\n{\n  \"token\": \"f8324047f20144f6914e7be19304f943\",\n  \"expire_at\": 1504772734\n}\n\n请求重置密码\n调试接口\n只有设置了 email 或者 phone 的用户才可以重置密码。\n\n通过 email 重置密码，只需传入 email ，通过邮件发送重置密码链接\n通过 phone 重置密码，传入 phone, new_pwd, code (通过调用获取短信验证码接口获取)\n\n请求地址及方式\nPOST\nhttp://api.gizwits.com/app/reset_password\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nemail\nstring\n否\nbody\n注册邮箱\n\n\nphone\nstring\n否\nbody\n注册手机号码\n\n\nnew_pwd\nstring\n否\nbody\n新密码\n\n\ncode\nstring\n否\nbody\n验证码\n\n\n\n响应参数\n无\n验证码的获取和校验\n调试接口\n短信验证码的主要用途有：\n\n手机号用户注册\n手机号用户重置密码\n其他您认为需要短信验证码的敏感操作\n\n接口能实现获取和校验验证码：\n\n获取短信验证码只需要传入 phone\n验证短信验证码需要传入 phone 和 code\n\n关于国外手机号\n\n发送短信验证码到国外手机号，需要遵循如下格式：+{国家码}{手机号}。假设一个美国（国家码为 1）的手机号为 4246531234，那么 phone 就应该填写为 \"+14246531234\"\n国家码列表可以通过这里获取。\n\n短信验证码正确校验后立即失效，默认有效期为 24 小时。\n请求地址及方式\n  POST\n  http://api.gizwits.com/app/sms_code\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token,通过获取APP Token接口取得\n\n\nphone\nstring\n是\nbody\n手机号码\n\n\ncode\nstring\n是\nbody\n验证码\n\n\n\n响应参数\n无\n获取图片验证码\n调试接口\n返回的 captcha_url 就是图片验证码的 URL，将图片显示给用户\n请求地址及方式\n  GET\n  http://api.gizwits.com/app/verify/codes\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token,通过获取APP Token接口取得\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\ncaptcha_url\nstring\n图片验证码URL地址\n\n\ncaptcha_id\nstring\n图片验证码id\n\n\n\n返回例子\n{\n  \"captcha_url\": \"http://api.gizwits.com/captcha/image/22d9cdc8edb13fd19f770afbed45351831403b5d/\",\n  \"captcha_id\": \"22d9cdc8edb13fd19f770afbed45351831403b5d\"\n}\n\n校验图片验证码并发送验证码\n调试接口\n对获取图片验证码接口的图片验证码进行校验，校验通过将发送短信验证码\n请求地址及方式\n  POST\n  http://api.gizwits.com/app/verify/codes\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token,通过获取APP Token接口取得\n\n\ncaptcha_id\nstring\n是\nbody\n图片验证码id\n\n\ncaptcha_code\nstring\n是\nbody\n图片验证码的值\n\n\nphone\nstring\n是\nbody\n手机号码\n\n\n\n响应参数\n无\n校验短信验证码\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/verify/codes\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token,通过获取APP Token接口取得\n\n\nphone\nstring\n是\nbody\n手机号码\n\n\nsms_code\nstring\n是\nbody\n验证码\n\n\n\n响应参数\n无\n消息中心\n查询消息列表\n调试接口\n获取用户的消息，如分享信息、D3规则推送的消息\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/messages?type=1&limit=20&skip=0\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ntype\ninteger\n是\nquery\n消息类型，1：设备分享消息\n\n\nlimit\ninteger\n否\nquery\n返回的结果条数\n\n\nskip\ninteger\n否\nquery\n表示跳过的条数，间接表示页数。\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\ntotal\ninteger\n消息总数\n\n\nlimit\ninteger\n返回的结果条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\nid\nstring\n消息id编号\n\n\ncreated_at\nstring\n消息创建时间（UTC时间）\n\n\nupdated_at\nstring\n消息更新时间（UTC时间）\n\n\ntype\ninteger\n消息类型，1：设备分享消息\n\n\nstatus\ninteger\n消息状态，0 未读，1 已读，2 删除\n\n\ncontent\nstring\n信息内容\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"total\": 50,\n    \"limit\": 1,\n    \"skip\": 0,\n    \"previous\": \"/app/messages?skip=5&type=1&limit=1\",\n    \"next\": \"/app/messages?skip=7&type=1&limit=1\"\n  },\n  \"objects\": [\n    {\n        \"status\": 0,\n        \"created_at\": \"2017-09-11T11:41:23Z\",\n        \"updated_at\": \"2017-09-11T11:41:23Z\",\n        \"content\": \"您给 188****888 共享了设备 微信宠物屋!\",\n        \"type\": 1,\n        \"id\": \"59b676638c7d500018a9ed98\"\n     },\n  ]\n}\n\n\n标记已读和删除消息\n调试接口\n将用户信息标记为已读和删除消息\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/messages/{id}?status=1\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\ninteger\n是\npath\n消息id编号\n\n\nstatus\ninteger\n是\nquery\n消息状态：1：已读，2：删除\n\n\n\n响应参数\n无\n绑定管理\n当设备与用户之间绑定后，设备与用户之间就会存在对应的“绑定角色”关系。\n绑定角色分为4种类，首绑用户: special ；拥有者: owner ；访客: guest ；普通用户: normal\n角色场景说明：\n\n当设备没有分享过且设备没有任何用户绑定过。A用户绑定该设备，A用户成为 special ， B用户再绑定该设备，B用户成为normal 。\n设当前A用户为 special ，B用户为 normal 。当A用户解除绑定，B用户成为 special ，A用户与该设备之间没有“绑定角色”关系。\n设当前A用户为 special ，B用户为 normal 。产品开启了设备分享，A用户将设备分享给C用户，无论C用户是否接受，A用户成为 owner，B用户变成 guest。\n当开启分享功能且设备没有任何用户绑定。A用户绑定该设备，A用户成为 owner ，其他用户无法再绑定该设备。\n设当前A用户为 owner ，C用户未绑定过该设备 。A用户将设备分享给C用户，且C用户接受分享。A用户成仍是 owner，C用户为 guest。\n设当前A用户为 owner ，B用户为 guest 。A用户将设备解除绑定，A用户和B用户与该设备之间没有“绑定角色”关系。\n除 owner 用户，其他用户无法分享设备，一个设备只有一个owner\n\n绑定设备\n可以通过一下两种方式绑定设备：\n\n通过 product_key 和 MAC 地址绑定设备\n通过二维码绑定设备，二维码内容为 product_key 和 MAC 加密后的内容，所以本质上和上面一种方式一样\n\n通过 MAC 地址绑定设备\n调试接口\n将用户与设备进行绑定\n请求地址及方式\n  POST\n  http://api.gizwits.com/app/bind_mac\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nX-Gizwits-Timestamp\nstring\n是\nheader\n请求时间戳，与服务器相差不能超过 5 分钟\n\n\nX-Gizwits-Signature\nstring\n是\nheader\n签名，计算方法为 lower(md5(product_secret + X-Gizwits-Timestamp ))\n\n\nproduct_key\nstring\n是\nbody\n产品product_key\n\n\nmac\nstring\n是\nbody\n设备mac地址\n\n\nremark\nstring\n否\nbody\n备注\n\n\ndev_alias\nstring\n否\nbody\n设备别名\n\n\nset_owner\ninteger\n否\nbody\n是否设置成 owner，只对开启了设备分享功能的产品有效；0（默认值）：不设置成owner，1：设置成owner\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nproduct_key\nstring\n产品product_key\n\n\ndid\nstring\n设备id\n\n\nmac\nstring\n设备mac地址\n\n\nis_online\nboolean\n是否在线\n\n\npasscode\nstring\n设备  passcode\n\n\nhost\nstring\n连接服务器的域名\n\n\nport\ninteger\nM2M 的 mqtt 端口号\n\n\nport_s\ninteger\nM2M 的 mqtt SSL 端口号\n\n\nws_port\ninteger\nwebsocket 端口号\n\n\nwss_port\ninteger\nwebsocket SSL 端口号\n\n\nremark\nstring\n设备备注\n\n\nis_disabled\nboolean\n是否注销\n\n\ntype\nstring\n设备类型，单品设备:normal,中控设备:center_control,中控子设备:sub_dev\n\n\ndev_alias\nstring\n设备别名\n\n\ndev_label\nArray[string]\n设备标签列表，目前用于语音 API 批量设备控制\n\n\nrole\nstring\n绑定角色， 特殊用户:special,拥有者:owner,访客:guest,普通用户:normal\n\n\n\n返回例子\n{\n    \"product_key\": \"4214bf2d79694a259232431b6f2ef46b\",\n    \"did\": \"gKufzxZwYeyd3Skbsb6mza\",\n    \"mac\": \"accf2350d446\",\n    \"is_online\": false,\n    \"passcode\": \"JHHOOIWJBA\",\n    \"host\": \"m2m.gizwits.com\",\n    \"port\": 1883,\n    \"port_s\": 8883,\n    \"ws_port\": 8080,\n    \"wss_port\": 8880,\n    \"remark\": \"备注信息\",\n    \"is_disabled\": false,\n    \"type\": \"normal\",\n    \"dev_alias\": \"设备别名\",\n    \"dev_label\": [],\n    \"role\": \"special\"\n\n}\n\n解绑设备\n调试接口\n用户已绑定的设备进行解绑\n请求地址及方式\n  DELETE\n  https://api.gizwits.com/app/bindings\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndevices\nArray\n是\nbody\n需要解绑的设备数组\n\n\ndid\nstring\n是\nbody\n设备ID\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nsuccess\nArray[string]\n解绑成功的设备\n\n\nfailed\nArray[string]\n解绑失败的设备\n\n\n\n返回例子\n{\n    \"failed\": [],\n    \"success\": [\n        \"xAAcCYawLFD9JfMysqYf7d\",\n        \"WCWGkbS4Ttynzwx9brzpEa\"\n    ]\n}\n\n获取绑定列表\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/bindings\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nlimit\ninteger\n否\nquery\n返回的结果条数\n\n\nskip\ninteger\n否\nquery\n表示跳过的条数，间接表示页数\n\n\nshow_disabled\ninteger\n否\nquery\n是否显示已注销的设备，1:显示，0:不显示\n\n\nshow_proto_ver\ninteger\n否\nquery\n是否显示设备通信协议版本，1:显示，0:不显示\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\ndevices\nArray\n绑定的设备组\n\n\nproduct_key\nstring\n产品product_key\n\n\ndid\nstring\n设备id\n\n\nmac\nstring\n设备mac地址\n\n\nis_online\nboolean\n是否在线\n\n\npasscode\nstring\n设备  passcode\n\n\nhost\nstring\n连接服务器的域名\n\n\nport\ninteger\nM2M 的 mqtt 端口号\n\n\nport_s\ninteger\nM2M 的 mqtt SSL 端口号\n\n\nws_port\ninteger\nwebsocket 端口号\n\n\nwss_port\ninteger\nwebsocket SSL 端口号\n\n\nremark\nstring\n设备备注\n\n\nis_disabled\nboolean\n是否注销\n\n\ntype\nstring\n设备类型，单品设备:normal,中控设备:center_control,中控子设备:sub_dev\n\n\ndev_alias\nstring\n设备别名\n\n\ndev_label\nArray[string]\n设备标签列表，目前用于语音 API 批量设备控制\n\n\nproto_ver\nstring\n协议版本号，'01', '01_01', '03', '04'\n\n\nwifi_soft_version\nstring\nwifi版本号\n\n\nis_sandbox\nboolean\n是否连接sandbox环境\n\n\nrole\nstring\n绑定角色， 首绑用户:special,拥有者:owner,访客:guest,普通用户:normal\n\n\n\n返回例子\n{\n    \"devices\": [\n      {\n          \"product_key\": \"55af63815cc34788aeeb9451a2454412\",\n          \"did\": \"7r7u8XPkCRLGVYTYrtjoCB\",\n          \"mac\": \"virtual:site\",\n          \"is_online\": false,\n          \"passcode\": \"123456\",\n          \"host\": \"sandbox.gizwits.com\",\n          \"port\": 1883,\n          \"port_s\": 8883,\n          \"ws_port\": 8080,\n          \"wss_port\": 8880,\n          \"remark\": \"备注信息\",\n          \"is_disabled\": false,\n          \"type\": \"normal\",\n          \"dev_alias\": \"设备别名\",\n          \"dev_label\": [],\n          \"proto_ver\": \"04\",\n          \"wifi_soft_version\": null,\n          \"is_sandbox\": true,\n          \"role\": \"special\"\n      },\n      {\n          \"product_key\": \"4214bf2d79694a259232431b6f22f46b\",\n          \"did\": \"gKufzxZwYeyd3Skbsb6mza\",\n          \"mac\": \"accf2350d447\",\n          \"is_online\": false,\n          \"passcode\": \"JHHOOIWJBA\",\n          \"host\": \"m2m.gizwits.com\",\n          \"port\": 1883,\n          \"port_s\": 8883,\n          \"ws_port\": 8080,\n          \"wss_port\": 8880,\n          \"remark\": \"备注信息\",\n          \"is_disabled\": false,\n          \"type\": \"normal\",\n          \"dev_alias\": \"设备别名\",\n          \"dev_label\": [],\n          \"proto_ver\": \"04\",\n          \"wifi_soft_version\": \"04000006\",\n          \"is_sandbox\": true,\n          \"role\": \"special\"\n      }\n    ]\n}\n\n通过二维码绑定设备\n调试接口\n必须是通过机智云的二维码生成服务(查看教程)生成的二维码才可以调用本接口。\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/bind_latest\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nqr_content\nstring\n是\nbody\n通过扫描二维码得出的字符串\n\n\nset_owner\ninteger\n否\nbody\n是否设置成 owner，只对开启了设备分享功能的产品有效；0（默认值）：不设置成owner，1：设置成owner\n\n\n\n响应参数\n无\n修改绑定信息\n调试接口\n用户可以对绑定的设备修改别名和备注。\n同一个设备被多个用户绑定，每个用户都可以对该设备设置别名和备注，互不冲突。\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/bindings/{did}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\ninteger\n是\npath\n设备ID\n\n\nremark\nstring\n否\nbody\n设备备注\n\n\ndev_alias\nstring\n否\nbody\n设备别名\n\n\ndev_label\nArray[string]\n否\nbody\n设备标签列表，目前用于语音 API 批量设备控制\n\n\n\n注：body的参数最少填写输入一个\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nremark\nstring\n设备备注\n\n\ndev_label\nArray[string]\n设备标签列表，目前用于语音 API 批量设备控制\n\n\ndev_alias\nstring\n设备别名\n\n\n\n返回例子\n{\n    \"remark\": \"备注\",\n    \"dev_label\": [\n        \"标签1\",\n        \"标签2\"\n    ],\n    \"dev_alias\": \"设备别名\"\n}\n\n查询设备绑定的Guest用户\n调试接口\n查看接受设备分享邀请的用户信息\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/{did}/bindings\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n设备ID\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nusername\nstring\n账号username,中间4个字母*替代\n\n\nphone\nstring\n账号phone,中间4个数字*替代\n\n\ncreated_at\nstring\nGuest 用户接受分享的时间（UTC时间）\n\n\nuid\nstring\nGuest用户的UID\n\n\nemail\nstring\n账号email,@前面4个字符*替代\n\n\n\n返回例子\n[\n    {\n        \"username\": \"2****2\",\n        \"phone\": null,\n        \"created_at\": \"2017-09-19T07:12:32Z\",\n        \"uid\": \"c0a85d0773e24f15a6853f3148c82313\",\n        \"email\": null\n    }\n]\n\n解绑 Guest 用户\n调试接口\nOwner 解除 Guest 用户对设备的绑定关系\n请求地址及方式\n  DELETE\n  https://api.gizwits.com/app/{did}/bindings\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n设备ID\n\n\nuid\nstring\n否\nquery\nguest 的 uid，不能是自己\n\n\n\n响应参数\n无\n设备远程监控\n获取设备最新状态\n调试接口\n该接口获取的是 24 小时内，设备最近一次上报的数据点值。\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/devdata/{did}/latest\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\ndid\nstring\n是\npath\n设备ID\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\ndid\nstring\n设备ID\n\n\nupdated_at\nstring\n最后更新时间\n\n\nattr\nobject\n数据点及其值\n\n\n\n返回例子\n{\n  \"did\": \"WCWGkbS42tynzwx9brzpEa\",\n  \"updated_at\": 1505809000,\n  \"attr\": {\n    \"alert_full\": 0,\n    \"alert_shutdown\": 0,\n    \"mode\": \"制冷\",\n    \"fan_swing\": 0,\n    \"switch\": 0,\n    \"fan_speed\": \"低风\",\n    \"fault_roomtemp\": 0,\n    \"room_temp\": -10,\n    \"set_temp\": 16,\n    \"off_timing\": 0,\n    \"on_timing\": 0\n  }\n}\n\n获取产品数据点定义\n调试接口\nAPI 调用限制\n\nAppID 和 product_key 关联\n\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/datapoint?product_key={product_key}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nproduct_key\nstring\n是\npath\n产品product_key\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nname\nstring\n产品名称\n\n\nentities\nArray\n[EntityItem]\n\n\nprotocolType\nstring\n固定值：standard\n\n\nproduct_key\nstring\n产品product_key\n\n\npacketVersion\nstring\n固定值：4\n\n\nui\ninline_model_7\n手机客户端 UI 定义\n\n\nEntityItem\n——————\n——————\n\n\nid\ninteger\n固定值：0\n\n\nname\nstring\n固定值：entity0\n\n\ndisplay_name\nstring\n固定值：机智云开发套件\n\n\nattrs\nArray\n[AttrItem]\n\n\ninline_model_7\n——————\n——————\n\n\nobject\ninline_model_1\n\n\n\nsections\nArray\nUI 片段列表:[SectionItem]\n\n\nAttrItem\n——————\n——————\n\n\nid\ninteger\n数据点顺序\n\n\nname\nstring\n数据点标示名\n\n\ndisplay_name\nstring\n数据点显示名\n\n\ndesc\nstring\n固定值：.....\n\n\ntype\nstring\n读写类型，W: 读写,R: 只读,N: 报警,E: 故障\n\n\ndata_type\nstring\n数据类型，bool：布尔;'uint8','uint16','uint32'：数值型;enum：枚举;binary:扩展型]\n\n\nuint_spec\ninline_model_4\n当 data_type 为 uint8/uint16/uint32 时，有该字段\n\n\nenum\nArray\n当 data_type 为 enum 时，有该字段\n\n\nposition\ninline_model_5\n字节与比特位描述\n\n\ninline_model_1\n——————\n——————\n\n\nversion\ninteger\n固定值：4\n\n\nshowEditButton\nboolean\n固定值：false\n\n\nSectionItem\n——————\n——————\n\n\nelements\nArray\n[ElementItem]\n\n\ninline_model_4\n——————\n——————\n\n\nmin\ninteger\n最少值\n\n\nmax\ninteger\n最大值\n\n\nratio\nnumber\n分辨率k\n\n\naddition\ninteger\n增量\n\n\ninline_model_5\n——————\n——————\n\n\nbit_offset\ninteger\n位索引，如果为变长协议，固定为 0\n\n\nlen\ninteger\n长度\n\n\nunit\nstring\n单位，'bit', 'byte'\n\n\nbyte_offset\ninteger\n字节索引，如果为变长协议，固定为 0\n\n\nElementItem\n——————\n——————\n\n\ntitle\nstring\n数据点显示名\n\n\nkey\nstring\nentity0.{数据点标示名}\n\n\ntype\nstring\n'QBooleanElement', 'QFloatElement', 'QRadioElement', 'QMultilineElement', 'QLabelElement'\n\n\nkeyboardType\nstring\n键盘类型，固定值，\"NumbersAndPunctuation\"\n\n\nmaxLength\ninteger\ntype 为 QMultilineElement 才有该字段，最大长度，为数据点定义长度的 2 倍\n\n\nitems\nArray\ntype 为 QRadioElement 才有该字段，枚举值列表\n\n\nboolValue\nboolean\ntype 为 QBooleanElement 才有该字段，固定值：false\n\n\nbind\nstring\ntype 为 QFloatElement 才有该字段，固定值：floatValue:float\n\n\nmaximumValue\nnumber\ntype 为 QFloatElement 才有该字段，最大值\n\n\nminimumValue\nnumber\ntype 为 QFloatElement 才有该字段，最少值\n\n\nvalue\ninteger\ntype 为 QFloatElement 才有该字段，固定值：0\n\n\nobject\ninline_model_6\n\n\n\ninline_model_6\n——————\n——————\n\n\naction\nstring\n固定值:entity0\n\n\nbind\nArray[string]\n固定值:entity0.{数据点标示名}\n\n\nperm\nstring\n读写类型：W: 读写,R: 只读,N: 报警,E: 故障\n\n\nunit_spec\ninline_model_2\ntype 为 QFloatElement 才有该字段\n\n\ninline_model_2\n——————\n——————\n\n\nmax\ninteger\n最大值\n\n\nstep\ninteger\n步进\n\n\nmin\ninteger\n最小值\n\n\n\n返回例子\n{\n  \"name\": \"宠物屋\",\n  \"entities\": [\n    {\n      \"id\": 0,\n      \"display_name\": \"机智云开发套件\",\n      \"attrs\": [\n        {\n          \"display_name\": \"开启/关闭红色灯\",\n          \"name\": \"LED_OnOff\",\n          \"data_type\": \"bool\",\n          \"position\": {\n            \"bit_offset\": 0,\n            \"len\": 1,\n            \"unit\": \"bit\",\n            \"byte_offset\": 0\n          },\n          \"type\": \"status_writable\",\n          \"id\": 0,\n          \"desc\": \".....\"\n        }\n      ],\n      \"name\": \"entity0\"\n    }\n  ],\n  \"protocolType\": \"standard\",\n  \"product_key\": \"268162799f764b999f834b5a02eb894d\",\n  \"packetVersion\": \"0x00000004\",\n  \"ui\": {\n    \"object\": {\n      \"version\": 4,\n      \"showEditButton\": false\n    },\n    \"sections\": [\n      {\n        \"elements\": [\n          {\n            \"boolValue\": false,\n            \"object\": {\n              \"action\": \"entity0\",\n              \"bind\": [\n                \"entity0.LED_OnOff\"\n              ],\n              \"perm\": \"W\"\n            },\n            \"type\": \"QBooleanElement\",\n            \"key\": \"entity0.LED_OnOff\",\n            \"title\": \"开启/关闭红色灯\"\n          }\n        ]\n      }\n    ]\n  }\n}\n\n获取设备详情\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/devices/{did}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n设备ID\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nproduct_key\nstring\n产品product_key\n\n\ndid\nstring\n设备id\n\n\nmac\nstring\n设备mac地址\n\n\nis_online\nboolean\n是否在线\n\n\npasscode\nstring\n设备  passcode\n\n\nhost\nstring\n连接服务器的域名\n\n\nport\ninteger\nM2M 的 mqtt 端口号\n\n\nport_s\ninteger\nM2M 的 mqtt SSL 端口号\n\n\nws_port\ninteger\nwebsocket 端口号\n\n\nwss_port\ninteger\nwebsocket SSL 端口号\n\n\nremark\nstring\n设备备注\n\n\nis_disabled\nboolean\n是否注销\n\n\ntype\nstring\n设备类型，单品设备:normal,中控设备:center_control,中控子设备:sub_dev\n\n\ndev_alias\nstring\n设备别名\n\n\ndev_label\nArray[string]\n设备标签列表，目前用于语音 API 批量设备控制\n\n\nrole\nstring\n绑定角色， 首绑用户:special,拥有者:owner,访客:guest,普通用户:normal\n\n\n\n返回例子\n{\n  \"remark\": \"\",\n  \"ws_port\": 8080,\n  \"did\": \"gKufzxZwYeyd3Skbsb6mzz\",\n  \"port_s\": 8883,\n  \"is_disabled\": false,\n  \"host\": \"m2m.gizwits.com\",\n  \"product_key\": \"4214bf2d79694a259232431b6f2ef46a\",\n  \"port\": 1883,\n  \"mac\": \"accf2350d446\",\n  \"role\": \"guest\",\n  \"is_online\": false,\n  \"passcode\": \"JHHOOIWJBY\",\n  \"wss_port\": 8880\n}\n\n获取设备的通信日志和上下线记录\n调试接口\n用于查询最近7天内任意两天的设备通讯日志和上下线记录。\n入参的类型（type）\n\n通信日志查询, type 字段为 cmd\n上下线记录查询, type 字段为 online\n\n返回结果（type）\n\nmeta:\n通信日志查询, type 字段为 cmd\n上下线记录查询, type 字段为 online\n\nobjects:\n\n通信数据查询返回数据字段的 type 字段为 app2dev(app 到设备的通信), dev2app(设备到 app 的通信)\n上下线查询返回数据的 type 字段为 dev_online(上线), dev_re_online(完成离线流程前再次登陆), dev_offline(离线)\n\n结束时间戳end_time\n\n必须小于等于当前系统时间戳\n必须大于开始时间戳.\n终止时间戳与开始时间戳之差必须小于48小时\n\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/devices/{did}/raw_data?type={type}&start_time={start_time}&end_time={end_time}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n设备ID\n\n\ntype\nstring\n是\nquery\n类型，cmd:通信日志；online：上下线记录\n\n\nstart_time\ninteger\n是\nquery\n开始时间戳，单位秒\n\n\nend_time\ninteger\n是\nquery\n结束时间戳，单位秒\n\n\nskip\ninteger\n否\nquery\n跳过的条数，跳过条目数+返回条目数必须<=5000, 默认为0\n\n\nlimit query\ninteger\n否\nquery\n返回的条数，需<=1000,默认为20\n\n\nsort\nstring\n否\nquery\n排序方式，dese：降序；ase：升序。默认降序\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nsort\nstring\n排序方式，dese：降序；ase：升序\n\n\nlimit\ninteger\n返回的条数\n\n\nend_time\ninteger\n结束时间戳\n\n\ndid\nstring\n设备ID\n\n\nskip\ninteger\n跳过的条数\n\n\nstart_time\ninteger\n开始时间戳\n\n\ntotal\ninteger\n查询结果的条数\n\n\ntype\nstring\nmeta的type。查询类型，cmd:通信日志；online：上下线记录\n\n\ntype\nstring\nobjects的type。 类型：app2dev：app 到设备的通信；dev2app：设备到 app 的通信；dev_online：上线；dev_re_online：完成离线流程前再次登陆；dev_offline：离线\n\n\nip\nstring\n上报数据端的IP地址\n\n\npayload_bin\nstring\n通讯数据\n\n\ntimestamp\ninteger\n上报数据的时间\n\n\nsource\nstring\napp2dev时，才有此字段触发端的类型，d3：有D3规则引擎触发；client：客户端上报数据\n\n\nuid\nstring\napp2dev时，才有此字段。用户的User ID\n\n\nappid\nstring\napp2dev时，才有此字段。APP ID\n\n\n\n返回例子\n{\n  \"meta\": {\n    \"sort\": \"desc\",\n    \"limit\": 20,\n    \"end_time\": 1505871861,\n    \"did\": \"WCWGkbS4Ttynzwx9brzpEa\",\n    \"skip\": 0,\n    \"start_time\": 1505750399,\n    \"total\": 17,\n    \"type\": \"cmd\"\n  },\n  \"objects\": [\n    {\n      \"ip\": \"10.104.222.219\",\n      \"payload_bin\": \"000000030b0000910400000010000000\",\n      \"type\": \"dev2app\",\n      \"timestamp\": 1505871342.875\n    },\n    {\n      \"ip\": \"127.0.0.1\",\n      \"payload_bin\": \"0000000309000090010200000010\",\n      \"type\": \"app2dev\",\n      \"timestamp\": 1505871743.564,\n      \"source\": \"d3\"\n    },\n    {\n      \"uid\": \"c0a85d0773e24f15a6853f3148c80a33\",\n      \"timestamp\": 1505871743.2,\n      \"ip\": \"183.233.131.216\",\n      \"payload_bin\": \"000000030400009002\",\n      \"source\": \"client\",\n      \"appid\": \"17f5eabb5782434da65fffdc87e605bf\",\n      \"type\": \"app2dev\"\n    }\n  ]\n}\n\n远程控制设备\n调试接口\n通过云端对设备进行控制\n原始指令(raw):\n默认格式为十进制数组，设置 binary_coding 参数可使用 hex 和 base64，\n如要发送 payload 为二进制 011000010110001001100011 ，每组byte换成一个十进制数组的值得就是：[97,98,99]；\n如要发送 payload 为16进制 616263 ，每组byte换成一个十进制数组的值得就是：[97,98,99]。\n{\n  \"raw\": [97,98,99]\n}\n\n数据点方式(attrs):\n设备产品必须定义了数据点。如要设置扩展类型的字段 binary 为16进制 1234567 ，需要补齐扩展型长度：\n扩展型默认为hex16 ，设置 binary_coding 参数可使用 base64 。\n{\n  \"attrs\": {\n    \"binary\": \"1234567000\"\n  }\n}\n\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/control/{did}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n设备ID\n\n\nraw\nArray[integer]\n否\nbody\n原始控制指令\n\n\nattrs\nobject\n否\nbody\n\n\n\n注：body的参数最少填写输入一个\n响应参数\n无\n设备分享\n开启设备分享功能后，“绑定角色”就会有 Owner 和 Guest。\n设备分享的主要有两种方式：\n\n普通设备分享\n通过二维码分享设备\n\n分享使用场景\n普通设备分享\n\nOwner 选择一个要分享的设备，调用创建分享邀请接口创建分享邀请\nOwner 和 Guest 都将收到一条设备分享消息\n被分享的用户调用查询分享邀请接口，查询分享给自己的邀请\n被分享的用户调用接受分享邀请接口接受邀请，被分享的用户成为 Guest\nOwner 和 Guest 都将收到一条设备接受分享消息\n\n通过二维码分享设备\n\nOwner 选择一个要分享的设备，调用创建分享邀请接口创建分享邀请\n接口返回字段中的 qr_content 生成二维码信息，Owner 将二维码图片展示给需要分享的用户\n用户扫描二维码，获取邀请码，调用查询二维码分享信息接口，查看分享内容\n再调用接受二维码分享邀请接口，接受分享邀请，被分享的用户成为 Guest\nOwner 和 Guest 都将收到一条设备分享消息\n\n取消设备分享\n\nOwner 调用取消/收回分享接口，取消分享出去的邀请取消，及收回已经接受的邀请\nGuest 用户若还没有接受，Owner 将收到一条设备取消分享消息\nGuest 用户对设备的绑定被取消，同时，Owner 和 Guest 都将收到一条设备取消分享消息\n\nOwner 权限转移\n\nOwner 调用权限转移接口，填写需要转移的设备和需要成为owner用户的ID\n原 Owner 用户解绑设备，原 Guest 用户成为新的 Owner\n\n创建分享邀请\n调试接口\n此接口只有设备主账号可以调用\n\n如果 type 为普通分享，uid/username/email/phone 四选一，为是被分享者的用户信息；\n如果 type 为二维码分享，uid、username、email、phone 设置为空，若设置不会生效；\n普通分享24小时过期，二维码分享15分钟过期；\n针对二维码分享，客户端收到返回的二维码内容之后，本地生成二维码图片；\n\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/sharing\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ntype\ninteger\n是\nbody\n分享类型，0：普通分享，1：二维码分享\n\n\ndid\nstring\n否\nbody\n设备ID\n\n\nuid\nstring\n否\nbody\n普通分享类型，被分享的用户ID\n\n\nusername\nstring\n否\nbody\n普通分享类型，被分享的用户名\n\n\nemail\nstring\n否\nbody\n普通分享类型，被分享的用户邮箱地址\n\n\nphone\nstring\n否\nbody\n普通分享类型，被分享的用户手机号码\n\n\nduration\ninteger\n否\nbody\n持续分享时间，guest 接受分享之后可使用设备的时长，单位：分钟。最小时长 1 分钟，最大时长 1440 分钟\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n分享记录id，针对普通分享才有\n\n\nqr_content\ninteger\n二维码图片内容，针对二维码分享才有\n\n\n\n返回例子\n{\n    \"qr_content\": \"type=share&code=60a6cacabe4046f4aa25ac1f79d81a4f\",\n    \"id\": null\n}\n\n查询分享邀请\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/sharing?sharing_type={sharing_type}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nsharing_type\ninteger\n是\nquery\n分享类型，0：我分享的设备，1：分享给我的设备\n\n\nstatus\nstring\n否\nquery\n分享状态，0：未接受分享，1：已接受分享，2：拒绝分享，3：取消分享\n\n\ndid\nstring\n否\nquery\n指定的设备did，只有owner用户可查询指定did的分享信息\n\n\nlimit\ninteger\n否\nquery\n返回的条数，默认20\n\n\nskip\ninteger\n否\nquery\n跳过的条数，默认0\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\ntotal\ninteger\n总条数\n\n\nlimit\ninteger\n返回的条数\n\n\nskip\ninteger\n跳过的条数\n\n\nprevious\nstring\n上一页的请求地址\n\n\nnext\nstring\n下一页的请求地址\n\n\nid\ninteger\n分享记录id\n\n\ntype\ninteger\n分享类型，0：普通分享，1：二维码分享\n\n\nuid\nstring\n用户ID\n\n\nusername\nstring\n用户名,中间4个字母*替代\n\n\nuser_alias\nstring\n用户别名\n\n\nemail\nstring\n用户邮箱地址,@前面4个字符*替代\n\n\nphone\nstring\n用户手机号码,中间4个数字*替代\n\n\ndid\nstring\n设备id\n\n\nproduct_name\nstring\n产品名称\n\n\ndev_alias\nstring\n设备别名\n\n\nstatus\ninteger\n当前分享状态 0：未接受分享，1：已接受分享，2：拒绝分享，3：取消分享\n\n\ncreated_at\nstring\n创建分享时间 （UTC时间）\n\n\nupdated_at\nstring\n分享状态更新时间 （UTC时间）\n\n\nexpired_at\nstring\n分享超时时间 （UTC时间）\n\n\n\n注：\n\n若 sharing_type 为 0，表示以 Owner 身份查询自己发出的分享邀请，返回结果中用户信息为 Guest 的信息\n若 sharing_type 为 1，表示以 Guest 身份查询收到的分享邀请，返回结果中的用户信息为 Owner 的信息\n\n返回例子\n{\n  \"meta\": {\n    \"previous\": null,\n    \"skip\": 0,\n    \"total\": 1,\n    \"limit\": 20,\n    \"next\": null\n  },\n  \"objects\": [\n    {\n      \"status\": 0,\n      \"username\": \"G****s\",\n      \"uid\": \"f082f4e235974cfeb6a1b2346024f47e\",\n      \"did\": \"gKufzxZwYeyd3Skbsb6mza\",\n      \"created_at\": \"2017-07-21T09:46:56Z\",\n      \"updated_at\": \"2017-07-21T09:46:56Z\",\n      \"email\": \"G****s@gizwits.com\",\n      \"phone\": null,\n      \"dev_alias\": \"设备别名\",\n      \"id\": 10411,\n      \"user_alias\": \"gizwits\",\n      \"type\": 0,\n      \"product_name\": \"微信宠物屋\",\n      \"expired_at\": \"2017-07-22T09:46:56Z\"\n    }\n  ]\n}\n\n取消/收回分享\n调试接口\n二维码分享的设备无法收回\n请求地址及方式\n  DELETE\n  https://api.gizwits.com/app/sharing/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\ninteger\n是\npath\n分享记录id\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\ninteger\n分享记录id\n\n\n\n返回例子\n{\n    \"id\": 10471\n}\n\n接受/拒绝分享\n调试接口\n二维码分享的设备无法收回\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/sharing/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\ninteger\n是\npath\n分享记录id\n\n\nstatus\ninteger\n是\nquery\n接受/拒绝分享，1：接受分享，2：拒绝分享\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\ninteger\n分享记录id\n\n\n\n返回例子\n{\n    \"id\": 10471\n}\n\n获取二维码分享信息\n调试接口\n设备拥有者 owner 无法使用此接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/sharing/code/{code}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ncode\ninteger\n是\npath\n二维码分享的qr_content\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nowner\nstring\n设备拥有者信息，手机号/邮箱/用户名/uid\n\n\nproduct_name\nstring\n产品名称\n\n\ndev_alias\nstring\n设备别名\n\n\nexpired_at\nstring\n分享超时时间（UTC时间）\n\n\n\n返回例子\n{\n  \"owner\": \"G****s\",\n  \"product_name\": \"微信宠物屋\",\n  \"dev_alias\": \"设备别名\",\n  \"expired_at\": \"2017-08-21T12:22:58Z\"\n}\n\n接受二维码分享邀请\n调试接口\n设备拥有者 owner 无法使用此接口\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/sharing/code/{code}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ncode\ninteger\n是\npath\n二维码分享的qr_content\n\n\n\n响应参数\n无\n修改用户备注信息\n调试接口\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/sharing/{id}/alias?user_alias={user_alias}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\ninteger\n是\npath\n分享记录id\n\n\nuser_alias\nstring\n是\nquery\n\n\n\n响应参数\n无\nowner 权限转移\n调试接口\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/sharing/1/transfer?uid=1\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\n\n设备ID\n\n\nuid\nstring\n是\nquery\n需要成为owner用户的ID\n\n\n\n响应参数\n无\n设备分组\n设备分组常用场景：\n1、将多个设备归类到某一个物理空间，如：房间、客厅。方便管理\n\n首先调用创建分组接口创建分组，输入分组名称\n创建成功后对分组内的设备进行批量添加/删除，调用将设备列表添加到分组接口和将设备列表从分组移除接口\n通过查询分组的设备信息接口可以查看分组下的全部设备\n\n2、对相同产品的多个设备进行统一控制，如：走廊的全部灯开关\n\n首先调用创建分组接口创建分组，输入分组名称和产品PK\n创建成功后对分组内的设备进行批量添加/删除，调用将设备列表添加到分组接口和将设备列表从分组移除接口\n通过对设备分组内的设备统一控制接口对设备发送统一的控制指令，从而进行对设备的批量控制\n\n查询用户所有的分组\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/group\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\ncreated_at\nstring\n设备分组创建时间（UTC 时间）\n\n\nupdated_at\nstring\n设备分组更新时间（UTC 时间）\n\n\nproduct_key\nstring\n产品 product_key，单PK的分组才会有值\n\n\ngroup_name\nstring\n设备分组名称\n\n\nverbose_name\nstring\n产品名称，单PK的分组才会有值\n\n\nid\nstring\n设备分组 id\n\n\n\n返回例子\n[\n  {\n    \"created_at\": \"2017-09-22T09:57:44Z\",\n    \"updated_at\": \"2017-09-22T09:57:44Z\",\n    \"product_key\": \"4214b12d79694a259232431b6f2ef46a\",\n    \"group_name\": \"分组名称1\",\n    \"verbose_name\": \"微信宠物屋\",\n    \"id\": \"59c4de98dc348f001a08feba\"\n  },\n  {\n    \"created_at\": \"2017-09-22T09:58:18Z\",\n    \"updated_at\": \"2017-09-22T09:58:18Z\",\n    \"product_key\": \"\",\n    \"group_name\": \"分组名称2\",\n    \"verbose_name\": \"\",\n    \"id\": \"59c4deba8c7d50001ba06df3\"\n  }\n]\n\n创建分组\n调试接口\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/group\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nproduct_key\nstring\n否\nbody\n产品PK，对单个pk分组需要输入此参数\n\n\ngroup_name\nstring\n是\nbody\n设备分组名称\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n设备分组 id\n\n\n\n返回例子\n{\n  \"id\": \"59c4deba8c7d50001ba06df3\"\n}\n\n删除设备分组\n调试接口\n请求地址及方式\n  DELETE\n  https://api.gizwits.com/app/group/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n设备分组 id\n\n\n\n响应参数\n无\n修改分组信息\n调试接口\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/group/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n设备分组 id\n\n\ngroup_name\nstring\n是\nbody\n设备分组名称\n\n\n\n响应参数\n无\n查询分组的设备信息\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/group/{id}/devices\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n设备分组 ID\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\ndid\nstring\n该分组下的设备ID\n\n\ntype\nstring\n设备类型：普通设备：noramal；中控设备：center_control；中控子设备：sub_dev\n\n\nverbose_name\nstring\n产品名称，单PK的分组才会有值\n\n\ndev_alias\nstring\n设备别名\n\n\nproduct_key\nstring\n产品 product_key，单PK的分组才会有值\n\n\n\n返回例子\n[\n  {\n    \"did\": \"WCWGkbS4Ttynzwx9brzpEa\",\n    \"type\": \"normal\",\n    \"verbose_name\": \"微信宠物屋\",\n    \"dev_alias\": \"设备别名\",\n    \"product_key\": \"4234bf2d79694a259232431b6f2ef46a\"\n  }\n]\n\n将设备列表添加到分组\n调试接口\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/group/{id}/devices?show_detail={show_detail}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n设备分组 ID\n\n\nshow_detail\ninteger\n否\nquery\n返回错误信息，1：添加失败的did返回详细错误信息，0(默认值)：添加失败的did，不返回详细错误信息\n\n\ndids\nArray\n是\nbody\n需要添加到分组的设备ID数组\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nfailed\nArray\n添加成功的设备ID 数组\n\n\ndetail\nArray\n添加失败原因，show_detail为1时候才会返回此信息\n\n\nsuccess\nArray\n添加失败的设备ID 数组\n\n\ndid\nstring\n添加的失败的设备ID\n\n\nerror_message\nstring\n失败错误信息\n\n\nerror_code\ninteger\n失败错误码\n\n\ndetail_msg\nstring\n详细错误信息\n\n\n\n返回例子\n{\n  \"failed\": [\n      \"WCWGkbS4Ttynz123czpEa\"\n    ],\n  \"detail\": [\n      {\n        \"did\": \"WCWGkbS123cynzwxrzpEa\",\n        \"error_message\": \"device not found!\",\n        \"error_code\": 9014,\n        \"detail_msg\": null\n      }\n    ],\n  \"success\": [\n    \"XD3GkbS21tynzwx9brzpEa\"\n  ]\n}\n\n将设备列表从分组移除\n调试接口\n请求地址及方式\n  DELETE\n  https://api.gizwits.com/app/group/{id}/devices\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n设备分组 ID\n\n\ndids\nArray\n是\nbody\n需要移出分组的设备ID数组\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nfailed\nArray\n添加成功的设备ID 数组\n\n\nsuccess\nArray\n添加失败的设备ID 数组\n\n\ndid\nstring\n添加的失败的设备ID\n\n\n\n返回例子\n{\n  \"failed\": [],\n  \"success\": [\n    \"WCWGkb234tynzwx9brzpEa\"\n  ]\n}\n\n对设备分组内的设备统一控制\n调试接口\n通过云端对分组内的所有设备进行控制，该接口只能统一控制单PK分组的设备。\n原始指令(raw):\n默认格式为十进制数组，设置 binary_coding 参数可使用 hex 和 base64，\n如要发送 payload 为二进制 011000010110001001100011 ，每组byte换成一个十进制数组的值得就是：[97,98,99]；\n如要发送 payload 为16进制 616263 ，每组byte换成一个十进制数组的值得就是：[97,98,99]。\n{\n  \"raw\": [97,98,99]\n}\n\n数据点方式(attrs):\n设备产品必须定义了数据点。如要设置扩展类型的字段 binary 为1234567(16进制)，需要补齐扩展型长度；\n扩展型默认为hex16 ，设置 binary_coding 参数可使用 base64 。\n{\n  \"attrs\": {\n    \"boolean\":true,\n    \"binary\": \"1234567000\"\n  }\n}\n\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/group/{id}/control\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n设备分组 ID\n\n\nraw\nArray[integer]\n否\nbody\n原始控制指令\n\n\nattrs\nobject\n否\nbody\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\ndid\nstring\n分组下的设备ID\n\n\nresult\nboolean\n是否控制成功，true：成功；false：失败\n\n\n\n返回例子\n[\n  {\n    \"did\": \"WCWGkbS4Tty123x9brzpEa\",\n    \"result\": true\n  },\n  {\n    \"did\": \"gKufzxZw43dd3Skbsb6mzz\",\n    \"result\": false\n  }\n]\n\n设备联动\n创建设备联动的规则，实现一个或多个设备的状态变化时，自动控制一个或多个设备的状态改变。\n联动的设备需要绑定同一个用户，不同产品下的设备需要先进行产品关联。\n联动规则创建后，可以随时进行修改，或者删除。\n点击查看详细使用教程\n查询规则可用变量\n调试接口\n通过该接口可以查询appid所绑定的全部产品的数据点。\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/rules/params?product_key={product_key}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nproduct_key\nstring\n是\nquery\n多个pk用“,”隔开，参数为空时默认选中与appid绑定的所有pk，填入与appid无绑定的pk时该pk无效\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\ndisplay_name\nstring\n数据点显示名称\n\n\nenum\nArray\n枚举值\n\n\ntype\nstring\n数据类型，数值型:int；布尔型:bool；枚举型:enum;扩展型：binary\n\n\nname\nstring\n数据点名称\n\n\n\n返回例子\n{\n  \"4214b435f9694a259232431b6f2ef46a\": [\n    {\n      \"display_name\": \"开关\",\n      \"enum\": [],\n      \"type\": \"bool\",\n      \"name\": \"switch\"\n    },\n    {\n      \"display_name\": \"倒计时开机\",\n      \"enum\": [],\n      \"type\": \"int\",\n      \"name\": \"on_timing\"\n    },\n    {\n      \"display_name\": \"倒计时关机\",\n      \"enum\": [],\n      \"type\": \"int\",\n      \"name\": \"off_timing\"\n    }\n  ]\n}\n\n查询联动规则列表\n调试接口\n通过该接口可以查询appid所绑定的全部产品的数据点。\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/rules?limit=20&skip=0\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nlimit\ninteger\n否\nquery\n返回的结果条数\n\n\nskip\ninteger\n否\nquery\n表示跳过的条数，间接表示页数\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nremark\nstring\n联动规则备注\n\n\nname\nstring\n联动规则名称\n\n\ndid\nstring\n设备ID\n\n\ninterval\ninteger\n最小触发间隔(单位:秒)\n\n\nproduct_key\nstring\n产品PK\n\n\nrule_id\ninteger\n联动规则ID\n\n\nevent\nstring\n触发方式\n\n\nevent_attr\nobject\n当触发方式为alert(报警)/fault(故障)，[RulesEventAttr]\n\n\ninput\nArray\n规则中需要用到的设备数据 [RulesInput]\n\n\ncondition\nArray\n条件判断 [RulesCondition]\n\n\noutput\nArray\n触发动作 [RulesOutput]\n\n\nRulesEventAttr\n——————\n——————\n\n\nattr_name\nstring\n发生这个报警/故障的数据点\n\n\nvalue\nstring\n报警/故障的发生/取消, 1表示发生, 0表示取消\n\n\nRulesOutput\n——————\n——————\n\n\ndid\nstring\n被控制的设备id\n\n\ntype\nstring\n触发类型，devctrl:控制设备；delay：延时\n\n\nattrs\nobject\n数据点方式控制设备\n\n\nraw\nArray\n原始控制指令\n\n\ndelay\ninteger\n延时时长, 单位:秒\n\n\nRulesInput\n——————\n——————\n\n\ndid\nstring\n规则数据的来源的设备id\n\n\nprefix\nstring\n用于在条件及输出中引用这个设备的数据点值的前缀\n\n\nproduct_key\nstring\n规则数据的来源的设备对应的产品PK\n\n\nRulesCondition\n——————\n——————\n\n\nopt\nstring\n比较运算符, 可选值有: >, >=, <, <=, ==, != (注:只有数值类型才能比较大小)\n\n\nright\nstring\n右比较参数\n\n\nleft\nstring\n左比较参数\n\n\n\n返回例子\n{\n    \"rules\": [\n        {\n            \"remark\": \"\",\n            \"name\": \"打开开关，三灯100值\",\n            \"did\": \"WCWGkbS4Ttynzwx9brzpEa\",\n            \"interval\": 0,\n            \"product_key\": \"4214bf2d123194a259232431b6f2ef46a\",\n            \"event\": \"data\",\n            \"output\": [\n                [\n                    {\n                        \"did\": \"WCWGk43ftynzwx9brzpEa\",\n                        \"type\": \"devctrl\",\n                        \"attrs\": {\n                            \"LED_R\": 100,\n                            \"LED_G\": 100,\n                            \"LED_B\": 100\n                        }\n                    }\n                ],\n                [\n                    {\n                        \"did\": \"WCWGk43ftynzwx9brzpEa\",\n                        \"type\": \"devctrl\",\n                        \"attrs\": {\n                            \"fan_swing\": 1\n                        }\n                    }\n                ]\n            ],\n            \"input\": [\n                {\n                    \"did\": \"WCWGk43ftynzwx9brzpEa\",\n                    \"prefix\": \"device1\",\n                    \"product_key\": \"4214bf2d123194a259232431b6f2ef46a\"\n                },\n                {\n                    \"did\": \"WCWGk43ftynzwx9brzpEa\",\n                    \"prefix\": \"device2\",\n                    \"product_key\": \"4214bf2d123194a259232431b6f2ef46a\"\n                }\n            ],\n            \"rule_id\": 8826,\n            \"condition\": [\n                [\n                    {\n                        \"opt\": \"==\",\n                        \"right\": \"1\",\n                        \"left\": \"device1.switch\"\n                    }\n                ]\n            ]\n        }\n    ]\n}\n\n创建联动规则\n调试接口\nproduct_key与did:\n当触发方式为online/offline/alert/fault/data时, 产生这个触发方式的设备由该参数指定, 以下把指定的这个设备称为主设备\nevent参数\n表示该规则的触发方式,以下是可选值的意义:\nonline  : 设备上线\noffline : 设备下线\nalert   : 设备某个报警数据点发生报警\nfault   : 设备某个故障数据点发生故障\ndata    : 设备上报状态\nevent_attr参数\n表示当触发方式为alert(报警)/fault(故障)时, 发生这个报警/故障的数据点,以及报警/故障的发生/恢复,由该参数指定\n\"event_attr\": {\n    \"attr_name\": \"datapoint_alert\",  //发生这个报警/故障的数据点\n    \"value\": \"1\" //报警/故障的发生/取消, 值为1时表示发生, 值为0时表示取消\n}\n\n注:\n\n这里提到的报警/故障的\"发生\"指的是－设备上一次上报的报警/故障数据点的值为0, 这一次上报的为1, 那么报警/故障发生\n这里提到的报警/故障的\"恢复\"指的是－设备上一次上报的报警/故障数据点的值为1, 这一次上报的为0, 那么报警/故障恢复\n其他情况均不属于\"发生\"和\"恢复\"\n\ninput参数\n指定规则中需要用到的设备数据,数组中每一个对象代表一个设备的数据,不需要使用设备数据时可忽略此参数:\n[{\n    \"product_key\": \"pk1\", //设备所属Product key\n    \"did\": \"did1\",        //设备did\n    \"prefix\": \"device1\"   //用于在条件及输出中引用这个设备的数据点值的前缀, 如设置了这个参数为device1时,则device1.datapoint1表示引用这个设备的标识名为datapoint1的数据点\n}]\n\ncondition参数\n指定触发规则需要满足的条件, 云端处理时将逐组检查数组内的条件, 任意一组条件满足时触发输出\n[\n    [{\n        \"left\": \"device1.datapoint1\",//左比较参数, 参数的值类型需要和右比较参数一致\n        \"opt\": \"==\", //比较运算符, 可选值有: >, >=, <, <=, ==, != (注:只有数值类型才能比较大小)\n        \"right\": \"1\" //右比较参数, 参数的值类型需要和左比较参数一致,使用常数时注意,\"1\"代表数字1,\"'1'\"或\"\\\"1\\\"\"才是字符串\"1\"\n    }],\n    [{// 每个数组表示一组条件，当这个组里的所有条件都满足时，这一组条件满足\n        \"left\": \"device1.datapoint1\",\n        \"opt\": \"==\",\n        \"right\": \"1\"\n    },{\n        \"left\": \"device2.datapoint2\",\n        \"opt\": \">\",\n        \"right\": \"25\"\n    }]\n]\n\noutput参数\n指定当条件满足时, 需要做的事情，可认为云端同时执行各组动作，各组之间互不影响\n原始指令(raw):\n默认格式为十进制数组\n如要发送 payload 为二进制 011000010110001001100011 ，每组byte换成一个十进制数组的值得就是：[97,98,99]；\n如要发送 payload 为16进制 616263 ，每组byte换成一个十进制数组的值得就是：[97,98,99]。\n{\n  \"raw\": [97,98,99]\n}\n\n数据点方式(attrs):\n设备产品必须定义了数据点。如要设置扩展类型的字段 binary 为16进制 1234567，需要补齐扩展型长度：\n{\n  \"attrs\": {\n    \"binary\": \"1234567000\"\n  }\n}\n\noutput参数示例：\n[\n    [{ // 每个数组表示一组输出动作，按顺序执行，前面的动作执行失败时，后面不会执行\n        \"type\": \"devctrl\",   // output的类型, devctrl表示控制设备\n        \"did\": \"did1\",       // 指定被控制的设备的did\n        \"attrs\": {           // key-value形式\n            \"datapoint1\": 1, // 设置datapoint1值为1\n            \"datapoint2\": 25,\n            \"datapoint3\": \"黄色\"\n        }\n    },{\n        \"type\": \"delay\", // output的类型, delay表示延时\n        \"delay\": 5       // 延时时长, 单位:秒\n    },{\n        \"type\": \"devctrl\",\n        \"did\": \"QxP6E9qFwwzsqKb2UYf4uw\",\n        \"raw\": [1, 2, 3] // raw形式\n    }],\n    [{\n        \"type\": \"devctrl\",\n        \"did\": \"QxP6E9qFwwzsqKb2UYf4uw\",\n        \"attrs\": {\n            \"datapoint1\": 1,\n            \"datapoint2\": 25,\n            \"datapoint3\": \"黄色\"\n        }\n    }]\n]\n\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/rules\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nremark\nstring\n否\nbody\n联动规则备注\n\n\nname\nstring\n是\nbody\n联动规则名称\n\n\ndid\nstring\n是\nbody\n设备ID\n\n\ninterval\ninteger\n否\nbody\n最小触发间隔(单位:秒)\n\n\nproduct_key\nstring\n是\nbody\n产品PK\n\n\nevent\nstring\n是\nbody\n触发方式\n\n\nevent_attr\nobject\n否\nbody\n当触发方式为alert(报警)/fault(故障)，[RulesEventAttr]\n\n\ninput\nArray\n是\nbody\n规则中需要用到的设备数据 [RulesInput]\n\n\ncondition\nArray\n是\nbody\n条件判断 [RulesCondition]\n\n\noutput\nArray\n是\nbody\n触发动作 [RulesOutput]\n\n\nRulesEventAttr\n——————\n否\nbody\n——————\n\n\nattr_name\nstring\n否\nbody\n发生这个报警/故障的数据点\n\n\nvalue\nstring\n否\nbody\n报警/故障的发生/取消, 1表示发生, 0表示取消\n\n\nRulesOutput\n——————\n是\nbody\n——————\n\n\ndid\nstring\n是\nbody\n被控制的设备id\n\n\ntype\nstring\n是\nbody\n触发类型，devctrl:控制设备；delay：延时\n\n\nattrs\nobject\n否\nbody\n数据点方式控制设备\n\n\nraw\nArray\n否\nbody\n原始控制指令\n\n\ndelay\ninteger\n否\nbody\n延时时长, 单位:秒\n\n\nRulesInput\n——————\n是\nbody\n——————\n\n\ndid\nstring\n是\nbody\n规则数据的来源的设备id\n\n\nprefix\nstring\n是\nbody\n用于在条件及输出中引用这个设备的数据点值的前缀\n\n\nproduct_key\nstring\n是\nbody\n规则数据的来源的设备对应的产品PK\n\n\nRulesCondition\n——————\n是\nbody\n——————\n\n\nopt\nstring\n是\nbody\n比较运算符, 可选值有: >, >=, <, <=, ==, != (注:只有数值类型才能比较大小)\n\n\nright\nstring\n是\nbody\n右比较参数\n\n\nleft\nstring\n是\nbody\n左比较参数\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nrule_id\ninteger\n联动规则ID\n\n\n\n返回例子\n{\n  \"rule_id\": 1213\n}\n\n删除联动规则\n调试接口\n请求地址及方式\n  DELETE\n  https://api.gizwits.com/app/rules/{rule_id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nrule_id\ninteger\n是\npath\n需要删除的联动规则ID\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nrule_id\ninteger\n联动规则ID\n\n\n\n返回例子\n{\n  \"rule_id\": 1234\n}\n\n修改联动规则\n调试接口\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/rules/{rule_id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nremark\nstring\n否\nbody\n联动规则备注\n\n\nname\nstring\n是\nbody\n联动规则名称\n\n\ndid\nstring\n是\nbody\n设备ID\n\n\ninterval\ninteger\n否\nbody\n最小触发间隔(单位:秒)\n\n\nproduct_key\nstring\n是\nbody\n产品PK\n\n\nrule_id\ninteger\n是\nbody\n联动规则ID\n\n\nevent\nstring\n是\nbody\n触发方式\n\n\nevent_attr\nobject\n否\nbody\n当触发方式为alert(报警)/fault(故障)，[RulesEventAttr]\n\n\ninput\nArray\n是\nbody\n规则中需要用到的设备数据 [RulesInput]\n\n\ncondition\nArray\n是\nbody\n条件判断 [RulesCondition]\n\n\noutput\nArray\n是\nbody\n触发动作 [RulesOutput]\n\n\nRulesEventAttr\n——————\n否\nbody\n——————\n\n\nattr_name\nstring\n否\nbody\n发生这个报警/故障的数据点\n\n\nvalue\nstring\n否\nbody\n报警/故障的发生/取消, 1表示发生, 0表示取消\n\n\nRulesOutput\n——————\n是\nbody\n——————\n\n\ndid\nstring\n是\nbody\n被控制的设备id\n\n\ntype\nstring\n是\nbody\n触发类型，devctrl:控制设备；delay：延时\n\n\nattrs\nobject\n否\nbody\n数据点方式控制设备\n\n\nraw\nArray\n否\nbody\n原始控制指令\n\n\ndelay\ninteger\n否\nbody\n延时时长, 单位:秒\n\n\nRulesInput\n——————\n是\nbody\n——————\n\n\ndid\nstring\n是\nbody\n规则数据的来源的设备id\n\n\nprefix\nstring\n是\nbody\n用于在条件及输出中引用这个设备的数据点值的前缀\n\n\nproduct_key\nstring\n是\nbody\n规则数据的来源的设备对应的产品PK\n\n\nRulesCondition\n——————\n是\nbody\n——————\n\n\nopt\nstring\n是\nbody\n比较运算符, 可选值有: >, >=, <, <=, ==, != (注:只有数值类型才能比较大小)\n\n\nright\nstring\n是\nbody\n右比较参数\n\n\nleft\nstring\n是\nbody\n左比较参数\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nrule_id\ninteger\n联动规则ID\n\n\n\n返回例子\n{\n  \"rule_id\": 1234\n}\n\n用户场景\n查询用户所有的场景\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/scene\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n场景 id\n\n\nscene_name\nstring\n场景名称\n\n\ncreated_at\nstring\n场景创建时间（UTC 时间）\n\n\nupdated_at\nstring\n场景更新时间（UTC 时间）\n\n\nremark\nstring\n场景备注\n\n\ntask_type\nstring\n场景任务类型：\"delay\": 延时任务，\"device\": 控制当个设备任务，\"group\": 控制设备分组任务（仅可控制单 product_key 分组)\n\n\ndid\nstring\n针对单品控制任务，设备 did\n\n\nproduct_key\nstring\n针对非延时任务，产品 product_key\n\n\ngroup_name\nstring\n针对设备分组控制任务，设备分组名称\n\n\nraw\nstring\n针对非延时任务，原始控制指令，base64 编码\n\n\nattrs\nobject\n针对非延时任务，数据点控制命令，枚举型数据点传序号，扩展型数据点传 base64 编码字符串\n\n\ndev_remark\nstring\n针对设备控制任务，设备备注\n\n\ntime\ninteger\n针对延时任务，延时时间，以秒为单位，最大值： 3600 秒\n\n\ngroup_id\nstring\n针对设备分组控制任务，设备分组 id\n\n\nverbose_name\nstring\n针对非延时任务，产品名称\n\n\ndev_alias\nstring\n针对设备控制任务，设备别名\n\n\n\n返回例子\n[\n  {\n    \"remark\": \"备注\",\n    \"tasks\": [\n      {\n        \"task_type\": \"device\",\n        \"did\": \"WCWGkbS4Ttynzw123rzpEa\",\n        \"product_key\": \"4214bf2d79321259232431b6f2ef46a\",\n        \"group_name\": \"\",\n        \"raw\": \"\",\n        \"attrs\": {\n          \"switch\": true\n        },\n        \"dev_remark\": \"\",\n        \"time\": 0,\n        \"group_id\": \"\",\n        \"verbose_name\": \"微信宠物屋\",\n        \"dev_alias\": \"\"\n      }\n    ],\n    \"created_at\": \"2017-09-25T10:09:07Z\",\n    \"updated_at\": \"2017-09-25T10:09:07Z\",\n    \"scene_name\": \"场景名\",\n    \"id\": \"59c8d5c3234d50001a21c872\"\n  }\n]\n\n创建场景\n调试接口\n原始指令(raw):\n默认格式为 base64 ，设置 binary_coding 参数可使用 hex，\n如要发送 payload 为 010203 ，编译后就是： AQID ；\n{\n  \"raw\": \"AQID\"\n}\n\n数据点方式(attrs):\n设备产品必须定义了数据点。如要设置扩展类型的字段 binary 为1234567(16进制)，需要补齐扩展型长度；\n扩展型默认为hex16 ，设置 binary_coding 参数可使用 base64 。\n{\n  \"attrs\": {\n    \"boolean\":true,\n    \"binary\": \"1234567000\"\n  }\n}\n\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/scene\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nscene_name\nstring\n是\nbody\n场景名称\n\n\nremark\nstring\n否\nbody\n场景备注\n\n\ntask_type\nstring\n是\nbody\n场景任务类型： \"delay\": 延时任务，\"device\": 控制当个设备任务，\"group\": 控制设备分组任务（仅可控制单 product_key 分组)\n\n\ntime\ninteger\n否\nbody\n针对延时任务，延时时间，以秒为单位，最大值： 3600 秒\n\n\ndid\nstring\n否\nbody\n针对单品控制任务，设备 did\n\n\ngroup_id\nstring\n否\nbody\n针对设备分组控制任务，设备分组 id\n\n\nattrs\nobject\n否\nbody\n针对非延时任务，数据点控制命令，枚举型数据点传序号，扩展型数据点传 base64 编码字符串\n\n\nraw\nstring\n否\nbody\n针对非延时任务，原始控制指令，base64 编码\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n场景 id\n\n\n\n返回例子\n{\n  \"id\": \"59c8d5c38c7d50001a21c872\"\n}\n\n删除场景\n调试接口\n请求地址及方式\n  DELETE\n  https://api.gizwits.com/app/scene/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n场景ID\n\n\n\n响应参数\n无\n修改场景信息\n调试接口\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/scene/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n场景ID\n\n\nscene_name\nstring\n是\nbody\n场景名称\n\n\nremark\nstring\n否\nbody\n场景备注\n\n\ntask_type\nstring\n是\nbody\n场景任务类型： \"delay\": 延时任务，\"device\": 控制当个设备任务，\"group\": 控制设备分组任务（仅可控制单 product_key 分组)\n\n\ntime\ninteger\n否\nbody\n针对延时任务，延时时间，以秒为单位，最大值： 3600 秒\n\n\ndid\nstring\n否\nbody\n针对单品控制任务，设备 did\n\n\ngroup_id\nstring\n否\nbody\n针对设备分组控制任务，设备分组 id\n\n\nattrs\nobject\n否\nbody\n针对非延时任务，数据点控制命令，枚举型数据点传序号，扩展型数据点传 base64 编码字符串\n\n\nraw\nstring\n否\nbody\n针对非延时任务，原始控制指令，base64 编码\n\n\n\n响应参数\n无\n查询场景任务执行状态\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/scene/{id}/task\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n场景ID\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nstatus\ninteger\n场景任务执行状态,0：进行中;1：执行完成;2：执行失败;3：任务未在执行\n\n\n\n返回例子\n{\n  \"status\": 1\n}\n\n执行场景任务\n调试接口\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/scene/{id}/task\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n场景ID\n\n\n\n响应参数\n无\n\n返回成功，场景任务开始执行\n\n定时任务管理\n定时任务分为如下几类：\n\n一次性定时任务\n按星期重复定时任务\n按天重复定时任务\n\n每个定时任务都可以设置使能状态，只有开启状态的定时任务才会被执行。\n定时任务管理下的全部接口均使用 UTC 时间\n定时任务管理接口只能对单个设备设置定时任务\n获取定时任务\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/devices/{did}/scheduler?limit=20&skip=0\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n需要设置定时任务的设备id\n\n\nlimit\ninteger\n否\nquery\n返回的结果条数\n\n\nskip\ninteger\n否\nquery\n表示跳过的条数，间接表示页数。\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n定时任务id\n\n\ncreated_at\nstring\n任务创建时间 UTC 时间\n\n\nproduct_key\nstring\n产品PK\n\n\ndid\nstring\n需要设置定时任务的设备id\n\n\nraw\nstring\n原始控制指令\n\n\nattrs\nobject\n\n\n\ndate\nstring\n一次性定时任务的执行时间\n\n\ntime\nstring\n定时任务执行的时间，精确到分钟，格式xx:xx，如：02:30\n\n\nrepeat\nstring\n是否重复，\"none\",\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\n重复的日期列表，如[1, 15]表示每月1日和15日重复\n\n\nstart_date\nstring\n定时任务执行的开始日期，该天0点开始，格式xxxx-xx-xx，如2016-09-01\n\n\nend_date\nstring\n定时任务执行的结束日期，该天24点结束，格式xxxx-xx-xx，如2016-10-01\n\n\nenabled\nboolean\n是否启用，若不启用则时间到也不触发，默认启用\n\n\nremark\nstring\n任务备注\n\n\n\n返回例子\n[\n  {\n    \"remark\": \"备注\",\n    \"repeat\": \"none\",\n    \"end_date\": \"2017-09-26\",\n    \"did\": \"LWHWrRAnzRbxtv9cyuNFSY\",\n    \"created_at\": \"2017-09-26T06:36:47\",\n    \"enabled\": true,\n    \"days\": [],\n    \"product_key\": \"b6777e0a343b422b8c474254e016b4dc\",\n    \"id\": \"59c9f57f8c7d50001963992c\",\n    \"raw\": \"\",\n    \"attrs\": {\n      \"bool\": true\n    },\n    \"time\": \"15:00\",\n    \"date\": \"2017-09-26\",\n    \"start_date\": \"2017-09-20\"\n  }\n]\n\n创建定时任务\n调试接口\n创建一次性定时任务\n\nrepeat 设置为 none\ndate 和 time 必须填写，并且注意 date 和 time 为执行定时任务时的 UTC 时间\n\n创建按星期重复定时任务\n\nrepeat 为重复星期，多个用逗号分隔；比如每周一执行，设置为 \"mon\"，每周一、周三执行，设置为 \"mon,wed\"；\nrepeat 为重复星期时，可选值为： mon,tue,wed,thu,fri,sat,sun\ntime 必须填写，并且注意星期和 time 为执行定时任务时的 UTC 时间\n可以选填 start_date 和 end_date 表示定时任务开启的日期范围\n\n创建按天重复的定时任务\n\nrepeat 设置为 day\ndays 设置为要执行的日期列表；比如每月 1 号执行，设置为 [\"1\"]；每月 1 号、15 号执行，设置为 [\"1\", \"15\"]\ntime 必须填写，并且注意 days 和 time 为执行定时任务时的 UTC 时间\n可以选填 start_date 和 end_date 表示定时任务开启的日期范围\n\n原始指令(raw):\n默认格式为 hex16 ，设置 binary_coding 参数可使用 base64 ，\n如要发送 payload 为二进制 011000010110001001100011 ，每组byte换成16进制就是： 616263 ；\n{\n  \"raw\": 616263\n}\n\n数据点方式(attrs):\n设备产品必须定义了数据点。如要设置扩展类型的字段 binary 为1234567(16进制)，需要补齐扩展型长度；\n扩展型默认为hex16 ，设置 binary_coding 参数可使用 base64 。\n{\n  \"attrs\": {\n    \"boolean\":true,\n    \"binary\": \"1234567000\"\n  }\n}\n\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/devices/{did}/scheduler\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n需要设置定时任务的设备id\n\n\nraw\nstring\n否\nbody\n原始控制指令\n\n\nattrs\nobject\n否\nbody\n\n\n\ndate\nstring\n是\nbody\n一次性定时任务的执行时间\n\n\ntime\nstring\n是\nbody\n定时任务执行的时间，精确到分钟，格式xx:xx，如：02:30\n\n\nrepeat\nstring\n是\nbody\n是否重复，\"none\",\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\n否\nbody\n重复的日期列表，如[1, 15]表示每月1日和15日重复\n\n\nstart_date\nstring\n否\nbody\n定时任务执行的开始日期，该天0点开始，格式xxxx-xx-xx，如2016-09-01\n\n\nend_date\nstring\n否\nbody\n定时任务执行的结束日期，该天24点结束，格式xxxx-xx-xx，如2016-10-01\n\n\nenabled\nboolean\n否\nbody\n是否启用，若不启用则时间到也不触发，默认启用\n\n\nremark\nstring\n否\nbody\n任务备注\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n定时任务id\n\n\n\n返回例子\n{\n  \"id\": \"59c9f57f8c7d50001963992c\"\n}\n\n修改定时任务\n调试接口\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/devices/{did}/scheduler/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n需要设置定时任务的设备id\n\n\nid\nstring\n是\npath\n需要修改的定时任务id\n\n\nraw\nstring\n否\nbody\n原始控制指令\n\n\nattrs\nobject\n否\nbody\n\n\n\ndate\nstring\n是\nbody\n一次性定时任务的执行时间\n\n\ntime\nstring\n是\nbody\n定时任务执行的时间，精确到分钟，格式xx:xx，如：02:30\n\n\nrepeat\nstring\n是\nbody\n是否重复，\"none\",\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\n否\nbody\n重复的日期列表，如[1, 15]表示每月1日和15日重复\n\n\nstart_date\nstring\n否\nbody\n定时任务执行的开始日期，该天0点开始，格式xxxx-xx-xx，如2016-09-01\n\n\nend_date\nstring\n否\nbody\n定时任务执行的结束日期，该天24点结束，格式xxxx-xx-xx，如2016-10-01\n\n\nenabled\nboolean\n否\nbody\n是否启用，若不启用则时间到也不触发，默认启用\n\n\nremark\nstring\n否\nbody\n任务备注\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n定时任务id\n\n\n\n返回例子\n{\n  \"id\": \"59c9f57f8c7d50001963992c\"\n}\n\n删除定时任务\n调试接口\n请求地址及方式\n  DELETE\n  https://api.gizwits.com/app/devices/{did}/scheduler/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n定时任务id\n\n\n\n响应参数\n无\n通用定时任务\n通用定时任务 为 定时任务管理 的升级接口，能对场景、分组和单个设备创建定时任务。\n获取定时任务\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/app/common_scheduler?did={did}&group_id={group_id}&scene_id={scene_id}&limit={limit}&skip={skip}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n否\npath\n需要设置定时任务的设备id\n\n\ngroup_id\nstring\n否\npath\n分组id\n\n\nscene_id\nstring\n否\npath\n场景id\n\n\nlimit\ninteger\n否\nquery\n返回的结果条数\n\n\nskip\ninteger\n否\nquery\n表示跳过的条数，间接表示页数。\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n定时任务id\n\n\ncreated_at\nstring\n任务创建时间 UTC 时间\n\n\nproduct_key\nstring\n产品PK\n\n\nscene_id\nstring\n\n\n\ngroup_id\nstring\n\n\n\ndid\nstring\n需要设置定时任务的设备id\n\n\nraw\nstring\n原始控制指令\n\n\nattrs\nobject\n\n\n\ndate\nstring\n一次性定时任务的执行时间\n\n\ntime\nstring\n定时任务执行的时间，精确到分钟，格式xx:xx，如：02:30\n\n\nrepeat\nstring\n是否重复，\"none\",\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\n重复的日期列表，如[1, 15]表示每月1日和15日重复\n\n\nstart_date\nstring\n定时任务执行的开始日期，该天0点开始，格式xxxx-xx-xx，如2016-09-01\n\n\nend_date\nstring\n定时任务执行的结束日期，该天24点结束，格式xxxx-xx-xx，如2016-10-01\n\n\nenabled\nboolean\n是否启用，若不启用则时间到也不触发，默认启用\n\n\nremark\nstring\n任务备注\n\n\n\n返回例子\n[\n  {\n    \"remark\": \"备注\",\n    \"repeat\": \"none\",\n    \"end_date\": \"2017-09-26\",\n    \"did\": \"LWHWrRAnzRbxtv9cyuNFSY\",\n    \"created_at\": \"2017-09-26T06:36:47\",\n    \"enabled\": true,\n    \"days\": [],\n    \"product_key\": \"b6777e0a343b422b8c474254e016b4dc\",\n    \"id\": \"59c9f57f8c7d50001963992c\",\n    \"raw\": \"\",\n    \"attrs\": {\n      \"bool\": true\n    },\n    \"time\": \"15:00\",\n    \"date\": \"2017-09-26\",\n    \"scene_id\": \"\",\n    \"group_id\": \"\",\n    \"start_date\": \"2017-09-20\"\n  }\n]\n\n创建定时任务\n调试接口\n\ndid, group_id, scene_id 参数只需传其中一个，分别用于创建设备，设备分组，用户场景定时任务，\n若同时传了多个，则按此优先级取第一个有效字符串；\n针对场景任务，不需要传 raw 和 attrs 控制命令，传了会被忽略；\n创建循环类型与定时任务管理接口一致。\n\n原始指令(raw):\n默认格式为 hex16 ，设置 binary_coding 参数可使用 base64 ，\n如要发送 payload 为二进制 011000010110001001100011 ，每组byte换成16进制就是： 616263 ；\n{\n  \"raw\": 616263\n}\n\n数据点方式(attrs):\n设备产品必须定义了数据点。如要设置扩展类型的字段 binary 为1234567(16进制)，需要补齐扩展型长度；\n扩展型默认为hex16 ，设置 binary_coding 参数可使用 base64 。\n{\n  \"attrs\": {\n    \"boolean\":true,\n    \"binary\": \"1234567000\"\n  }\n}\n\n请求地址及方式\n  POST\n  https://api.gizwits.com/app/common_scheduler\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n否\nbody\n需要设置定时任务的设备id\n\n\ngroup_id\nstring\n否\nbody\n需要设置定时任务的设备分组id\n\n\nscene_id\nstring\n否\nbody\n需要设置定时任务的场景id\n\n\nraw\nstring\n否\nbody\n原始控制指令\n\n\nattrs\nobject\n否\nbody\n\n\n\ndate\nstring\n是\nbody\n一次性定时任务的执行时间\n\n\ntime\nstring\n是\nbody\n定时任务执行的时间，精确到分钟，格式xx:xx，如：02:30\n\n\nrepeat\nstring\n是\nbody\n是否重复，\"none\",\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\n否\nbody\n重复的日期列表，如[1, 15]表示每月1日和15日重复\n\n\nstart_date\nstring\n否\nbody\n定时任务执行的开始日期，该天0点开始，格式xxxx-xx-xx，如2016-09-01\n\n\nend_date\nstring\n否\nbody\n定时任务执行的结束日期，该天24点结束，格式xxxx-xx-xx，如2016-10-01\n\n\nenabled\nboolean\n否\nbody\n是否启用，若不启用则时间到也不触发，默认启用\n\n\nremark\nstring\n否\nbody\n任务备注\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n通用定时任务id\n\n\n\n返回例子\n{\n  \"id\": \"59c9f57f8c7d50001963992c\"\n}\n\n修改定时任务\n调试接口\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/common_scheduler/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\nid\nstring\n是\npath\n通用定时任务id\n\n\ndid\nstring\n否\nbody\n需要设置定时任务的设备id\n\n\ngroup_id\nstring\n否\nbody\n需要设置定时任务的设备分组id\n\n\nscene_id\nstring\n否\nbody\n需要设置定时任务的场景id\n\n\nraw\nstring\n否\nbody\n原始控制指令\n\n\nattrs\nobject\n否\nbody\n\n\n\ndate\nstring\n是\nbody\n一次性定时任务的执行时间\n\n\ntime\nstring\n是\nbody\n定时任务执行的时间，精确到分钟，格式xx:xx，如：02:30\n\n\nrepeat\nstring\n是\nbody\n是否重复，\"none\",\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"\n\n\ndays\nArray\n否\nbody\n重复的日期列表，如[1, 15]表示每月1日和15日重复\n\n\nstart_date\nstring\n否\nbody\n定时任务执行的开始日期，该天0点开始，格式xxxx-xx-xx，如2016-09-01\n\n\nend_date\nstring\n否\nbody\n定时任务执行的结束日期，该天24点结束，格式xxxx-xx-xx，如2016-10-01\n\n\nenabled\nboolean\n否\nbody\n是否启用，若不启用则时间到也不触发，默认启用\n\n\nremark\nstring\n否\nbody\n任务备注\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nid\nstring\n通用定时任务id\n\n\n\n返回例子\n{\n  \"id\": \"59c9f57f8c7d50001963992c\"\n}\n\n删除定时任务\n调试接口\n请求地址及方式\n  DELETE\n  https://api.gizwits.com/app/common_scheduler/{id}\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n需要设置定时任务的设备id\n\n\nid\nstring\n是\npath\n通用定时任务id\n\n\n\n响应参数\n无\n高级数据接口\n获取设备聚合数据\n该接口可以对设备上报的数值型数据点数据进行聚合，可以按小时/天/周/月对数据点数据进行求和/平均值/最大值/最小值进行聚合。\n一次可以获取多个数据点的聚合数据。\n要使用该接口，必须先请求开通该接口。请求通过的之后上报的数据才会进行聚合运算。\n调试接口\n请求地址及方式\n  PUT\n  https://api.gizwits.com/app/devdata/{did}/agg_data\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\nX-Gizwits-User-token\nstring\n是\nheader\n用户token\n\n\ndid\nstring\n是\npath\n设备ID\n\n\nstart_ts\ninteger\n是\nquery\n开始时间，单位为毫秒\n\n\nend_ts\ninteger\n否\nquery\n结束时间，单位为毫秒\n\n\nattrs\nstring\n是\nquery\n数字类型数据点名称，多个数据点用逗号分隔\n\n\naggregator\nstring\n是\nquery\n统计方式，sum：合计；avg：平均值；max：最大值；min：最少值\n\n\nunit\nstring\n是\nquery\n汇总方式,hours：小时；day：天；weeks：周；months：月\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\naggregator\nstring\n统计方式，sum：合计；avg：平均值；max：最大值；min：最少值\n\n\nend_ts\ninteger\n开始时间，单位为毫秒\n\n\nstart_ts\ninteger\n结束时间，单位为毫秒\n\n\nattrs\nstring\n查询的数据点\n\n\nunit\nstring\nsum：合计；avg：平均值；max：最大值；min：最少值\n\n\ndatatime\nstring\n\n\n\nuid\nstring\n用户id\n\n\nproduct_key\nstring\n产品PK\n\n\nattrs\nobject\n数据点聚合结果\n\n\n\n返回例子\n{\n  \"query\": {\n    \"aggregator\": \"sum\",\n    \"end_ts\": null,\n    \"start_ts\": 1505318400000,\n    \"attrs\": \"set_temp, alert_shutdown, room_temp\",\n    \"unit\": \"HOURS\"\n  },\n  \"data\": [\n    {\n      \"datatime\":\"\",\n      \"uid\":\"c0a85d0773e24f15a6853f3148c80a33\",\n      \"product_key\":\"42121342d79694a259232431b6f2ef46a\",\n      \"attrs\":{\n        \"set_temp\":\"12\",\n        \"alert_shutdown\":\"12\",\n        \"room_temp\":\"12\"\n      }\n    }\n  ]\n}\n\n系统信息\n查询 Open API 版本\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/status\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nversion\nstring\nopen API 版本号\n\n\n\n返回例子\n{\n  \"status\": {\n    \"version\": \"2.15.1\"\n  }\n}\n\n\n获取 Open API 所有的错误码\n调试接口\n请求地址及方式\n  GET\n  https://api.gizwits.com/errors\n请求参数\n\n\n\n参数\n类型\n必填\n参数类型\n描述\n\n\n\n\nX-Gizwits-Application-Id\nstring\n是\nheader\nappid\n\n\n\n响应参数\n\n\n\n参数\n类型\n描述\n\n\n\n\nstatus\nstring\n响应码\n\n\nerror_code\nstring\n错误码\n\n\nerror_message\nstring\n错误信息\n\n\n\n返回例子\n[\n  {\n    \"status\": 404,\n    \"error_message\": \"scene not found!\",\n    \"error_code\": 9220\n  },\n  {\n    \"status\": 400,\n    \"error_message\": \"the scene does not belong to you!\",\n    \"error_code\": 9221\n  }\n]\n\n\n详细错误信息可查看下表Open API 错误码表\n附录：Open API 错误码表\n\n\n\n错误码\n错误类别\n描述\n\n\n\n\n9001\nGIZ_OPENAPI_MAC_ALREADY_REGISTERED\nmac already registered!\n\n\n9002\nGIZ_OPENAPI_PRODUCT_KEY_INVALID\nproduct_key invalid\n\n\n9003\nGIZ_OPENAPI_APPID_INVALID\nappid invalid\n\n\n9004\nGIZ_OPENAPI_TOKEN_INVALID\ntoken invalid\n\n\n9005\nGIZ_OPENAPI_USER_NOT_EXIST\nuser not exist\n\n\n9006\nGIZ_OPENAPI_TOKEN_EXPIRED\ntoken expired\n\n\n9007\nGIZ_OPENAPI_M2M_ID_INVALID\nm2m_id invalid\n\n\n9008\nGIZ_OPENAPI_SERVER_ERROR\nserver error\n\n\n9009\nGIZ_OPENAPI_CODE_EXPIRED\ncode expired\n\n\n9010\nGIZ_OPENAPI_CODE_INVALID\ncode invalid\n\n\n9011\nGIZ_OPENAPI_SANDBOX_SCALE_QUOTA_EXHAUSTED\nsandbox scale quota exhausted!\n\n\n9012\nGIZ_OPENAPI_PRODUCTION_SCALE_QUOTA_EXHAUSTED\nproduction scale quota exhausted!\n\n\n9013\nGIZ_OPENAPI_PRODUCT_HAS_NO_REQUEST_SCALE\nproduct has no request scale!\n\n\n9014\nGIZ_OPENAPI_DEVICE_NOT_FOUND\ndevice not found!\n\n\n9015\nGIZ_OPENAPI_FORM_INVALID\nform invalid!\n\n\n9016\nGIZ_OPENAPI_DID_PASSCODE_INVALID\ndid or passcode invalid!\n\n\n9017\nGIZ_OPENAPI_DEVICE_NOT_BOUND\ndevice not bound!\n\n\n9018\nGIZ_OPENAPI_PHONE_UNAVALIABLE\nphone unavailable!\n\n\n9019\nGIZ_OPENAPI_USERNAME_UNAVALIABLE\nusername unavailable!\n\n\n9020\nGIZ_OPENAPI_USERNAME_PASSWORD_ERROR\nusername or password error!\n\n\n9021\nGIZ_OPENAPI_SEND_COMMAND_FAILED\nsend command failed!\n\n\n9022\nGIZ_OPENAPI_EMAIL_UNAVALIABLE\nemail unavailable!\n\n\n9023\nGIZ_OPENAPI_DEVICE_DISABLED\ndevice is disabled!\n\n\n9024\nGIZ_OPENAPI_FAILED_NOTIFY_M2M\nfail to notify m2m!\n\n\n9025\nGIZ_OPENAPI_ATTR_INVALID\nattr invalid!\n\n\n9026\nGIZ_OPENAPI_USER_INVALID\nuser invalid!\n\n\n9027\nGIZ_OPENAPI_FIRMWARE_NOT_FOUND\nfirmware not found!\n\n\n9028\nGIZ_OPENAPI_JD_PRODUCT_NOT_FOUND\nJD product info not found!\n\n\n9029\nGIZ_OPENAPI_DATAPOINT_DATA_NOT_FOUND\ndatapoint data not found!\n\n\n9030\nGIZ_OPENAPI_SCHEDULER_NOT_FOUND\nscheduler not found!\n\n\n9031\nGIZ_OPENAPI_QQ_OAUTH_KEY_INVALID\nqq oauth key invalid!\n\n\n9032\nGIZ_OPENAPI_OTA_SERVICE_OK_BUT_IN_IDLE\nota upgrade service OK, but in idle or disable!\n\n\n9033\nGIZ_OPENAPI_BT_FIRMWARE_UNVERIFIED\nbt firmware unverified,except verify device!\n\n\n9034\nGIZ_OPENAPI_BT_FIRMWARE_NOTHING_TO_UPGRADE\nbt firmware is OK, but nothing to upgrade!\n\n\n9035\nGIZ_OPENAPI_SAVE_KAIROSDB_ERROR\nSave kairosdb error!\n\n\n9036\nGIZ_OPENAPI_EVENT_NOT_DEFINED\nevent not defined!\n\n\n9037\nGIZ_OPENAPI_SEND_SMS_FAILED\nsend sms failed!\n\n\n9038\nGIZ_OPENAPI_APPLICATION_AUTH_INVALID\nX-Gizwits-Application-Auth invalid!\n\n\n9039\nGIZ_OPENAPI_NOT_ALLOWED_CALL_API\nNot allowed to call deprecated API!\n\n\n9040\nGIZ_OPENAPI_BAD_QRCODE_CONTENT\nbad qrcode content!\n\n\n9041\nGIZ_OPENAPI_REQUEST_THROTTLED\nrequest was throttled\n\n\n9042\nGIZ_OPENAPI_DEVICE_OFFLINE\ndevice offline!\n\n\n9043\nGIZ_OPENAPI_TIMESTAMP_INVALID\nX-Gizwits-Timestamp invalid!\n\n\n9044\nGIZ_OPENAPI_SIGNATURE_INVALID\nX-Gizwits-Signature invalid!\n\n\n9045\nGIZ_OPENAPI_DEPRECATED_API\nAPI deprecated!\n\n\n9046\nGIZ_OPENAPI_REGISTER_IS_BUSY\nRegister already in progress!\n\n\n9077\nGIZ_OPENAPI\nemail already exists but not activate!\n\n\n9080\nGIZ_OPENAPI_CANNOT_SHARE_TO_SELF\ncan not share device to self!\n\n\n9081\nGIZ_OPENAPI_ONLY_OWNER_CAN_SHARE\nguest or normal user can not share device!\n\n\n9082\nGIZ_OPENAPI_NOT_FOUND_GUEST\nguest user not found!\n\n\n9083\nGIZ_OPENAPI_GUEST_ALREADY_BOUND\nguest user alread bound!\n\n\n9084\nGIZ_OPENAPI_NOT_FOUND_SHARING_INFO\nsharing record not found!\n\n\n9085\nGIZ_OPENAPI_NOT_FOUND_THE_MESSAGE\nmessage record not found!\n\n\n9087\nGIZ_OPENAPI_SHARING_IS_WAITING_FOR_ACCEPT\nsharing alread created,waiting for the guest to accept!\n\n\n9088\nGIZ_OPENAPI_SHARING_IS_EXPIRED\nsharing record expired!\n\n\n9089\nGIZ_OPENAPI_SHARING_IS_COMPLETED\nsharing record status is not unaccept!\n\n\n9090\nGIZ_OPENAPI_INVALID_SHARING_BECAUSE_UNBINDING\nowner binding disabled!\n\n\n9092\nGIZ_OPENAPI_ONLY_OWNER_CAN_BIND\nowner exist, guest can not bind!\n\n\n9093\nGIZ_OPENAPI_ONLY_OWNER_CAN_OPERATE\npermission denied, you are not owner!\n\n\n9094\nGIZ_OPENAPI_SHARING_ALREADY_CANCELLED\nsharing already canceled!\n\n\n9095\nGIZ_OPENAPI_OWNER_CANNOT_UNBIND_SELF\ncan not unbind self!\n\n\n9096\nGIZ_OPENAPI_ONLY_GUEST_CAN_CHECK_QRCODE\npermission denied, you are not guest!\n\n\n9098\nGIZ_OPENAPI_MESSAGE_ALREADY_DELETED\nnotify delele binding failed!\n\n\n9099\nGIZ_OPENAPI_BINDING_NOTIFY_FAILED\nnotify delele binding failed!\n\n\n9100\nGIZ_OPENAPI_ONLY_SELF_CAN_MODIFY_ALIAS\npermission denied, you are not owner or guest!\n\n\n9101\nGIZ_OPENAPI_ONLY_RECEIVER_CAN_MARK_MESSAGE\npermission denied, you are not the receiver!\n\n\n9999\nGIZ_OPENAPI_RESERVED\nreserved\n\n\n\n"},{"title":"ESP8266开发指南","url":"/zh-cn/GCP/wmodule/ESP8266.html","content":"ESP8266开发概述\n\n芯片模组型号：乐鑫ESP8266\n所属企业：乐鑫信息科技（上海）有限公司\n模组类型：wifi模组\n机智云自研的串口通信协议GAgent赋予乐鑫ESP8266联网能力。\n只需在模组上烧写Gagent固件，即可快速实现设备M2M接入、数据统计分析、远程控制、OTA升级、第三方接口等功能服务。该固件支持SoC方案及二次开发，大大降低开发成本，缩短研发周期。\n\nESP8266 SDK（GAgent）固件下载\n应用范围\n智能家居 \\ 智能家电 \\ 智慧公寓 \\ 智慧安防 \\ 物联网M2M \\ 单品类解决方案（净水器、空气净化器、照明、卫浴、厨电等） \\ 商用租赁 \\ 智能充电桩 \\ 工业控制 \\ 农业大棚 \\ 资产管理 \\ 客户案例。\nESP8266快速联网\n硬件厂商对硬件智能化的第一步是让设备能够联网，GAgent是机智云提供的一款兼容国内主流Wi-Fi模块、移动网络模块的模组系统。硬件厂商只需理解如何与GAgent进行通讯即可。\n相关链接：\n\n了解GAgent详解\n设备快速接入机智云\n\n\nIoT 开发\n用ESP8266只需5步开发一个iot产品:\n\nStep1：在ESP8266芯片上烧写GAgent固件；\nStep2：在机智云开发者中心创建产品，并定义数据点；\nStep3：下载自动生成的模组通信协议；\nStep4：使用虚拟设备和机智云APP进行调试；\nStep5：通过机智云APP与虚拟设备联动。\n\n至此，一个产品的Demo已经制作完成。\n如需加速产品开发，可使用机智云提供的MCU代码自动生成工具、APP开源框架。\nESP8266 SOC开发\n\nESP8266  SOC开发介绍\n低成本SOC开发\nGoKit-SoC-ESP8266开发套件介绍\nGOkit3  SOC 教学视频\nESP8266 烧写机智云GAgent固件教程详解\nESP8266 雾计算ECE入门教程（超详细）\nESP8266 教程汇总\n\n应用案例\n常见应用案例\n\n51单片机连接机智云小案例：stc89c52+esp8266-01\nArduino Pro mini智能小夜灯（ESP8266）\n植物宝\n用 ESP8266 做一个网络插座 (SOC方案)\n基于ESP8266 SOC 车库照明系统\n\n开源项目\n\n智能家居应用模型One\n智能药盒\n智能婴儿摇篮\n智能灯\n智能温控器\n智能鞋柜\n智能家居云控制套件\n智能健康计\n智能插座\n智慧宿舍\n智能仓鼠管家（语音版）\n无线工业粉尘监测仪\n\n商用项目\n部分商用项目：\n\n伊莱特智能电饭煲\n全球客服 A.O.史密斯\n华商三优电动车智能充电应用平台\n西默智能路由器\n艾沃净水机：连接微信，智慧饮水\n戴勒姆Care2Share\n酷蛙智能净水器\n诸葛小明床头灯，语音控制 wifi音响自动感应\n新科微信操控空调\n希澈智能声波牙刷\n巴比立方智能果蔬种植机\n幸福森林空气净化器\nC1智能鱼缸温控器\nOnread智能插座\n无源智能墙壁开关\n\n常见问题\n\nGAgent for ESP8266固件\n下载地址\n\nESP8266最简单的编译环境搭建和机智云SOC代码导入 http://club.gizwits.com/thread-5344-1-1.html\n\nESP8266 物联网开发专区 http://club.gizwits.com/forum-170-1.html\n\n机智云调试APP下载地址：\n安卓用户，可在机智云官网下载，亦可在 应用商店 搜索“机智云”下载；\nios用户，可在机智云官网下载，亦可在 APPStore 搜索“机智云”下载；\n\n5分钟了解机智云\n\n机智云支持哪些WiFi模块、GSM模块？\n\n汉枫 HF-LPB100、HF-LPB120、LPT120\n乐鑫/安信可    esp-8266\nRealtek8711am、联盛德TLN13SP01、广州致远AW54101WFX、高通QCA4004\nTI    CC3200、NXP QFN-1、上海移远M26\n广和通G510、 中兴ME3610 、中兴ME3630\n\n\n在哪可以购买已烧写好GAgent固件的ESP8266模块\n\n\n关于机智云\n机智云，Giz(mo)Wits（设备智慧）是广州机智云物联网科技有限公司旗下品牌，全球领先的物联网开发和云服务商，全栈物联网平台服务领导者，国内第一个智能硬件自助开发(PaaS)及云服务(SaaS)平台\n公司拥有完整的技术研发团队、安全团队和人工智能团队，为有志于进军物联网开发者和企业提供安全、可靠的一站式物联网开发工具和云端运维服务，涵盖终端管理、连接管理、应用支持和业务分析等主要功能，已服务车联网、新能源、工业互联、医疗健康、消费类电子产品等众多行业。\n模块化开发工具\n以下是机智云提供的模块化开发工具：\n\n标准GAgent串口通讯协议\nMCU代码自动生成工具\nAPP代码自动生成工具\n自动化产测工具\nOTA固件升级\n国际版应用邮件模板\n产品互联（Echo接入等）\nSnoti服务\n企业API、OPEN API\nRTDB实时大数据统计\n\n解决方案\n以下是机智云提供的解决方案：\n\n信息家电/大家电智能化/小家电智能化/\n厨电信息化解决方案\n智能净水器/智能空气净化器/\n汽车电子/车联网/智能充电桩\n公寓/楼宇/家居/酒店智能化解决方案\n安防 / 消防\n电机控制\n智能电网\n医疗/保健/卫生\n\n官方技术交流群\n\nG1机智云物联网云服务 104975951\nG2机智云物联网云服务 491509598\nG3机智云物联网云服务 287087942\nG4机智云-STM32 iot开发 289447077\nG5-APP代码自动生成公测 599735135\nG6机智云-Arduino iot开发 378683984\n\n联系我们\n\n地址: 广州天河区天平架陶庄路5号众创空间8-9层 研发中心\n电话: 020-6224-0080\n邮箱: service@gizwits.com\nNewYork   646.201.9357\n\n\n"},{"title":"汉枫HF-LPB100/HB-LPB120开发指南","url":"/zh-cn/GCP/wmodule/LPB100.html","content":"汉枫开发概述\n\n芯片模组型号：汉枫HF-LPB100/HB-LPB120\n所属企业：上海汉枫电子科技有限公司\n模组类型：wifi模组\n\n机智云自研的串口通信协议GAgent赋予汉枫HF-LPB100/HF-LPT120联网能力。\n只需在模组上烧写Gagent固件，即可实现上层应用（手机APP等控制端、云端）到产品设备的双向数据通讯，此外，还提供对设备的配置入网、发现绑定、程序升级等功能。\n汉枫HF-LPB100/HB-LPB120 SDK（GAgent）固件下载\n应用范围\n智能家居 \\ 智能家电 \\ 智慧公寓 \\ 智慧安防 \\ 物联网M2M \\ 单品类解决方案（净水器、空气净化器、照明、卫浴、厨电等） \\ 商用租赁 \\ 智能充电桩 \\ 工业控制 \\ 农业大棚 \\ 资产管理 \\ 客户案例。\n快速联网\n硬件厂商对硬件智能化的第一步是让设备能够联网，GAgent是机智云提供的一款兼容国内主流Wi-Fi模块、移动网络模块的模组系统。硬件厂商只需理解如何与GAgent进行通讯即可。\n相关链接：\n · 了解GAgent详解\n · 设备快速接入机智云\n\nIoT 开发\n用汉枫HF-LPB100/HF-LPT120只需5步开发一个iot产品:\n\nStep1：在汉枫HF-LPB100/HF-LPT120芯片上烧写GAgent固件；\nStep2：在机智云开发者中心创建产品，并定义数据点；\nStep3：下载自动生成的模组通信协议；\nStep4：使用虚拟设备和机智云APP进行调试；\nStep5：通过机智云APP与虚拟设备联动。\n至此，一个产品的Demo已经制作完成。\n\n如需加速产品开发，可使用机智云提供的MCU代码自动生成工具、APP开源框架。\n文档资料\n\nHF-LPB100串口烧写说明\nHF-LPT120串口烧写说明\n串口工具SecureCRT 下载\n 低成本高效APP开发\n使用Gizwits Open API，快速开发轻应用\n\n应用案例\n常见应用案例\n\n51单片机连接机智云小案例：stc89c52+esp8266-01\nArduino Pro mini智能小夜灯\n植物宝\n智能插座报警器\n\n开源项目\n\n智能家居应用模型One\n智能药盒\n智能婴儿摇篮\n智能灯\n智能温控器\n智能鞋柜\n智能家居云控制套件\n智能健康计\n智能插座\n智慧宿舍\n智能仓鼠管家（语音版）\n无线工业粉尘监测仪\n\n商用项目\n部分商用项目：\n\n伊莱特智能电饭煲\n全球客服 A.O.史密斯\n华商三优电动车智能充电应用平台\n西默智能路由器\n艾沃净水机：连接微信，智慧饮水\n戴勒姆Care2Share\n酷蛙智能净水器\n诸葛小明床头灯，语音控制 wifi音响自动感应\n新科微信操控空调\n希澈智能声波牙刷\n巴比立方智能果蔬种植机\n幸福森林空气净化器\nC1智能鱼缸温控器\nOnread智能插座\n无源智能墙壁开关\n\nFAQ\n\nGAgent for 汉枫固件下载地址\n\nHF-LPB100串口烧写说明\n\nHF-LPT120串口烧写说明\n\n在哪可以购买已烧写好GAgent固件的汉枫模块：https://shop159680395.taobao.com/\n\nGAgent for 汉枫LPB100固件下载地址\n\n机智云调试APP下载地址：\n安卓用户，可在机智云官网下载，亦可在 应用商店 搜索“机智云”下载；\nios用户，可在机智云官网下载，亦可在 APPStore 搜索“机智云”下载；\n\n5分钟了解机智云\n\n机智云支持哪些WiFi模块、GSM模块？\n\n汉枫 HF-LPB100、HF-LPB120、LPT120\n乐鑫/安信可    esp-8266\nRealtek8711am、联盛德TLN13SP01、广州致远AW54101WFX、高通QCA4004\nTI    CC3200、NXP QFN-1、上海移远M26\n广和通G510、 中兴ME3610 、中兴ME3630\n\n\n\n关于机智云\n机智云，Giz(mo)Wits（设备智慧）是广州机智云物联网科技有限公司旗下品牌，全球领先的物联网开发和云服务商，全栈物联网平台服务领导者，国内第一个智能硬件自助开发(PaaS)及云服务(SaaS)平台\n公司拥有完整的技术研发团队、安全团队和人工智能团队，为有志于进军物联网开发者和企业提供安全、可靠的一站式物联网开发工具和云端运维服务，涵盖终端管理、连接管理、应用支持和业务分析等主要功能，已服务车联网、新能源、工业互联、医疗健康、消费类电子产品等众多行业。\n模块化开发工具\n以下是机智云提供的模块化开发工具：\n\n标准GAgent串口通讯协议\nMCU代码自动生成工具\nAPP代码自动生成工具\n自动化产测工具\nOTA固件升级\n国际版应用邮件模板\n产品互联（Echo接入等）\nSnoti服务\n企业API、OPEN API\nRTDB实时大数据统计\n\n解决方案\n以下是机智云提供的解决方案：\n\n信息家电/大家电智能化/小家电智能化/\n厨电信息化解决方案\n智能净水器/智能空气净化器/\n汽车电子/车联网/智能充电桩\n公寓/楼宇/家居/酒店智能化解决方案\n安防 / 消防\n电机控制\n智能电网\n医疗/保健/卫生\n\n官方技术交流群\n\nG1机智云物联网云服务 104975951\nG2机智云物联网云服务 491509598\nG3机智云物联网云服务 287087942\nG4机智云-STM32 iot开发 289447077\nG5-APP代码自动生成公测 599735135\nG6机智云-Arduino iot开发 378683984\n\n联系我们\n\n地址: 广州天河区天平架陶庄路5号众创空间8-9层 研发中心\n电话: 020-6224-0080\n邮箱: service@gizwits.com\nNewYork   646.201.9357\n\n\n"},{"title":"广和通G510开发指南","url":"/zh-cn/GCP/gmodule/G510.html","content":"G510开发概述\nG510是广和通推出的一款基于GPRS的通讯模组，符合工业级要求，通过了88小时×7轮的严酷ALT测试。它又是是业界最小的邮票口封装无线通信模块，支持GSM/GPRS 850/900/1800/1900MHz四频，超小的体积，超低的功耗，超强的EMC和ESD性能，拥有内置协议栈和双串口，为用户提供完美的语音通话功能和高速的GPRS数据传输速度。适用于M2M领域中各种高要求、多元化的应用需求。\n机智云自研的串口通信协议GAgent赋予乐鑫 G510 联网能力。\n只需在 G510 上烧写GAgent固件，即可快速实现设备M2M接入、数据统计分析、远程控制、OTA升级、第三方接口等功能服务。该固件支持MCU代码自动生成和APP代码自动生成功能，大大降低开发成本，缩短研发周期。\nG510 SDK(GAgent)固件下载\n广和通G510模组联网方案\nhttp://docs.gizwits.com/zh-cn/deviceDev/debug/G510.html\n应用范围\n智能家居 \\ 智能家电 \\ 智慧公寓 \\ 智慧安防 \\ 物联网M2M \\ 单品类解决方案（净水器、空气净化器、照明、卫浴、厨电等） \\ 商用租赁 \\ 智能充电桩 \\ 工业控制 \\ 农业大棚 \\ 资产管理 \\ 客户案例。\n快速联网\n硬件厂商对硬件智能化的第一步是让设备能够联网，GAgent是机智云提供的一款兼容国内主流Wi-Fi模块、移动网络模块的模组系统。硬件厂商只需理解如何与GAgent进行通讯即可。\n相关链接：\n\n【GPRS模组】广和通FIBOCOM_G510 支持接入机智云\n广和通G510模组接入方案\n\n\nIoT 开发\n用 G510 只需5步开发一个iot产品:\n\nStep1：在 G510 芯片上烧写GAgent固件；\nStep2：在机智云开发者中心创建产品，并定义数据点；\nStep3：下载自动生成的模组通信协议；\nStep4：使用虚拟设备和机智云APP进行调试；\nStep5：通过机智云APP与虚拟设备联动。\n\n至此，一个产品的Demo已经制作完成。\n如需加速产品开发，可使用机智云提供的MCU代码自动生成工具、APP开源框架。\n文档资料\n\n入网模组：广和通G510 无线GPRS模块官方资料及调试教程（编程工具、硬件手册、数据手册都有）\n广和通G510模组接入方案  ：全篇文章的内容包括G510模组的管脚介绍、SIM卡连接、供电要求、串口定义以及固件烧写方法等，\n\n代码自动生成\nMCU代码自动生成\n自动生成的代码实现了机智云通信协议的解析与封包、传感器数据与通信数据的转换逻辑，并封装成了简单的API，且提供了多种平台的实例代码。当设备收到云端或APP端的数据后，程序会将数据转换成对应的事件并通知到应用层，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，就可以完成产品的开发。\n\nMCU代码自动生成神器来袭，想用它提高开发效率吗\n\nAPP代码自动生成\n自动生成的APP代码模块化集成了一个智能硬件APP必备功能，主要包括：\n\n用户部分：用户注册，找回密码、第三方登录（微信登录、QQ登录）\n配置设备入网（Arilink+SoftAP）\n设备发现，列表展示\n设备控制\n消息推送：设备报警后给APP推送报警信息，主要合作推送平台是极光推送和百度推送。\n\n开发者下载源码后，只需要优化UI和设计设备控制界面控制逻辑，源码的控制页面编写了机智云SDK控制设备的标准流程，APP源码二次开发过程中只需按照该流程进行相关代码的优化即可快速完成针对自身产品的智能控制APP。\n应用案例\n开源项目\n\n智能家居应用模型One\n智能药盒\n智能婴儿摇篮\n智能灯\n智能温控器\n智能鞋柜\n智能家居云控制套件\n智能健康计\n智能插座\n智慧宿舍\n智能仓鼠管家（语音版）\n无线工业粉尘监测仪\n\n商用项目\n部分商用项目：\n\n伊莱特智能电饭煲\n全球客服 A.O.史密斯\n华商三优电动车智能充电应用平台\n西默智能路由器\n艾沃净水机：连接微信，智慧饮水\n戴勒姆Care2Share\n酷蛙智能净水器\n诸葛小明床头灯，语音控制 wifi音响自动感应\n新科微信操控空调\n希澈智能声波牙刷\n巴比立方智能果蔬种植机\n幸福森林空气净化器\nC1智能鱼缸温控器\nOnread智能插座\n无源智能墙壁开关\n\n常见问题\n\n机智云有支持GPRS模块吗？？有的话哪里可以买的到？ http://club.gizwits.com/thread-5394-1-1.html\n\n不使用官方的固件能接入机智云吗？？ http://club.gizwits.com/thread-5371-1-1.html\n\nGPRS模块接入机智云平台要收费？ http://club.gizwits.com/thread-3503-1-1.html\n\n机智云调试APP下载地址：\n安卓用户，可在机智云官网下载，亦可在 应用商店 搜索“机智云”下载；\nios用户，可在机智云官网下载，亦可在 APPStore 搜索“机智云”下载；\n\n5分钟了解机智云\n\n机智云支持哪些WiFi模块、GSM模块？\n\n汉枫 HF-LPB100、HF-LPB120、LPT120\n乐鑫/安信可    esp-8266\nRealtek8711am、联盛德TLN13SP01、广州致远AW54101WFX、高通QCA4004\nTI    CC3200、NXP QFN-1、上海移远M26\n广和通G510、 中兴ME3610 、中兴ME3630\n\n\n\n关于机智云\n机智云，Giz(mo)Wits（设备智慧）是广州机智云物联网科技有限公司旗下品牌，全球领先的物联网开发和云服务商，全栈物联网平台服务领导者，国内第一个智能硬件自助开发(PaaS)及云服务(SaaS)平台\n公司拥有完整的技术研发团队、安全团队和人工智能团队，为有志于进军物联网开发者和企业提供安全、可靠的一站式物联网开发工具和云端运维服务，涵盖终端管理、连接管理、应用支持和业务分析等主要功能，已服务车联网、新能源、工业互联、医疗健康、消费类电子产品等众多行业。\n模块化开发工具\n以下是机智云提供的模块化开发工具：\n\n标准GAgent串口通讯协议\nMCU代码自动生成工具\nAPP代码自动生成工具\n自动化产测工具\nOTA固件升级\n国际版应用邮件模板\n产品互联（Echo接入等）\nSnoti服务\n企业API、OPEN API\nRTDB实时大数据统计\n\n解决方案\n以下是机智云提供的解决方案：\n\n信息家电/大家电智能化/小家电智能化/\n厨电信息化解决方案\n智能净水器/智能空气净化器/\n汽车电子/车联网/智能充电桩\n公寓/楼宇/家居/酒店智能化解决方案\n安防 / 消防\n电机控制\n智能电网\n医疗/保健/卫生\n\n机智云客户：\n\n官方技术交流群\n\nG1机智云物联网云服务 104975951\nG2机智云物联网云服务 491509598\nG3机智云物联网云服务 287087942\nG4机智云-STM32 iot开发 289447077\nG5-APP代码自动生成公测 599735135\nG6机智云-Arduino iot开发 378683984\n\n联系我们\n\n地址: 广州天河区天平架陶庄路5号众创空间8-9层 研发中心\n电话: 020-6224-0080\n邮箱: service@gizwits.com\nNewYork   646.201.9357\n\n\n"},{"title":"什么是绑定其它产品的应用","url":"/zh-cn/UserManual/hide/app.html","content":"定义\n绑定其它产品的应用是为了实现一个App可以控制多款产品的需求而必须进行的操作。\n详细说明\n在App开发过程，机智云会为您的产品分配的一个独立用户系统。在“应用配置”页面创建的App ID都是指向该用户系统。你只需要把iOS和Android的App ID分别写进去对应平台的App里，这样就可以实现在iOS登录的账号也可以在Android登录。\n上面的方法在一个产品对应一个App时是没问题，但是，有些客户厂商不止生产一款产品，他们希望生产的所有产品都可以使用同一个App进行控制。这种一个App控制多个产品的App我们称之为超级App。想实现超级App的方法就是让不同的产品的用户系统都指向同一个，也就是“绑定其它产品的应用”这个功能。选定其中一个产品的用户系统作为中心，其它产品去绑定它，再把作为中心产品的App ID写到对应平台的App里就完成了。\n操作说明\n应用配置增加了一个高级功能——「绑定其它产品的应用」，主要满足部分厂商一个App控制旗下多个设备的需求。\n例如以下场景：\n例如公司Q有多个产品，分别是A、B、C，但他不想每个产品都单独一个App，而是希望三个产品都用同一个app。现在提供了「绑定其它产品的应用」功能，选择其中一个为中心，如产品A为中心，产品B与产品C绑定产品A，开发App时使用产品A的App ID就行。\n具体操作如下：\n第一步：点击“高级”选择“绑定其它产品的应用”\n\n第二步：选择要绑定的产品\n\n第三步：看到绑定的后的效果\n\n期待您向我们反馈对于本次新功能的感受：http://cn.mikecrm.com/3RkhIv7\n"},{"title":"本周热门下载","url":"/zh-cn/UserManual/hide/download.html","content":"GAgent固件\nGAgent是运行在各种通讯模组上的一款应用程序（固件）,可以提供上层应用（手机APP等控制端、云端）到产品设备的双向数据通讯，此外，还提供对设备的配置入网、发现绑定、程序升级等功能。产品开发者使用GAgent后，只需要关心产品的业务逻辑开发，不用关心数据的通讯功能开发，大大降低了开发的难度。\n本周热门下载：\n 1 乐鑫ESP8266 联网固件\n 2 汉枫LPT120/LPB120 联网固件\n 3 汉枫LPB100 联网固件\n 4 高通QCA4004 联网固件\n 5 RealTek 8711AM  联网固件\n 6 联盛德 TLN13SP01 联网固件\n 7 MXCHIP 联网固件\n开源框架\n开源框架是机智云出品的，包含Wi-Fi类智能硬件app通用功能的一套源码。只要是使用机智云协议的产品，开发者开发配套的app时都可以直接使用该框架的源码实现快速开发，从而也满足app的开发周期短、成本低的要求。\n本周热门下载：\n 1 开源框架 for iOS\n 2 开源框架 for Android\n设备接入SDK\n设备接入SDK封装了手机（包括PAD等设备）与机智云智能硬件的通讯过程，以及手机与云端的通讯过程。使用SDK，可以使得开发者快速完成APP开发，开发者仅需关注APP的UI和UE设计即可，而相对复杂的协议与错误处理等事项可忽略。\n本周热门下载：\n 1 iOS SDK\n 2 Android SDK\n 3 APICloud SDK\n 4 BT/BLE设备接入SDK for iOS\n 5 BT/BLE设备接入SDK for Android\n统计分析SDK\n统计分析SDK用于将数据进行云存储、云获取和云计算，蓝牙产品是主要使用对象。产生的数据会通过手机传输到云存储器中，如需数据调用，则通过接口获取即可。\n目前提供的基本数据运算有：数据求和、数据平均、数据最大值及最小值查找等。\n本周热门下载：\n\nBT/BLE统计分析SDK for iOS\nBT/BLE统计分析SDK for Android\n\n开源APP\n智能灯\n这是一款可以帮助开发者快速使用GizWifiSDK，连接到机智云的开源物联示例APP。该APP针对的是智能家电中的灯泡类产品，此款产品已满足用户基本功能需求，其中包括：1.用户登录；2.配置入网；3. 搜索设备列表；4.绑定或解绑设备；5.灯开关；6.色彩和色温切换；7.色彩和色温连续调节；8.亮度调节；9.修改设备别名；10.倒计时开关；11.云端定时预约，不限次数等等。\n本周热门下载：\n\n源码链接 for iOS\n源码链接 for Android\n\n开源硬件\n本周热门下载：\n\n植物宝\n智能宠物屋\n智能桌上足球\n\n开发者开源项目\n热门下载项目：\n1 智能家居\n\n智能婴儿摇篮\nArduino 智能灯\n智能家居云控制套件\n智能插座\n智慧宿舍\n智能鞋柜\nPM25监测智能插座方案\n\n2 医疗健康\n\n智能药盒\n智能健康计\n\n3 工业、商用\n\n商场智能温控器\n无线工业粉尘监测仪\n\n4 智能玩具\n\n仓鼠管家和OpenHamtaro开源项目\n智能桌上足球\n\n机智云Wi-Fi/移动通信产品调试APP\n机智云App是全球首款IoT设备通用调试工具，根据开发者自定义的产品功能，自动生成可响应的控制页面。开发者在机智云平台开发智能硬件时，可以很方便地使用该App对硬件设备进行调试和验证。此APP有完整的用户注册、登陆和注销流程，并且可以完成机智云智能硬件的配置入网、设备搜索、设备绑定、设备登录、设备控制、远程控制、状态更新、本地远程切换等基本设备操作。\n本周热门下载：\n\n机智云Wi-Fi/移动通信产品调试App for iOS\n机智云Wi-Fi/移动通信产品调试App for Android\n\n产测工具\n使用产测工具，可以快速检验工厂生产线上的成品或者半成品。产测工具是一个简单的手机APP，可以在用户产品中定义产测的测试项，再对工厂的设备进行相关定义项的自动测试。设备针对测试项测试通过后，表示产品合格。\n产测工具可以将设备并行处理，平均5～10秒可以完成一个设备的测试，从而大大提高测试的速度。\n本周热门下载：\n\nWi-Fi产测应用\n\n"},{"title":"新版OTA介绍","url":"/zh-cn/UserManual/hide/newOTA.html","content":"概述\n新版OTA对于旧版OTA存在的一些问题进行了优化，降低了开发者在使用OTA时的学习成本。\n新版OTA增加与优化的功能\n1.针对不同的场景，可以设置设备OTA是否需要用户在App上确认，例如功能升级需要用户在App上确认的“手动升级”，bug修复则可以设置不需要用户确认的“静默升级”。\n2.增加了可查看全部设备的版本分布，让你可了解到你设备目前版本的分布情况。\n3.新固件推送后，新的设备出货后如果是旧版本，也可以升级到新固件版本，不需要重新设置推送。\n4.原来的“硬件版本号”与“软件版本号”分别改名为“固件系列”与“版本号”。\n5、操作页面交互方面的优化，操作更方便易懂。\n新版OTA暂不支持的功能\n1.暂时不支持设置推送的规则，默认全部推送。\n2.暂时不支持子设备的推送。\n切换前需要注意的问题\n1.同一个固件类型如果有多个同时推送，切换到新版OTA只保留最新一个推送，其它推送会移到推送历史列表\n2.原来设置的推送规则，切换到新版OTA将不再生效。\n3.切换到新版OTA后，将不能返回到旧版OTA，请谨慎选择。\n"},{"title":" 开发文档","url":"/zh-cn/UserManual/hide/open_resourse.html","content":"专题热点 、 本周热门下载\n机智云平台概述\n1 机智云平台概述\n机智云平台是机智云物联网公司经过多年行业内的耕耘及对物联网行业的深刻理解，而推出的面向个人、企业开发者的一站式智能硬件开发及云服务平台。平台提供了从定义产品、设备端开发调试、应用开发、产测、云端开发、运营管理、数据服务等覆盖智能硬件接入到运营管理全生命周期服务的能力。\n机智云平台为开发者提供了自助式智能硬件开发工具与开放的云端服务。通过傻瓜化的自助工具、完善的SDK与API服务能力最大限度降低了物联网硬件开发的技术门槛，降低开发者的研发成本，提升开发者的产品投产速度，帮助开发者进行硬件智能化升级，更好的连接、服务最终消费者。\n2 机智云平台架构\n\n快速入门\n五分钟了解机智云接入流程\n\n五分钟了解机智云接入流程\n机智云名词定义解释\n\n设备快速接入机智云\n\n了解GAgent\n设备如何快速接入\n设备快速接入机智云\nSOC快速入门\n\n硬件厂商对硬件智能化的第一步是让设备能够联网，GAgent是机智云提供的一款兼容国内主流Wi-Fi模块、移动网络模块的模组系统，可以提供上层应用（手机APP等控制端、云端）到产品设备的双向数据通讯，此外，还提供对设备的配置入网、发现绑定、程序升级等功能。\n产品开发者使用GAgent后，只需要关心产品的业务逻辑开发，不用关心数据的通讯功能开发，大大降低了开发的难度。\n目前机智云提供由机智云移植的WiFi模组对应固件有：汉枫LPB100、乐鑫8266、汉枫LPT120、高通4004 、RealTek 8711AM 、庆科3162、广和通G510等。\nAPP快速接入机智云\n\nApp开发准备工作\nAndroid App快速开发\niOS App快速开发\n\n设备开发（硬件接入）\n1 固件烧写教程\nGAgent主要的作用是数据转发，是设备数据、机智云、应用端（APP）的数据交互桥梁。可将GAgent移植到WiFi模组、GPRS模组、PC端等。\n部分模组固件烧写教程：\n\n汉枫 LPB100串口烧写说明\n乐鑫 ESP8266串口烧写说明\n汉枫 LPT120串口烧写说明\n庆科 3162串口烧写说明\n广和通 G510串口烧写说明\n串口工具使用文档\n日志抓取教程文档\n相关开发指南：\n\n乐鑫ESP8266开发指南\n汉枫HF-LPB100/HB-LPB120开发指南\n广和通G510开发指南\nSTM32开发指南（IoT）    \nArduino开发指南（IoT）\nGokit开发概述和试用申请\n下载中心的页面Gagent\n\n2 MCU 代码自动生成\n使用MCU代码自动生成工具，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，就可以完成产品的开发。支持STM32（多型号）、Arduino uno、ESP8266 SOC方案的代码自动生成。\n\nMCU代码自动生成工具介绍\nDEV SDK Common版移植说明（通用平台）\n\n3  Gokit 资料\n Gokit3是GoKit产品系列的第三代，支持MCU、SoC、BLE、语音、模式切换等特性。目前支持的SoC方案模组有ESP8266、Hi3518E模组、宇音天下模组等。\n\nGokit 3 系列开发套件简介\nGoKit 3 硬件手册\nGoKit3(S) 开发套件介绍\nGoKit3(S) 二次开发--开发环境搭\nGoKit3(S) 二次开发-程序详解\nGoKit3(V) 使用说明书\nGoKit3(V) 二次开发--开发指南\nGoKit3(V) 支持词条介绍\nGoKit3(V) 二次开发-程序详解\nGoKit3(V) 二次开发-程序详解\nGokit 2 使用指南\n\n4 ECE雾计算\n\nECE雾计算入门教程\n相关视频：\n企业账号注册\n固件烧录\npk烧录\nMCU协议介绍\nlua脚本讲解\ngokit跑lua演示\n\n\n\n5 Arduino UNO\n\nArduino UNO WiFi 接入机智云介绍\nArduino Uno WiFi 之ESP8266固件烧写教程\nArduino Uno WiFi SDK之API介绍\nArduino Uno WiFi 智能小夜灯\n\nAPP开发\n机智云提供了APP SDK、开源框架、微信SDK，便于开发者快速构建手机应用端系统，只需根据工具指引实现业务功能，无需实现底层功能。\n1 APP代码自动生成\n\nAPP代码自动生成 开发指南\n\n2 Echo控制\n\n接入亚马逊Echo音箱教程\n使用Echo音箱控制GoKit2\n\n3 微信开发\n\n了解微信应用开发\n微信开发教程\n\n4 SDK 接入\n使用SDK，可以使得开发者快速完成APP开发，开发者仅需关注APP的UI和UE设计即可，而相对复杂的协议与错误处理等事项可忽略。\n\n安卓SDK接入\nIOS SDK接入\nAPICloud SDK使用指南\nSDK数据透传方法解析\n\n5 APP 开源框架\nAPP开发者可以在框架上实现具体产品的控制页面就可以生成一个完整的APP。\n\niOS开源框架使用指南（含源码)\niOS App消息推送集成\niOS App集成第三方登录与换肤\nAndroid开源框架使用指南（含源码）\nAndroid App消息推送\nAndroid App集成第三方登录与换肤\n开源框架视频教程\n\n云端开发\n开发者如果已完成设备接入、APP开发，还需要从机智云PaaS平台获取数据构建一套业务管理系统，或者访问机智云提供的服务，则需了解以下文档:\n\n了解企业应用开发\n了解消息消息代理服务接口（Noti服务）\n了解企业API\nSNoti API (V2.1.3)\nGizwits Open API（新）\nWebsocket API 指南\nAPI使用教程\n使用openapi（postman）控制虚拟设备\n使用Websocket 网页控制设备\n使用聚合API使用教程\n设备联动API使用教程\nSnoti 数据实时同步服务demo使用教程\n\n\n\n\n\n用户手册\n\n个人项目产品转企业项目产品\nOTA使用教程\n产测工具使用文档\nD3 Engine使用教程\nECE雾计算使用教程\n接入亚马逊Echo音箱教程\n实时大数据使用说明\n\n行业解决方案\n机智云拥有多年的经验积累，可为客户提供各个垂直领域的行业解决方案。下面选择几个比较有代表性的行业解决方案： \n\n充电桩行业解决方案\n空净行业解决方案\n净水行业解决方案\n\n"},{"title":"privacy policy/terms of use","url":"/zh-cn/UserManual/hide/statement.html","content":"Welcome!\nSo you have purchased our Gizwits device and are starting to use the devices! Any information you share with us (e.g. for creating a Gizwits Account) will help us to provide you with services related to Gizwits device and to improve them to make them even better. We explain here our ways of collecting and using information, and how we protect your privacy. In this privacy policy, “personal data” means information that can be used to identify an individual, either from that information alone, or from that information and other information we have access to about that individual. We collect both personal and non-personal data to enable and facilitate the best user experience possible.\n​\nWhat information is collected and how do we use it?\nTypes of Personal Data Collected\n\nIn order to provide our services to you, we will ask you to provide necessary personal data that is required to provide those services. \n\nSet up and log in of Gizwits Account.Personal data that are collected for creating a Gizwits Account may include your email address or mobile phone number, device related information (e.g. IMEI number) and various location related information (e.g. location area code, mobile network and country codes).\n\nPurchasing your Gizwits products.When you make purchases through the Gizwits e-commerce website or other 3rd party c-commerce website such as amazon, we may collect your Gizwits Account ID (or mobile phone number or email addressed used to create your Gizwits Account), name, phone number, delivery address and order details, etc. Gizwits provides logistics services to deliver the products purchased on the e-commerce website. Gizwits has an after sales system to handle after sales services for users. When you use these services, we may also collect the order number, invoice date, list of purchased items and your contact details in order to process the services.\n\nSync Gizwits device data.When you synchronise the Gizwits device data, e.g. to Gizwits device Cloud Service, we may collect data relating to your activities and functionalities of Gizwits device, such as those obtained from our sensors and features on Gizwits device, your device on/off time, and smart alarm related information.\n\nSharing your content.When you share content or send information to family and friends, we may collect personal information of those people, such as their names, email addresses, telephone numbers, and mailing addresses (if we need to send a product to them). You hereby represent and warrant that you have obtained necessary consent for use of third parties’ personal data if you choose to provide them to us. When you share content or invite users to use Gizwits device, please note that other users may see personal data you share.\n\nProcessing the services.In providing the above services, we may also collect data in relation to your device, including your Gizwits device ID, firmware version, device OS version, model and system, and visiting IP and time.\n\n\n​\nHow the Personal Data is used\n\nTo provide you with our products and services, processing your orders, performing contractual obligations between you and us, to ensure the functions and safety of our products, to verify your identity, to prevent and trace fraudulent or inappropriate usage\n\nTo develop our products and services, together with general and statistical information\n\nTo communicate with you, including providing you with notifications on products and services that are updated or launched\n\nTo provide marketing and promotional materials to you on our products and services (please note that you may unsubscribe anytime)\n\nTo personalise product design and to provide you with services tailored for you, for example, recommending and displaying information and advertisements regarding products suited to you, and to invite you to participate in surveys relating to your use of Gizwits device\n\nTo conduct investigations regarding our products and services\n\nIf you participate in our lottery, contest or other promotions, we may use your personal data to manage such activities\n\nTo provide maintenance services, monitor software licenses, to improve our products or analyse the efficiency of our operations\n\n\nOther Information\nWe use statistical data that does not specifically identify you (non-personal data) to help in our operations and improve our products and services and provide a better user experience for you. Here are some of the non-personal data we may collect and how we use them:\n\nWhen you create a Gizwits Account, download our software, register in our e-commerce website, participate in online surveys or interact with us in other ways, we may collect your language preferences, postal code, area code number and time zone in which you use our products and services, and your profession.\n\nWhen you opt-in to participate in our User Experience Improvement Program, we may gather statistics relating to your use of our products functions, on an anonymous basis. This may include information relating to your use of our official website, products and services. If there is an abnormal shutdown or breakdown, we may collect information relating to your mobile device to diagnose the problem.\n\nWhen you use our services or functions that are based on location information, e.g. carry out a location search, take advantage of advertising, use weather functions, access information based on maps, etc., we may collect your geographical information.\n\nWhen you use our website, online services, interactive applications, email messages and advertising, we may use cookies and other technical elements (e.g. pixel labels) to collect and store non-personal data. These enable us to provide you with a better experience and improve our overall service quality, e.g. in saving your preferred language settings, sending emails in a readable format, to determine whether the emails have been opened or not, etc.\n\nWhen you use the Internet browser in using our products and services, we may collect log information, e.g. IP address, browser type, language, reference source, operating system, date and time marking and click rate data.\n\nWhen you first use and activate your Gizwits device, the device’s unique identification code and approximate geographical information may be collected.\n​\n\n\nYou have control over your information!\nWe recognise that privacy concerns differ from person to person. Therefore, we provide examples of ways we make available for you to choose to restrict the collection, use, disclosure or processing of your personal data and control your privacy settings, such as controlling the settings under the User Experience Improvement Program, Location Access functions, and your Gizwits Account.\n​\nAccess, Updating or Correcting Your Personal Data\nYou have the right to request access and/or correction or any other personal data that we hold about you. When you update your personal data, you will be asked to verify your identity before we proceed with your request. Once we obtain sufficient information to accommodate your request for access or correction of your personal data, we shall process in accordance with the laws of your country. While we try our utmost in acceding to your requests, unreasonably repetitive or unrealistic requests or those that put others’ privacy at risk may be declined.\nWe normally provide such services for free but reserve the right to charge a reasonable fee.\nIf you believe any information we are holding on you is incorrect or incomplete, please write to or email us as soon as possible at the email address below. Email: gizwits_echo@gizwits.com.\nFor details relating to the personal data in your Gizwits Account, you may also access and change them at Email: gizwits_echo@gizwits.com.\n​\nWithdrawal of Consent\nYou may withdraw your consent for the collection, use and/or disclosure of your personal data in our possession or control by submitting a request. This may be done by accessing your Gizwits Account management center at Email:  . We will process your request within a reasonable time from when the request was made, and thereafter not collect, use and/or disclose your personal data as per your request.\nPlease recognise that your withdrawal of consent could result in certain legal consequences. Depending on the extent of your withdrawal of consent for us to process your personal data, it may mean that you will not be able to enjoy Gizwits’s products and services.\n​\nWho do we share your information with?\nUnless we tell you in this privacy policy, we will keep your personal information confidential. We may disclose your personal data on occasion to third parties in order to provide the products or services that you have requested. Some of these third parties may be located outside your home country.\nDisclosure may include the scenarios listed in this section below. In each case described in this section, you can be assured that Gizwits will only share your personal data in accordance with your consent. You should know that when Gizwits shares your personal data with a third party under any circumstance described in this section, Gizwits will ensure that the third party is subject to practices and obligations to comply with the relevant data protection and privacy laws of your country. Gizwits will contractually ensure compliance by any foreign Third Party Service Providers with the privacy standards that apply in your home jurisdiction.\nDisclosure to Gizwits group companies and Third Party Service Providers\nIn order to conduct business operations smoothly, the Gizwits entity which collects your personal data may disclose your personal data from time to time to other Gizwits group companies (in communications, social media, technology or cloud business), or our third party service providers which are our mailing houses, delivery service providers, telecommunications companies, data centres, data storage facilities, and customer service providers, agents, related corporations, and/or other third parties (together “Third Party Service Providers”). Such Third Party Service Providers would be processing your personal data on Gizwits’s behalf or for one or more of the purposes listed above.\nPersonal data will only be shared by Gizwits to provide or improve our products or services and will not be shared for use for marketing purposes.\n​\nDisclosure to Others\nGizwits may disclose your personal data without further consent if required or permitted by law in the following cases:\ncases in which the disclosure is required or authorized based on the applicable laws and/or regulations;\ncases in which the disclosure is necessary to respond to an emergency that threatens the life, health or safety of the individual or another individual;\ncases in which the disclosure is necessary for the prevention of crime or legal proceedings;\ncases in which the purpose of such disclosure is clearly in the individual’s interests, and if consent cannot be obtained in a timely way;\ncases in which the disclosure is necessary for any investigation or proceedings;\ncases in which the disclosure is to any officer of a prescribed law enforcement agency upon production of written authorisation signed by the head or director of that law enforcement agency, or a person of a similar rank, certifying that the personal data is necessary for the purposes of the functions or duties of the officer; and/or\ncases in which the disclosure is to a public agency and such disclosure is necessary in the public interest.\n​\nInformation Not Requiring Consent\nWe may share anonymised information and statistics in aggregate form with third parties for business purposes, for example with advertisers on our website, or we may tell our business partners the number of customers in certain demographic groups who purchased certain products or who carried out certain transactions.\nFor the avoidance of doubt, in the event that we are permitted by law to collect, use or disclose your personal data without your consent, such permission granted by the law shall continue to apply.\n​\nInformation Safety Safeguards\nWe are committed to ensuring that your personal data is secure. In order to prevent unauthorised access, disclosure or other similar risks, we have put in place reasonable physical, electronic and managerial procedures to safeguard and secure the information we collect. We have put in place the following security procedures and technical and organisational measures to safeguard your personal data.\nInformation safety is very important to us. We will take all practicable steps to safeguard your personal data. Through our protective measures above, especially encrypted storage and transmission, your data is as secure as it can be. Certain details of encrypted data cannot be accessed by anyone except by you.\n​\nWhen this Privacy Policy applies\nOur Privacy Policy does not apply to products and services offered by a third party. Gizwits products and services may include third party’s products or services. When you use such products or services, they may collect your information too. For this reason, we strongly suggest you to read the third party’s privacy policy as you have taken time to read ours. We are not responsible for and cannot control how third parties use personal data which they collect from you. Our Privacy Policy does not apply to other sites linked from our services.\n​\nMinors\nWe consider it the responsibility of parents to monitor their children’s use of our products and services. Nevertheless, it is our policy not to require personal data from minors or offer to send any promotional materials to persons in that category. Gizwits does not seek or intend to seek to receive any personal data from minors. Should a parent or guardian have reasons to believe that a minor has provided Gizwits with personal data without their prior consent, please contact us to ensure that the personal data is removed and unsubscribe them from any of the applicable Gizwits services.\nOur Services are not directed to individuals under 13. We do not knowingly collect personal information from children under 13. If we become aware that a child under 13 has provided us with personal information, we will take steps to delete such information. If you become aware that a child has provided us with personal information, please contact us at gizwits_echo@gizwits.com.\n​\nUpdates To The Privacy Policy\nWe keep our Privacy Policy under regular review. If we change our Privacy Policy, we will post the changes on Gizwits websites, so that you may be aware of the information we collect and how we use it. Such changes to our Privacy Policy shall apply fro m the time that we post the same on the Gizwits websites. Your continued use of products and services on the websites, mobile phones and/or any other device will be taken as acceptance of the updated Privacy Policy. We will seek your fresh consent before we collect more personal data from you or when we wish to use or disclose your personal data for new purposes.\nprivacy policy/terms of use\n"},{"title":"视频教程","url":"/zh-cn/UserManual/hide/videos.html","content":"开源框架App使用教程\n1 App开发前传\nhttp://v.qq.com/x/page/p0344jspddv.html开发者中心产品及设备应用创建（App开发前传）\n2 iOS APP开发\nhttp://v.qq.com/x/page/b0350blmgcf.html使用开源框架快速开发一个功能简单的iOS App\n3 Android APP开发\nhttp://v.qq.com/x/page/p03512if92n.html使用开源框架快速开发一个功能简单的Android App\nGokit3入门视频（2016）\nGokit3是GoKit产品系列的第三代，支持MCU、SoC、BLE、语音、模式切换等特性。目前支持的SoC方案模组有ESP8266、Hi3518E模组、宇音天下模组等。详情请点击：详细介绍\n1 GoKit3介绍\nhttp://v.qq.com/page/c/i/7/c0342fr44i7.html\n2 自助开发平台介绍\nhttp://v.qq.com/page/q/k/a/q0342olq9ka.html\n3 GoKit3(S)开发套件介绍\nhttp://v.qq.com/page/c/9/q/c03428fzm9q.html\n4 GoKit3(S)配置入网及APP控制\nhttp://v.qq.com/page/d/h/p/d034237oghp.html\n5 GoKit3(V)开发套件介绍\nhttp://v.qq.com/page/d/c/8/d0342cuq3c8.html\n6 GoKit3(V)配置入网及APP控制\nhttp://v.qq.com/page/n/6/d/n0342s3oc6d.html\n7 GoKit3(S)二次开发-程序详解\nhttp://v.qq.com/x/page/f03438iug4b.html\n8 GoKit3(S)源码详解\nhttp://v.qq.com/x/page/a0344o3b9yt.html\n9 GoKit3(V)二次开发-程序详解\nhttp://v.qq.com/x/page/w03411dulvm.html\n10 GoKit3(V)源码详解\nhttp://v.qq.com/x/page/e03433vgpkj.html\n7 MCU代码自动生成工具\nhttp://v.qq.com/x/page/z0343uhrvis.html\n8 通用版MCU代码自动生成及移植\nhttp://v.qq.com/x/page/j0343youjqw.html\nECE雾计算入门教程\n机智云ECE雾计算主要对接智能设备用的通信模组和手机，采取编译性语言（C语言）和解析性语言（Lua）相结合的方式，使用解析性脚本，将适配策略在云端进行配置，配置后通过推送的方式发送到模组或手机，设备收到新的配置策略后，立即执行；配置策略分别负责适配传输层协议适配、业务层协议适配、数据的计算方法等。详情请点击：http://docs.gizwits.com/zh-cn/UserManual/ece.html\n1 企业账号注册\nhttps://v.qq.com/x/page/n0362u2fgws.html\n2 固件烧录\nhttp://v.qq.com/x/page/r03612h7pr0.html\n3 pk烧录\nhttp://v.qq.com/x/page/p0361baxn9z.html\n4 MCU协议介绍\nhttp://v.qq.com/x/page/a03619wrrqr.html\n5 lua脚本讲解\nhttp://v.qq.com/x/page/d03617dbq8p.html\n6 gokit跑lua演示\nhttp://v.qq.com/x/page/y0361kmy887.html\nGokit 开发视频（2015）\n1 机智云Gokit入门:《Demo MCU程序修改及烧录》\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_1_s0151wvtsvu.html\n2 客户端与机智云智能设备通信的实现原理\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_2_b0151o7w1zc.html\n3 机智云Gokit宠物屋Android客户端开发\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_4_f0151z50adz.html\n4 机智云Gokit高级篇：《使用Gokit扩展接口》\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_3_i0151h0cl97.html\n5 机智云Gokit宠物网 iOS开源代码详解\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_5_z01518k3lbv.html\n6 机智云GoKit MCU范例程序源码详解\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_6_m0151hk7of1.html\n7 机智云硬件接入服务功能介绍\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_7_j0151tqnsbl.html\n8 机智云开放平台功能介绍\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_8_u01519wzbc0.html\n9 Gokit介绍\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_9_l0151m0lmbn.html\n10 物联网硬件基础框架及开发流程\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_10_y0151e0rj5e.html\n11 快速开始：利用机智云后台工具定义物联网硬件\nhttp://v.qq.com/boke/gplay/e93106a715b9724ba25e9827b38c171e_p8u0000012ab6fm_11_t0151u0kupl.html\n2016年机智云开发者大会主题分享\n1 机智云4.0\nhttp://v.qq.com/x/page/l03423njkot.html\n分享嘉宾：机智云CEO  Jack\n2 机智云4.0产品介绍\nhttp://v.qq.com/x/page/k0341a0ok1v.html\n分享嘉宾： 机智云首席技术官  Yan\n3 机智云4.0人工智能\nhttp://v.qq.com/x/page/z0342kkm6s9.html\n分享嘉宾：人工智能实验室负责人  Ming\n4 快速玩转APP开发\nhttp://v.qq.com/x/page/v03422w8hr7.html\n分享嘉宾：方案架构师  Ryan\n5  一步智能，无须代码开发的智能化解决方案\nhttp://v.qq.com/x/page/k0342tohb7s.html\n分享嘉宾：方案架构师  Owen\n6  智能热潮来袭，净水行业的互联网时代\nhttp://v.qq.com/x/page/o0342zxphkw.html\n分享嘉宾：高级产品经理  Lien\n7 通过PaaS平台进行物联垂直行业SaaS开发\nhttp://v.qq.com/x/page/q0342l3nn64.html\n分享嘉宾：云端负责人  Fox\n"},{"title":"Gokit开发概述和试用申请","url":"/zh-cn/developer/resource/Gokit.html","content":"Gokit免费试用申请  、  免费兑换GoKit开发板\nGokit3\nGokit3是GoKit产品系列的第三代，支持MCU、SoC、BLE、语音、模式切换等特性。目前支持的SoC方案模组有esp8266、Hi3518E模组、宇音天下模组等。\n\n具备以下特性：\n\n1、独创的双排模组接口，兼容MCU和SoC两种连接方式。\n2、1路USB转TTL调试串口。可用于SoC方式开发的日志输出。\n3、兼容arduino接口。\n4、GoKit经典传感器组合，温湿度、红外感应、双向电机、RGB灯。\n5、3个key。\n6、增加2路MIC，1路Speaker。\n7、丰富的扩展接口，如OLED等。\n\nGokit3 的三个版本：\n\nGoKit3(V) - 语音模组版   （GoKit3功能板+底板+宇音天下模组）\nGoKit3(S) - SoC版（乐鑫模组(GoKit3转接板)+底板+GoKit3功能板）\nGoKit3(H) - 高性能模组版\n\nGokit 3S\nGoKit3(S)采用一体式SOC解决方案，并具有一定的拓展性，图如下：\n\nGokit3S支持两种开发模式：\n\nSoC开发模式：\n\n即功能板+wifi模组的连接方式，是GoKit3(S)的默认方式，发货固件即为MCU版本固件，可直接使用，用法与GoKit2相同。需要注意的是SoC方式不能接底板，否则不能正常运行。\n二次开发源码包及原理图已经开放，地址是：ESP8266 SoC源码包 http://site.gizwits.com/zh-cn/developer/resource/hardware?type=GoKit，选择“微信宠物屋 for GoKit3(S) ESP8266”进行下载。\n原理图 http://club.gizwits.com/thread-2889-1-1.html\n-SOC开发快速入门\n\n\nMCU开发模式：\n\nMCU的方式可得到与GoKit2相同的开发方式，即底板+功能板+wifi模组的连接方式。使用MCU的连接方式需要开发者自更新wifi模组的固件。\nSTM32 MCU源码包 http://site.gizwits.com/zh-cn/developer/resource/hardware?type=GoKit，选择“微信宠物屋 for GoKit 2 STM”进行下载。\nMCU开发快速入门\nSTM32代码自动生成\n\n\n\n\n\nMCU和SOC开发模式对比：\n\nMCU版  :是分体式的设计方案。WiFi模组只负责信息的接收与发送，它通过串口等方式与MCU进行通信，需要在MCU上进行协议解析与外设相关的开发。\n总结：这种方案的优点是不受限于WiFi SOC片上资源、应用扩展度高；缺点是开发难度大、生产成本高。\n\nSOC版   :是整体式的设计方案。它将WiFi模组与外设驱动模块直接连接起来，直接在WiFi SOC上进行开发，省去了一层通讯过程。\n总结：这种方案的优点是能降低开发难度、降低生产成本；缺点是受限于WiFi SOC片上资源，应用有限。\n\n\nGokit 3V\nGoKit3(V)开发套件，此套件支持语音识别、语音控制传感器。使用Lark7618模组进行智能硬件产品开发时，有以下几点需要注意：\n\nLark7618支持语音识别功能，且符合标准机智云接入协议。\n使用Lark7618模组进行产品开发时需采用MCU方式进行开发，即模组插到功能板模组接口的MCU侧。\nLark7618需配合底板使用，支持Arduino版和STM32版。\n将Gokit3S的WiFi模块替换成Lark718模块，即可改造城Gokit3S\n需注意的是：GoKit3(V)使用MCU的方式连接(天线朝向电机一方)，配合底板MCU进行产品开发。\n\nGokit3开发指南\n\nGokit3 资料下载\nGOKIT3系列开发套件简介\nGOKIT3硬件手册\nGOKIT3（S）使用说明书\nGOKIT3（S）开发套件介绍\nGOKIT3（S）二次开发\nGOKIT3（S）源码详解\nGOKIT3（V）使用说明书\nGOKIT3（V）开发指南\nGOKIT3（V）词条管理\nGOKIT3（V）源码详解\nGOKIT2使用指南\n\nGokit3教学视频\n\n1-GoKit3介绍    http://v.qq.com/page/c/i/7/c0342fr44i7.html\n2-自助开发平台介绍    http://v.qq.com/page/q/k/a/q0342olq9ka.html\n3-GoKit3(S)开发套件介绍    http://v.qq.com/page/c/9/q/c03428fzm9q.html\n4-GoKit3(S)配置入网及APP控制    http://v.qq.com/page/d/h/p/d034237oghp.html\n5-GoKit3(V)开发套件介绍    http://v.qq.com/page/d/c/8/d0342cuq3c8.html\n6-GoKit3(V)配置入网及APP控制    http://v.qq.com/page/n/6/d/n0342s3oc6d.html\n7-GoKit3代码自动生成工具    http://v.qq.com/x/page/z0343uhrvis.html\n8-GoKit3 DEV SDK Common版移植说明    http://v.qq.com/x/page/j0343youjqw.html\n9-GoKit3(S)二次开发-程序详解    http://v.qq.com/x/page/f03438iug4b.html\n10-GoKit3(S)源码详解    http://v.qq.com/x/page/a0344o3b9yt.html\n11-GoKit3(V)二次开发-程序详解    http://v.qq.com/x/page/w03411dulvm.html\n12-GoKit3(V)源码详解    http://v.qq.com/x/page/e03433vgpkj.html\n\nGokit2\nGoKit2代为机智云于2015年推出的一款面向智能家居场景的开发板。用于帮助开发者快速实现智能硬件的原型开发。GoKit支持开发者将产品接入目前行业中各大流行的模组方案，帮助他们与高通、庆科、博通、 汉枫等对接，开发者只需扫一下相应的二维码就可以连接机智云2.0，通过机智云后台定义产品，产品通过WiFi模块上的GAgent接入机智云M2M服务 器，扫描二维码直接控制设备。GoKit上还集成了马达、1600万色的LED、Wifi模块、红外光感、温湿度等传感器。\nGokit2标准版（STM32）\n针对企业开发者，GoKit为大家提供熟悉的ST开发平台。使用STM32底板打造智能硬件原型，可更快的实现量产时的代码移植和复用。\n\n企业开发者也能获得机智云官方提供的基于STM32的智能硬件开源案例代码和参考实现。\n\n学习Gokit STM32底板开发 >\n\nGokit2创客版（Arduino）\n为了让更多物联网开发者能够快速开发出自己的产品，机智云与Arduino官方战略合作，面向所有智能硬件爱好者、创客和个人，免费提供开发板及相关技术支持。\n\n配合内置丰富传感器的应用板和机智云自助开发平台，让开发者可在最短30分钟内就能搭建自己的智能硬件。\n\n学习Gokit Arduino底板开发 >\n\nGokit2开发指南\n\nGokit2历代资料整理（新）\nGoKit 能给您带来什么\nGoKit 2 开箱    \n使用Echo音箱控制GoKit2\n玩转Gokit 2\n\nGOkit2 教学视频\n\nGokit介绍    http://v.qq.com/x/page/l0151m0lmbn.html\n机智云Gokit入门:《Demo MCU程序修改及烧录》    https://v.qq.com/x/page/s0151wvtsvu.html\n客户端与机智云智能设备通信的实现原理    http://v.qq.com/x/page/b0151o7w1zc.html\n机智云Gokit宠物屋Android客户端开发    http://v.qq.com/x/page/f0151z50adz.html\n机智云Gokit高级篇：《使用Gokit扩展接口》    http://v.qq.com/x/page/i0151h0cl97.html\n机智云Gokit宠物网 iOS开源代码详解    http://v.qq.com/x/page/z01518k3lbv.html\n机智云GoKit MCU范例程序源码详解    http://v.qq.com/x/page/m0151hk7of1.html\n机智云硬件接入服务功能介绍    http://v.qq.com/x/page/j0151tqnsbl.html\n机智云开放平台功能介绍    http://v.qq.com/x/page/u01519wzbc0.html\n物联网硬件基础框架及开发流程    http://v.qq.com/x/page/y0151e0rj5e.html\n快速开始：利用机智云后台工具定义物联网硬件    http://v.qq.com/x/page/t0151u0kupl.html\n\nGokit1\n已停产。\nGokit免费试用申请\n\nGokit免费试用申请：http://dev.gizwits.com/zh-cn/developer/activity/gokit/request/organization\n免费兑换GoKit开发板：http://dev.gizwits.com/zh-cn/developer/activity/gokit/gotcha\n\n开源硬件项目\n\n智能家居应用模型One\n智能药盒    \n智能婴儿摇篮\n智能灯\n智能温控器\n智能鞋柜\n智能家居云控制套件\n智能健康计\n智能插座\n智慧宿舍\n智能仓鼠管家（语音版）\n无线工业粉尘监测仪\n\n商用项目\n部分商用项目：\n\n伊莱特智能电饭煲\n全球客服 A.O.史密斯\n华商三优电动车智能充电应用平台\n西默智能路由器\n艾沃净水机：连接微信，智慧饮水\n戴勒姆Care2Share\n酷蛙智能净水器\n诸葛小明床头灯，语音控制 wifi音响自动感应\n新科微信操控空调\n希澈智能声波牙刷\n巴比立方智能果蔬种植机\n幸福森林空气净化器\nC1智能鱼缸温控器\nOnread智能插座\n无源智能墙壁开关\n\nFAQ\n\nGokit社区：http://club.gizwits.com/forum-133-1.html\nSTM32社区：http://club.gizwits.com/forum-228-1.html\nGokit试用申请：http://dev.gizwits.com/zh-cn/developer/activity/gokit/request/organization\n兑换GoKit开发板：http://dev.gizwits.com/zh-cn/developer/activity/gokit/gotcha\nGokit购买： 在淘宝搜索“机智云”  或者是点击此链接： https://shop159680395.taobao.com/\n技术支持/项目接入咨询：400-6565-488\n\n关于机智云\n机智云，Giz(mo)Wits（设备智慧）是广州机智云物联网科技有限公司旗下品牌，全球领先的物联网开发和云服务商，全栈物联网平台服务领导者，国内第一个智能硬件自助开发(PaaS)及云服务(SaaS)平台\n公司拥有完整的技术研发团队、安全团队和人工智能团队，为有志于进军物联网开发者和企业提供安全、可靠的一站式物联网开发工具和云端运维服务，涵盖终端管理、连接管理、应用支持和业务分析等主要功能，已服务车联网、新能源、工业互联、医疗健康、消费类电子产品等众多行业。\n模块化开发工具\n以下是机智云提供的模块化开发工具：\n\n标准GAgent串口通讯协议\nMCU代码自动生成工具 \nAPP代码自动生成工具\n自动化产测工具\nOTA固件升级\n国际版应用邮件模板\n产品互联（Echo接入等）\nSnoti服务\n企业API、OPEN API\nRTDB实时大数据统计\n\n解决方案\n以下是机智云提供的解决方案：\n\n信息家电/大家电智能化/小家电智能化/\n厨电信息化解决方案\n智能净水器/智能空气净化器/\n汽车电子/车联网/智能充电桩\n公寓/楼宇/家居/酒店智能化解决方案\n安防 / 消防\n电机控制\n智能电网\n医疗/保健/卫生\n\n官方技术交流群\n\nG1机智云物联网云服务 104975951\nG2机智云物联网云服务 491509598\nG3机智云物联网云服务 287087942\nG4机智云-STM32 iot开发 289447077\nG5-APP代码自动生成公测 599735135\nG6机智云-Arduino iot开发 378683984\n\n联系我们\n\n地址: 广州天河区天平架陶庄路5号众创空间8-9层 研发中心\n电话: 020-6224-0080\n邮箱: service@gizwits.com\nNewYork   646.201.9357\n\nGokit试用申请  、  兑换GoKit开发板\n"},{"title":"ArduinoUNOWiFi接入机智云介绍","url":"/zh-cn/deviceDev/ArduinoUNO/ArduinoUNOWiFi_intro.html","content":"1. 前文需知\n1.1 准备工作\n硬件：GOKIT 2/3 功能板+ArduinoUnoWiFi\n软件：机智云产品调试APP（点击此处为下载链接）+Arduino IDE（1.7.10版以上）\n其他：机智云开发者账号\n1.2     初识ArduinoUnoWiFi\nArduinoUnoWiFi 是 ArduinoOrg 推出的一款基于 ArduinoUno 的开发板，主芯片仍然采用与 ArduinoUno 相同的 ATMega328p，使得开发者能够像使用 Arduino Uno一样使用它。ArduinoUnoWiFi集成了乐鑫的ESP8266芯片作为WiFi模块以提供无线联网功能，支持 OTA程序无线下载功能，支持 REST 方式实现远程控制，支持 Web 方式轻松配置网络。WiFi 功能使得 Arduino UnoWiFi 可以轻松实现无线控制，但是假如没有一款优秀的云服务器来提供固定 IP访问和数据保存，也是无法实现不在同一局域网中的远程控制的。Gizwits 为个人开发者带来了福音，在设备节点小于一定数量时，Gizwits 为开发者提供免费云服务器使用。另外为了简化开发难度，Gizwits 提供了数据上传分发的详细协议格式及 APP 范例。\n本文将介绍如何自动生成ArduinoUno平台的机智云接入库，将库导入Arduino IDE，编译下载到Arduino unoWiFi上。\n1.3     什么是“代码自动生成工具”\n为了降低开发者的开发门槛，缩短开发周期，降低开发资源投入，机智云推出了代码自动生成服务。云端会根据产品定义的数据点生成对应产品的设备端代码。\n自动生成的代码实现了机智云通信协议的解析与封包、传感器数据与通信数据的转换逻辑，并封装成了简单的API，且提供了多种平台的实例代码。当设备收到云端或APP端的数据后，程序会将数据转换成对应的事件并通知到应用层，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，就可以完成产品的开发。\n使用自动生成的代码开发产品，就不必再处理协议相关的部分了，开发者可以将节省出来的精力集中在产品的核心功能开发上。\n2. 利用“代码自动生成工具”自动生成Arduino平台MCU代码\n2.1 创建产品\n登录机智云开发者中心：http://dev.gizwits.com/\n\n点击右上角创建新产品，输入相应的产品信息后点击“保存”。\n\n2.2 添加数据点\n添加相应的数据点\n\n\n添加成功后点击“应用”\n \n2.3 生成arduino平台的MCU方案代码\n注：如果之前没有定义数据点则无法使用自动生成代码服务。\n1）定义好产品后，选择左侧服务中的“MCU开发”(假设采用的MCU是ArduinoUNOWiFi)，选中硬件方案中的“独立MCU方案”，再选择“硬件平台”中的“ArduinoUNOWiFi”，最后点击“生成代码包”，等待生成完毕下载即可。\n\n2）下载完成后解压如下\n\n3.    Arduino平台代码的导入和编译下载\n3.1 Arduino IDE的下载和安装\nArduino IDE(Integrated Development Environment)即Arduino 集成开发环境，只要在IDE中编写程序代码，将程序上传到Arduino电路板后，程序便会告诉Arduino电路板要做些什么了。本文档使用Arduino IDE 1.7.10版本，以下为下载链接\n链接: http://pan.baidu.com/s/1c25QA8w 密码: ixkj\n\n下载完后为一个zip压缩包，解压出来为一个exe文件，双击安装即可。安装完成后，打开入下图所示界面。\n\n3.2 自动生成接入库导入Arduino IDE\n1）打开Arduino IDE，点击项目-导入库-添加库。\n\n2）将自动生成代码解压到一个名为GizwitsArduinoUnoWiFi的文件夹下，点击打开。\n\n3）导入成功后，导入的库的目录在我的文档-Arduino-libraries下\n\n4）打开GizwitsArduinoUnoWiFi文件夹，examples便是示例文件夹。\n\n注：生成文件的介绍以及使用请查看文档《ArduinoUnoWiFiSDK 之 API 介绍》\n3.3     将自动生成并编译好的代码上传到ArduinoUnoWiFi\n自动生成完的代码的examples目录下有两个文件夹，文件夹里面分别是networkconfig.ino（配置网络示例）和simpleTry.ino（数据点示例）\n\n注：这里需要先上传完networkconfig.ino（配置网络示例），用机智云调试APP配置网络，配置成功后，再上传simpleTry.ino（数据点示例）。\n3.3.1 上传networkconfig.ino（配置网络示例）\n1）打开Arduino IDE，选择工具-板-Arduino Uno WiFi\n\n2）打开设备管理器，找到Arduino Uno WiFi的端口，这里我们的端口为COM6。\n\n3）我们点开IDE工具-端口，选择COM6（Arduino Uno WiFi），然后右下角显示arduino Uno on COM6即可。\n\n4）点击上传，显示上传成功\n\n5）配置网络，本文选用机智云调试APP来配置网络\n     \n   \n\n6）若配置失败，则检查wifi环境是否故障，是否受限，应采用2.4Ghz频段的WIFI环境进行配置，若配置成功则进入下一步\n3.3.2 上传simpleTry.ino（数据点示例）\n1）打开simpleTry文件夹内的simpleTry.ino，选好端口，点击上传，显示上传成功。\n\n2）将设备重新上电，点击刷新，将会看到名称已显示，说明MCU固件已经完全烧录成功。\n\n4. 相关支持\n\n1)相关支持\n\n如果您是开发者\n注册机智云开发者平台，即可免费体验相关开发工具\n开发者平台：site.gizwits.com\nGokit在线申请：www.gizwits.com/zh-cn/gokit\n\n2)如果您是团队\n\nGizWits针对团体有很多支持计划，您可以和GizWtis联系，快速得到技术支持\n联系邮箱：service@gizwits.com\n联系电话：020-6224-0080\n官方二维码：\n\n"},{"title":"ArduinoUnoWiFi SDK之API介绍","url":"/zh-cn/deviceDev/ArduinoUNO/ArduinoUnoWiFi_SDK_API.html","content":"1 文件介绍\n\n重要文件解读：\n1.gizwits_product.cpp\n该文件为产品相关处理函数，如gizwitsEventProcess()。\n2.gizwits_product.h\n该文件为gizwits_product.c的头文件，如HARDWARE_VERSION、SOFTWARE_VERSION。\n3.gizwits_protocol.cpp\n该文件为SDK API接口函数定义文件。\n4.gizwits_protocol.h\n该文件为gizwits_protocol.c对应头文件,相关API的接口声明均在此文件中。\n5.工程文件\nnetworkConfig.ino\n按键配置入网示例，实现了两个按键驱动，key1短按通知模组进入产测模式，key1长按复位模组，key2短按模组进入softAP模式，key2长按模组进入Airlink模式。\nsimpleTry.ino\n数据点示例，主要处理数据的下发和上报。\n2 Gizwits类方法介绍\nvoid begin(void)\n\ngizwits协议初始化接口。用户调用该接口可以完成Gizwits协议相关初始化（包括协议串口的初始化、串口接收数据缓冲区初始化）。\n\nvoid process(void)\n\n该函数中完成了相应协议数据的处理及数据上报的等相关操作，需要在loop中调用。\n\nvoid setBindMode(uint8_t mode)\n\n模组配置网络接口，参数mode[in]：WIFI_MODE_TYPE_T枚举值\n参数为WIFI_RESET_MODE，恢复模组出厂配置接口，调用会清空所有配置参数，恢复到出厂默认配置。\n参数为WIFI_SOFTAP_MODE或WIFI_AIRLINK_MODE，配置模式切换接口，支持SoftAP和AirLink模式。参数为WIFI_SOFTAP_MODE时配置模组进入SoftAp模式，参数为WIFI_AIRLINK_MODE配置模组进入AirLink模式。\n参数为WIFI_PRODUCTION_TEST，模组进入产测模式。\n参数为WIFI_NINABLE_MODE，模组进入可绑定模式，可绑定时间为NINABLETIME(gizwits_protocol.h中声明)，默认为0，表示模组永久可绑定。\nbool wifiHasBeenSet(EVENT_TYPE_T eventType)\n查询模组状态接口，参数eventType[in]：EVENT_TYPE_T枚举值\n参数为WIFI_SOFTAP，函数返回为true则表示模组状态为SOFTAP模式\n参数为WIFI_AIRLINK，函数返回为true则表示模组状态为AIRLINK模式\n参数为WIFI_STATION，函数返回为true则表示模组状态为STATION模式\n参数为WIFI_CON_ROUTER，函数返回为true则表示模组状态为已连接到路由器\n参数为WIFI_DISCON_ROUTER，函数返回为true则表示模组状态为断开路由器\n参数为WIFI_CON_M2M，函数返回为true则表示模组状态为连接到M2M状态\n参数为WIFI_DISCON_M2M，函数返回为true则表示模组状态为断开M2M状态\n\nvoid read(EVENT_TYPE_T eventType, bool* value)\n\n参数eventType[in]:数据点事件宏\n参数value[out]:返回的数据\nbool型数据点下发数值获取接口。用户获取到下发的数值，做相应处理。\n\nvoid read(EVENT_TYPE_T eventType, uint32_t* value)\n\n参数eventType[in]:数据点事件宏\n参数value[out]:返回的数据\n无符号整型数值类数据点和枚举型数据点下发数值获取接口。用户获取到下发的数值，做相应处理。\n\nvoid read(EVENT_TYPE_T eventType, int32_t* value)\n\n参数eventType[in]:数据点事件宏\n参数value[out]:返回的数据\n有符号整型数值类数据点下发数值获取接口。用户获取到下发的数值，做相应处理。\n\nvoid read(EVENT_TYPE_T eventType, float* value)\n\n参数eventType[in]:数据点事件宏\n参数value[out]:返回的数据\n浮点型数值类数据点下发数值获取接口。用户获取到下发的数值，做相应处理。\n\nvoid readBinary(EVENT_TYPE_T eventType, uint8_t* data)\n\n参数eventType[out]:数据点事件宏\n参数data[out]:返回的数据\n扩展型数据点下发数值获取接口。用户获取到下发的数值，做相应处理。注意，使用云端自动生成的代码，扩展型数据点使用数组存储并且长度已经定义完毕，用户不需要传参，也不许任意改动该长度定义。\n\nvoid write(VALUE_TYPE_T valueType, bool value)\n\n参数valueType[in]:可写数据点事件宏\n参数value[in]:待上报数据\nbool型数据点数据上报接口。用户通过传感器或者其他获取到数据，通过该接口上报到云端和APP。\n\nvoid write(VALUE_TYPE_T valueType, uint32_t value)\n\n参数valueType[in]:可写数据点事件宏\n参数value[in]:待上报数据\n无符号整型数值类和枚举类数据点数据上报接口。用户通过传感器或者其他获取到数据，通过该接口上报到云端和APP。\n\nvoid write(VALUE_TYPE_T valueType, int32_t value)\n\n参数valueType[in]:可写数据点事件宏\n参数value[in]:待上报数据\n有符号整型数值类数据点数据上报接口。用户通过传感器或者其他获取到数据，通过该接口上报到云端和APP。\n\nvoid write(VALUE_TYPE_T valueType, float value)\n\n参数valueType[in]:可写数据点事件宏\n参数value[in]:待上报数据\n浮点型数值类数据点数据上报接口。用户通过传感器或者其他获取到数据，通过该接口上报到云端和APP。\n\nvoid writeBinary(VALUE_TYPE_T valueType, uint8_t* data,uint32_t dataLen)\n\n参数eventType[in]:数据点事件宏\n参数data[in]:待上报的数据\n参数dataLen[in]:待上报的数据长度\n扩展型数据点上报接口。注意，使用云端自动生成的代码，扩展型数据点使用数组存储并且长度已经定义完毕，也不许改动该长度定义。\n\nbool hasBeenSet(EVENT_TYPE_T eventType)\n\n参数eventType[in]:可写数据点事件宏\n返回true表示已产生该数据点事件，如APP控制某数据点动作。用户首先判断该数据点事件是否发生，再去做相应处理。\n\n3 二次开发\n配置入网\n支持SoftAp和AirLink两种方式配置入网，相应接口为setBindMode()。networkConfig工程提供给了按键配置入网的示例。\n举例：KEY2长按3s触发AirLink配置模式\ncase KEY2_LONG_PRESS:\nmyGizwits.setBindMode(WIFI_AIRLINK_MODE);\nBreak;\n数据采集\nsimpleTry示例已经自动生成了关于开发者定义的需要上报的所有数据点信息。bool型数据点使用bool型变量，无符号整型数值类或者枚举型数据点使用unsigned long型变量，有符号整型数值类数据点使用long型变量，浮点型数据点使用float型变量，扩展型数据点使用数组存储，长度信息已经生成，开发者只需要实现数据采集即可。特别提醒，如果开发者自行定义变量，变量类型定义一定要遵从上述规则，数值型变量的赋值一定不要越界（超过在云端定义的数据大小范围）。\n举例：温度采集\nlong varW_Temperature = 0;//采集函数返回温度数值\nmyGizwits.write(VALUE_TEMPERATURE, varW_Temperature);//Add Sensor Data Collection\n事件处理\nsimpleTry示例已经自动生成了关于开发者定义的需要处理的所有数据点信息的基础框架。bool型数据点使用bool型变量，无符号整型数值类或者枚举型数据点使用unsigned long型变量，有符号整型数值类数据点使用long型变量，浮点型数据点使用float型变量，扩展型数据点使用数组存储，长度信息已经生成，开发者只需要实现相应处理即可。特别提醒，如果开发者自行定义变量，变量类型定义一定要遵从上述规则。\n举例：控制LED开关(bool型)\nbool varR_LED_OnOff = 0;\nif(myGizwits.hasBeenSet(EVENT_LED_ONOFF))\n{\n    myGizwits.read(EVENT_LED_ONOFF,&varR_LED_OnOff);//Address for storing data\n//判断动作是开/关，做灯相应处理\n}\n"},{"title":"ArduinoUnoWiFi 之ESP8266固件烧写教程","url":"/zh-cn/deviceDev/ArduinoUNO/Tutorial.html","content":"概况\nArduino Uno WiFi是Arduino Org推出的一款基于Arduino Uno的开发板，主芯片仍然采用与Arduino Uno相同的ATMega328p，使得开发者能够像使用Arduino Uno一样使用它。\nArduino Uno WiFi集成了乐鑫的ESP8266芯片作为WiFi模块以提供无线联网功能，支持OTA程序无线下载功能，支持REST方式实现远程控制，支持Web方式轻松配置网络。 \nWiFi功能使得Arduino Uno WiFi可以轻松实现无线控制，但是假如没有一款优秀的云服务器来提供固定IP访问和数据保存，也是无法实现不在同一局域网中的远程控制的。 \nGizwits为个人开发者带来了福音，在设备节点小于一定数量时，Gizwits为开发者提供免费云服务器使用。另外为了简化开发难度，Gizwits提供了数据上传分发的详细协议格式及APP范例。 \n本文将介绍Arduino Uno WiFi 板ESP8266固件烧写流程与方法。\n     \n准备工作\n1、ESP8266烧写工具及固件下载\n链接: http://pan.baidu.com/s/1c25QA8w 密码: ixkj\n2、连接烧写串口（TX/RX直连，如若出现连接失败，则做交叉连接尝试）：\n\n烧录\n按照下列步骤进行镜像上传：\n\n使用Arduino IDE工具下载Blink.ino到ATMega328p\n\n\n\n使用USB2Serial工具的Tx Rx GND管脚分别接至Arduino Uno WiFi的Tx Rx GND管脚\n将USB2Serial工具USB接口接至PC，并保证驱动已安装，PC可识别串口\n将Uno WiFi断电，按住开发板上ESP B/L开关的同时上电，以进入下载模式\n使用FlashDownloadTool进行镜像下载，配置如下，其中COM PORT根据实际情况选择\n\n\n\n点击START按钮等待同步\n\n\n\n使用公对公杜邦线一端接至GND管脚，另一端接至Uno WiFi开发板背面ARDUINO.ORG上方的测试点，不需要焊接，程序上传完毕后断开即可\n测试点与GND导通时即完成同步，开始程序上传，上传完毕后断开即可\n\n"},{"title":"Arduino Uno WiFi智能小夜灯","url":"/zh-cn/deviceDev/ArduinoUNO/example.html","content":"1. 前文需知\n1.1 项目说明\n智能灯作为一种最为常见的智能家居设备，在市场前景以及低门槛的驱动下，该产品已经成为开发者已经众多厂家青睐的大众化产品。你可以使用手机控制灯光开启或关闭、调节亮度及颜色甚至与音响系统同步闪烁，这种体验听上去就很有趣。\n本作品希望通过将使用Arduino Uno WiFi板结合GoKit2上的功能板，配合WS2812 8段RGB灯珠板子，使用机智云云端服务器，改造成可用手机来控制的无线wifi小彩灯，还原这个受大众欢迎的炫彩智能灯神秘的本质。\n1.2 彩灯功能说明\n\n开关\n多种模式自由切换，这些模式包括：自定义、呼吸灯、霹雳游侠、极光、温馨\n\n附注：本例只实现彩灯的一些常用功能，更多的自定义和应用场景，用户可根据自己    的需求自定义完成\n1.3 项目所使用的硬件清单\nArduino Uno WiFi  1片\nGoKit2 扩展版 1片\n8位 WS2812 5050 RGB LED 小板  1个\n杜邦线若干\n1.4 项目所用的开发环境\nArduino IDE（1.7.10以上版本）\n1.5 项目所使用的源码\nWS2812 5050 RGB LED Arduino 库文件\n机智云云端自动生成源码（基于ArduinoUnoWiFi 平台）\n1.6 其他\n机智云开发者账号\n智能小夜灯的数据点文件或者自己云端新建\n2.项目制作\n2.1 硬件部分\n使用烙铁将杜邦线，按照下图把WS2812 RGB小灯板的接线线焊接起来。\n\n然后把小灯板的VCC、GND、DIN引脚分别按照下图图片所展示的效果图，将杜邦线的另一端接到GoKit2拓展版的扩展接口排针上。\n\nDIN -> D9\n\n\n2.2 云端部分\n2.2.1 注册GizWits账号\n登陆 http://dev.gizwits.com/zh-cn/developer/ 进行注册账号\n2.2.2 新建一个名为“智能小夜灯”的产品\n新建产品方式参加以下链接图示部分：新建产品教程\n\n2.2.3 云端数据点\n本次项目一共5个数据点，细节可以参考下图：\n\n新建项目的数据点可以通过两种方式来完成，一种是手动新建，新建方式可以点击下图右上角的“定义数据点教程”查看并建立本次项目的数据点；另一种是通过别人导出的数据点Excel表格完成数据点的新建，导入方式参考下图，这里不做重点描述，这次项目的数据点Excel表格通过下方链接获取。\n\n本次项目数据点Excel表格下载链接：\n链接：https://pan.baidu.com/s/1bLznVw 密码: ustg\n手动添加数据点参考一下链接：手动添加数据点教程\n\n注意：数据点环节很重要，如果没有数据点，则无法使用自动生成工具。\n2.2.4 使用云端自动生成工具，生成项目源码\n云端自动生成工具的详细介绍和使用方式，请参考“ArduinoUNOWiFi接入机智云介绍”文档的介绍和操作。\n到这里整个工程项目的准备工作就完成了，下面是修改函数部分的指引。\n2.3 获取源码\n2.3.1 下载云端自动生成源码\nArduinoUNOWiFi 云端自动生成源码，创建之后在项目如图所示的地方获得，下载下来后跟据自己的习惯修改文件夹的名字，本次项目将文件修改为“GizLamp”\n\n2.3.2 下载WS2812驱动库文件\n库文件链接：https://github.com/adafruit/Adafruit_NeoPixel\n本次项目所需要的文件如下\n\n2.3.3 Arduino IDE安装\n请参考“Arduino Uno WiFi接入机智云介绍”文档中，第“3.1 Arduino IDE的下载和安装”章节\n2.3.4 工程文件和Libraries文件导入到\n请参考“ArduinoUNOWiFi接入机智云介绍”文档中，第“3.2 自动生成接入库导入Arduino IDE”章节\n2.4 修改源码\n2.4.1 程序预览\n首先，我们使用Arduino IDE打开云端自动生成工具生成的simpleTry.ino文件，并预览一下，如下图：\n\n然后，我们参见“ArduinoUnoWiFi SDK之API介绍”文档里的对“事件处理”这一部分的描述以及举例部分程序结构：\n\n之后，在继续看一下myGizwits.hasBeenSet()和myGizwits.read(,)这两条函数的解析：\n\n\n通过对比的我们应该了解到这套程序的思路是，如果需要在这套程序中读取一个云端下发的数据，首先需要通过myGizwits.hasBeenSet()这条函数判断这个数据点事件有是否发生，如果数据点事件发生了就通过myGizwits.read(,)这个函数去把发生的事件所产生的数据读取出来，然后再做相应的判断。\n注意：read(,)在“ArduinoUnoWiFi SDK之API介绍”一共有四条，读取不同是据点事    件时，返回值的参数会有差异，使用之前参考“ArduinoUnoWiFi SDK之API介绍”文    档\n应该大体有个理解啦吧！其实你会发现所有你要操作的事件都完成好了！！好，那我们开始修改程序，首先从“2.4.2引用部分开始”\n2.4.2 引用部分\n1）添加WS2812驱动H文件\n#include <Adafruit_NeoPixel.h>\n\n2）定义WS2812的数据通信引脚，以及RGB灯数量。\n#define PIN 9         //使用arduino uno wifi的9号引脚\n#define NUM_LEDS 8    //WS2812小板的数量是8个\n\n3）初始化LED数量、通信引脚号和驱动模式\nAdafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, PIN, NEO_GRB + NEO_KHZ800);\n\n1）该函数中NUM_LEDS，表示控制的点亮多少个全彩灯珠，如果你想改变灯珠点亮的个数你可以    在    这里进行修改。\n2）PIN表示的是与开发板所连的第几个端口，我们这里使用的是第9个端口，你可根    据自己的需要    修改对应的端口。\n3）关于NEO_GRB+NEO_KHZ800，这包括了与开发板所连的具体类型。具体的介绍可以参考文本最    后    Adafruit_NeoPixel库文件的解析，以及根据指导完成更多的案例。\n引用部分完整修改参考如下\n\n接着修改“2.4.3 void setup(){}部分”\n2.4.3 void setup(){}部分\n将以下代码添加到“void setup（）{}”函数里面用于初始化\nstrip.begin();\nstrip.show();// Initialize all pixels to 'off'\n\n最后修改“2.4.4 void loop(){}部分”\n2.4.4 void loop(){}部分\n这一部份我们刚才已经熟悉过啦，那直接修改吧。首先，把所有自动生成工具，所定义的变量全部找出来，如下：\n\n注：红色部分是从绿色部分复制出来的，绿色部分是自动工具自动生成的。\n然后，移动操作事件，如下：\n\n完成以上动作之后，只要在//user add这部分添加相应的驱动函数，就可以完成一个简单的彩灯，不过程序需要优化，才能有比较友好的用户体验。\n需要注意地方是：\n彩灯场景切换事件（EVENT_SCENE）\n以及用户自定义事件（EVENT_RLAMP||EVENT_GLAMP||EVENT_BLAMP），均使用以下函数    读取云端下发的数值；只不过场景切换事件在云端创建的数据点类型是枚举型，使用    以下函数读取云端下的数值时，该函数返回的值为：0,1,2,3,4；而在用户自定义事件    下实用函数，返回的值为：0~255\n\n2.5 编译烧录\n请参考“ArduinoUNOWiFi接入机智云介绍”文档中，第“3.3.2上传simpleTry.ino（数据点示例）”章节\n\n注意：这里的案例修改是彩灯部分程序，不包含配置wifi入网环节，产品联网需要先更新“networkconfig.ino（配置网络示例）”工程到ArduinoUNOWiFi板子上，进行配网，然后在更新本次的工程文件“simpleTry.ino（数据点示例）”产品才能正常连接路由器登陆云端。更新“networkconfig.ino（配置网络示例）”工程请参考“ArduinoUNOWiFi接入机智云介绍”文档中，第“3.3.1上传networkconfig.ino（配置网络示例）”章节\n\n3.项目调试\n3.1 下载Demo App\n前往机智云下载中心，根据下图提示实用手机扫描下载调试产品的Demo App，调试产品体验产品。\n\n3.2 产品体验\n使用Demo App局域网内发现，并绑定彩灯之后，App的操作界面，一个完整的彩灯制作就完成了。\n\n注意：\n局域网发现为：ArduinoUnoWiFi板子和Demo App处于同一个WiFi热点下，Demo App才会发现这个设备，否则无法发现，从而无法就使用Demo App去绑定和操作这个设备。举个例子，ArduinoUnoWiFi板子被配置了链接到名字为“Gizwits”这个WiFi热点（确定已连接，并要确定Gizwits这个热点是可以链接外网），那么使用Demo App的那部手机也需要链接到名为“Gizwits”这个热点下，否则就无法发现设备。\n\n产品制作完成\n\n最后附上本次项目的源码下载链接如下：\n链接：http://pan.baidu.com/s/1c1BROha 密码：bzw5\n4.相关支持\n\n1)相关支持\n\n如果您是开发者\n注册机智云开发者平台，即可免费体验相关开发工具\n开发者平台：site.gizwits.com\nGokit在线申请：www.gizwits.com/zh-cn/gokit\n\n2)如果您是团队\n\nGizWits针对团体有很多支持计划，您可以和GizWtis联系，快速得到技术支持\n联系邮箱：service@gizwits.com\n联系电话：020-6224-0080\n官方二维码：\n\n"},{"title":"MCU代码自动生成工具介绍","url":"/zh-cn/deviceDev/DevSDK/代码自动生成工具.html","content":"原标题：GoKit3二次开发-代码自动生成工具介绍\n查看旧版代码自动生成工具介绍\n前文需知\n1.什么是“代码自动生成工具”\n为了降低开发者的开发门槛，缩短开发周期，降低开发资源投入，机智云推出了代码自动生成服务。云端会根据产品定义的数据点生成对应产品的设备端代码。\n自动生成的代码实现了机智云通信协议的解析与封包、传感器数据与通信数据的转换逻辑，并封装成了简单的API，且提供了多种平台的实例代码。当设备收到云端或APP端的数据后，程序会将数据转换成对应的事件并通知到应用层，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，就可以完成产品的开发。\n使用自动生成的代码开发产品，就不必再处理协议相关的部分了，开发者可以将节省出来的精力集中在产品的核心功能开发上。\n2.支持的平台\n自动生成服务支持的硬件方案有：独立MCU方案、SOC方案。其中独立MCU方案支持的硬件平台有：stm32f103c8x平台、通用平台（即“其他平台”）；SOC方案支持的硬件平台有：ESP8266平台。\nMCU方案与SOC方案区别：\n\n\n\n方案\n说明\n\n\n\n\nMCU方案\n模组负责与云端信息的交互，通过串口与主控板（即MCU）进行通信，需要在MCU上进行协议解析与外设控制的开发。\n\n\nSoC方案\n节省一颗MCU芯片，利用模组内部资源完成传感器操作和产品逻辑。\n\n\n\nMCU方案中除了支持STM32平台，还可以将我们生成好的通用平台版代码移植到符合条件的任意平台，从而实现机智云所提供的各种功能（详细移植过程请查看《GoKit3二次开发--通用平台版移植说明》）。\n“代码自动生成工具”的使用\n1.创建产品\n登录机智云开发者中心：http://dev.gizwits.com/\n\n点击右上角创建新产品\n输入相应的产品信息后点击“保存”。\n\n2.添加数据点\n添加相应的数据点\n\n\n添加成功后点击“应用”\n\n3.生成目标平台代码\n\n注：如果之前没有定义数据点则无法使用自动生成代码服务。\n\n3.1 生成MCU方案代码\n定义好产品后，选择左侧服务中的“MCU开发”(假设采用的MCU是STM32F103C8x)，选中硬件方案中的“独立MCU方案”，再选择“硬件平台”中的“stm32f103c8x”，最后点击“生成代码包”，等待生成完毕下载即可。\n\n注：如果是其他MCU芯片，请选择“其他平台”选项，然后将生成的代码包移植到使用的平台，移植方法参考《GoKit3二次开发-通用平台版移植说明》。\n\n\n\n3.2 生成SoC方案代码\n定义好产品后，选择左侧服务中的“SoC开发”(假设使用的SoC芯片是esp8266)，选中硬件方案中的“SoC方案”，则选择“硬件平台”中的“esp8266”，最后点击“生成代码包”，等待生成完毕下载即可。\n\n下载完成后解压如下\n\n自动生成代码说明\n1. STM32平台文件说明\n\n主要文件说明：\n\n\n\n文件\n说明\n\n\n\n\ngizwits_product.c\n该文件为产品相关处理函数，如 gizEventProcess()平台相关硬件初始化，如串口、定时器等\n\n\ngizwits_product.h\n该文件为 gizwits_product.c 的头文件，存放产品相关宏定义如： HARDWARE_VERSION 、SOFTWARE_VERSION\n\n\ngizwits_protocol.c\n该文件为 SDK API 接口函数定义文件\n\n\ngizwits_protocol.h\n该文件为 gizwits_protocol.c 对应头文件,相关 API 的接口声明均在此文件中\n\n\n\n2. ESP8266平台文件说明\n\n主要文件说明：\n\n\n\n文件\n说明\n\n\n\n\nlibgagent.a\n该文件为机智云设备接入协议库文件,文件位于 lib 目录下\n\n\ngagent_external.h\n该文件为 libgagent.a 对应头文件,两个文件配合使用\n\n\ngizwits_product.c\n该文件为平台相关处理文件，存放事件处理API接口函数，即 gizwitsEventProcess()\n\n\ngizwits_product.h\n该文件为  gizwits_product.c 的头文件，存放产品相关宏定义如： HARDWARE_VERSION 、SOFTWARE_VERSION\n\n\ngizwits_protocol.c\n该文件为协议实现文件，存放 SDK API 接口函数\n\n\ngizwits_protocol.h\n该文件为 gizwits_protocol.c 对应头文件，协议相关宏定义即 API 接口声明均在此文件中。\n\n\n\n二次开发介绍\n1. 代码二次开发需知\n自动生成的代码已经根据用户定义的产品数据点信息，并针对STM32、ESP8266等平台，生成了对应的机智云串口协议层代码，用户只需要调用相应的API接口或添加相应的逻辑处理即可。代码框架如下图所示：\n\n\n需要开发的部分为：\n\n\n\n下行处理：例如LED灯开关、电机转速控制等。\n\n\n\n\n上行处理：例如温湿度数据采集，红外传感器状态获取等。\n\n\n\n\n配置处理：配置入网及恢复出厂设置。\n\n\n2. 二次开发举例\n自动生成的代码在各平台之间使用了统一的协议封装，故二次开发所完成的修改也几乎相同，下面以STM32平台为例。\n2.1 下行处理\n首先要完成的是传感器驱动开发，然后在Gizwits目录下的gizwits_product.c文件中的gizwitsEventProcess()函数中处理相应事件即可（如下例中的ledRgbControl(),功能是控制RGB灯的颜色）。\n下面以控制RGB LED为例，代码示例如下：\n修改前：\nif(0x01 == currentDataPoint.valueLED_ONOFF)\n{\n  //user handle\n}\nelse\n{\n  //user handle    \n}        \nbreak;\n\n修改后：\nif(0x01 == currentDataPoint.valueLED_ONOFF)\n{\n  //user handle\nledRgbControl(254,0,0);\n}\nelse\n{\n  //user handle    \nledRgbControl(0,0,0);  \n}        \nbreak;\n\n2.2 上行处理\n首先要完成的是传感器驱动开发，然后在Gizwits目录下的gizwits_product.c文件中的userHandle()函数中实现传感器数据采集，用户只需并将采集到的数值赋值给对应用户区的设备状态结构体数据位即可（如下例中的：currentDataPoint.valueInfrared = irHandle();）。\n下面以红外传感器的数据获取为例（只读型数据点的操作会被云端自动生成），如下：\n修改前：\nvoid userHandle(void)\n{\n    /*\n    currentDataPoint.valueInfrared = ;//Add Sensor Data Collection\n    */\n}\n\n修改后：\nvvoid userHandle(void)\n{\n    currentDataPoint.valueInfrared = irHandle();\n}\n\n\n特别提醒：userHandle()被while循环调用，执行速度较快，需要针对不同的需求，用户可调整数据点数据的采集周期和接口实现位置，预防由于传感器数据采集过快引发的不必要的问题。但不建议在userHandle()中调用延时函数来降低执行频率。正确方法如下：\n\nvoid userHandle(void)\n{\nstatic uint32_t irLastTimer = 0;\n\nif((gizGetTimerCount()-irLastTimer ) > SAMPLING_TIME_MAX)         {\ncurrentDataPoint.valueInfrared = irHandle();\n\nirLastTimer = gizGetTimerCount();\n    }\n}\n\n2.3 配置处理\n除了数据的上行与下行处理外，还需要一些配置操作需要完成，如下：\n\n配置入网\n恢复出厂配置\n\n我们提供了一个API接口，实现上述操作，定义如下。\nint32_t gizwitsSetMode(uint8_t mode)\n参数mode支持WIFI_RESET_MODE、WIFI_SOFTAP_MODE、WIFI_AIRLINK_MODE三种(详情见gizwits_protocol.h文件的 WIFI_MODE_TYPE_T)，分别完成恢复出厂配置，进入softap配置模式，进入airlink配置模式操作。您可以根据产品的定义实现不同的配置操作，如按键触发进入配置模式。\n更多\n截止至2017年，MCU代码自动生成功能特性如下\n\n支持8位、16位、32位的MCU\nCubemx无缝对接\n支持四大类MCU：51单片机、MSP430、STM32、arduino，含正点原子等\n兼容esp8266 SOC开发方式，含8M、16M、32M模组\n\n立即试用\n"},{"title":"GoKit3二次开发-代码自动生成工具介绍(旧)","url":"/zh-cn/deviceDev/DevSDK/代码自动生成工具_old.html","content":"2017年10月30日起已使用新版MCU代码生成，查看新版代码自动生成工具介绍\n前文需知\n1.什么是“代码自动生成工具”\n为了降低开发者的开发门槛，缩短开发周期，降低开发资源投入，机智云推出了代码自动生成服务。云端会根据产品定义的数据点生成对应产品的设备端代码。\n自动生成的代码实现了机智云通信协议的解析与封包、传感器数据与通信数据的转换逻辑，并封装成了简单的API，且提供了多种平台的实例代码。当设备收到云端或APP端的数据后，程序会将数据转换成对应的事件并通知到应用层，开发者只需要在对应的事件处理逻辑中添加传感器的控制函数，就可以完成产品的开发。\n使用自动生成的代码开发产品，就不必再处理协议相关的部分了，开发者可以将节省出来的精力集中在产品的核心功能开发上。\n2.支持的平台\n自动生成服务支持的硬件方案有：独立MCU方案、SOC方案。其中独立MCU方案支持的硬件平台有：stm32f103c8x平台、通用平台（即“其他平台”）；SOC方案支持的硬件平台有：ESP8266平台。\nMCU方案与SOC方案区别：\n\n\n\n方案\n说明\n\n\n\n\nMCU方案\n模组负责与云端信息的交互，通过串口与主控板（即MCU）进行通信，需要在MCU上进行协议解析与外设控制的开发。\n\n\nSoC方案\n节省一颗MCU芯片，利用模组内部资源完成传感器操作和产品逻辑。\n\n\n\nMCU方案中除了支持STM32平台，还可以将我们生成好的通用平台版代码移植到符合条件的任意平台，从而实现机智云所提供的各种功能（详细移植过程请查看《GoKit3二次开发--通用平台版移植说明》）。\n“代码自动生成工具”的使用\n1.创建产品\n登录机智云开发者中心：http://dev.gizwits.com/\n\n点击右上角创建新产品\n输入相应的产品信息后点击“保存”。\n\n2.添加数据点\n添加相应的数据点\n\n\n添加成功后点击“应用”\n\n3.生成目标平台代码\n\n注：如果之前没有定义数据点则无法使用自动生成代码服务。\n\n3.1 生成MCU方案代码\n定义好产品后，选择左侧服务中的“MCU开发”(假设采用的MCU是STM32F103C8x)，选中硬件方案中的“独立MCU方案”，再选择“硬件平台”中的“stm32f103c8x”，最后点击“生成代码包”，等待生成完毕下载即可。\n\n注：如果是其他MCU芯片，请选择“其他平台”选项，然后将生成的代码包移植到使用的平台，移植方法参考《GoKit3二次开发-通用平台版移植说明》。\n\n\n\n3.2 生成SoC方案代码\n定义好产品后，选择左侧服务中的“SoC开发”(假设使用的SoC芯片是esp8266)，选中硬件方案中的“SoC方案”，则选择“硬件平台”中的“esp8266”，最后点击“生成代码包”，等待生成完毕下载即可。\n\n下载完成后解压如下\n\n自动生成代码说明\n1. STM32平台文件说明\n\n主要文件说明：\n\n\n\n文件\n说明\n\n\n\n\ngizwits_product.c\n该文件为产品相关处理函数，如 gizEventProcess()平台相关硬件初始化，如串口、定时器等\n\n\ngizwits_product.h\n该文件为 gizwits_product.c 的头文件，存放产品相关宏定义如： HARDWARE_VERSION 、SOFTWARE_VERSION\n\n\ngizwits_protocol.c\n该文件为 SDK API 接口函数定义文件\n\n\ngizwits_protocol.h\n该文件为 gizwits_protocol.c 对应头文件,相关 API 的接口声明均在此文件中\n\n\n\n2. ESP8266平台文件说明\n\n主要文件说明：\n\n\n\n文件\n说明\n\n\n\n\nlibgagent.a\n该文件为机智云设备接入协议库文件,文件位于 lib 目录下\n\n\ngagent_external.h\n该文件为 libgagent.a 对应头文件,两个文件配合使用\n\n\ngizwits_product.c\n该文件为平台相关处理文件，存放事件处理API接口函数，即 gizwitsEventProcess()\n\n\ngizwits_product.h\n该文件为  gizwits_product.c 的头文件，存放产品相关宏定义如： HARDWARE_VERSION 、SOFTWARE_VERSION\n\n\ngizwits_protocol.c\n该文件为协议实现文件，存放 SDK API 接口函数\n\n\ngizwits_protocol.h\n该文件为 gizwits_protocol.c 对应头文件，协议相关宏定义即 API 接口声明均在此文件中。\n\n\n\n二次开发介绍\n1. 代码二次开发需知\n自动生成的代码已经根据用户定义的产品数据点信息，并针对STM32、ESP8266等平台，生成了对应的机智云串口协议层代码，用户只需要调用相应的API接口或添加相应的逻辑处理即可。代码框架如下图所示：\n\n\n需要开发的部分为：\n\n\n\n下行处理：例如LED灯开关、电机转速控制等。\n\n\n\n\n上行处理：例如温湿度数据采集，红外传感器状态获取等。\n\n\n\n\n配置处理：配置入网及恢复出厂设置。\n\n\n2. 二次开发举例\n自动生成的代码在各平台之间使用了统一的协议封装，故二次开发所完成的修改也几乎相同，下面以STM32平台为例。\n2.1 下行处理\n首先要完成的是传感器驱动开发，然后在Gizwits目录下的gizwits_product.c文件中的gizwitsEventProcess()函数中处理相应事件即可（如下例中的ledRgbControl(),功能是控制RGB灯的颜色）。\n下面以控制RGB LED为例，代码示例如下：\n修改前：\nif(0x01 == currentDataPoint.valueLED_ONOFF)\n{\n  //user handle\n}\nelse\n{\n  //user handle    \n}        \nbreak;\n\n修改后：\nif(0x01 == currentDataPoint.valueLED_ONOFF)\n{\n  //user handle\nledRgbControl(254,0,0);\n}\nelse\n{\n  //user handle    \nledRgbControl(0,0,0);  \n}        \nbreak;\n\n2.2 上行处理\n首先要完成的是传感器驱动开发，然后在user目录下main.c文件中的userHandle()函数中实现传感器数据采集，用户只需并将采集到的数值赋值给对应用户区的设备状态结构体数据位即可（如下例中的：currentDataPoint.valueInfrared = irHandle();）。\n下面以红外传感器的数据获取为例（只读型数据点的操作会被云端自动生成），如下：\n修改前：\nvoid userHandle(void)\n{\n    /*\n    currentDataPoint.valueInfrared = ;//Add Sensor Data Collection\n    */\n}\n\n修改后：\nvvoid userHandle(void)\n{\n    currentDataPoint.valueInfrared = irHandle();\n}\n\n\n特别提醒：userHandle()被while循环调用，执行速度较快，需要针对不同的需求，用户可调整数据点数据的采集周期和接口实现位置，预防由于传感器数据采集过快引发的不必要的问题。但不建议在userHandle()中调用延时函数来降低执行频率。正确方法如下：\n\nvoid userHandle(void)\n{\nstatic uint32_t irLastTimer = 0;\n\nif((gizGetTimerCount()-irLastTimer ) > SAMPLING_TIME_MAX)         {\ncurrentDataPoint.valueInfrared = irHandle();\n\nirLastTimer = gizGetTimerCount();\n    }\n}\n\n2.3 配置处理\n除了数据的上行与下行处理外，还需要一些配置操作需要完成，如下：\n\n配置入网\n恢复出厂配置\n\n我们提供了一个API接口，实现上述操作，定义如下。\nint32_t gizwitsSetMode(uint8_t mode)\n参数mode支持WIFI_RESET_MODE、WIFI_SOFTAP_MODE、WIFI_AIRLINK_MODE三种(详情见gizwits_protocol.h文件的 WIFI_MODE_TYPE_T)，分别完成恢复出厂配置，进入softap配置模式，进入airlink配置模式操作。您可以根据产品的定义实现不同的配置操作，如按键触发进入配置模式。\n"},{"title":"GoKit 3 硬件手册","url":"/zh-cn/deviceDev/Gokit3/GoKit3硬件手册.html","content":"GoKit 3 开发套件概述\n1.硬件相关\nGoKit 3采用可扩展式的硬件设计方案。核心硬件是包括：功能扩展板、ESP8266 WiFi模块。\n同时GoKit 3兼容标准Arduino接口、Hi3518E WiFi模块、语音模块等相关模组。\n2.软件相关\nGoKit 3开发套件使用机智云物联网云服务平台，使用自定义数据点的IoT开发框架，用户可以试用其方便地开发智能硬件产品。\nESP8266 Wi-Fi模组\n1.ESP8266介绍\n乐鑫ESP8266 拥有高性能无线SOC，给移动平台设计师带来福音，它以最低成本提供最大实用性，为 WiFi 功能嵌入其他系统提供无限可能。\n2.ESP8266结构图\n\n3.ESP8266特点\n\n802.11 b/g/n\nWIFI @2.4 GHz， 支持 WPA/WPA2 安全模式\n超小尺寸模组 11.5mm*11.5mm\n内置 10 bit 高精度 ADC\n内置 TCP/IP 协议栈\n内置 TR 开关、 balun、 LNA、功率放大器和匹配网络\n内置 PLL、稳压器和电源管理组件\n802.11b 模式下+ 19.5dBm 的输出功率\n支持天线分集\n断电泄露电流小于10uA\n内置低功率 32 位 CPU：可以兼作应用处理器\nSDIO 2.0、 SPI、 UART\nSTBC、 1x1 MIMO、 2x1 MIMO\nA-MPDU 、 A-MSDU 的聚合和 0.4 s的保护间隔\n2ms之内唤醒、连接并传递数据包\n待机状态消耗功率小于1.0mW (DTIM3)\n工作温度范围 -40 ~ 125℃\n\n4.ESP8266实物图\nWiFi模组（正面）：\n\nWiFi模组（反面）：\n\n5.ESP8266模组接口原理图\n\nGoKit 3功能扩展板\n1.功能扩展板介绍\nGoKit 3功能扩展板兼容多种型号的WiFi模组，用于连接各种外设传感器，用于模拟实际应用功能，其拥有丰富的扩展接口（如咪头接口、扬声器接口、语音降噪接口等），并兼容标准 Arduino 接口，方便开发者在其上完成二次开发。\n2.功能扩展板硬件功能\n\n\n\n序号\n硬件功能\n功能说明\n\n\n\n\n2\n红外探测器\n可以探测是否有阻挡\n\n\n3\nRGB LED\n可编程全彩LED灯\n\n\n4\n可编程电机\n可编程正反转及调速电机\n\n\n5\n温湿度传感器\n\n\n\n6\n三个可编程按键\n\n\n\n7\n一组咪头接口\n\n\n\n8\n扬声器接口\n\n\n\n9\n语音降噪模块接口\n\n\n\n10\nUSB转Uart接口\n可以更方便对GoKit供电，并打印日志\n\n\n12\n双模式模组接口\n可按需求切换为SOC模式或MCU模式\n\n\n13\nOLED接口\n可复用SPI等其他接口\n\n\n\n预留接口\n具有电源输出、SWD、Uart TTL等接口功能\n\n\n\n3.功能扩展板实物图\n功能扩展板实物图（正面）：\n\n功能扩展板实物图（反面）：\n\n4.功能扩展板详解\n4.1 按键\n功能扩展板上设计有三个可编程按键，用户可根据需要来使用。\n硬件原理图如下：\n\n4.2 红外传感器\n扩展板上采用一个单光束反射式红外光电传感器ST188，该传感器模块对环境光线适应能力强，其具有一对红外线发射与接收管，发射管发射出一定频率的红外线，当检测方向遇到障碍物（反射面）时，红外线反射回来被接收管接收，经过比较器电路处理之后，红色指示灯会亮起，同时信号输出接口输出数字信号（一个低电平信号），可通过电位器旋钮调节检测距离，有效距离范围2～80cm，工作电压为3.3V-5V。该传感器的探测距离可以通过电位器调节、具有干扰小、便于装配、使用方便等特点。比较器采用LM393，工作稳定。\n硬件原理图如下：\n\n4.3 温湿度传感器\n扩展板上设计了一款有已校准数字信号输出的温湿度传感器：DHT11。\n该传感器是一款含有已校准数字信号输出的温湿度复合传感器。它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有极高的可靠性不卓越的长期稳定性。传感器包拪一个电阻式感湿元件和一个 NTC测温元件，并不一个高性能MCU连接。因此该产品具有品质卓越、抗干扰能力强、性价比极高等优点。每个 DHT11 传感器都在极为精确的湿度校验室中进行校准。校准系数以程序的形式储存在 OTP 内存中，传感器内部在检测信号的处理过程中要调用这些校准系数。单线制串行接口，使系统集成变得简易快捷。超小的体积、极低的功耗，信号传输距离可达 20 米以上，产品为 4 针单排引脚封装。\n相关参数：精度湿度+-5%RH， 温度+-2℃，量程湿度20-90%RH， 温度0~50℃。\n驱动的时序图如下图所示：\n\n硬件原理图如下：\n\n4.4 微型直流电动机\n为了模拟现场的执行机构，扩展板上设计一个微型直流电动机，采用L9110进行驱动。\nL9110是为控制和驱动电机设计的两通道推挽式功率放大专用集成电路器件，将分立电路集成在单片IC之中，使外围器件成本降低，整机可靠性提高。该芯片有两个TTL/CMOS兼容电平的输入，具有良好的抗干扰性；两个输出端能直接驱动电机的正反向运动，它具有较大的电流驱动能力，每通道能通过800mA的持续电流，峰值电流能力可达1.5A；同时它具有较低的输出饱和压降；内置的钳位二极管能释放感性负载的反向冲击电流，使它在驱动继电器、直流电机、步进电机或开关功率管的使用上安全可靠，产品为 4 针单排引脚封装。\n管脚波形图：\n\n硬件原理图如下：\n\n4.5 RGB 三色 LED\n扩展板上设计了一个RGB三色LED指示灯，通过P9813驱动，可以实现对LED的全色彩控制。\nP9813 是一款全彩点光源 LED 驱劢芯片，采用 CMOS 工艺，提供三路恒流驱劢及256级灰度调制输出。采用双线传输方式(DATA不CLK)，内建再生，可提升传输距离。用于驱动显示灯光发换、各式字符发换、彩色动漫图案。根据不同控制器和客户不同形式要求，进行脱机或联机运行。\n该芯片的特点：\n\nIC 输入电压 5V～6.5V；内置LDO，4.5V稳压输出；\n外置单电阻反馈模式，三路驱劢，每路驱动电流 0-45mA；\n带有输入信号校验功能；\n内置环振（1.2MHz）支持不间断 FREE－RUN 调制输出，维持画面静止功能； \n最大串行输入数据时钟频率15MHz； \n具有信号锁相再生，1MHz 数据传输速度下级联点光源可达 1024 个；\nLED 驱动端口耐压 17V。\n\n驱动的时序图如下图所示：\n\n注意：由于 P9813 不是标准的 I2C 接口，为了节约 IO，电路连接在 I2C 的总线上，但是需要配置为 GPIO，根据时序图来实现调色，调光的功能。\n硬件原理图如下：\n\n4.6 OLED屏幕接口\n有机収光二极管（Organic Light-Emitting Diode，OLED）具有自収光，不需背光源、对比度高、厚度薄、规角广、反应速度快、可用于挠曲性面板、使用温度范围广、构造及制程较简单等优异之特性，被认为是下一代的平面显示器新兴应用技术。\n功能扩展板提供一个OLED屏幕接口。\n硬件原理图如下：\n\n4.7 扬声器接口\n功能扩展板提供一个扬声器接口。\n硬件原理图如下：\n\n4.8 咪头接口\n功能扩展板提供一组咪头接口。\n硬件原理图如下：\n\n4.9 标准 Arduino 接口\n扩展板采用了标准的 Arduino 接口，能使扩展板与Arduino之间无缝链接，也可以插在任何标准的Arduino 的 MCU 主板中。\n硬件原理图如下：\n\n4.10 UART 转USB接口\n扩展板预留一个 USB 接口，方便用户调试和通信。转换芯片采用CP2102，具有集成度高的特点，可内置USB2.0全速功能控制器、USB收发器、晶体振荡器、EEPROM及异步串行数据总线（UART），支持调制解调器全功能信号，无需任何外部的USB器件。\n硬件原理图如下：\n\n4.11 WiFi模组接口\n拓展版提供一个双模式模组接口，可按需求切换为SOC模式（GoKit 3所使用的模式）或MCU模式。\n硬件原理图如下：\n\n4.12 语音降噪模块接口\n扩展板提供一个语音降噪模块接口。\n硬件原理图如下：\n\n4.13 预留接口\n功能板将部分没有用到的接口全部引出，方便开发者扩展应用。\n下图是预留的扩展接口：\n\nP6 接口是Arduino的外置兼容接口。\nP7 接口中有一组SWD接口（可用于模组程序烧录）、一组Uart TTL接口（用来输出模组Debug日志）。\nP9接口具有电源输出、共地的功能。\n开发者支持\n使用Gokit 系列开収套件，用户将拥有机智云开发者专有账号，给予开发者进入机智云云平台的技术支持，包括开发者所需要的资料及SDK、社区论坛服务、以及其他服务。\n机智云官方网站：http://www.gizwits.com/\n开发者论坛： http://club.gizwits.com/forum.php\n文档中心：http://docs.gizwits.com\n附录：GoKit 3原理图下载地址\nhttp://club.gizwits.com/thread-2889-1-1.html\n"},{"title":"Gokit3系列开发套件简介","url":"/zh-cn/deviceDev/Gokit3/Gokit3开发套件简介.html","content":"GoKit3介绍\nGokit3是GoKit产品系列的第三代，支持MCU、SoC模式切换等特性。目前支持的SoC方案模组有ESP8266、Hi3518E等模组，支持的MCU方案模组有ESP8266、汉风、庆科、宇音天下等模组。\nGoKit3的扩展板的模组接口采用双排母的设计，模组的单排针根据用法不同选择MCU(MCU模式接口)和SOC(SOC模式接口)两种接入方式，如下图所示扩展板接口图：\n\n\n 说明：\n\nSOC版本的模组应该插到扩展板的SOC模式接口上，并且使用时应与底板分离，否则模组程序无法正常启动。\n\nMCU版本的模组应该插到扩展板的MCU模式接口上，否则模组无法通过串口与底板正常启动。\n\n\nGoKit3套件\n1、GoKit3 套件说明\n\nGoKit3(S)是机智云（GizWits）推出的物联网智能硬件开发套件之一，目的是帮助传统硬件快速接入互联网。完成入网之后，数据可以在产品与云端、制造商与用户之间互联互通，实现智能互联。\n主要特点：\n\n分体式的设计方案，即底板(SoC方式应去掉)+功能板+模组。\n\n支持MCU和SoC两种连接方式。\n\nMCU方式支持多种无线WiFi模组并可随意更换。\n\n支持标准版(STM32底板)和创客版(Arduino底板)。\n\n基于机智云(GizWits)开发平台，高效、易用、安全。\n\n提供完整开源Demo工程和相关SDK集成指南。\n\n\n硬件资源：\n\n红外探测器；\n\n温湿度传感器；\n\nRGB三色LED；\n\n可调速微型直流电机；\n\n3个自定义功能按键\n\nOLED显示屏接口；\n\nArduino标准接口；\n\n内置USB2UART调试接口。\n\n其他预留接口\n\n\n创客版底板\n\n标准版底板\n\n2、SOC版与MCU版的区别\n\n\nMCU版\n是分体式的设计方案。WiFi模组只负责信息的接收与发送，它通过串口等方式与MCU进行通信，需要在MCU上进行协议解析与外设相关的开发。\n总结：这种方案的优点是不受限于WiFi SOC片上资源、应用扩展度高；缺点是需要适配通信协议且生产成本高。\nSOC版\n是整体式的设计方案。它将WiFi模组与外设驱动模块直接连接起来，直接在WiFi SOC上进行开发，省去了一层通讯过程。\n 总结：这种方案的优点是能降低开发难度、降低生产成本；缺点是受限于WiFi SOC片上资源，应用有限。\n3、GoKit3后期规划\n为了使开发者能够基于GoKit开发更多类型产品及应用，我们有更高性能的SoC、BLE等不同接入方式的模组正在研发中，请大家关注机智云网站动态。\n"},{"title":"GoKit-MCU程序详解","url":"/zh-cn/deviceDev/Gokit3Voice/GoKit-MCU-explanation.html","content":"查看旧版MCU_程序详解\n通信协议详解\n1 协议命令格式\n我们首先了解具体通讯协议的约定，可以看到协议格式为：\n\n说明：\n1) 包头(header)固定为0xFFFF；\n2) 长度(len)是指从cmd 开始到整个数据包结束所占用的字节数；\n3) 命令字（cmd）表示具体的命令含义，详见协议举例；\n4) 消息序号(sn)由发送方给出,接收方响应命令时需把消息序号返回给发送方；\n5) 标志位（flag），本产品填写默认0；\n6) payload（p0数据区），详细参见p0 数据区约定；\n7) 检验和(checksum)的计算方式为从len～DATA，按字节求和；\n8) 所有发送的命令都带有确认,如在200 毫秒内没有收到接收方的响应,发送方；应重发,最多重发3 次；\n9) 多于一个字节的整型数字以大端字节序编码（网络字节序）；\n10) 数字均用16 进制表示；\n2 “p0 数据区约定”解析\n“p0 数据区约定”有如下功能：\n1) 模块向MCU发送控制命令时携带p0 命令和命令标志位以及可写数据区\n2) MCU主动发送状态时或者回复模块的状态查询时携带p0命令和完整数据区\n3) 数据区会自动合并布尔和枚举变量，且有严格的顺序，不可任意改变\n怎么来理解这三个功能呢？将前序中准备的《XX-机智云接入串口通讯协议文档》如打开，我们会看到如下命令：\n1）WiFi模组请求设备信息；\n2）WiFi模组与设备MCU的心跳；\n3）设备MCU通知WiFi模组进入配置模式；\n4）设备MCU重置WiFi模组；\n5）WiFi模组向设备MCU通知WiFi模组工作状态的变化；\n6）WiFi模组请求重启MCU；\n7）非法消息通知；\n8）WiFi模组读取设备的当前状态；\n9）设备MCU向WiFi模组主动上报当前状态；\n10）WiFi模组控制设备；\n（之后非重点省略）\n“p0 数据区约定”主要作用是完成有效数据的上传(协议4.8、4.9)与下达(协议4.10)，其中上传协议的组成形式为：action(1B) + dev_status(11B) ; 下达协议的组成形式为：action(1B) + attr_flags(1B) + attr_vals(6B) ; 其中：\n\n\n\np0 数据区内容\n含义\n\n\n\n\naction\n表示”p0 命令”的传输方向，即：WiFi -> MCU 或 MCU ->Wifi\n\n\ndev_status\n表示上报的所有数据点的设备状态\n\n\nattr_flags\n表示有效的控制型数据点\n\n\nattr_vals\n表示有效控制数据点的数据值\n\n\n\n需要特别注意的是“p0 数据区约定”约定第三条，数据区会自动合并布尔和枚举变量，且有严格的顺序，不可任意改变。对应上面的“byte0”合并了“bool”和“enum”类型。\n至此“p0 数据区约定”的解析到此结束，之后我们还会分析MCU的程序实现。\n程序详解\n1 代码目录介绍\n1.1 一级目录说明\n\n\n\n\n文件夹\n说明\n\n\n\n\nGizwits\n协议相关目录\n\n\nHal\n外设驱动库\n\n\nLib\nSTM32驱动库\n\n\nProject\n工程管理文件\n\n\nUser\n代码入口文件目录\n\n\nUtils\n工具函数目录\n\n\nREADME.txt\nGoKit3(V)文档\n\n\n\n1.2 代码文件说明\n\n主要文件说明：\n\n\n\n文件\n说明\n\n\n\n\ngizwits_product.c\n该文件为产品相关处理函数，如 gizEventProcess(),平台相关硬件初始化，如串口、定时器等\n\n\ngizwits_product.h\n该文件为 gizwits_product.c 的头文件，存放产品相关宏定义如： HARDWARE_VERSION 、SOFTWARE_VERSION\n\n\ngizwits_protocol.c\n该文件为 SDK API 接口函数定义文件\n\n\ngizwits_protocol.h\n该文件为 gizwits_protocol.c 对应头文件，相关 API 的接口声明均在此文件中\n\n\n\n1.3 协议API介绍\n\n\n\nAPI 名称\nAPI 功能\n\n\n\n\nvoid gizwitsInit(void)\ngizwits协议初始化接口。用户调用该接口可以完成Gizwits协议相关初始化（包括协议相关定时器、串口的初始化）。\n\n\nvoid gizwitsSetMode(uint8_t mode)\n参数mode[in]：仅支持0,1和2,其他数据无效。参数为0，恢复模组出厂配置接口，调用会清空所有配置参数，恢复到出厂默认配置。参数为1时配置模组进入SoftAp模式；                参数为2配置模组进入AirLink模式。\n\n\nvoid gizwitsSetMode(uint8_t mode)\n参数mode[in]：仅支持0,1和2,其他数据无效。参数为0，恢复模组出厂配置接口，调用会清空所有配置参数，恢复到出厂默认配置。参数为1时配置模组进入SoftAp模式；                参数为2配置模组进入AirLink模式\n\n\nvoid gizwitsHandle(dataPoint_t *dataPoint)\n参数dataPoint[in]:用户设备数据点。该函数中完成了相应协议数据的处理即数据上报的等相关操作。\n\n\nint8_t gizwitsEventProcess (eventInfo_t info, uint8_t data, uint32_t len)\n参数info[in]:事件队列;参数data[in]:数据;参数len [in]:数据长度;用户数据处理函数,包括wifi状态更新事件和控制事件。a)Wifi状态更新事件:WIFI_开头的事件为wifi状态更新事件，data参数仅在WIFI_RSSI有效，data值为RSSI值,数据类型为uint8_t，取值范围0~7。b)控制事件:与数据点相关,本版本代码会打印相关事件信息，相关数值也一并打印输出，用户只需要做命令的具体执行即可。\n\n\n\n2 程序实现原理\n协议实现机制：\n协议解析后，将P0数据区的有效数据点生成对应的数据点事件，再按事件处理数据点。\n数据点转换事件的说明：\n根据协议P0数据区的attr_flags位判断出有效数据点，并将其转化成对应的数据点事件，然后在事件处理函数中(gizwitsEventProcess)完成事件的处理。\n3 程序初始化说明\n3.1 数据协议结构体的定义\n结构体dataPoint_t  ，代码位置: MCU_STM32xxx_source\\Gizwits\\gizwits_protocol.h\n\n说明：结构体dataPoint_t作用是存储用户区的设备状态信息，用户根据云端定义的数据点向其对应的数据位赋值后便不需关心数据的转换，其数据位对应“p0 数据区约定”中的“4.9 设备MCU向WiFi模组主动上报当前状态”中的：dev_status(11B) 位：\n\nattrFlags_t、attrVals_t ，代码位置: MCU_STM32xxx_source\\Gizwits\\gizwits_protocol.h\n\n结构体attrFlags_t、attrVals_t分别对应“p0 数据区约定”中的“4.10 WiFi模组控制设备”中的：attr_flags(1B) + attr_vals(6B)位：\n\n结构体devStatus_t，代码位置: MCU_STM32xxx_source\\Gizwits\\gizwits_protocol.h\n\n结构体devStatus_t对应“p0 数据区约定”中的“4.9 设备MCU向WiFi模组主动上报当前状态”中的：dev_status(11B) 位：\n\n特别说明：\nA. 数据结构说明\ndataPoint_t 为应用层数据结构，开发者需要了解并会使用（具体使用方式请查看：“2.7.1 只读型数据的获取”一节）。\nattrFlags_t、attrVals_t、devStatus_t为通信层数据结构，开发者需要结合通讯协议进行理解。\nB. 位段举例说明：\nuint8_t motor_switch:1; 是一种位段的使用方式。因为 uint8_t型数据占用 8bit（8位）的空间，协议中motor_switch占用字段bit0（第一位）所以uint8_t motor_switch:1表示使用1位的空间。\nuint8_t reserve:7; 因为程序中申请内存时的最小单位是byte(字节)，而这里我们是按bit(位，8bit = 1byte)进行了使用，故需补齐不足1byte的剩余bit(使用n bit后需补齐剩余的8-n bit)。\n注：位段不能跨字节操作，否则会造成数据读写错误。\n3.2 程序主函数\n位置：MCU_STM32xxx_source\\User\\main.c中main() 函数：\n\n相关说明：\n\n\n\n函数\n说明\n\n\n\n\nSystemInit()\n平台相关的硬件初始化（非API，不同的平台名称可能不同）\n\n\nuserInit()\n用户相关的初始化，如：外设驱动初始化、打印串口初始化（非API，不同的平台名称可能不同）\n\n\ngizwitsInit()\n平台、协议处理初始化，如：用户定时器初始化、协议通信串口初始化（协议API）\n\n\nuserHandle()\n用户事件回调函数，用户可以自定义事件在该函数中完成相应的协议处理。（非API，不同的平台名称可能不同）\n\n\ngizwitsHandle()\n协议相关的主函数（协议API）\n\n\n\n​\n3.3 用户程序初始化\n接下来看用户初始化相关代码（位置：gizwits_product.c中userInit() 函数）：\n\n这部分完成了RGB LED、电机、温湿度、红外传感器的硬件驱动初始化以及电机初始状态，对应的驱动程序实现都在 MCU_STM32xxx_source\\Hal 下。\n这里主要完成了配置入网的功能，作为开发者可以按照自己的需求来实现这部分代码。\n​下面是平台协议相关初始化 （位置：gizwits_protocol.c中gizwitsInit() 函数）：\n\n其中完成了定时器、串口的初始化（详情查看2.3.4、2.3.5两节），以及一个环形缓冲区的初始化。\n最后是一个通信处理模块结构体的变量的初始化，该变量为通信模块的全局变量：\n\n其定义的位置：Gizwits\\gizwits_protocol.c\n\n相关结构体内容，详情查看“2.3.1 数据协议结构体的定义”一节。\n3.4 定时器使用\n相关代码：\n定时器初始化，代码位置：MCU_STM32xxx_source\\Gizwits\\gizwits_product.c 中timerInit()函数\n\n注：这里我们定义了周期为1ms的定时器，其定时计算公式为：\n\n定时器中断函数，代码位置：MCU_STM32xxx_source\\Gizwits\\gizwits_product.c\n\n注：在该中断函数内我们完成了周期为1ms的定时累加计数。\n定时器使用说明：\n代码位置：MCU_STM32xxx_source\\Gizwits\\gizwits_product.h\n\na.这里我们使用定时器TIM3(#define TIMER TIM3)；\nb.TIM3的中断回调函数为UTIM3_IRQHandler() (#define TIMER_IRQ_FUN TIM3_IRQHandler);\n特别说明（复用TIMER2的方式，修改对应宏即可）：\n\n\n3.5 串口的使用\n相关代码：\n串口初始化，位置：MCU_STM32xxx_source\\Gizwits\\gizwits_product.c 中的uartInit()\n\n串口中断函数，位置：MCU_STM32xxx_source\\Gizwits\\gizwits_product.c\n\n串口使用说明：\n代码位置：MCU_STM32xxx_source\\Gizwits\\gizwits_product.h\n\na.这里我们使用USART2(#define UART USART2)，作为数据通信的串口;\nb.设置它的波特率为9600(#define UART_BAUDRATE 9600)\nc.USART2的串口中断回调函数为USART2_IRQHandler() (#define UART_IRQ_FUN USART2_IRQHandler)，在该中断函数内我们完成了串口数据的接收。\n特别说明（复用USART1的方式，修改对应宏即可）：\n\n4 配置模式说明\n设备需要进入配置模式才能进行联网，并与云端进行通信，在本示例工程中是通过按键触发进入相应的配置模式。\nWifi 配置接口说明：\n/**\n\n@brief WiFi配置接口\n​\n\n用户可以调用该接口使WiFi模组进入相应的配置模式或者复位模组\n\n​\n\n@param[in] mode 配置模式选择：0x0， 模组复位 ;0x01， SoftAp模式 ;0x02， AirLink模式\n\n​\n@return 错误命令码\n*/\n·int32_t gizwitsSetMode(uint8_t mode)\n\n程序中触发逻辑位置：MCU_STM32xxx_source\\User\\main.c\nA.进入Soft AP 模式：key2按键短按。\n\nB.进入AirLink 模式：key2按键长按。\n\nC.模组复位：key1按键长。\n\n5 协议处理函数的实现\n位置：MCU_STM32xxx_source\\Gizwits\\gizwits_protocol.c中gizwitsHandle() 函数：\n\n以下是该协议处理函数的详细介绍：\n● 首先是一些局部变量的初始化，比较重要的是：“protocolHead_t *recvHead = NULL;”它的作用是保存解析出来的协议包头。\n\n● 然后是协议的重发机制，它的作用是对发送后的协议数据进行超时判断，超时200ms进行重发，重发上限为三次：\n\n● 接下来程序会从环形缓冲区中抓取一包的数据，例如协议4.9：\n\n程序中对应如下：\n\n● 当我们获得到一整包的数据，就会进入下面的if判断逻辑，进行协议的解析。\n\n这里保存了接收到的协议包头：\n\n● 然后是各协议命令的处理流程：\n\n其中完成了《机智云 - 设备串口通讯协议》中相关的协议处理，如下：\n\n例如协议4.8：\n\n其“cmd”值 为“0x03”，对应程序中的的case为“CMD_ISSUED_P0”\n\n同理其他协议cmd值对应的宏定义的位置在Gizwits\\gizwits_protocol.h中:\n\n其中与P0协议有关的处理都在“gizProtocolIssuedProcess”中完成，详情请查看“2.6 控制型协议的实现”、“2.7 上报型协议的实现”两节。\n其余协议处理函数功能如下所示：\n\n\n\n函数\n说明\n\n\n\n\ngizProtocolGetDeviceInfo\n完成“协议4.1 WiFi模组请求设备信息”\n\n\ngizProtocolIssuedProcess\n完成“协议4.8 WiFi模组读取设备的当前状态”与“协议4.10 WiFi模组控制设备”。当Wifi模组接收来自云端或APP端下发的相关协议数据发送到MCU端，经过协议报文解析后将相关协议数据传入次函数，进行下一步的协议处理。\n\n\ngizProtocolCommonAck\n发送通用协议报文数据\n\n\ngizProtocolModuleStatus\n完成“协议4.5 WiFi模组向设备MCU通知WiFi模组工作状态的变化”的处理\n\n\ngizProtocolWaitAckCheck\n完成 “协议4.4 设备MCU重置WiFi模组 中 WiFi模组回复”后清除ACK协议报文\n\n\ngizProtocolReboot\n完成“协议4.4 设备MCU重置WiFi模组” 的相关操作\n\n\ngizProtocolErrorCmd\n完成“协议4.7 非法消息通知” 的处理\n\n\ngizwitsEventProcess()\n执行用户事件回调函数，用户可以自定义事件在该函数中完成相应的协议处理。\n\n\n\n● 协议判断完成后是一个状态机的判断，用来完成对应协议命令的处理：\n\n例如在P0协议处理函数（gizProtocolIssuedProcess）中，当我们完成了控制型协议的解析，会让 issuedFlag = 1，如下：\n\n然后会执行如下的处理，执行gizwitsEventProcess函数：\n\n在gizwitsEventProcess 中，完成了对应控制型事件的处理，其他状态的issuedFlag 同理。\n● 之后是一个数据上报判断机制，主要执行了gizCheckReport函数。\n\ngizCheckReport函数的作用用来判断当前与上次上报数据的一致性，如果符合上报条件便上报，上报条件要符合协议“4.9 设备MCU向WiFi模组主动上报当前状态”中的描述：\n\n符合上报之后会执行数据类型的转化函数gizDataPoints2ReportData（详情查看“2.8 机智云协议数据处理”一节），以及数据上报函数gizReportData。\n● 最后一段代码是一个数据定时上报机制：\n\n对应协议“4.9 设备MCU向WiFi模组主动上报当前状态”中的描述：\n\n至此我们完成了协议处理函数的详解。\n6 控制型协议的实现\n与控制型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\ngizProtocolIssuedProcess\n该函数被gizwitsHandle调用，接收来自云端或app端下发的相关协议数据\n\n\nACTION_CONTROL_DEVICE\n进行“控制型协议”的相关处理\n\n\ngizDataPoint2Event\n根据协议生成“控制型事件”，并完成相应数据类型的转换\n\n\ngizwitsEventProcess\n根据已生成的“控制型事件”进行相应事件处理（即调用相应的驱动函数）\n\n\n\n6.1 控制型事件处理\n相关代码位置:  \nMCU_STM32xxx_source\\Gizwits\\gizwits_product.c 中 gizwitsEventProcess() 函数：\n功能说明：\n完成写类型外设的事件处理。\n相应代码：\n\n6.2 可写型数据类型转换\n接收到来自云端的数据后，由于原始数据经过特殊处理，所以要在gizDataPoint2Event中进行相应的数据的转换。\n转换函数说明：\n\n\n\n函数\n说明\n\n\n\n\ngizDecompressionValue\n完成传输数据的压缩处理，详情查看“2.8.2 数据解压与压缩处理”一节。\n\n\ngizX2Y\n将用户区数据转化为传输数据，详情查看“2.8.1 数据点类型转换”一节。\n\n\n\n程序中对应：\n\n\n7 上报型协议的实现\n与上报型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\nuserHandle\n获取用户区的上报型数据\n\n\ngizCheckReport\n判断是否上报当前状态的数据\n\n\ngizDataPoints2ReportData\n完成用户区数据到上报型数据的转换\n\n\ngizReportData\n将转换后的上报数据通过串口发送给WiFi模块\n\n\n\n7.1 只读型数据的获取\n相关代码位置:  \nMCU_STM32xxx_source\\Gizwits\\gizwits_product.c 中 userHandle() 函数：\n使用说明：\n该函数中完成了用户区上报型数据的获取。用户只需将读到的数据赋值到用户区当前设备状态结构体即可：\n\n注：赋值完的数据是通过gizwitsHandle （详情请查看“2.5 协议处理函数的实现”一节中：数据上报判断机制gizCheckReport部分）上报云端的，开发者不需要关注变化上报和定时上报。\n7.2 上报状态判断\n为了让API接口更简化，处理更简单，机智云把更多的判断放到协议模块来处理，达到了开发者只要把状态更新到协议处理模块，不需要关心何时上报，由协议处理模块自动完处理的目的。\n相关代码:  \nMCU_STM32xxx_source\\Gizwits\\gizwits_protocol.c 中 checkReport() 函数：\n功能说明：\n根据协议判断是否上报当前状态的数据，判断逻辑如下：\n\n控制型数据发生状态变化，立刻主动上报当前状态\n用户触发或环境变化所产生的, 其发送的频率不能快于6秒每次\n\n协议中说明如下：(“4.9 设备MCU向WiFi模组主动上报当前状态”)\n\n以红灯开关为例：\n\n注：这部分用户可结合“2.5 协议处理函数的实现”一节中“数据上报判断机制”的内容来理解）。\n7.3 只读型数据类型转换\n获得到用户区的原始数据后，在传输到云端前要进行相应的数据转换，所以要在gizDataPoints2ReportData中进行相应的数据的转换。\n转换函数说明：\n\n\n\n函数\n说明\n\n\n\n\ngizCompressValue\n完成传输数据的压缩处理，详情查看“2.8.2 数据解压与压缩处理”一节。\n\n\n\n\n\n\ngizY2X      |   将用户区数据转化为传输数据，详情查看“2.8.1 数据点类型转换”一节。 |\n8 机智云协议数据处理\n8.1 数据点类型转换\n机智云为使设备功能定义更加简单直接，使用户输入的数值转换成设备能够识别的uint类型，这套算法的核心公式是：y=kx+m （y：显示值；x：传输值；k：分辨率；m：增量）\n​\n以《微信宠物屋》的温湿度传感器温度数据点为例：\n\n取值范围：-13（Ymin） ~ 187（Ymax），分辨率：1，增量：-13 ；\n其分辨率、偏移量作为宏定义定义在app\\Gizwits\\gizwits_product.h中：\n\n根据公式：y=kx＋m，k = 1 ; m = -13\n实际传输的值：x = (y - m) / k\n转换函数在程序中的说明：\nA.X2Y的转换：\n\nB. Y2X的转换：\n\n8.2 数据解压与压缩处理\n设备端与自云端的数据交互过程中，一些特殊类型（bool和enum类型）的数据点原始数据只有被特殊处理后才可被云端解析，所以设备端在接收云端数据时要进行数据的解压处理；在向云端发送数据时进行数据的压缩处理。\n机智云已封装出了相应的处理接口：\n\n\n\n处理名称\n接口名称\n\n\n\n\nbool和enum类型数据点数据解压\ngizDecompressionValue\n\n\nbool和enum类型数据点数据压缩\ngizCompressValue\n\n\n\n以《微信宠物屋》的RGB LED控制为例，云端定义如下：\n\n对应文档中数据存储格式如下：\n\n字节序与bit序对应代码中宏定义如下：\n\n对应的数据点在接收解压时处理如下(位于gizDataPoint2Event函数中)：位于\n\n对应的数据点在发送压缩时处理如下(位于gizDataPoints2ReportData函数中)：\n\n相关支持\n1) 如果您是开发者\nGoKit是面向智能硬件开发者限量免费开放，注册我们的论坛或关注我们的官方微信均可发起申请即可。\n开发者论坛： http://club.gizwits.com/forum.php\n文档中心：http://docs.gizwits.com\n2) 如果您是团体\nGizWits针对团体有很多支持计划，您可以和GizWtis联系，快速得到GoKit以及技术支持；\n网站地址：http://www.gizwits.com/about-us\n官方二维码：\n\n"},{"title":"GoKit3(V)二次开发--开发指南","url":"/zh-cn/deviceDev/Gokit3Voice/GoKit3V二次开发指南.html","content":"初见GoKit3(V)\n\n上图既是GoKit3(V)开发套件，此套件支持语音识别、语音控制传感器。使用Lark7618模组进行智能硬件产品开发时，有以下几点需要注意：\n1、Lark7618支持语音识别功能，且符合标准机智云接入协议。\n2、使用Lark7618模组进行产品开发时需采用MCU方式进行开发，即模组插到功能板模组接口的MCU侧。\n3、Lark7618需配合底板使用，支持Arduino版和STM32版。\n开发\nGoKit3(V)开发套件的开发是通过MCU获取传感器数据或控制传感器的，所以GoKit3(V)的开发工作分两部分，一个是MCU端的开发工作，另一个是将数据点与语音控制命令绑定。下面分别介绍下这两部分的开发工作。\n1 MCU端开发\nLark7618符合机智云标准接入协议，通过串口与MCU进行数据交互，交互协议为机智云模组串口通信协议，开发者可以使用MCU的方式进行智能硬件的开发。开发步骤如下：\n1、在机智云自助开发平台定义产品。并下载《XXX-机智云接入串口通信协议文档》。\n2、根据《XXX-机智云接入串口通信协议文档》实现MCU端程序。\n具体开发步骤和方法可以参考《10_GoKit3(V)二次开发--程序移植》、《11_GoKit3(V)二次开发--程序详解》，本节不再进行详细说明。\n2 命令绑定数据点\n2.1 术语\n\n\n\n术语\n说明\n\n\n\n\n机智云\n机智云是广州机智云物联网科技有限公司的旗下品牌，是一家智能硬件自助开发和物联网（IOT）云服务平台，面向企业／开发者提供智能硬件PaaS及SaaS云服务，业务覆盖智能家居、健康穿戴、智慧交通、智慧城市、商业及工业等应用。参考http://www.gizwits.com/\n\n\n机智云productkey\n机智云产品标识码，开发者通过机智云后台创建新产品后，自动生成的一个32位字符串。系统通过productkey将用户在宇音天下平台上注册的产品和机智云的产品进行绑定\n\n\n机智云产品json文件\n定义机智云产品数据点的json文件，系统需要下载机智云产品json文件才能解析出数据点从而实现命令和数据点的关联\n\n\n宇音天下平台\n由宇音天下公司开发为Lark7618模块提供升级资源管理的云服务平台\n\n\n命令\n不同的业务动作称之为命令，如开灯和关灯就是两个不同命令，一个命令可拥有多个词条\n\n\n词条\n命令的不同问法称之为词条，如开灯，可以有“开灯”、“把灯打开”、“灯打开”等多种语义相近的词条\n\n\n命令目录\n为了方便命令管理将命令按照树形目录结构管理。系统提供“内部控制”、“通用控制”、“家居控制”等预先定义的命令目录\n\n\n自定义命令\n非系统自带、由用户自行添加的命令\n\n\n产品注册\n向宇音天下后台提交购买模块的公司和开发产品等信息的过程称为产品注册\n\n\n产品登录\n用注册得到的账号登录宇音天下后台\n\n\n出厂烧录\n通过串口将出厂参数烧录到模块的过程\n\n\n生成升级资源\n将命令词条和MP3统一打包成供模块解析的资源bin文件\n\n\n上传升级资源\n将资源bin文件上传到宇音天下平台供模块下载更新\n\n\n加载上次资源\n将系统管理的词条、MP3和出厂参数设置恢复到最近上传升级资源时的编辑状态，可在此基础上做进一步修改\n\n\n数据点\n数据点是在机智云平台定义的和设备通讯所承载的单个数据，包含类型、长度和取值范围等属性\n\n\n\n2.2 资源管理工具业务流程\n1)  在宇音天下平台注册用户账号（开发阶段建议先注册测试账号），定义产品；\n2)  管理用户出厂参数，并将出厂参数烧录到模块中；\n3） 对于机智云开发者，在业务参数中设置机智云productkey,下载机智云产品json文件。\n4)  命令管理：将命令目录中选中的命令导入到命令管理窗口，管理命令以及对应词条；机智云用户还需设置命令对应的机智云产品数据点。\n5)  MP3管理：替换系统MP3,选取内置MP3,加载用户MP3； \n6)  生成升级资源，并将升级资源上传到宇音天下平台供模块下载；\n7)  重启模块（模块断电重新上电）或随机在9:00-11:00和15:00-17:00任意时间点，模块自动下载升级至更新资源； \n8)  测试模块命令词条和MP3资源下载是否正确； \n9)  更新资源重复步骤3，直到形成最终的产品资源；\n以上工作做完后，用户进入产品发布阶段，按照下列流程\n1)  重新在宇音天下平台注册正式账号（此时上次测试账号管理的词条和mp3资源会自动应用到新的正式账号中）； \n2)  将出厂参数依次烧录到所有模块中；\n3)  生成升级资源，并将升级资源上传到宇音天下平台供模块下载更新；\n4)  客户拿到产品模块后，通过APP设置模块WIFI上网参数；\n5)  模块自动升级产品资源； \n6)  用户根据需要在产品上线后升级新的产品资源；\n注：\n\n 产品发布请注册正式账号，不同产品需要注册不同的正式账号，开发阶段请不要申请正式账号进行产品测试，避免正式账号下存在过多的测试升级资源文件。\n\n2.3 资源管理工具使用方法\n2.3.1 程序启动\n第一次使用资源管理工具软件时鼠标右击\n，以管理员方式运行，软件检测到本机如果没有注册Mscomm32.ocx（串口通讯控件）会自动注册Mscomm32.ocx，如果360之类的安全软件提示程序正在修改注册表，请允许本次操作。\n\n\n2.3.2 程序主界面\n主界面包括词条更新、MP3更新和出厂参数配置和业务参数四个tab页，分别管理词条、MP3和出厂参数，业务参数。其中出厂参数通过串口烧录到所有模块中，词条和MP3、业务参数所做的改变需要打包成升级资源供模块下载更新。即出厂参数是在产品提交给用户前由厂家预先烧录好，而词条、MP3、业务参数是产品上线运行后由厂家进行修改后打包上传到宇音天下平台供模块下载更新升级。\n\n注：程序提供右键菜单，一些操作会放在右键菜单里，用户可在操作窗口中用鼠标右键弹出菜单执行相应功能。\n2.3.3 注册产品\n用户拿到模块后首先必须向宇音天下平台注册产品。注册时必须正确填写公司名称和产品名称（注册信息必须如实填写，宇音天下有权禁止非法的注册账号）、登录账号等信息。 \n\n注：在开发阶段请注册测试账号。\n7618模块支持的产品形态：\n1）模式2：集成机智云数据点功能可支持远程控制的应用模式；用户和机智云合作，在机智云平台定义产品，通过机智云平台实现设备远程控制，wifi芯片采用宇音天下公司7618芯片，集成wifi上网和语音控制功能。\n\n注：对于机智云用户，如果想实现语音控制设备，请选择模式2。\n2.3.4 产品登录\n用产品注册账号登录宇音天下平台。在进行【出厂烧录】、【生成升级资源】、【上传升级资源】时如果未登录宇音天下平台系统会提示登录。\n\n2.3.5 出厂参数配置\n用户注册产品并登录后，可设置出厂参数，可在出厂时设置的参数如下图所示：\n\nwifi用户名和密码在公司内部产品测试阶段可输入公司的wifi账号信息，保证模块可以正常上网。\n设置完成后点击【保存】保存配置参数。\n2.3.6 出厂烧录\n将配置的出厂参数和注册的产品信息烧录到模块中。\n\n\n请检查以上产品信息是否正确\n\n请检查出厂参数配置是否正确\n\n请选择串口号\n\n请将所有模块依次连接串口，执行“开始烧录”\n\n将依次把产品信息和出厂参数配置烧录到模块中\n\n\n注：不要开机后立刻执行出厂烧录，约等待20秒左右时间再进行出厂烧录。\n2.3.7 业务参数设置\n1) 设置是否允许固件升级\n,如果不允许7618芯片固件升级请选择否。\n注：修改是否允许固件升级参数项设置后，必须点击上传升级资源，芯片下载正常工作后才起作用。\n用户如果验证Lark7618固件运行稳定，无需宇音天下后续对固件进行功能升级则可选择不允许固件升级。\n2) 设置机智云productkey\n针对用户在机智云平台定义产品形态的模式2，输入productkey，点击保存。\n\n保存机智云的productkey后，点击下载产品json文件，就可将在命令管理中将命令与机智云数据点关联起来，从而实现语音控制设备。\n机智云gokit开发套件对应的产品智能宠物屋的productkey是：6f3074fe43894547a4f1314bd7e3ae0b\n了解机智云更多详情，请进入官方网站：http://www.gizwits.com/\n注：如果用户在注册产品时产品形态选择模式1，则在业务参数设置界面中不会出现与机智云productkey相关的设置项。\n2.3.8 命令和词条管理\n按下列步骤执行：\n1) 初次执行时选取命令目录中对应的命令，导入到命令窗口中。\n\n目录展开/收缩：展开和收缩命令目录\n命令展开/收缩：展开和收缩命令\n选择所有/全部取消：选中所有命令或取消所有选中。\n在命令目录中根据产品应用场合选择合适的命令，然后点击【导入】，导入到命令管理窗口，用户可在命令管理列表中对命令进行编辑管理。\n2)命令管理\n命令管理界面如下图所示：\n\n命令管理功能有：\n添加用户自定义命令\n删除命令\n编辑命令回答\n词条管理功能有：\n添加词条\n删除词条\n编辑词条\n功能中【选择所有/全部取消】是给选取框设置或取消选中标志，只有选取框打勾的数据才会被打包到资源中。\n【删除】和【编辑】功能需要通过鼠标点击数据条目（不是点击选取框）系统将条目显示为蓝底白字后操作才能继续进行，可以通过shift、ctrl键配合鼠标进行成片多选或隔行多选。\n2.3.9 MP3更新\nMP3资源管理界面如下图所示：\n\n其中系统MP3可被替换，系统MP3全部打到资源包中。\n内置MP3可以通过选取框选中否决定是否打包到资源文件中。\n用户可通过专门文件夹整理自己需要的MP3，通过【载入用户MP3】选取用户MP3所在文件夹系统自动将该文件夹下所有MP3全部加载到列表中，用户可通过选取框选中否决定是否将用户MP3打包到资源中。\n可删除用户MP3（不是点击选取框，系统将条目显示为蓝底白字后操作才能删除本MP3）。\n注意：\n1.编辑回答的文本框文本不能超过56个汉字或字母。\n2.添加词条的的文本框不能超过20个汉字或字母。\n3.添加的MP3文件，文件名不能超过50个汉字或字母(避免文件名过长)，内置资源不能超过2M。\n2.3.10 数据点管理\n此功能只在注册时选择模式2才生效。\n1) 设置数据点\n选择命令，弹出右键菜单，选择数据点，设置数据点值，最后点击确定保存。\n\n\n\n2) 删除数据点\n选择数据点，右键菜单执行【删除数据点】，可清除为命令设置的数据点。\n3) 删除所有数据点\n在命令管理窗口中弹出右键菜单，执行【清除所有数据点】，系统将删除所有数据点的定义。\n2.3.11 生成升级资源\n系统将选择的命令、词条、MP3资源统一打包为升级资源，供模块下载更新。\n升级资源前必须登录宇音天下平台，确认本次升级的资源与相对应的产品配套（命令、词条、MP3等资源）。\n资源最大不能超过2M，请合理安排资源。\n只有选取框被打勾的内容才打包到资源中，如下图所示：\n\n2.3.12 上传升级资源\n生成升级资源后可上传升级资源到宇音天下云平台供模块下载。升级的资源关联到指定的产品，只要模块烧录的产品信息和该资源对应的产品信息一致，模块就会自动下载升级资源。\n2.3.13 加载上次资源\n将系统管理的词条、MP3和出厂参数设置恢复到最近上传升级资源时的编辑状态，可在此基础上做进一步修改。\n每次上传升级资源时系统将升级资源在本地做备份，加载上次资源系统将放弃本地所做的修改，将词条、MP3和出厂参数恢复到上次上传时的状态。\n注：加载上次资源应在同一电脑上进行操作，如果用户更换电脑应将上一次操作软件时所在的整个文件夹复制到新的电脑上。\n2.3.14 正式产品发布\n在用测试账号对模块进行烧录、资源升级测试后，用户已经形成了稳定的命令、词条和MP3资源被保存到资源管理工具数据库中。\n按照下列步骤可将测试账号测试通过的词条、MP3资源配置应用到正式账号中，从而进行正式产品发布：\na) 以测试账号登录后，在界面中执行注册，向宇音天下注册正式账号，账号类型选择\n，如实填写公司、产品信息。注册正式账号后，上次针对测试账号所做的命令、词条和MP3资源自动绑定到正式账号中，即本地数据自动与新账号关联。注：必须先以测试账号登录后再注册正式账号才能将测试账号最后形成的稳定的资源配置自动迁移到正式账号上，否则用户还需在正式账号重新进行资源配置。\nb)将产品信息依次烧录到所有模块中。\nc)重新生成资源、上传升级资源（注册了新的正式账号需要重新生成和上传资源到宇音天下平台供模块下载）\n3 机智云gokit开发套件语音控制功能演示\n本章节适宜于用户购买了机智云与宇音天下合作提供的gokit套件（采用北京宇音天下开发的Lark7618模块，集成wifi通讯、语音识别和语音合成功能），可通过语音控制设备。\n按照下列操作步骤实现通过语音控制gokit开发套件的电机转动、灯光控制。\n1) 注册账号时产品形态选择模式2\n2) 在命令窗口中选择转动【转动控制】、【灯光】，然后导入\n\n在业务参数中设置机智云宠物屋的productkey,输入：6f3074fe43894547a4f1314bd7e3ae0b，下载产品定义json文件。\n\n3) 设置电机命令对应的数据点\n\n\n说明：按照机智云宠物屋数据点定义，电机转速是-5~5之间整数值，5为正转最大转速，-5为反转最大转速，0为停止转动。\n依次设置电机相关的其它数据点。\n4) 设置灯控数据点\n设置【开灯】命令的数据点\n\n\n【关灯】则选择数据点“开启/关闭红色灯(LED_OnOff)”,设置值选择“否(false)”。\n【红色灯光】则选择数据点“设置LED红色值（LED_R）”,设置值254。\n【绿色灯光】则选择数据点“设置LED红色值（LED_G）”,设置值254。\n【蓝色灯光】则选择数据点“设置LED红色值（LED_B）”,设置值254。\n【黄色灯光】则选择数据点“设置LED组合颜色（LED_COLOR）”,设置值黄色。\n【紫色灯光】则选择数据点“设置LED组合颜色（LED_COLOR）”,设置值紫色。\n【粉色灯光】则选择数据点“设置LED组合颜色（LED_COLOR）”,设置值粉色。\n5)出厂参数烧录\n6)上传升级资源\n7)重启gokit套件，下载升级资源\n8)用设置的唤醒名唤醒Lark7618模块，测试下列命令\n开灯，关灯，红色灯光，蓝色灯光，高速转动，低速转动等，观察gokit套件设备是否做出响应。\n4 使用注意事项\n1）串口通讯采用Mscomm32.ocx控件，系统会自动注册该控件，如果进入烧录系统弹出程序运行错误窗口，说明Msconn32.ocx未能自动注册成功（一般是在win7及其以上版本机器），请改用管理员身份执行程序。\n\n还不能烧录，则执行手工注册，按下列步骤执行：\n■ 先将软件所在目录下的Mscomm32.ocx拷贝到c:\\windows\\system32。\n■ 以管理员方式运行cmd.exe进入命令行窗口\n点桌面左下角开始-所有程序-附件-右键命令提示符-选择以管理员身份运行（如图1），打开DOS界面后在命令行窗口执行 regsvr32.exe  c:\\windows\\system32\\Mscomm32.ocx\n\n\n2）软件可执行程序为:Lark7618ResTool.exe,请勿改为中文文件名。\n3）如果登录是新注册用户，必须配置好出厂参数，执行【出厂烧录】程序，才能正常生成、更新！\n4）请正确填写注册信息，保存好账号密码，系统暂未提供修改注册信息功能，如需重置请和宇音天下联系。\n5）只有在注册时产品形态选择模式2，即支持机智云才可实现命令与机智云数据点关联，了解机智云请参考http://www.gizwits.com。\n6）本工具建议只在一台计算机上使用，应避免多人在不同计算机上用同一账号使用本工具。如果要更换计算机，请将本软件整个文件夹全部复制到新的计算机，否则在新的计算机上使用工具将不会拥有其他计算机编辑的词条。\n"},{"title":"GoKit3(V)使用说明书","url":"/zh-cn/deviceDev/Gokit3Voice/GoKit3V使用说明书.html","content":"初见GoKit3(V)\n\n首先您需要弄清楚的有这些：\n1.  初步了解GoKit3(V)，没有看的同学请查看《Gokit3系列开发套件简介》。\n2.  了解按钮的功能，定义如下表：\n\n\n\n\n\n\n\n\n\n\n按键\n触发\n功能\n\n\nKey1\n短按\n自定义\n\n\nKey1\n长按(3s)\n复位WiFi模组\n\n\nKey2\n短按\n进入Soft AP模式\n\n\nKey2\n长按(3s)\n进入AirLink模式\n\n\nKey3\n自定义\n自定义\n\n\n\n注意：\n功能板支持MCU/SoC两种方式，GoKit3(V)使用MCU的方式连接(天线朝向电机一方)，配合底板MCU进行产品开发。\n下载官方应用\n1.  下载GoKit的官方APP （分IOS、安卓两个版本）\n方式一：用微信扫说明书上的二维码（首选推荐方式）\n首先，使用手机上具有“扫一扫”功能的APP（如微信或扫一扫），扫描说明书上的二维码。\n\n注：说明书上含有两个二维码，印刷在说明书上的二维码才是GoKit对应的APP的下载链接，如上图。\n接下来，点击右上角选择在浏览器中打开，并点击安装。\n \n最后，待APP下载成功后点击安装IOE Demo，等待安装成功后点击完成。\n \n方式二：在机智云下载中心中下载\n 在手机浏览器中登录机智云下载中心：\n http://site.gizwits.com/zh-cn/developer/resource/demo_app?protoc=WIFI\n根据您手机系统选择对应的下载，将鼠标放到下图二维码位置，即可放大二维码。打开手机的“扫一扫”功能app软件，对准二维码进行扫描，按照提示进行下载并安装即可。（安装过程与方式一相同）\n\n安装成功后可以在桌面看到IOE Demo的图标。\n\n将GoKit和微信账号绑定：\n\n打开微信软件，使用“扫一扫”功能扫描说明书上的二维码，关注“机智云智能宠物屋”公众号。\n\n\n注：贴在说明书上的二维码为绑定微信用的二维码，不要与上面的APP二维码弄混，效果如上图。\n连接到路由器\n现在您已经拿到了GoKit，已经下载了APP，那么接下来的一步，就是将您的GoKit连接到您的路由器上去，如何做到呢？\n3.1 配置入网\n给GoKit供电\n注意：确认手机已连接可用的路由器，可以上外网，最重要的一点：你要知道自己登陆的WiFi密码哦（后面马上要用到）。\n打开机智云APP (IOE Demo)，如果您的APP未使用过，您的APP应该不会显示任何设备（如下图）\n\n点击此界面的右上菜单(1)，点击添加设备(2)（如下图），模组类型选择“宇音天下(3)”，然后输入您的路由器SSID(4)、密码(5)。填完后点击下一步(6).\n \n按照下图(7)所示配置开发套件进入配置模式，点击“已完成上述操作(8)”后，点击“下一步(9)”,您可以听到较高频率的声音.\n\n\n当听到喇叭提示“接收成功正在联网”后表示配置成功，待语音提示“联网成功”就可以是进行控制了。\n注：在此期间，您可以看到GoKit的绿灯熄灭，说明GoKit 3已连接到您的路由器。\n让GoKit亮起来\n使用唤醒词“玛莉玛莉”唤醒GoKit\n对着GoKit说“玛莉玛莉”，听到喇叭“嘀”的提醒音说明GoKit已经被唤醒，可以接收控制指令了。\n语音控制\nGoKit唤醒之后，对她说“打开红色灯光”，GoKit就会将RGB灯点亮，并显示为红色。\n其他控制传感器同理。\n注意：\n除语音控制外，还支持APP控制，使用方法与其他模组一样。\n即使GoKit不在身边依然近在咫尺\nGoKit天生支持远程连接，您可以将您的手机切换成2G、3G、4G，然后打开软件，您的GoKit依然存在，点击设备后就如同本地操作一样，唯一不同的就是目前的连接方式是远程连接。\n总结\n若想了解整个机智云的开发框架请查看开发者文档中心：\n\nhttp://docs.gizwits.com\n\n更多的开发教程请查看社区GoKit开源套件板块\n\nGoKit开源套件\n\n"},{"title":"GoKit3(V)二次开发-程序详解（旧）","url":"/zh-cn/deviceDev/Gokit3Voice/GoKit3V程序详解.html","content":"2017年9月25日起已使用新版MCU代码生成，查看新版自动生成代码程序详解\n通信协议详解\n1 协议命令格式\n我们首先了解具体通讯协议的约定，可以看到协议格式为：\n\n说明：\n1) 包头(header)固定为0xFFFF；\n2) 长度(len)是指从cmd 开始到整个数据包结束所占用的字节数；\n3) 命令字（cmd）表示具体的命令含义，详见协议举例；\n4) 消息序号(sn)由发送方给出,接收方响应命令时需把消息序号返回给发送方；\n5) 标志位（flag），本产品填写默认0；\n6) payload（p0数据区），详细参见p0 数据区约定；\n7) 检验和(checksum)的计算方式为从len～DATA，按字节求和；\n8) 所有发送的命令都带有确认,如在200 毫秒内没有收到接收方的响应,发送方；应重发,最多重发3 次；\n9) 多于一个字节的整型数字以大端字节序编码（网络字节序）；\n10) 数字均用16 进制表示；\n2 “p0 数据区约定”解析\n“p0 数据区约定”有如下功能：\n1) 模块向MCU发送控制命令时携带p0 命令和命令标志位以及可写数据区\n2) MCU主动发送状态时或者回复模块的状态查询时携带p0命令和完整数据区\n3) 数据区会自动合并布尔和枚举变量，且有严格的顺序，不可任意改变\n怎么来理解这三个功能呢？将前序中准备的《XX-机智云接入串口通讯协议文档》如打开，我们会看到如下命令：\n1）WiFi模组请求设备信息；\n2）WiFi模组与设备MCU的心跳；\n3）设备MCU通知WiFi模组进入配置模式；\n4）设备MCU重置WiFi模组；\n5）WiFi模组向设备MCU通知WiFi模组工作状态的变化；\n6）WiFi模组请求重启MCU；\n7）非法消息通知；\n8）WiFi模组读取设备的当前状态；\n9）设备MCU向WiFi模组主动上报当前状态；\n10）WiFi模组控制设备；\n（之后非重点省略）\n“p0 数据区约定”主要作用是完成有效数据的上传(协议4.8、4.9)与下达(协议4.10)，其中上传协议的组成形式为：action(1B) + dev_status(11B) ; 下达协议的组成形式为：action(1B) + attr_flags(1B) + attr_vals(6B) ; 其中：\n\n\n\np0 数据区内容\n含义\n\n\n\n\naction\n表示”p0 命令”的传输方向，即：WiFi -> MCU 或 MCU ->Wifi\n\n\ndev_status\n表示上报的所有数据点的设备状态\n\n\nattr_flags\n表示有效的控制型数据点\n\n\nattr_vals\n表示有效控制数据点的数据值\n\n\n\n需要特别注意的是“p0 数据区约定”约定第三条，数据区会自动合并布尔和枚举变量，且有严格的顺序，不可任意改变。对应上面的“byte0”合并了“bool”和“enum”类型。\n至此“p0 数据区约定”的解析到此结束，之后我们还会分析MCU的程序实现。\n程序详解\n1 代码目录介绍\n1.1 一级目录说明\n\n\n\n\n文件夹\n说明\n\n\n\n\nGizwits\n协议相关目录\n\n\nHal\n外设驱动库\n\n\nLib\nSTM32驱动库\n\n\nProject\n工程管理文件\n\n\nUser\n代码入口文件目录\n\n\nREADME.txt\nGoKit3(V)文档\n\n\n\n1.2 代码文件说明\n\n主要文件说明：\n\n\n\n文件\n说明\n\n\n\n\ngizwits_product.c\n该文件为产品相关处理函数，如 gizEventProcess(),平台相关硬件初始化，如串口、定时器等\n\n\ngizwits_product.h\n该文件为 gizwits_product.c 的头文件，存放产品相关宏定义如： HARDWARE_VERSION 、SOFTWARE_VERSION\n\n\ngizwits_protocol.c\n该文件为 SDK API 接口函数定义文件\n\n\ngizwits_protocol.h\n该文件为 gizwits_protocol.c 对应头文件，相关 API 的接口声明均在此文件中\n\n\n\n1.3 协议API介绍\n\n\n\nAPI 名称\nAPI 功能\n\n\n\n\nvoid gizwitsInit(void)\ngizwits协议初始化接口。用户调用该接口可以完成Gizwits协议相关初始化（包括协议相关定时器、串口的初始化）。\n\n\nvoid gizwitsSetMode(uint8_t mode)\n参数mode[in]：仅支持0,1和2,其他数据无效。参数为0，恢复模组出厂配置接口，调用会清空所有配置参数，恢复到出厂默认配置。参数为1时配置模组进入SoftAp模式；                参数为2配置模组进入AirLink模式。\n\n\nvoid gizwitsSetMode(uint8_t mode)\n参数mode[in]：仅支持0,1和2,其他数据无效。参数为0，恢复模组出厂配置接口，调用会清空所有配置参数，恢复到出厂默认配置。参数为1时配置模组进入SoftAp模式；                参数为2配置模组进入AirLink模式\n\n\nvoid gizwitsHandle(dataPoint_t *dataPoint)\n参数dataPoint[in]:用户设备数据点。该函数中完成了相应协议数据的处理即数据上报的等相关操作。\n\n\nint8_t gizwitsEventProcess (eventInfo_t info, uint8_t data, uint32_t len)\n参数info[in]:事件队列;参数data[in]:数据;参数len [in]:数据长度;用户数据处理函数,包括wifi状态更新事件和控制事件。a)Wifi状态更新事件:WIFI_开头的事件为wifi状态更新事件，data参数仅在WIFI_RSSI有效，data值为RSSI值,数据类型为uint8_t，取值范围0~7。b)控制事件:与数据点相关,本版本代码会打印相关事件信息，相关数值也一并打印输出，用户只需要做命令的具体执行即可。\n\n\n\n2 程序实现原理\n协议实现机制：\n协议解析后，将P0数据区的有效数据点生成对应的数据点事件，再按事件处理数据点。\n数据点转换事件的说明：\n根据协议P0数据区的attr_flags位判断出有效数据点，并将其转化成对应的数据点事件，然后在事件处理函数中(gizwitsEventProcess)完成事件的处理。\n3 程序初始化说明\n3.1 数据协议结构体的定义\n结构体dataPoint_t  ，代码位置: gokit_mcu_stm32_xxx\\Gizwits\\gizwits_protocol.h\n\n说明：结构体dataPoint_t作用是存储用户区的设备状态信息，用户根据云端定义的数据点向其对应的数据位赋值后便不需关心数据的转换，其数据位对应“p0 数据区约定”中的“4.9 设备MCU向WiFi模组主动上报当前状态”中的：dev_status(11B) 位：\n\nattrFlags_t、attrVals_t ，代码位置: gokit_mcu_stm32_xxx\\Gizwits\\gizwits_protocol.h\n\n结构体attrFlags_t、attrVals_t分别对应“p0 数据区约定”中的“4.10 WiFi模组控制设备”中的：attr_flags(1B) + attr_vals(6B)位：\n\n结构体devStatus_t，代码位置: gokit_mcu_stm32_xxx\\Gizwits\\gizwits_protocol.h\n\n结构体devStatus_t对应“p0 数据区约定”中的“4.9 设备MCU向WiFi模组主动上报当前状态”中的：dev_status(11B) 位：\n\n特别说明：\nA. 数据结构说明\ndataPoint_t 为应用层数据结构，开发者需要了解并会使用（具体使用方式请查看：“2.7.1 只读型数据的获取”一节）。\nattrFlags_t、attrVals_t、devStatus_t为通信层数据结构，开发者需要结合通讯协议进行理解。\nB. 位段举例说明：\nuint8_t motor_switch:1; 是一种位段的使用方式。因为 uint8_t型数据占用 8bit（8位）的空间，协议中motor_switch占用字段bit0（第一位）所以uint8_t motor_switch:1表示使用1位的空间。\nuint8_t reserve:7; 因为程序中申请内存时的最小单位是byte(字节)，而这里我们是按bit(位，8bit = 1byte)进行了使用，故需补齐不足1byte的剩余bit(使用n bit后需补齐剩余的8-n bit)。\n注：位段不能跨字节操作，否则会造成数据读写错误。\n3.2 程序主函数\n位置：gokit_mcu_stm32_xxx\\User\\main.c中main() 函数：\n\n相关说明：\n\n\n\n函数\n说明\n\n\n\n\nSystemInit()\n平台相关的硬件初始化（非API，不同的平台名称可能不同）\n\n\nuserInit()\n用户相关的初始化，如：外设驱动初始化、打印串口初始化（非API，不同的平台名称可能不同）\n\n\ngizwitsInit()\n平台、协议处理初始化，如：用户定时器初始化、协议通信串口初始化（协议API）\n\n\nuserHandle()\n用户事件回调函数，用户可以自定义事件在该函数中完成相应的协议处理。（非API，不同的平台名称可能不同）\n\n\ngizwitsHandle()\n协议相关的主函数（协议API）\n\n\n\n3.3 用户程序初始化\n接下来看用户初始化相关代码（位置：main.c中userInit() 函数）：\n\n这部分完成了RGB LED、电机、温湿度、红外传感器的硬件驱动初始化以及电机初始状态，对应的驱动程序实现都在 gokit_mcu_stm32_xxx\\Hal 下。\n这里主要完成了配置入网的功能，作为开发者可以按照自己的需求来实现这部分代码。\n下面是平台协议相关初始化 （位置：main.c中gizwitsInit() 函数）：\n\n其中完成了定时器、串口的初始化（详情查看2.3.4、2.3.5两节），以及一个环形缓冲区的初始化。\n最后是一个通信处理模块结构体的变量的初始化，该变量为通信模块的全局变量：\n\n其定义的位置：user\\user_mian.c\n\n相关结构体内容，详情查看“2.3.1 数据协议结构体的定义”一节。\n3.4 定时器使用\n相关代码：\n定时器初始化，代码位置：gokit_mcu_stm32_xxx\\Gizwits\\gizwits_product.c 中timerInit()函数\n\n注：这里我们定义了周期为1ms的定时器，其定时计算公式为：\n\n定时器中断函数，代码位置：gokit_mcu_stm32_xxx\\Gizwits\\gizwits_product.c\n\n注：在该中断函数内我们完成了周期为1ms的定时累加计数。\n定时器使用说明：\n代码位置：gokit_mcu_stm32_xxx\\Gizwits\\gizwits_product.h\n\na.这里我们使用定时器TIM3(#define TIMER TIM3)；\nb.TIM3的中断回调函数为UTIM3_IRQHandler() (#define TIMER_IRQ_FUN TIM3_IRQHandler);\n特别说明（复用TIMER2的方式，修改对应宏即可）：\n\n\n3.5 串口的使用\n相关代码：\n串口初始化，位置：gokit_mcu_stm32_xxx\\Gizwits\\gizwits_product.c 中的uartInit()\n\n串口中断函数，位置：gokit_mcu_stm32_xxx\\Gizwits\\gizwits_product.c\n\n串口使用说明：\n代码位置：gokit_mcu_stm32_xxx\\Gizwits\\gizwits_product.h\n\na.这里我们使用USART2(#define UART USART2)，作为数据通信的串口;\nb.设置它的波特率为9600(#define UART_BAUDRATE 9600)\nc.USART2的串口中断回调函数为USART2_IRQHandler() (#define UART_IRQ_FUN USART2_IRQHandler)，在该中断函数内我们完成了串口数据的接收。\n特别说明（复用USART1的方式，修改对应宏即可）：\n\n4 配置模式说明\n设备需要进入配置模式才能进行联网，并与云端进行通信，在本示例工程中是通过按键触发进入相应的配置模式。\nWifi 配置接口说明：\n/**\n\n@brief WiFi配置接口\n*\n\n用户可以调用该接口使WiFi模组进入相应的配置模式或者复位模组\n*\n\n@param[in] mode 配置模式选择：0x0， 模组复位 ;0x01， SoftAp模式 ;0x02， AirLink模式\n*\n\n@return 错误命令码\n*/\n·int32_t gizwitsSetMode(uint8_t mode)\n\n程序中触发逻辑位置：gokit_mcu_stm32_xxx\\User\\main.c\nA.进入Soft AP 模式：key2按键短按。\n\nB.进入AirLink 模式：key2按键长按。\n\nC.模组复位：key1按键长。\n\n5 协议处理函数的实现\n位置：gokit_mcu_stm32_xxx\\Gizwits\\gizwits_protocol.c中gizwitsHandle() 函数：\n\n以下是该协议处理函数的详细介绍：\n● 首先是一些局部变量的初始化，比较重要的是：“protocolHead_t *recvHead = NULL;”它的作用是保存解析出来的协议包头。\n\n● 然后是协议的重发机制，它的作用是对发送后的协议数据进行超时判断，超时200ms进行重发，重发上限为三次：\n\n● 接下来程序会从环形缓冲区中抓取一包的数据，例如协议4.9：\n\n程序中对应如下：\n\n● 当我们获得到一整包的数据，就会进入下面的if判断逻辑，进行协议的解析。\n\n这里保存了接收到的协议包头：\n\n● 然后是各协议命令的处理流程：\n\n其中完成了《机智云 - 设备串口通讯协议》中相关的协议处理，如下：\n\n例如协议4.8：\n\n其“cmd”值 为“0x03”，对应程序中的的case为“CMD_ISSUED_P0”\n\n同理其他协议cmd值对应的宏定义的位置在Gizwits\\gizwits_protocol.h中:\n\n其中与P0协议有关的处理都在“gizProtocolIssuedProcess”中完成，详情请查看“2.6 控制型协议的实现”、“2.7 上报型协议的实现”两节。\n其余协议处理函数功能如下所示：\n\n\n\n函数\n说明\n\n\n\n\ngizProtocolGetDeviceInfo\n完成“协议4.1 WiFi模组请求设备信息”\n\n\ngizProtocolIssuedProcess\n完成“协议4.8 WiFi模组读取设备的当前状态”与“协议4.10 WiFi模组控制设备”。当Wifi模组接收来自云端或APP端下发的相关协议数据发送到MCU端，经过协议报文解析后将相关协议数据传入次函数，进行下一步的协议处理。\n\n\ngizProtocolCommonAck\n发送通用协议报文数据\n\n\ngizProtocolModuleStatus\n完成“协议4.5 WiFi模组向设备MCU通知WiFi模组工作状态的变化”的处理\n\n\ngizProtocolWaitAckCheck\n完成 “协议4.4 设备MCU重置WiFi模组 中 WiFi模组回复”后清除ACK协议报文\n\n\ngizProtocolReboot\n完成“协议4.4 设备MCU重置WiFi模组” 的相关操作\n\n\ngizProtocolErrorCmd\n完成“协议4.7 非法消息通知” 的处理\n\n\ngizwitsEventProcess()\n执行用户事件回调函数，用户可以自定义事件在该函数中完成相应的协议处理。\n\n\n\n● 协议判断完成后是一个状态机的判断，用来完成对应协议命令的处理：\n\n例如在P0协议处理函数（gizProtocolIssuedProcess）中，当我们完成了控制型协议的解析，会让 issuedFlag = 1，如下：\n\n然后会执行如下的处理，执行gizwitsEventProcess函数：\n\n在gizwitsEventProcess 中，完成了对应控制型事件的处理，其他状态的issuedFlag 同理。\n● 之后是一个数据上报判断机制，主要执行了gizCheckReport函数。\n\ngizCheckReport函数的作用用来判断当前与上次上报数据的一致性，如果符合上报条件便上报，上报条件要符合协议“4.9 设备MCU向WiFi模组主动上报当前状态”中的描述：\n\n符合上报之后会执行数据类型的转化函数gizDataPoints2ReportData（详情查看“2.8 机智云协议数据处理”一节），以及数据上报函数gizReportData。\n● 最后一段代码是一个数据定时上报机制：\n\n对应协议“4.9 设备MCU向WiFi模组主动上报当前状态”中的描述：\n\n至此我们完成了协议处理函数的详解。\n6 控制型协议的实现\n与控制型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\ngizProtocolIssuedProcess\n该函数被gizwitsHandle调用，接收来自云端或app端下发的相关协议数据\n\n\nACTION_CONTROL_DEVICE\n进行“控制型协议”的相关处理\n\n\ngizDataPoint2Event\n根据协议生成“控制型事件”，并完成相应数据类型的转换\n\n\ngizwitsEventProcess\n根据已生成的“控制型事件”进行相应事件处理（即调用相应的驱动函数）\n\n\n\n6.1 控制型事件处理\n相关代码位置:  \ngokit_mcu_stm32_xxx\\Gizwits\\gizwits_product.c 中 gizwitsEventProcess() 函数：\n功能说明：\n完成写类型外设的事件处理。\n相应代码：\n\n6.2 可写型数据类型转换\n接收到来自云端的数据后，由于原始数据经过特殊处理，所以要在gizDataPoint2Event中进行相应的数据的转换。\n转换函数说明：\n\n\n\n函数\n说明\n\n\n\n\ngizDecompressionValue\n完成传输数据的压缩处理，详情查看“2.8.2 数据解压与压缩处理”一节。\n\n\ngizX2Y\n将用户区数据转化为传输数据，详情查看“2.8.1 数据点类型转换”一节。\n\n\n\n程序中对应：\n\n\n7 上报型协议的实现\n与上报型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\nuserHandle\n获取用户区的上报型数据\n\n\ngizCheckReport\n判断是否上报当前状态的数据\n\n\ngizDataPoints2ReportData\n完成用户区数据到上报型数据的转换\n\n\ngizReportData\n将转换后的上报数据通过串口发送给WiFi模块\n\n\n\n7.1 只读型数据的获取\n相关代码位置:  \ngokit_mcu_stm32_xxx\\User\\main.c 中 userHandle() 函数：\n使用说明：\n该函数中完成了用户区上报型数据的获取。用户只需将读到的数据赋值到用户区当前设备状态结构体即可：\n\n注：赋值完的数据是通过gizwitsHandle （详情请查看“2.5 协议处理函数的实现”一节中：数据上报判断机制gizCheckReport部分）上报云端的，开发者不需要关注变化上报和定时上报。\n7.2 上报状态判断\n为了让API接口更简化，处理更简单，机智云把更多的判断放到协议模块来处理，达到了开发者只要把状态更新到协议处理模块，不需要关心何时上报，由协议处理模块自动完处理的目的。\n相关代码:  \ngokit_mcu_stm32_xxx\\Gizwits\\gizwits_protocol.c 中 checkReport() 函数：\n功能说明：\n根据协议判断是否上报当前状态的数据，判断逻辑如下：\n\n控制型数据发生状态变化，立刻主动上报当前状态\n用户触发或环境变化所产生的, 其发送的频率不能快于6秒每次\n\n协议中说明如下：(“4.9 设备MCU向WiFi模组主动上报当前状态”)\n\n以红灯开关为例：\n\n注：这部分用户可结合“2.5 协议处理函数的实现”一节中“数据上报判断机制”的内容来理解）。\n7.3 只读型数据类型转换\n获得到用户区的原始数据后，在传输到云端前要进行相应的数据转换，所以要在gizDataPoints2ReportData中进行相应的数据的转换。\n转换函数说明：\n\n\n\n函数\n说明\n\n\n\n\ngizCompressValue\n完成传输数据的压缩处理，详情查看“2.8.2 数据解压与压缩处理”一节。\n\n\n\n\n\n\ngizY2X      |   将用户区数据转化为传输数据，详情查看“2.8.1 数据点类型转换”一节。 |\n8 机智云协议数据处理\n8.1 数据点类型转换\n机智云为使设备功能定义更加简单直接，使用户输入的数值转换成设备能够识别的uint类型，这套算法的核心公式是：y=kx+m （y：显示值；x：传输值；k：分辨率；m：增量）\n以《微信宠物屋》的温湿度传感器温度数据点为例：\n\n取值范围：-13（Ymin） ~ 187（Ymax），分辨率：1，增量：-13 ；\n其分辨率、偏移量作为宏定义定义在app\\Gizwits\\gizwits_product.h中：\n\n根据公式：y=kx＋m，k = 1 ; m = -13\n实际传输的值：x = (y - m) / k\n转换函数在程序中的说明：\nA.X2Y的转换：\n\nB. Y2X的转换：\n\n8.2 数据解压与压缩处理\n设备端与自云端的数据交互过程中，一些特殊类型（bool和enum类型）的数据点原始数据只有被特殊处理后才可被云端解析，所以设备端在接收云端数据时要进行数据的解压处理；在向云端发送数据时进行数据的压缩处理。\n机智云已封装出了相应的处理接口：\n\n\n\n处理名称\n接口名称\n\n\n\n\nbool和enum类型数据点数据解压\ngizDecompressionValue\n\n\nbool和enum类型数据点数据压缩\ngizCompressValue\n\n\n\n以《微信宠物屋》的RGB LED控制为例，云端定义如下：\n\n对应文档中数据存储格式如下：\n\n字节序与bit序对应代码中宏定义如下：\n\n对应的数据点在接收解压时处理如下(位于gizDataPoint2Event函数中)：位于\n\n对应的数据点在发送压缩时处理如下(位于gizDataPoints2ReportData函数中)：\n\n相关支持\n1) 如果您是开发者\nGoKit是面向智能硬件开发者限量免费开放，注册我们的论坛或关注我们的官方微信均可发起申请即可。\n开发者论坛： http://club.gizwits.com/forum.php\n文档中心：http://docs.gizwits.com\n2) 如果您是团体\nGizWits针对团体有很多支持计划，您可以和GizWtis联系，快速得到GoKit以及技术支持；\n网站地址：http://www.gizwits.com/about-us\n官方二维码：\n\n"},{"title":"GoKit3(V)支持词条介绍","url":"/zh-cn/deviceDev/Gokit3Voice/GoKit3V词条.html","content":"\n支持词条列表\nGoKit3(V)支持词条与数据点绑定，默认绑定的词条有：\n\n单个词条介绍\n每一个词条对应一个数据点，且包括多个所属命令，下面分别介绍每一个命令。\n1. 开灯\n开灯对应数据点为：\n\n所属命令有：\n\n2. 关灯\n关灯对应数据点为：\n\n所属命令有：\n\n\n3. 黄色灯光\n对应数据点为：\n\n所属命令有：\n\n\n4. 紫色灯光\n对应数据点是：\n\n所属命令有：\n\n\n5. 粉色灯光\n对应数据点是：\n\n所属命令有：\n\n\n6. 关闭灯光\n对应数据点是：\n\n所属命令有：\n\n7. 开启红色灯光\n对应数据点是：\n\n所属命令有：\n\n8. 关闭红色灯光\n对应数据点是：\n\n所属命令有：\n\n9. 低速转动\n对应数据点是：\n\n所属命令有：\n\n\n10. 中速转动\n对应数据点是：\n\n所属命令有：\n\n\n11. 高速转动\n对应数据点：\n\n所属命令有：\n\n\n12. 低速反转\n对应数据点是：\n\n所属命令有：\n\n\n13. 中速反转\n对应数据点是：\n\n所属命令有：\n\n\n14. 高速反转\n对应数据点是：\n\n所属命令有：\n\n\n15. 开始转动\n对应数据点是：\n\n所属命令有：\n\n16. 停止转动\n对应数据点是：\n\n所属命令有：\n\n17. 开始反转\n对应数据点：\n\n所属命令有：\n\n18. 停止反转\n对应数据点是：\n\n所属命令有：\n\n"},{"title":"GoKit-SoC程序详解","url":"/zh-cn/deviceDev/WiFiSOC/GoKit-SoC-explanation.html","content":"查看旧版MCU_程序详解\n通信协议详解\n1 协议阅读前需知\nA. SOC版与MCU版的区别：\n由于SoC方案是直接在WiFi模组上进行开发故没有MCU这一概念，无需进行串口协议传输，没有协议组包和协议解析这些步骤，所以没有串口协议，重点是“P0数据区”解析这部分。\nB. SOC版与MCU版的联系：\n云端生成的协议文档默认是MCU版的协议文档，其实SOC版完全可复用MCU版的协议，故在这里直接将《xxx-机智云接入串口通讯协议文档》中的MCU理解为SOC（后文同理）。\n2 “p0 数据区约定”\n“p0 数据区约定”有如下功能：\n1) 模块向SOC发送控制命令时携带p0 命令和命令标志位以及可写数据区\n2) SOC主动发送状态时或者回复模块的状态查询时携带p0命令和完整数据区\n3) 数据区会自动合并布尔和枚举变量，且有严格的顺序，不可任意改变\n怎么来理解这三个功能呢？将前序中准备的《XX-机智云接入串口通讯协议文档》如打开，我们会看到如下命令：\n1）WiFi模组请求设备信息；\n2）WiFi模组与设备SOC的心跳；\n3）设备SOC通知WiFi模组进入配置模式；\n4）设备SOC重置WiFi模组；\n5）WiFi模组向设备SOC通知WiFi模组工作状态的变化；\n6）WiFi模组请求重启SOC；\n7）非法消息通知；\n8）WiFi模组读取设备的当前状态；\n9）设备SOC向WiFi模组主动上报当前状态；\n10）WiFi模组控制设备；\n（之后非重点省略）\n大部分的基础通信协议代码机智云已经为大家实现了，所以我们特别关注8、9、10三条命令即可。\n我们先关注命令10如下：\n\n注：SOC版代码无需关注P0协议区以外的协议内容，后文同理。\n对应上面“p0 数据区约定”中的功能1）“模块向SOC发送控制命令时携带p0 命令和命令标志位以及可写数据区”，可知：“action(1B)”代表p0 命令、“attr_flags(1B）”代表命令标志位、“attr_vals(6B)”代表可写数据区。\n那程序中如何识别呢，往下看协议的注解：\n1).命令标志位(attr_flags)表示相关的数据值是否为有效值，相关的标志位为“1”表示值有效，为“0”表示值无效，从右到左的标志位依次为：\n\n\n\n标志位\n功能\n\n\n\n\nbit0\n设置LED_OnOff\n\n\nbit1\n设置LED_Color\n\n\nbit2\n设置LED_R\n\n\nbit3\n设置LED_G\n\n\nbit4\n设置LED_B\n\n\nbit5\n设置Motor_Speed\n\n\n\n这里可以清楚的看到attr_flags占1B字节，其中bit0代表：设置LED_OnOff......bit5：设置Motor_Speed，那么对于我们的SOC接收到WIFI发来的控制命令后，我们通过识别attr_flags的每一位即可对应出需要控制的设备。\n2).设置数据值(attr_vals(6B)) 即可写数据区，定义如下：\n\n这里可以清楚的看到，只有相关的设置标志位（attr_flags）为1时，数据值才是有效的，需要特别注意的是“p0 数据区约定”约定第三条，数据区会自动合并布尔和枚举变量，且有严格的顺序，不可任意改变。对应上面的“byte0”合并了“bool”和“enum”类型。\n3 协议分析总结\n“p0 数据区约定”主要作用是完成有效数据的上传(协议4.8、4.9)与下达(协议4.10)，其中上传协议的组成形式为：action(1B) + dev_status(11B) ; 下达协议的组成形式为：action(1B) + attr_flags(1B) + attr_vals(6B) ; 其中：\n\n\n\np0 数据区内容\n含义\n\n\n\n\naction\n表示”p0 命令”的传输方向，即：WiFi -> MCU 或 MCU ->Wifi\n\n\ndev_status\n表示上报的所有数据点的设备状态\n\n\nattr_flags\n表示有效的控制型数据点\n\n\nattr_vals\n表示有效控制数据点的数据值\n\n\n\n至此“p0 数据区约定”的解析到此结束，之后我们还会分析SOC的程序实现。\n程序详解\n1 代码目录介绍\n1.1 一级目录\n\n说明：\n\n\n\n文件夹\n说明\n\n\n\n\napp\n用户目录（开发者主要关注）\n\n\nbin\n固件生成目录\n\n\ninclude\n模组驱动相关库\n\n\nld\n动态链接库\n\n\nlib\n工程文件\n\n\ntools\n相关工具\n\n\nreadme.txt\n工程使用介绍\n\n\nESP8266_SoC_User_Guide _V0.5.pdf\nGokit3S二次开发导读\n\n\n\n1.2 代码文件说明\n\n主要文件说明：\n\n\n\n文件\n说明\n\n\n\n\nlibgagent.a\n该文件为机智云设备接入协议库文件,文件位于 lib 目录下\n\n\ngagent_external.h\n该文件为 libgagent.a 对应头文件,两个文件配合使用\n\n\ngizwits_product.c\n该文件为平台相关处理文件，存放事件处理API接口函数，即 gizwitsEventProcess()\n\n\ngizwits_product.h\n该文件为 gizwits_product.c 的头文件，存放产品相关宏定义如： HARDWARE_VERSION 、SOFTWARE_VERSION\n\n\ngizwits_protocol.c\n该文件为协议实现文件，存放 SDK API 接口函数\n\n\ngizwits_protocol.h\n该文件为 gizwits_protocol.c 对应头文件，协议相关宏定义以及 API 接口声明均在此文件中。\n\n\n\n1.3 协议API介绍\n\n\n\nAPI 名称\nAPI 功能\n\n\n\n\nvoid gizwitsInit(void)\ngizwits协议初始化接口。用户调用该接口可以完成Gizwits协议相关初始化（包括协议相关定时器、串口的初始化）。\n\n\nvoid gizwitsSetMode(uint8_t mode)\n参数mode[in]：仅支持0,1和2,其他数据无效。参数为0，恢复模组出厂配置接口，调用会清空所有配置参数，恢复到出厂默认配置。参数为1时配置模组进入SoftAp模式；参数为2配置模组进入AirLink模式。\n\n\nvoid gizwitsHandle(dataPoint_t *dataPoint)\n参数dataPoint[in]:用户设备数据点。该函数中完成了数据上报等相关操作。\n\n\nint8_t gizwitsEventProcess (eventInfo_t info, uint8_t data, uint32_t len)\n参数info[in]:事件队列 参数data[in]:数据 参数len [in]:数据长度 用户数据处理函数,包括wifi状态更新事件和控制事件。 a)Wifi状态更新事件 WIFI_开头的事件为wifi状态更新事件，data参数仅在WIFI_RSSI有效，data值为RSSI值,数据类型为uint8_t，取值范围0~7。 b)控制事件 与数据点相关,本版本代码会打印相关事件信息，相关数值也一并打印输出，用户只需要做命令的具体执行即可。\n\n\n\n2 程序实现原理\n协议实现机制：\n协议解析后，将P0数据区的有效数据点生成对应的数据点事件，再按事件处理数据点。\n数据点转换事件的说明：\n根据协议P0数据区的attr_flags位判断出有效数据点，并将其转化成对应的数据点事件，然后在事件处理函数中(gizEventProcess)完成事件的处理。\n3 程序初始化说明\n3.1 数据协议结构体的定义\n结构体dataPoint_t  ，代码位置: SoC_ESP8266_32M_source\\app\\Gizwits\\gizwits_protocol.h\n\n说明：结构体dataPoint_t，作用是存储用户区的设备状态信息，用户根据云端定义的数据点向其对应的数据位赋值后便不需关心数据的转换，其数据位分别对应“p0 数据区约定”中的“4.9 设备MCU向WiFi模组主动上报当前状态”中的：dev_status(11B) 位：\n\nattrFlags_t、attrVals_t ，代码位置: SoC_ESP8266_32M_source\\app\\Gizwits\\gizwits_protocol.h\n\n结构体attrFlags_t、attrVals_t分别对应“p0 数据区约定”中的“4.10 WiFi模组控制设备”中的：attr_flags(1B) + attr_vals(6B)位：\n\ndevStatus_t，代码位置: SoC_ESP8266_32M_source\\Gizwits\\gizwits_protocol.h\n\n结构体devStatus_t对应“p0 数据区约定”中的“4.9 设备MCU向WiFi模组主动上报当前状态”中的：dev_status(11B) 位：\n\n特别说明：\nA. 数据结构说明\ndataPoint_t 为应用层数据结构，开发者需要了解并会使用（具体使用方式请查看：“2.7.1 只读型数据的获取”一节）。\nattrFlags_t、attrVals_t、devStatus_t为通信层数据结构，开发者需要结合通讯协议进行理解。\nB. 位段举例说明：\nuint8_t motor_switch:1; 是一种位段的使用方式。因为 uint8_t型数据占用 8bit（8位）的空间，协议中motor_switch占用字段bit0（第一位）所以uint8_t motor_switch:1表示使用1位的空间。\nuint8_t reserve:7; 因为程序中申请内存时的最小单位是byte(字节)，而这里我们是按bit(位，8bit = 1byte)进行了使用，故需补齐不足1byte的剩余bit(使用n bit后需补齐剩余的8-n bit)。\n注：位段不能跨字节操作，否则会造成数据读写错误。\n3.2 程序主函数\n位置：SoC_ESP8266_32M_source\\app\\user\\user_main.c中user_init() 函数：\n\n说明：该函数作为整个系统的程序入口初始化了Gagent模块和Gizwits协议模块这两个主要的部分，其中跟开发者有关的是函数是gizwitsInit()、userHandle()，相关说明：\n\n\n\n函数\n说明\n\n\n\n\ngizwitsInit()\n协议解析处理模块初始化函数（协议API）\n\n\nuserHandle()\n定时器回调函数（1000ms定时周期，与时间相关的开发逻辑可以在这里实现）\n\n\n\n3.3 用户程序初始化\n位置：user_main.c中 “//user_init（） 相关程序”\n\n这部分完成了RGB LED、按键、电机、温湿度、红外传感器的硬件驱动调用，对应的驱动程序实现都在SoC_ESP8266_32M_source\\app\\driver下。\n其中完成了定时器初始化（详情查看2.3.4节）：\n\n以及系统任务初始化（详情查看2.3.5节）：\n\n3.4 定时器使用\n代码位置：app\\user\\user_main.c 中的user_init()函数\n\n相关宏定义：\n\nAPI说明：\n\n回调函数说明：\n\n在userTimerFunc() 中完成了周期100ms的定时执行，开发者可以在user_handle()中实现定时读取外设数据的操作，将读取到的数据赋值到用户区的全局结构体变量：\n\n3.5 系统任务的使用\n代码位置：app\\user\\user_main.c 中的gizwitsInit()函数中\n\nAPI使用说明：\n\n回调函数说明：\n\n开发者可以自定义系统任务(system_os_post中的消息类型)，然后在系统任务回调函数中(gizwitsUserTask)添加对应的任务处理(即switch中对应的消息类型)。\n需要注意的是：任务优先级不可随意修改（共有三个优先级，提供给开发者的是优先级0）：\n\n4 配置模式说明\n开发者只有先调用“WiFi配置接口”API才能使WiFi模组进入相应的配置模式，进而完成联网、云端通信的等功能。\n“WiFi配置接口”API 位置：SoC_ESP8266_32M_source\\app\\Gizwits\\gizwits_protocol.h\n\n在本示例工程中是通过按键触发进入相应的配置模式，程序中触发逻辑位置：SoC_ESP8266_32M_source\\app\\user\\main.c\nA.进入Soft AP 模式：key2按键短按。\n\nB.进入AirLink 模式：key2按键长按。\n\nC.模组复位：key1按键长。\n\n注：开发者可以按照自己的需求来实现配置模式。\n5 协议处理函数的实现\n位置：SoC_ESP8266_32M_source\\app\\Gizwits\\gizwits_protocol.c中gizIssuedProcess() 函数：\n该函数被Gagent模块调用，处理来自云端或APP端的相关p0数据协议。\n以下是该协议处理函数的详细介绍：\n● 首先是一些局部变量的初始化，比较重要的是“gizwitsIssued_t *gizIssuedData”它的作用是保存解析出来的协议包头：\n\n协议格式对应协议“4.10 WiFi模组控制设备”中“P0协议区”的标志位\"attr_flags\" + 数据值\"attr_vals\"\n\n● 然后是各协议命令的处理流程：\n\n由于SOC版相对MCU版去掉了串口协议等概念，故开发者在只需了解《xxx机智云接入串口通信协议文档》中的8、10三条指令：\n\n\n\n8）WiFi模组读取设备的当前状态； 10）WiFi模组控制设备；\n\n\n\n\n\n\n\n\n● 下面以以协议4.8的处理为例：\n\n其“action”值 为“0x02”，对应程序中的的case为“ACTION_READ_DEV_STATUS”\n\n之后完成了上报数据的数据类型转化（转化后的数据存储在gizwitsReport_t中的devStatus数据位中）：\n\n最后将待上报的数据以指针拷贝的方式进行输出：\n\n● 同理其他协议action值对应的宏定义的位置在Gizwits\\gizwits_protocol.h中:\n\n以上便是p0协议处理函数的详解。\n6 控制型协议的实现\n与控制型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\ngiziIssuedProcess\n该函数被gagent调用，接收来自云端或app端下发的相关协议数据\n\n\nACTION_CONTROL_DEVICE\n进行“控制型协议”的相关处理\n\n\ngizDataPoint2Event\n根据协议生成“控制型事件”，并完成相应数据类型的转换\n\n\ngizwitsEventProcess\n根据已生成的“控制型事件”进行相应事件处理（即调用相应的驱动函数）\n\n\n\n6.1 控制型事件的生成\n相关代码位置：\nSoC_ESP8266_32M_source\\app\\Gizwits\\gizwits_protocol.c 中 gizDataPoint2Event() 函数：\n功能说明：\n在该函数中完成了写类型外设事件的生成，以“红灯开关数据点”为例：\n\n这里对应协议“4.10 WiFi模组控制设备”：\n\n前面我们已经知道程序里的 “issuedData->attr_flags”就对应《微信宠物屋-机智云接入串口通信协议文档.pdf》中的“4.10 WiFi模组控制设备”中的attr_flags(1B)，作用是用来控制所选位的设备，在文档中我们可以看到attr_flags的第0位是用来选择控制LED灯开关的，即只要设置了第0位为1就表示要控制LED等开关了，代码中对应如下：\n\n接下来便是控制型事件的生成：\n\n以及完成数据的解压（详情请查看“2.8.2 数据解压与压缩处理”一节）：\n\n注意：枚举（如EVENT_LED_ONOFF）用来直观的表示事件的含义，用户自行添加、更改（位置：SoC_ESP8266_32M_source\\app\\Gizwits\\gizwits_protocol.h）\n\n6.2 控制型事件处理\n代码位置:SoC_ESP8266_32M_source\\app\\Gizwits\\gizwits_product.c 中 gizwitsEventProcess() 函数：\n功能说明：\n完成写类型外设事件的处理。\n\n这段程序功能的控制LED灯的开关：LED开关控制位 “issued->attr_vals.led_onoff” 的值若是LED_On（0x01）表示灯开，为LED_Off（0x01）表示灯关。这对应《微信宠物屋-机智云接入串口通信协议文档.pdf》中的“4.10 WiFi模组控制设备”中的attr_vals(6B)，即“数据位”，如下所示：\n\n第0位用来控制红灯亮灭，对应到在云端定义的数据点含义为：\n    = 0x00 = 红灯灭\n    = 0x01 = 红灯亮\n下面的程序基本和上面一样，只要大家看懂了《xxx-机智云接入串口通信协议文档.pdf》中的“4.10 WiFi模组控制设备”中的attr_flags(1B) 、attr_vals(6B)这两位就能编写控制型协议的程序了。\n6.3 可写型数据类型转换\n接收到来自云端的数据后，由于原始数据经过特殊处理，所以要在gizDataPoint2Event中进行相应的数据的转换。\n转换函数说明：\n\n\n\n函数\n说明\n\n\n\n\ngizDecompressionValue\n完成传输数据的压缩处理，详情查看“2.8.2 数据解压与压缩处理”一节。\n\n\ngizX2Y\n将用户区数据转化为传输数据，详情查看“2.8.1 数据点类型转换”一节。\n\n\n\n程序中对应：\n\n\n特别说明：\n网络字节序转化\n数据点为uint16、uint32型的数据要考虑网络字节序转化（uint16即使用exchangeBytes()函数），以电机控制为例：\n\n7 上报型协议的实现\n与上报型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\nuserTimerFunc\n获取用户区的上报型数据\n\n\ngizwitsHandle\n用户调用该接口可以完成设备数据的变化上报\n\n\ngizCheckReport\n判断是否上报当前状态的数据\n\n\ngizDataPoints2ReportData\n完成用户区数据到上报型数据的转换\n\n\ngagentUploadData\n将上报数据发送给WiFi模块\n\n\n\n7.1 只读型数据的获取\n相关代码:SoC_ESP8266_32M_source\\app\\user\\user_main.c 中 userTimerFunc() 函数：\n使用说明：\n该函数中完成了用户区上报型数据的获取。用户只需将读到的数据赋值到用户区当前设备状态结构体即可：\n\n7.2 上报状态判断\n为了让API接口更简化，处理更简单，机智云把更多的判断放到协议模块来处理，达到了开发者只要把状态更新到协议处理模块，不需要关心何时上报，由协议处理模块自动完处理的目的。\n相关代码:  \nSoC_ESP8266_32M_source\\app\\Gizwits\\gizwits_protocol.c 中 gizCheckReport() 函数：\n功能说明：\n根据协议判断是否上报当前状态的数据，判断逻辑如下：\n\n控制型数据发生状态变化，立刻主动上报当前状态\n\n用户触发或环境变化所产生的, 其发送的频率不能快于6秒每次\n\n\n协议中说明如下：(“4.9 设备MCU向WiFi模组主动上报当前状态”)\n\n以“逻辑1：控制型数据主动上报当前状态”为例：\n\n以“逻辑2：控制型数据主动上报当前状态”为例：\n\n7.3 只读型数据类型转换\n获得到用户区的原始数据后，在传输到云端前要进行相应的数据转换，所以要在gizDataPoints2ReportData中完成相应的数据的转换。\n转换函数说明：\n\n\n\n函数\n说明\n\n\n\n\ngizDataPoints2ReportData\n完成传输数据的压缩处理，详情查看“2.8.2 数据解压与压缩处理”一节。\n\n\ngizY2X\n将用户区数据转化为传输数据，详情查看“2.8.1 数据点类型转换”一节。\n\n\n\n​\n8 机智云协议数据处理\n8.1 数据点类型转换\n机智云为使设备功能定义更加简单直接，使用户输入的数值转换成设备能够识别的uint类型，这套算法的核心公式是：y=kx+m （y：显示值；x：传输值；k：分辨率；m：增量）\n以微信宠物屋的温湿度传感器温度检测为例：\n\n取值范围：-13（Ymin） ~ 187（Ymax），分辨率：1，增量：-13 ；\n其分辨率、偏移量作为宏定义定义在SoC_ESP8266_32M_source\\app\\Gizwits\\gizwits_product.h中：\n\n根据公式：y=kx＋m，k = 1 ; m = -13\n实际传输的值：x = (y - m) / k\n转换函数在程序中的说明：\nA.X2Y的转换：\n\nB. Y2X的转换：\n\n功能定义更加\n8.2 数据解压与压缩处理\n设备端与自云端的数据交互过程中，一些特殊类型（bool和enum类型）的数据点原始数据只有被特殊处理后才可被云端解析，所以设备端在接收云端数据时要进行数据的解压处理；在向云端发送数据时进行数据的压缩处理。\n机智云已封装出了相应的处理接口：\n\n\n\n处理名称\n接口名称\n\n\n\n\nbool和enum类型数据点数据解压\ngizDecompressionValue\n\n\nbool和enum类型数据点数据压缩\ngizCompressValue\n\n\n\n以《微信宠物屋》的RGB LED控制为例，云端定义如下：\n \n对应文档中数据存储格式如下：\n\n字节序与bit序对应代码中宏定义如下：\n\n对应的数据点在接收解压时处理如下(位于gizDataPoint2Event函数中)：位于\n\n对应的数据点在发送压缩时处理如下(位于gizDataPoints2ReportData函数中)：\n\n相关支持\n1) 如果您是开发者\nGoKit是面向智能硬件开发者限量免费开放，注册我们的论坛或关注我们的官方微信均可发起申请即可。\n开发者论坛： http://club.gizwits.com/forum.php\n文档中心：http://docs.gizwits.com\n2) 如果您是团体\nGizWits针对团体有很多支持计划，您可以和GizWtis联系，快速得到GoKit以及技术支持；\n网站地址：http://www.gizwits.com/about-us\n官方二维码：\n\n"},{"title":"GoKit3(S) 二次开发--开发环境搭建","url":"/zh-cn/deviceDev/WiFiSOC/GoKit3S二次开发.html","content":"查看旧版代码开发环境搭建\nGoKit3(S)开发环境准备\n1 开发环境搭建方式\nGoKit3(S)有两种开发环境的搭建方式：\n1) 使用乐鑫官方的ESP8266开发环境 (推荐方式)\n2) 使用自定义开发环境：虚拟机VMware(12.0版) + Ubuntu系统(14.04 <64位版>)，然后在Ubuntu下配置交叉编译工具编译源码。\n1.1 使用乐鑫官方开发环境(推荐方式)\n1) 下载官方编译环境安装包：\n链接: https://pan.baidu.com/s/1kVn12Iz\n安装包说明：\n\n注：\n开发者需先安装虚拟机VirtualBox (及运行VirtualBox-4.3.12-93733-Win.exe)，然后用VirtualBox 加载编译环境的虚拟镜像（ESP8266_lubuntu_20141021.ova）。\nxtensa-lx106-elf.tar.bz2 是交叉编译工具，在“自定义开发环境”时使用。\n2) 配置VirtualBox\n安装VirtualBox 4.3.12 后打开，按如下步骤进行操作：\nStep 1: 选择 \"Preferences\" 选项\n\nStep 2: 选择 \"General\" 创建VM默认虚拟机路径，例如： D:\\vm\n\nStep 3: 选择 \"Import Appliance \" 选项\n\nStep 4: 选择要加载的虚拟镜像，例如: D:\\vm\\ ESP8266_lubuntu_20141021.ova\n\nStep 5: 导入虚拟镜像\n\n导入后，可以发现相应文件 D:\\vm\\ ESP8266_lubuntu_1:\n\nStep 5: 创建共享文件夹\n在windows下创建名叫 \"share\"的共享文件，使VirtualBox与windows之间方便的进行文件传输，操作步骤如下：\n\n\nStep 6: 验证编译环境\n运行链接脚本： “./mount.sh”\n\n输入用户密码： “espressif”，回车确认。\n\n进入Gokit3(S)文件目录（可查看“GoKit3(S)源码编译”一节）\n\n运行编译脚本：./gen_misc.sh\n\n显示如下说明编译环境搭建成功。\n\n如有问题请查看乐鑫官方说明：\nhttps://github.com/esp8266/esp8266-wiki/wiki/Toolchain\n1.2 使用自定义开发环境\n1)安装VMware(12.0版) + Ubuntu系统，并创建共享目录”D:\\share”（方法自行百度）。\n2)配置开发环境\nStep 1: 将 xtensa-lx106-elf.tar.bz2  复制到 D:\\share 中。（之前创建的共享文件夹）完成后如下：\n\nStep 2: 进入Ubuntu运行Terminal，如下图顺序打开Terminal\n\n首先进入root权限，命令行中输入：sudo su ，输密码后回车。\n\n更新源：\napt-get update\n\n安装相关软件库：\n32位虚拟机执行：apt-get install vim git                        //一路回车确认\n64位虚拟机执行：apt-get install vim git libc6-dev-amd64            //一路回车确认\n进入共享文件夹：\ncd /mnt/hgfs/share\n\n命令行顺序执行：\ncp xtensa-lx106-elf.tar.bz2 /opt/\ncd /opt/\ntar -jxvf xtensa-lx106-elf.tar.bz2                    //解压后显示如下\n\ncd /home/$ username                        //$username为登录用户名\nvim .profile\nexport PATH=\"/opt/xtensa-lx106-elf/bin:$PATH\"        //添加到最后一行 保存退出\n\nexit                                            //注意在要退出超级用户权限\nsource .profile                                 //在用户名权限下执行此脚本\necho $PATH                                    //显示红框所示表示配置正确        \n\n如有问题请查看乐鑫官方说明：\nhttps://github.com/esp8266/esp8266-wiki/wiki/Toolchain\n2 GoKit3(S)源代码\nGoKit3(S)的源码获取方式请查看：代码自动生成工具介绍 中 生成SoC方案代码 一节。\n\nGoKit3(S)源码编译\n1) 将GoKit3(S)源码解压后放入share共享目录下：\n\n注：示例中以ESP8266 32M模组的源码为例，16M、8M同理。\n2) 进入编译目录：\ncd /mnt/hgfs/share/SoC_ESP8266_32M_source/app/\n\n3) 设置编译脚本为Unix格式，防止Win系统下对编译脚本产生影响(注:无法运行编译脚本时即可使用此方法)：\nvim gen_misc.sh\n:set ff=unix            //这是vim命令，非添加的内容\n:wq!                    //这是vim命令，非添加的内容\n\n4) 运行编译脚本：\n./gen_misc.sh\n\n注：如图所示表明编译成功\n5) 生成的固件位置:\nshare/SOC_ESP8266_32M_source/bin/upgrade\n\nWindows中显示如下\n\nGoKit3(S)固件下载\n1 打开烧写软件\n下载程序烧录工具“ESPFlashDownloadTool_v3.3.4.exe” ，下载地址：\nhttps://www.espressif.com/sites/default/files/tools/flash_download_tools_v3.6.4.rar\n下载完毕解压后点击运行“ESPFlashDownloadTool_v3.3.4.exe”\n\n2 设置烧写选项\nGoKit3(S) 烧写固件分为SOC版和MCU版，开发者应根据GoKit3(S) 的模式烧写对应版本的固件，详细介绍请查看《GoKit3(S) 开发套件介绍》中的“2. 了解SOC版与MCU版的区别”一节。\n2.1 GoKit3(S) SOC版\nSOC版的程序固件名称为：\nuser1.4096.new.6.bin\n编译后固件默认保存位置：     \nshare/SOC_ESP8266_xxM_source/bin/upgrade\n2.2 GoKit3(S) MCU版\nMCU版的程序固件名称为：\nGAgent_00ESP826_04020029_32Mbitcombine.bin\n点击下载\n详细介绍请查看《GoKit3(S) 开发套件介绍》中“5. 使用Gokit的MCU模式”一节。\n2.3 确认烧写选项\n烧写选项按如下图所示选择、填写：\n\n注：\n1).前三个 ‘.bin’ 文件都在D:\\share\\SoC_ESP8266_32M_source\\bin 目录下，选择对应的名称的 ‘.bin’文件即可。\n最后一个.bin 文件默认为SOC版固件：user1.4096.new.6.bin\n位置：D:\\share\\SoC_ESP8266_32M_source\\bin\\upgrade\\user1.4096.new.6.bin\n若烧写MCU版固件请选择 GAgent_00ESP826_04020029_32Mbitcombine.bin\n2).COM PORT 为TTL转串口的COM号（下边会说明）\n3).BAUDRATE建议为：115200（烧写速度慢但成功率高）\n3 连接TTL转USB接口\n\n将TTL转USB与电脑连接：\n\n设备管理器中找到对应的串口号：（此处为COM4）\n\n4 给Gokit供电\n\n注：\n这里USB可连直接接电源，若想查看日志可接电脑（需区别COM号）。\n5 烧写程序\n首先，将拨码开关设为程序烧录模式（下拨位置）\n\n相继按下烧录工具的“START”键与WiFi模组的“Reset”键，开始烧录程序：\n\n\n若显示“完成”及烧录成功\n\n注：若不成功，先查看COM是否正确，并调低BAUDRATE多试几次。\n接下来，将拨码开关设为正常使用模式（上拨位置）\n\n按下 Reset键重启模组，程序开始工作\n\n6 查看LOG日志\n将USB口（及供电接口）连接计算机便可通过串口（注意选择对应COM口号）打印工具查看LOG信息（波特率：115200）\n\n注：若LOG信息出现乱码，可重启串口打印软件，即可恢复正常。\n固件升级(OTA)\n1 上传固件\n登陆开发者中心，找到需要进行OTA的产品，按下图所示找到固件升级页面\n\n点击“创建新固件”按钮，按下图提示填写：\n\n说明：\n1、固件所在的目录是bin/upgrade/*bin\n2、自03000003版本后增加了Changelog文件，OTA软件版本号会在Changelog文件中描述。\n3、03000001版本软件版本号请使用040200xx\n4、OTA固件版本号必须大于运行在模组中的固件版本号\n2 验证固件\n固件创建完成后，可以看到如下界面：\n\n点击“验证固件”按钮，会看到如下图的弹框\n\n填入MAC，点击“推送”后等待OTA推送结果即可。\nFAQ&总结\n1 FAQ\n问：自定义开发环境共享文件夹不成功怎么办？\n答：使用如下命令重新安装VMware Tools\nsudo apt-get autoremove open-vm-dkms open-vm-tools --purge\n点击“虚拟机”—— 重新安装VMware Tools ——在终端中进入相应目录\ntar -zxvf VMwareTools-10.0.0-2977863.tar.gz\nsudo ./vmware-install.pl\n之后一路回车键确认直到安装完成即可\n2 总结\n至此，Gokit3的开发环境搭建、源码编译及固件下载已介绍完毕。\n若想深入了解Gokit3的硬件电路说明请查看：\n《GoKit3硬件手册》\n若想在Gokit3所给出的“微信宠物屋”代码示例的基础上开发自己的程序请查看：\n《GoKit3(S)程序开发手册》\n"},{"title":"GoKit3(S) 二次开发--开发环境搭建","url":"/zh-cn/deviceDev/WiFiSOC/GoKit3S二次开发_old.html","content":"2017年9月25日起已使用新版MCU代码生成，查看新版GoKit3(S)二次开发——开发环境搭建\nGoKit3(S)开发环境准备\n1 开发环境搭建方式\nGoKit3(S)有两种开发环境的搭建方式：\n1) 使用乐鑫官方的ESP8266开发环境 (推荐方式)\n2) 使用自定义开发环境：虚拟机VMware(12.0版) + Ubuntu系统(14.04 <64位版>)，然后在Ubuntu下配置交叉编译工具编译源码。\n1.1 使用乐鑫官方开发环境(推荐方式)\n1) 下载官方编译环境安装包：\n链接: https://pan.baidu.com/s/1kVn12Iz\n安装包说明：\n\n注：\n开发者需先安装虚拟机VirtualBox (及运行VirtualBox-4.3.12-93733-Win.exe)，然后用VirtualBox 加载编译环境的虚拟镜像（ESP8266_lubuntu_20141021.ova）。\nxtensa-lx106-elf.tar.bz2 是交叉编译工具，在“自定义开发环境”时使用。\n2) 配置VirtualBox\n安装VirtualBox 4.3.12 后打开，按如下步骤进行操作：\nStep 1: 选择 \"Preferences\" 选项\n\nStep 2: 选择 \"General\" 创建VM默认虚拟机路径，例如： D:\\vm\n\nStep 3: 选择 \"Import Appliance \" 选项\n\nStep 4: 选择要加载的虚拟镜像，例如: D:\\vm\\ ESP8266_lubuntu_20141021.ova\n\nStep 5: 导入虚拟镜像\n\n导入后，可以发现相应文件 D:\\vm\\ ESP8266_lubuntu_1:\n\nStep 5: 创建共享文件夹\n在windows下创建名叫 \"share\"的共享文件，使VirtualBox与windows之间方便的进行文件传输，操作步骤如下：\n\n\nStep 6: 验证编译环境\n运行链接脚本： “./mount.sh”\n\n输入用户密码： “espressif”，回车确认。\n\n进入Gokit3(S)文件目录（可查看“GoKit3(S)源码编译”一节）\n\n运行编译脚本：./gen_misc.sh\n\n显示如下说明编译环境搭建成功。\n\n如有问题请查看乐鑫官方说明：\nhttps://github.com/esp8266/esp8266-wiki/wiki/Toolchain\n1.2 使用自定义开发环境\n1)安装VMware(12.0版) + Ubuntu系统，并创建共享目录”D:\\share”（方法自行百度）。\n2)配置开发环境\nStep 1: 将 xtensa-lx106-elf.tar.bz2  复制到 D:\\share 中。（之前创建的共享文件夹）完成后如下：\n\nStep 2: 进入Ubuntu运行Terminal，如下图顺序打开Terminal\n\n首先进入root权限，命令行中输入：sudo su ，输密码后回车。\n\n更新源：\napt-get update\n\n安装相关软件库：\n32位虚拟机执行：apt-get install vim git                        //一路回车确认\n64位虚拟机执行：apt-get install vim git libc6-dev-amd64            //一路回车确认\n进入共享文件夹：\ncd /mnt/hgfs/share\n\n命令行顺序执行：\ncp xtensa-lx106-elf.tar.bz2 /opt/\ncd /opt/\ntar -jxvf xtensa-lx106-elf.tar.bz2                    //解压后显示如下\n\ncd /home/$ username                        //$username为登录用户名\nvim .profile\nexport PATH=\"/opt/xtensa-lx106-elf/bin:$PATH\"        //添加到最后一行 保存退出\n\nexit                                            //注意在要退出超级用户权限\nsource .profile                                 //在用户名权限下执行此脚本\necho $PATH                                    //显示红框所示表示配置正确        \n\n如有问题请查看乐鑫官方说明：\nhttps://github.com/esp8266/esp8266-wiki/wiki/Toolchain\n2 GoKit3(S)源代码\nGoKit3(S)源码下载地址，点击下载中\n\nGoKit3(S)源码编译\n1) 将GoKit3(S)源码解压后放入share共享目录下：\n\n2) 进入编译目录：\ncd /mnt/hgfs/share/gokit-soc-esp8266/app/\n\n3) 设置编译脚本为Unix格式，防止Win系统下对编译脚本产生影响：\nvim gen_misc.sh\n:set ff=unix            //这是vim命令，非添加的内容\n:wq!                    //这是vim命令，非添加的内容\n4) 运行编译脚本：\n./gen_misc.sh\n\n注：如图所示表明编译成功\n5) 生成的固件位置:\nshare/gokit3_SoC_ESP8266_xxx/bin/upgrade\n\nWindows中显示如下\n\nGoKit3(S)固件下载\n1 打开烧写软件\n下载程序烧录工具“FLASH_DOWNLOAD_TOOLS_v2.4” ，下载地址：\nhttp://bbs.espressif.com/viewtopic.php?f=57&t=433\n下载完毕解压后点击运行“ESP_DOWNLOAD_TOOL_V2.4.exe”\n\n2 设置烧写选项\nGoKit3(S) 烧写固件分为SOC版和MCU版，开发者应根据GoKit3(S) 的模式烧写对应版本的固件，详细介绍请查看《GoKit3(S) 开发套件介绍》中的“2. 了解SOC版与MCU版的区别”一节。\n2.1 GoKit3(S) SOC版\nSOC版的程序固件名称为：\nuser1.4096.new.6.bin\n编译后固件默认保存位置：     \nshare/gokit3_SoC_ESP8266_xxx/bin/upgrade\n2.2 GoKit3(S) MCU版\nMCU版的程序固件名称为：\nGAgent_00ESP826_04020011_16041419.bin\n点击下载)\n详细介绍请查看《GoKit3(S) 开发套件介绍》中“5. 使用Gokit的MCU模式”一节。\n2.3 确认烧写选项\n烧写选项按如下图所示选择、填写：\n\n注：\n1).前三个 ‘.bin’ 文件都在D:\\share\\gokit-soc-esp8266\\bin 目录下，选择对应的名称的 ‘.bin’文件即可。\n最后一个.bin 文件默认为SOC版固件：user1.4096.new.6.bin\n位置：D:\\share\\gokit-soc-esp8266\\bin\\upgrade\\user1.4096.new.6.bin\n若烧写MCU版固件请选择 GAgent_00ESP826_04020011_16041419.bin\n2).COM PORT 为TTL转串口的COM号（下边会说明）\n3).BAUDRATE建议为：115200（烧写速度慢但成功率高）\n3 连接TTL转USB接口\n\n将TTL转USB与电脑连接：\n\n设备管理器中找到对应的串口号：（此处为COM4）\n\n4 给Gokit供电\n\n注：\n这里USB可连直接接电源，若想查看日志可接电脑（需区别COM号）。\n5 烧写程序\n首先，将拨码开关设为程序烧录模式（下拨位置）\n\n相继按下烧录工具的“START”键与WiFi模组的“Reset”键，开始烧录程序：\n\n\n若显示“完成”及烧录成功\n\n注：若不成功，先查看COM是否正确，并调低BAUDRATE多试几次。\n接下来，将拨码开关设为正常使用模式（上拨位置）\n\n按下 Reset键重启模组，程序开始工作\n\n6 查看LOG日志\n将USB口（及供电接口）连接计算机便可通过串口（注意选择对应COM口号）打印工具查看LOG信息（波特率：115200）\n\n注：若LOG信息出现乱码，可重启串口打印软件，即可恢复正常。\n固件升级(OTA)\n1 上传固件\n登陆开发者中心，找到需要进行OTA的产品，按下图所示找到固件升级页面\n\n点击“创建新固件”按钮，按下图提示填写：\n\n说明：\n1、固件所在的目录是bin/upgrade/*bin\n2、自03000003版本后增加了Changelog文件，OTA软件版本号会在Changelog文件中描述。\n3、03000001版本软件版本号请使用040200xx\n4、OTA固件版本号必须大于运行在模组中的固件版本号\n2 验证固件\n固件创建完成后，可以看到如下界面：\n\n点击“验证固件”按钮，会看到如下图的弹框\n\n填入MAC，点击“推送”后等待OTA推送结果即可。\nFAQ&总结\n1 FAQ\n问：自定义开发环境共享文件夹不成功怎么办？\n答：使用如下命令重新安装VMware Tools\nsudo apt-get autoremove open-vm-dkms open-vm-tools --purge\n点击“虚拟机”—— 重新安装VMware Tools ——在终端中进入相应目录\ntar -zxvf VMwareTools-10.0.0-2977863.tar.gz\nsudo ./vmware-install.pl\n之后一路回车键确认直到安装完成即可\n2 总结\n至此，Gokit3的开发环境搭建、源码编译及固件下载已介绍完毕。\n若想深入了解Gokit3的硬件电路说明请查看：\n《GoKit3硬件手册》\n若想在Gokit3所给出的“微信宠物屋”代码示例的基础上开发自己的程序请查看：\n《GoKit3(S)程序开发手册》\n"},{"title":"GoKit3(S)使用说明书","url":"/zh-cn/deviceDev/WiFiSOC/GoKit3S使用说明书.html","content":"初见GoKit3(S)\n\n首先您需要弄清楚的有这些：\n初步了解GoKit3(S)，没有看的同学请查看 《GoKit3(S)开发套件介绍》\n了解按钮的功能，定义如下表：\n\n\n\n按键\n触发\n功能\n\n\n\n\nReset\n短按\n复位WiFi模组\n\n\nKey1\n短按\n自定义\n\n\nKey1\n长按(3s)\n复位WiFi模组\n\n\nKey2\n短按\n进入Soft AP模式\n\n\nKey2\n长按(3s)\n进入AirLink模式\n\n\nKey3\n自定义\n自定义\n\n\n\n下载官方应用\n想控制使用Gokit3（S），通常推荐这两种方法：使用“机智云（又称IoE Demo）”APP或机智云公众号（微信号：go-kit）。\n获取Gokit的官方APP“机智云（又称IoE Demo）” 的方式有：\n\n1）用微信扫一扫说明书上的二维码，下载“机智云”APP\n2）在机智云“下载中心”下载\n3）在应用商店，搜索“机智云”\n\n\n安装成功后可以在桌面看到“机智云（又称IOE Demo）”APP的图标。接下来，就可以控制Gokit3（S）了。\n\n连接到路由器\n现在您已经拿到了GoKit，安装了“机智云（又称IoE Demo）”APP，那么接下来的一步，就是将您的GoKit连接到您的路由器上去，如何做到呢？GoKit提供两种配置入网方式：AirLink 、 SoftAP。\n1 AirLink配置入网\nAirlink配置入网，操作步骤和Gokit3（S）纸质说明书的内容一致,如下所示：\n\n使用USB电源线为Gokit供电并开机\n收集接入Wifi网络，打开“机智云（IOE Demo）”APP，可选择登录APP或跳过，再在主界面点击“我的设备”，选择“添加设备”\n长按GoKit上的“KEY2”，【RGB LED】灯绿色目标是GoKit进入配置模式。\nApp上输入正在使用的WiFi网络密码，并点击“配置”，等待设备接入Wifi网络。\n在App上选择模组类型（请注意需和GoKit的模组型号保持一致），点击“下一步”，等待搜索并连接设备，通常这个过程是10~120s内完成。\n配置入网时的注意事项：\n\n路由器需为2.4G网络。暂不支持路由器为5G网络。\n请保持WiFi环境稳定。\nGoKit天生支持远程连接，您可以将您的手机切换成2G、3G、4G，然后打开软件，您的GoKit依然存在，点击设备后就如同本地操作一样，唯一不同的就是目前的连接方式是远程连接。\n\n接下来的是图文版Airlink配置入网方式。\n给GoKit供电（如下图）\n\n注意：确认手机已连接可用的路由器，可以上外网，最重要的一点：你要知道自己登陆的WiFi密码哦（后面马上要用到）。\n打开机智云APP (IOE Demo)，如果您的APP未使用过，您的APP应该不会显示任何设备（如下图）\n\n启动GoKit的AirLink配置模式\n长按Key2键3秒，待扩展板上常亮绿灯后，说明WiFi模块进入AirLink配置状态（如下图）\n\n返回APP界面（），点击此界面的右上菜单，点击添加设备（如下图），选择“乐鑫”的WiFi模块后输入您的路由器密码。\n\n\n\n在APP上点击配置按钮，等待不超过一分钟，APP就可以提示配置成功（下图）\n\n\n注：在此期间，您可以看到GoKit的绿灯熄灭，说明GoKit 3已连接到您的路由器。\n2. SoftAP配置入网\n打开GoKit的 SoftAP配置模式\n短按Key2键，待扩展板上常亮红灯后，说明WiFi模块进入SoftAP配置状态（如下图）。\n\n打开手机WiFi管理界面（一般在“设置”>“WiFi”中）\n\n选择形如“XPG-GAgent-XXXX”的WiFi热点密码：123456789（如下图）\n\n\n\n\n注意：XXXX是WiFi模组的MAC后四位（如上图的1FDC）。\n\n打开机智云APP （注意要从后台彻底关闭APP后再重新再打开一次）\n在弹出的界面中（如下）选择可用的WiFi热点并输入对应的密码\n\n等待不超过一分钟，APP就可以提示配置成功（下图）\n\n注：如果看到GoKit的红灯熄灭，说明GoKit 3已连成功接入您的路由器。\n让GoKit亮起来\n设备配置成功后，默认在发现新设备列表，并且未绑定（如下图）\n\n点击未绑定的设备，会自动绑定成功，此时设备进入可操作设备列表（如下图）\n\n点击设备，进入设备的操作页面（如下图），在此页面，您可以对GoKit进行各种控制，也可以收到GoKit跟您返回的各种状态。\n\n需要注意的几点：\n\ni. 如果您在设定LED组合颜色中，选择了自定义，您可以分别设定R、G、B的颜色；\nii. 如果您在设定LED组合颜色中，选择了具体的颜色，您就不可以再对R、G、B进行设置；\niii. 红外探测和温湿度上报都属于用户触发行为，都是在GoKit上进行触发，在APP上显示；\n\n即使GoKit不在身边依然近在咫尺\nGoKit天生支持远程连接，您可以将您的手机切换成2G、3G、4G，然后打开软件，您的GoKit依然存在，点击设备后就如同本地操作一样，唯一不同的就是目前的连接方式是远程连接。\nGoKit3(S)的MCU模式\nGoKit3(S)除了支持SOC模式同时支持MCU模式，两者区别请查看《Gokit3系列开发套件简介》中的“3.1. SOC版与MCU版的区别”一节，以下介绍如何使用MCU模式。\n1 先确认GoKit3(S)处于SOC模式\n因为只有在SOC模式下才能正常烧写固件，所以先确定ESP 8266 WiFi处于模组接口的SOC模式（靠下位置），如下图：\n\n2 烧写ESP8266对应的Gagent程序\n使用MCU模式时，ESP8266(WiFi模组)只负责信息的接收与发送，所以WiFi模组需要烧写Gagent源码固件。Gagent 是机智云开发的可运行在各种通讯模组上的一款应用程序，开发者使用 Gagent 后，只需要关心产品的业务逻辑开发，不用关心数据的通讯功能开发，大大降低了开发的难度。\n 新版Gagent程序下载地址\n 注：要下载ESP8266对应的最新版本，如下图：\n\n烧写方式：\nMCU模式的固件烧写与SOC模式下的固件烧写方式相似，详细方式请查看《机智云GAgent for ESP8266 串口烧写说明》。\n3 将模组切换到MCU模式\n将GoKit3(S)断电后再将ESP8266 WiFi模组从“SOC模式位置”（靠下位置）拔起，重插到“MCU模式位置”（靠上位置），如下图：\n\n4 MCU模式下的GoKit3(S)使用方法\n\nMCU模式下的GoKit3(S)操作方法与SOC模式下相同，配置入网方式请参照上文“3. 连接到路由器”一节。\n\n总结\n若想了解整个机智云的开发框架请查看开发者文档中心：\nhttp://docs.gizwits.com\n更多的开发教程请查看社区GoKit开源套件板块\n\nGoKit开源套件\n\n"},{"title":"GoKit3(S)开发套件介绍","url":"/zh-cn/deviceDev/WiFiSOC/GoKit3S开发套件介绍.html","content":"GoKit3(S)是什么\nGoKit3(S)是机智云（GizWits）推出的物联网智能硬件开发套件（第三代），目的是帮助传统硬件快速接入互联网。完成入网之后，数据可以在产品与云端、制造商与用户之间互联互通，实现智能互联。\n了解GoKit3(S)的硬件结构\nGoKit3(S)采用一体式SOC解决方案，并具有一定的拓展性，图如下：\n\nESP8266 ：乐鑫的一款高性能无线WiFi模组，可直接控制扩展板片上资源。\n功能扩展板：兼容多种型号的WiFi模组，用于连接各种外设传感器，用于模拟实际应用功能。\n功能扩展板（正面）：\n\n功能扩展板（反面）：\n\nWiFi模组（正面）：\n\nWiFi模组（反面）：\n\n了解GoKit3(S)提供的硬件功能\n\n\n\n序号\n硬件功能\n功能说明\n\n\n\n\n1\n乐鑫ESP8266 WiFi模组\n⽀持STA/AP⼯作模式\n\n\n2\n红外探测器\n可以探测是否有阻挡\n\n\n3\nRGB LED\n可编程全彩LED灯\n\n\n4\n可编程电机\n可编程正反转及调速电机\n\n\n5\n温湿度传感器\n\n\n\n6\n三个可编程按键\n\n\n\n7\n一组咪头接口\n\n\n\n8\n扬声器接口\n\n\n\n9\n语音降噪模块接口\n\n\n\n10\nUSB转Uart接口\n可以更方便对GoKit供电，并打印日志\n\n\n11\nUart TTL程序烧写接口\n可用USB转TTL烧写模组SOC程序\n\n\n12\n双模式模组接口\n可按需求切换为SOC模式（GoKit3(S)所使用的模式）或MCU模式\n\n\n13\nOLED接口\n可复用SPI等其他接口\n\n\n\n预留接口\n具有电源输出、SWD、Uart TTL、外置Arduino等接口功能\n\n\n\n注：详细硬件原理图请查看 《GoKit3.2 硬件手册》\nGoKit3(S)用法\nSoC方式\nSoC是最新推出的开发方式，即功能板+wifi模组的连接方式，是GoKit3(S)的默认方式，发货固件即为SoC固件，可直接使用，用法与GoKit2相同。需要注意的是SoC方式不能接底板，否则不能正常运行。\n二次开发源码包及原理图已经开放，地址是：\n1、ESP8266 SoC源码包下载页面 ，选择“微信宠物屋 for GoKit3(S) ESP8266”进行下载。\n2、原理图： http://club.gizwits.com/thread-2889-1-1.html\nMCU方式\nMCU的方式可得到与GoKit2相同的开发方式，即底板+功能板+wifi模组的连接方式。使用MCU的连接方式需要开发者自更新wifi模组的固件，固件下载地址及烧录方法见下面链接：\n1、GAgent固件，下载页面，选择“GAgent for ESP8266”。\n2、GAgent固件烧录方法\n3、STM32 MCU源码包，下载页面，选择“微信宠物屋 for GoKit 2 STM”进行下载。\n相关支持\n如果您是创客\nGoKit是面向智能硬件开发者限量免费开放，注册我们的论坛或关注我们的官方微信均可发起申请即可。\n官方网站地址： http://site.gizwits.com/developer/activity/gokit/request\n如果您是团体\nGizWits针对团体有很多支持计划，您可以和GizWtis联系，快速得到GoKit以及技术支持；\n网站地址： http://www.gizwits.com/about-us\n"},{"title":"GoKit3(S)二次开发-程序详解（旧）","url":"/zh-cn/deviceDev/WiFiSOC/GoKit3S程序详解.html","content":"2017年9月25日起已使用新版MCU代码生成，查看新版自动生成代码程序详解\n通信协议详解\n1 协议阅读前需知\nA. SOC版与MCU版的区别：\n由于SoC方案是直接在WiFi模组上进行开发故没有MCU这一概念，无需进行串口协议传输，没有协议组包和协议解析这些步骤，所以没有串口协议，重点是“P0数据区”解析这部分。\nB. SOC版与MCU版的联系：\n云端生成的协议文档默认是MCU版的协议文档，其实SOC版完全可复用MCU版的协议，故在这里直接将《xxx-机智云接入串口通讯协议文档》中的MCU理解为SOC（后文同理）。\n2 “p0 数据区约定”\n“p0 数据区约定”有如下功能：\n1) 模块向SOC发送控制命令时携带p0 命令和命令标志位以及可写数据区\n2) SOC主动发送状态时或者回复模块的状态查询时携带p0命令和完整数据区\n3) 数据区会自动合并布尔和枚举变量，且有严格的顺序，不可任意改变\n怎么来理解这三个功能呢？将前序中准备的《XX-机智云接入串口通讯协议文档》如打开，我们会看到如下命令：\n1）WiFi模组请求设备信息；\n2）WiFi模组与设备SOC的心跳；\n3）设备SOC通知WiFi模组进入配置模式；\n4）设备SOC重置WiFi模组；\n5）WiFi模组向设备SOC通知WiFi模组工作状态的变化；\n6）WiFi模组请求重启SOC；\n7）非法消息通知；\n8）WiFi模组读取设备的当前状态；\n9）设备SOC向WiFi模组主动上报当前状态；\n10）WiFi模组控制设备；\n（之后非重点省略）\n大部分的基础通信协议代码机智云已经为大家实现了，所以我们特别关注8、9、10三条命令即可。\n我们先关注命令10如下：\n\n注：SOC版代码无需关注P0协议区以外的协议内容，后文同理。\n对应上面“p0 数据区约定”中的功能1）“模块向SOC发送控制命令时携带p0 命令和命令标志位以及可写数据区”，可知：“action(1B)”代表p0 命令、“attr_flags(1B）”代表命令标志位、“attr_vals(6B)”代表可写数据区。\n那程序中如何识别呢，往下看协议的注解：\n1).命令标志位(attr_flags)表示相关的数据值是否为有效值，相关的标志位为“1”表示值有效，为“0”表示值无效，从右到左的标志位依次为：\n\n\n\n标志位\n功能\n\n\n\n\nbit0\n设置LED_OnOff\n\n\nbit1\n设置LED_Color\n\n\nbit2\n设置LED_R\n\n\nbit3\n设置LED_G\n\n\nbit4\n设置LED_B\n\n\nbit5\n设置Motor_Speed\n\n\n\n这里可以清楚的看到attr_flags占1B字节，其中bit0代表：设置LED_OnOff......bit5：设置Motor_Speed，那么对于我们的SOC接收到WIFI发来的控制命令后，我们通过识别attr_flags的每一位即可对应出需要控制的设备。\n2).设置数据值(attr_vals(6B)) 即可写数据区，定义如下：\n\n这里可以清楚的看到，只有相关的设置标志位（attr_flags）为1时，数据值才是有效的，需要特别注意的是“p0 数据区约定”约定第三条，数据区会自动合并布尔和枚举变量，且有严格的顺序，不可任意改变。对应上面的“byte0”合并了“bool”和“enum”类型。\n3 协议分析总结\n“p0 数据区约定”主要作用是完成有效数据的上传(协议4.8、4.9)与下达(协议4.10)，其中上传协议的组成形式为：action(1B) + dev_status(11B) ; 下达协议的组成形式为：action(1B) + attr_flags(1B) + attr_vals(6B) ; 其中：\n\n\n\np0 数据区内容\n含义\n\n\n\n\naction\n表示”p0 命令”的传输方向，即：WiFi -> MCU 或 MCU ->Wifi\n\n\ndev_status\n表示上报的所有数据点的设备状态\n\n\nattr_flags\n表示有效的控制型数据点\n\n\nattr_vals\n表示有效控制数据点的数据值\n\n\n\n至此“p0 数据区约定”的解析到此结束，之后我们还会分析SOC的程序实现。\n程序详解\n1 代码目录介绍\n1.1 一级目录\n\n说明：\n\n\n\n文件夹\n说明\n\n\n\n\napp\n用户目录（开发者主要关注）\n\n\nbin\n固件生成目录\n\n\ninclude\n模组驱动相关库\n\n\nld\n动态链接库\n\n\nlib\n工程文件\n\n\ntools\n相关工具\n\n\nreadme.txt\nGokit3S文档介绍\n\n\nuser guide V0.3.pdf\nGokit3S二次开发导读\n\n\n\n1.2 代码文件说明\n\n主要文件说明：\n\n\n\n文件\n说明\n\n\n\n\nlibgagent.a\n该文件为机智云设备接入协议库文件,文件位于 lib 目录下\n\n\ngagent_external.h\n该文件为 libgagent.a 对应头文件,两个文件配合使用\n\n\ngizwits_product.c\n该文件为平台相关处理文件，存放事件处理API接口函数，即 gizwitsEventProcess()\n\n\ngizwits_product.h\n该文件为 gizwits_product.c 的头文件，存放产品相关宏定义如： HARDWARE_VERSION 、SOFTWARE_VERSION\n\n\ngizwits_protocol.c\n该文件为协议实现文件，存放 SDK API 接口函数\n\n\ngizwits_protocol.h\n该文件为 gizwits_protocol.c 对应头文件，协议相关宏定义以及 API 接口声明均在此文件中。\n\n\n\n1.3 协议API介绍\n\n\n\nAPI 名称\nAPI 功能\n\n\n\n\nvoid gizwitsInit(void)\ngizwits协议初始化接口。用户调用该接口可以完成Gizwits协议相关初始化（包括协议相关定时器、串口的初始化）。\n\n\nvoid gizwitsSetMode(uint8_t mode)\n参数mode[in]：仅支持0,1和2,其他数据无效。参数为0，恢复模组出厂配置接口，调用会清空所有配置参数，恢复到出厂默认配置。参数为1时配置模组进入SoftAp模式；参数为2配置模组进入AirLink模式。\n\n\nvoid gizwitsHandle(dataPoint_t *dataPoint)\n参数dataPoint[in]:用户设备数据点。该函数中完成了数据上报等相关操作。\n\n\nint8_t gizwitsEventProcess (eventInfo_t info, uint8_t data, uint32_t len)\n参数info[in]:事件队列 参数data[in]:数据 参数len [in]:数据长度 用户数据处理函数,包括wifi状态更新事件和控制事件。 a)Wifi状态更新事件 WIFI_开头的事件为wifi状态更新事件，data参数仅在WIFI_RSSI有效，data值为RSSI值,数据类型为uint8_t，取值范围0~7。 b)控制事件 与数据点相关,本版本代码会打印相关事件信息，相关数值也一并打印输出，用户只需要做命令的具体执行即可。\n\n\n\n2 程序实现原理\n协议实现机制：\n协议解析后，将P0数据区的有效数据点生成对应的数据点事件，再按事件处理数据点。\n数据点转换事件的说明：\n根据协议P0数据区的attr_flags位判断出有效数据点，并将其转化成对应的数据点事件，然后在事件处理函数中(gizEventProcess)完成事件的处理。\n3 程序初始化说明\n3.1 数据协议结构体的定义\n结构体dataPoint_t  ，代码位置: gokit_mcu_stm32_xxx\\Gizwits\\gizwits_protocol.h\n\n说明：结构体dataPoint_t，作用是存储用户区的设备状态信息，用户根据云端定义的数据点向其对应的数据位赋值后便不需关心数据的转换，其数据位分别对应“p0 数据区约定”中的“4.9 设备MCU向WiFi模组主动上报当前状态”中的：dev_status(11B) 位：\n\nattrFlags_t、attrVals_t ，代码位置: gokit_mcu_stm32_xxx\\Gizwits\\gizwits_protocol.h\n\n结构体attrFlags_t、attrVals_t分别对应“p0 数据区约定”中的“4.10 WiFi模组控制设备”中的：attr_flags(1B) + attr_vals(6B)位：\n\ndevStatus_t，代码位置: gokit_mcu_stm32_xxx\\Gizwits\\gizwits_protocol.h\n\n结构体devStatus_t对应“p0 数据区约定”中的“4.9 设备MCU向WiFi模组主动上报当前状态”中的：dev_status(11B) 位：\n\n特别说明：\nA. 数据结构说明\ndataPoint_t 为应用层数据结构，开发者需要了解并会使用（具体使用方式请查看：“2.7.1 只读型数据的获取”一节）。\nattrFlags_t、attrVals_t、devStatus_t为通信层数据结构，开发者需要结合通讯协议进行理解。\nB. 位段举例说明：\nuint8_t motor_switch:1; 是一种位段的使用方式。因为 uint8_t型数据占用 8bit（8位）的空间，协议中motor_switch占用字段bit0（第一位）所以uint8_t motor_switch:1表示使用1位的空间。\nuint8_t reserve:7; 因为程序中申请内存时的最小单位是byte(字节)，而这里我们是按bit(位，8bit = 1byte)进行了使用，故需补齐不足1byte的剩余bit(使用n bit后需补齐剩余的8-n bit)。\n注：位段不能跨字节操作，否则会造成数据读写错误。\n3.2 程序主函数\n位置：gokit-soc-esp8266\\app\\user\\user_main.c中user_init() 函数：\n\n说明：该函数作为整个系统的程序入口初始化了Gagent模块和Gizwits协议模块这两个主要的部分，其中跟开发者有关的是函数是gizwitsInit()、userTimerFunc()、gizwitsUserTask()，相关说明：\n\n\n\n函数\n说明\n\n\n\n\ngizwitsInit()\n协议解析处理模块初始化函数（协议API）\n\n\nuserTimerFunc()\n定时器回调函数（100ms定时周期，与时间相关的开发逻辑可以在这里实现）\n\n\ngizwitsUserTask()\n用户事件回调函数，用户可在该函数中完成相应任务的处理\n\n\n\n3.3 用户程序初始化\n位置：user_main.c中 “//user_init 相关程序”\n\n这部分完成了RGB LED、按键、电机、温湿度、红外传感器的硬件驱动调用，对应的驱动程序实现都在gokit-soc-esp8266\\app\\driver下。\n其中完成了定时器初始化（详情查看2.3.4节）：\n\n以及系统任务初始化（详情查看2.3.5节）：\n\n3.4 定时器使用\n代码位置：app\\user\\user_main.c 中的user_init()函数\n\n相关宏定义：\n\nAPI说明：\n\n回调函数说明：\n\n在userTimerFunc() 中完成了周期100ms的定时执行，开发者可以在user_handle()中实现定时读取外设数据的操作，将读取到的数据赋值到用户区的全局结构体变量：\n\n3.5 系统任务的使用\n代码位置：app\\user\\user_main.c 中的user_init()函数\n\nAPI使用说明：\n\n回调函数说明：\n\n开发者可以自定义系统任务(system_os_post中的消息类型)，然后在系统任务回调函数中(gizwitsUserTask)添加对应的任务处理(即switch中对应的消息类型)。\n需要注意的是：任务优先级不可随意修改（共有三个优先级，提供给开发者的是优先级0）：\n\n4 配置模式说明\n开发者只有先调用“WiFi配置接口”API才能使WiFi模组进入相应的配置模式，进而完成联网、云端通信的等功能。\n“WiFi配置接口”API 位置：gokit_mcu_stm32_xxx\\Gizwits\\gizwits_protocol.h\n\n在本示例工程中是通过按键触发进入相应的配置模式，程序中触发逻辑位置：gokit_mcu_stm32_xxx\\User\\main.c\nA.进入Soft AP 模式：key2按键短按。\n\nB.进入AirLink 模式：key2按键长按。\n\nC.模组复位：key1按键长。\n\n注：开发者可以按照自己的需求来实现配置模式。\n5 协议处理函数的实现\n位置：Gizwits\\gizwits_protocol.c中gizIssuedProcess() 函数：\n该函数被Gagent模块调用，处理来自云端或APP端的相关p0数据协议。\n以下是该协议处理函数的详细介绍：\n● 首先是一些局部变量的初始化，比较重要的是“gizwitsIssued_t *gizIssuedData”它的作用是保存解析出来的协议包头：\n\n协议格式对应协议“4.10 WiFi模组控制设备”中“P0协议区”的标志位\"attr_flags\" + 数据值\"attr_vals\"\n\n● 然后是各协议命令的处理流程：\n\n由于SOC版相对MCU版去掉了串口协议等概念，故开发者在只需了解《xxx机智云接入串口通信协议文档》中的8、10三条指令：\n\n\n\n8）WiFi模组读取设备的当前状态； 10）WiFi模组控制设备；\n\n\n\n\n\n\n\n\n● 下面以以协议4.8的处理为例：\n\n其“action”值 为“0x02”，对应程序中的的case为“ACTION_READ_DEV_STATUS”\n\n之后完成了上报数据的数据类型转化（转化后的数据存储在gizwitsReport_t中的devStatus数据位中）：\n\n最后将待上报的数据以指针拷贝的方式进行输出：\n\n● 同理其他协议action值对应的宏定义的位置在Gizwits\\gizwits_protocol.h中:\n\n以上便是p0协议处理函数的详解。\n6 控制型协议的实现\n与控制型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\ngiziIssuedProcess\n该函数被gagent调用，接收来自云端或app端下发的相关协议数据\n\n\nACTION_CONTROL_DEVICE\n进行“控制型协议”的相关处理\n\n\ngizDataPoint2Event\n根据协议生成“控制型事件”，并完成相应数据类型的转换\n\n\ngizwitsEventProcess\n根据已生成的“控制型事件”进行相应事件处理（即调用相应的驱动函数）\n\n\n\n6.1 控制型事件的生成\n相关代码位置：\napp\\Gizwits\\gizwits_protocol.c 中 gizDataPoint2Event() 函数：\n功能说明：\n在该函数中完成了写类型外设事件的生成，以“红灯开关数据点”为例：\n\n这里对应协议“4.10 WiFi模组控制设备”：\n\n前面我们已经知道程序里的 “issuedData->attr_flags”就对应《微信宠物屋-机智云接入串口通信协议文档.pdf》中的“4.10 WiFi模组控制设备”中的attr_flags(1B)，作用是用来控制所选位的设备，在文档中我们可以看到attr_flags的第0位是用来选择控制LED灯开关的，即只要设置了第0位为1就表示要控制LED等开关了，代码中对应如下：\n\n接下来便是控制型事件的生成：\n\n以及完成数据的解压（详情请查看“2.8.2 数据解压与压缩处理”一节）：\n\n注意：枚举（如EVENT_LED_ONOFF）用来直观的表示事件的含义，用户自行添加、更改（位置：app\\Gizwits\\gizwits_protocol.h）\n\n6.2 控制型事件处理\n代码位置:app\\Gizwits\\gizwits_product.c 中 gizwitsEventProcess() 函数：\n功能说明：\n完成写类型外设事件的处理。\n\n这段程序功能的控制LED灯的开关：LED开关控制位 “issued->attr_vals.led_onoff” 的值若是LED_On（0x01）表示灯开，为LED_Off（0x01）表示灯关。这对应《微信宠物屋-机智云接入串口通信协议文档.pdf》中的“4.10 WiFi模组控制设备”中的attr_vals(6B)，即“数据位”，如下所示：\n\n第0位用来控制红灯亮灭，对应到在云端定义的数据点含义为：\n    = 0x00 = 红灯灭\n    = 0x01 = 红灯亮\n下面的程序基本和上面一样，只要大家看懂了《xxx-机智云接入串口通信协议文档.pdf》中的“4.10 WiFi模组控制设备”中的attr_flags(1B) 、attr_vals(6B)这两位就能编写控制型协议的程序了。\n6.3 可写型数据类型转换\n接收到来自云端的数据后，由于原始数据经过特殊处理，所以要在gizDataPoint2Event中进行相应的数据的转换。\n转换函数说明：\n\n\n\n函数\n说明\n\n\n\n\ngizDecompressionValue\n完成传输数据的压缩处理，详情查看“2.8.2 数据解压与压缩处理”一节。\n\n\ngizX2Y\n将用户区数据转化为传输数据，详情查看“2.8.1 数据点类型转换”一节。\n\n\n\n程序中对应：\n\n\n特别说明：\n网络字节序转化\n数据点为uint16、uint32型的数据要考虑网络字节序转化（uint16即使用exchangeBytes()函数），以电机控制为例：\n\n7 上报型协议的实现\n与上报型协议相关的函数调用关系如下：\n\n函数调用说明：\n\n\n\n函数\n说明\n\n\n\n\nuserTimerFunc\n获取用户区的上报型数据\n\n\ngizwitsHandle\n用户调用该接口可以完成设备数据的变化上报\n\n\ngizCheckReport\n判断是否上报当前状态的数据\n\n\ngizDataPoints2ReportData\n完成用户区数据到上报型数据的转换\n\n\ngagentUploadData\n将上报数据发送给WiFi模块\n\n\n\n7.1 只读型数据的获取\n相关代码:app\\user\\user_main.c 中 userTimerFunc() 函数：\n使用说明：\n该函数中完成了用户区上报型数据的获取。用户只需将读到的数据赋值到用户区当前设备状态结构体即可：\n\n7.2 上报状态判断\n为了让API接口更简化，处理更简单，机智云把更多的判断放到协议模块来处理，达到了开发者只要把状态更新到协议处理模块，不需要关心何时上报，由协议处理模块自动完处理的目的。\n相关代码:  \nGizwits\\gizwits_protocol.c 中 gizCheckReport() 函数：\n功能说明：\n根据协议判断是否上报当前状态的数据，判断逻辑如下：\n\n控制型数据发生状态变化，立刻主动上报当前状态\n\n用户触发或环境变化所产生的, 其发送的频率不能快于6秒每次\n\n\n协议中说明如下：(“4.9 设备MCU向WiFi模组主动上报当前状态”)\n\n以“逻辑1：控制型数据主动上报当前状态”为例：\n\n以“逻辑2：控制型数据主动上报当前状态”为例：\n\n7.3 只读型数据类型转换\n获得到用户区的原始数据后，在传输到云端前要进行相应的数据转换，所以要在gizDataPoints2ReportData中完成相应的数据的转换。\n转换函数说明：\n\n\n\n函数\n说明\n\n\n\n\ngizDataPoints2ReportData\n完成传输数据的压缩处理，详情查看“2.8.2 数据解压与压缩处理”一节。\n\n\ngizY2X\n将用户区数据转化为传输数据，详情查看“2.8.1 数据点类型转换”一节。\n\n\n\n8 机智云协议数据处理\n8.1 数据点类型转换\n机智云为使设备功能定义更加简单直接，使用户输入的数值转换成设备能够识别的uint类型，这套算法的核心公式是：y=kx+m （y：显示值；x：传输值；k：分辨率；m：增量）\n以微信宠物屋的温湿度传感器温度检测为例：\n\n取值范围：-13（Ymin） ~ 187（Ymax），分辨率：1，增量：-13 ；\n其分辨率、偏移量作为宏定义定义在app\\Gizwits\\gizwits_product.h中：\n\n根据公式：y=kx＋m，k = 1 ; m = -13\n实际传输的值：x = (y - m) / k\n转换函数在程序中的说明：\nA.X2Y的转换：\n\nB. Y2X的转换：\n\n功能定义更加\n8.2 数据解压与压缩处理\n设备端与自云端的数据交互过程中，一些特殊类型（bool和enum类型）的数据点原始数据只有被特殊处理后才可被云端解析，所以设备端在接收云端数据时要进行数据的解压处理；在向云端发送数据时进行数据的压缩处理。\n机智云已封装出了相应的处理接口：\n\n\n\n处理名称\n接口名称\n\n\n\n\nbool和enum类型数据点数据解压\ngizDecompressionValue\n\n\nbool和enum类型数据点数据压缩\ngizCompressValue\n\n\n\n以《微信宠物屋》的RGB LED控制为例，云端定义如下：\n \n对应文档中数据存储格式如下：\n\n字节序与bit序对应代码中宏定义如下：\n\n对应的数据点在接收解压时处理如下(位于gizDataPoint2Event函数中)：位于\n\n对应的数据点在发送压缩时处理如下(位于gizDataPoints2ReportData函数中)：\n\n相关支持\n1) 如果您是开发者\nGoKit是面向智能硬件开发者限量免费开放，注册我们的论坛或关注我们的官方微信均可发起申请即可。\n开发者论坛： http://club.gizwits.com/forum.php\n文档中心：http://docs.gizwits.com\n2) 如果您是团体\nGizWits针对团体有很多支持计划，您可以和GizWtis联系，快速得到GoKit以及技术支持；\n网站地址：http://www.gizwits.com/about-us\n官方二维码：\n\n"},{"title":"广和通G510模组接入方案","url":"/zh-cn/deviceDev/debug/G510.html","content":"概述\n   G510是广和通推出的一款基于GPRS的通讯模组，本篇通过讲述如何通过G510模组把MCU接入到机智云云端，并实现通讯的方案。全篇文章的内容包括G510模组的管脚介绍、SIM卡连接、供电要求、串口定义以及固件烧写方法等，合作厂商在进行设备接入时请参照以下资料进行，以免造成不可控的错误。\n模组接入准备\nG510模组管脚图\n\nSIM卡连接方法\n模块包含了一个 SIM 卡接口，这个接口符合 GSM 11.11 和 GSM 11.12 标准（基于 ISO/IEC 7816） 。\n这些标准定义了 GSM SIM 卡的电气特性、 信令和协议规范。\n模块不包含 SIM 卡槽。SIM 卡槽必须放在模块外部的用户开发板上。模块的 SIM 卡接口包括了所有必须的信号，这些信号被接到接口连接器，直接并全部连接到外部的 SIM 卡。模块支持 1.8V 或者 2.85V 电平自动识别。当模块在开机后，首先 SIM_VCC 向外部 SIM 卡输出 1.8V电压来建立通信。如果通信不成功，SIM_VCC 会再次输出 2.85V 电压，并和 SIM 卡建立通信。\n\n下图显示了一个典型的 SIM 卡接口，连接到模块。在模块开发板上，使用 MOLEX （PN 912283001 &912360001）SIM 卡槽，来实现这种连接方式。\n无论 SIM_CD 是否使用，都必须上拉，保证 SIM 卡的检测稳定。模块内部已经将 SIM_DATA 信号上拉到 SIM_VCC，外围无需再上拉。\n\nSIM 卡接口和信号的设计特别重要。为了满足设计标准和规定，以下几点是必须要遵循的设计准则：\n\nSIM 卡的位置以及 SIM 信号的走线，必须远离任何可能的电磁干扰源，像射频天线和数字开关信号等。\n\n在模块接口连接器和 SIM 卡槽之间，SIM 卡走线长度不应超过 100mm，这样满足 EMC 法则，同时提供信号的完整性。\n\n为了避免 SIM 卡时钟和数据信号 （SIM_CLK 和 SIM_DATA） 之间的串扰，建议在开发板上将它们隔开，最好是由大地隔开。\n\nSIM 卡信号应使用低容性的保护性元器件进行 ESD 保护。建议使用 AVR M1005C270MAAB(TDK) ，并且 ESD 器件应该布局在 SIM 卡的附近\n\n\n电源接入管理\n模块必须由外部3.3V 到4.5V的直流电源单独供电， 而且电源必须在此电压下允许有 2.0A 的电流通过，此电流只是在 GSM 的时隙发送时的瞬态电流。 模块提供 2 个管脚由外部来供电，如下表\n\n\n\n管脚号\n管脚名\n描述\n\n\n\n\n9\nVBAT\n直流电源 VBAT = 3.3 V to 4.5 V\n\n\n10\nVBAT\n推荐电源电压：4.0V\n\n\n\nGSM 是时分多址，在发送时隙时会导致瞬时电流波动，由此会出现电压纹波现象。此时如果不处理妥当，这些频繁的电压纹波将会降低模块的性能。建议将此纹波控制在 300mV 以内。在任何情况下，模块的供电都不应该低于它的最小电压。为了降低纹波等对电源的影响，我们建议：\n\n在模块的电源输入端使用一颗1000uF或者更大的， 低ESR的电容。 这颗电容， 越靠近模块的VBAT管脚越好。\n使用低阻的电源，电源线和 LAYOUT 走线。\n电源走线越短越好。\n使用滤波电容给模块的供电滤波，如下表：\n\n\n\n\n推荐的容值\n功能\n描述\n\n\n\n\n1000 uF\n电流纹波\n降低发送时隙时对电源的影响，尽可能使用大容量电容\n\n\n10 nF, 100 nF\n数字开关噪声\n滤除由时钟，数字信号引起的噪声\n\n\n8.2 pF, 10 p\nDCS1800/PCS1900 MHz GSM 频段\n滤除由 GSM 高频段传输中带来的杂波\n\n\n33 pF, 39 pF\nGSM850/GSM900 MHz GSM 频段\n滤除由 GSM 低频段传输中带来的杂波\n\n\n\n串口的定义和使用\nG510 有 3 个 UART 串口。\n\nUART1 是一个完全独立的 8 线串行通信接口 (UART1). 这是主串口。默认端口配置为115200bps、 8 个数据位、1 个停止位和无奇偶校验。主要用于固件下载、log打印等。\n\n\n\n\n管脚号\n管脚名\n描述\n性能\n\n\n\n\n19\nUART1_TXD\n模块发送数据\n模块发送数据\n\n\n18\nUART1_RXD\n推模块接收数据\n模块接收数据\n\n\n21\nUART1_CTS\n清空发送\n模块切换接收\n\n\n20\nUART1_RTS\n请求发送\n模块提醒 DTE 接收\n\n\n\n\nUART2 是一个 2 线串口，只支持部分 AT 命令，用于和MCU通信。UART 2 默认端口配置为 115200bps、8 个数据位、1 个停止位和无奇偶校验。\n\n\n\n\n管脚号\n管脚名\n描述\n性能\n\n\n\n\n40\nUART1_TXD\n模块发送数据\nG510发送数据\n\n\n39\nUART1_RXD\n推模块接收数据\nG510接收数据\n\n\n\n\nHOST UART 是个 Debug UART，主要用来下载，校准，Trace 等，不支持 AT 命令。此口只在生产调试时使用，用户只需接测试点。\n\n参考资料\n如需获取更多的G510模组参考资料，请登陆广和通官方网站http://www.fibocom.com.cn/down.aspx?FId=n14:14:8 进行获取。\n如需获取接入机智云平台参考资料，请登陆机智云官方网站文档中心http://docs.gizwits.com/zh-cn/overview/overview.html 进行获取。\n搭建环境\n焊接对应管脚\nG510模组电路焊接：参照下方电路图，使用杜邦线连接以下管脚\n\n\n\n管脚\n参数\n\n\n\n\n1\nGND\n\n\n10\nVBAT\n\n\n19\nUART1_TXD\n\n\n18\nUART1_RXD\n\n\n14\nPOWER_ON\n\n\n\n连接模组\n电脑插入USB转TTL串口模块，查看模块所在COM口\n\n使用杜邦线将USB转TTL串口模块与焊接好的G510模组连接。\n\n下载固件与烧写工具\n下载G510的相对应的GAgent固件，打开烧写工具Fibocom_upgrade V1.3。\n\n烧写过程\n步骤1.切断电源\n先断开模组的供电（可拨掉VCC的杜邦线）。\n步骤2.配置烧写软件\n按照下图配置Fibocom_upgrade V1.3\n\n步骤3.进入烧写\n重新接上模组的VCC供电，把power_on打到低电平（接GND），烧写工具会自动运行。\n如果烧写失败，可能是模组还没开机，检查G510 开关机状态，VDD管脚电平为 0V 时，G510 处于关机状态，电平大于 2.85V 时，G510 处于开机状态。\n当 POWER_ON 管脚信号为低电平并且持续超过 800ms 时，模块将开机。\n\n效果验证\n1.使用杜邦线将USB转TTL串口模块与G510模组的UART2（注意:和烧录固件的不是同一串口）连接。\n\n\n\nG510模组管脚\n连接USB转TTL管脚\n\n\n\n\n1:GND\nGND\n\n\n10：VBAT\nVCC\n\n\n39：UART2_RXD\nTRX\n\n\n40：UART2_TXD\nTXD\n\n\n\n2.使用机智云XPG助手模拟MUC功能。\n按照下图配置，更多使用方法请点击这里\n\n3.另外，可以再增加一个USB转TTL模块，通过接G510的UART1串口来输出LOG日志，可以看见G510连接GAgent的过程。\n\n\n\nG510模组管脚\n连接USB转TTL管脚\n\n\n\n\n1:GND\nGND\n\n\n18：UART1_RXD\nTRX\n\n\n19：UART1_TXD\nTXD\n\n\n\n注：波特率为：115200\n注意：由于没有连接SIM卡，所以模组无法真正的连上网络，会一直报错。\n\n"},{"title":"机智云GAgent For HF-LPT120/LPB120/LPT220串口烧写说明","url":"/zh-cn/deviceDev/debug/HF-LPT120.html","content":"概述\n本文针对汉枫HF-LPT120模块进行串口模式烧写流程整理了一篇操作流程。合作厂商在进行模块烧写操作时请依次按照如下步骤进行，否则会产生不可控的错误。\n注意事项：HFLPT120/LPB120/LPT220 的串口模式烧写流程是一样的。\n操作流程\n1. 下载HF-LPT120对应的固件\n\n\n\n2. 解压下载的固件包\n\n解压之后会发现有两个文件，其中一个文件名为带有UART的bin文件为我们所需要的固件。\n3. 设备连接\n将HF-LPT120模块按照如下原理图进行接线，注意nReload需要输入低电平，本实验直接接地处理。KEY1实现外部复位功能。\n\n\n4. 串口设置\n4.1 确认串口参数\n将上述串口连接电脑后，通过“我的电脑”->“管理”-> “设备管理器”->“端口（COM 和LPT）”选项中可以看到相应增加的COM口。\n\n4.2 下载串口工具SecureCRT\n下载地址：http://pan.baidu.com/s/1dECLxYD\n下载解压后双击打开SecureCRT，点击快速连接后会弹出串口配置对话框。\n\n\n串口配置协议为Serial，端口为上述2.4.1中的COM口，波特率设置为230400（关键），数据位为8位，停止位为1位，无奇偶校验，最后点击连接。\n连接成功后，在SecureCRT工作区间会有光标闪烁。\n\n5. 烧写操作\n5.1 进入烧写模式\n当串口连接成功之后，将HF-LPT120进行复位（按下2.3节原理图所示的KEY1后松开）或者给模块重新上电后迅速连续单击键盘空格键，将会出现如下信息表示模块进入烧写模式。\n\n备注：此步骤不易操作实现，需要多次进行试验，当进行进入烧写模式操作始终无法显示上述信息的时候要注意检查串口设置是否正确，待确保串口设置无误后再次进行连接操作。\n上述窗体显示信息中，各命令解释如下： \n\n\n\nItem\nValue\n\n\n\n\n命令‘B’\n清除所有设置参数，包括出厂参数等。\n\n\n命令‘S’\n升级应用程序；SDK等编译出来文件（需使用串口方式的升级文件）的用此选项升级。\n\n\n命令‘G’\n执行应用程序。\n\n\n\n5.2 进行烧写\n输入“S”升级应用程序，再输入“Y”进入接收固件状态。\n\n当窗体连续打印出“CC”后选择”菜单栏” 中“传输”->”发送Xmode(N)”， 选择2.2节中所示的固件文件，点击发送。\n\n等待一段时候后，出现如上述信息表示烧写成功。\n"},{"title":"FIBOCOM_G510_datasheet_cn","url":"/zh-cn/module_source/G510/G510_datasheet.html","content":"1.    简介\n1.1 产品描述\nG510 模块支持 GSM 四频 850/900/1800/1900 MHz，模块的 GPRS 支持 class 10。该模块就是一个超小型的移动电话，它能够被集成进任何需要通过蜂窝网络进行语音通话或数据传输的系统或者产品中。因此，它能够大大提高系统的能力，将其从一个独立的，孤立的产品提升到一个强大的拥有全球通讯能力的高性能系统。\n1.2 产品规格\n表1-1\n\n2. 硬件概述\n2.1 硬件框图\n下图显示了模块的硬件框图。模块包括三个部分：数字部分，模拟部分和 GSM 收发机部分。\n\n图 2-1 G510 硬件框图\n2.1.1 数字部分\n1. 集成 Flash\n2. 集成 PSRAM\n3. 通信串口\n4. SIM 卡\n5. RTC 时钟\n2.1.2 模拟部分\n1. 电源管理\n2. 锁相环\n3.1.3 GSM 收发机部分\n1. G510 Q50-00 支持 GSM 850/900/1800/1900 频段\n2. 射频接收机，包括低噪声放大器，混频器，PLL，I/Q 输入输出\n3. GSM 数据接收发射芯片\n4. 射频前端控制，包括 RFPA 和天线开关\n2.2 电源\n模块必须由外部 3.3V 到 4.5V 的直流电源单独供电，而且电源必须在此电压下允许有 2.0A 的电流通过，此电流只是在 GSM 的时隙发送时的瞬态电流。 模块提供 2 个管脚由外部来供电，如下表：\n表2-2\n\n2.2.1 电源管理\n设计模块电源时必须小心谨慎。外部的直流电源不仅仅是给模块的数字和模拟接口供电，同时，也直接给射频部分的功率放大器供电。因此，任何的供电不稳，纹波大或者噪声等，都将直接影响到模块的性能。\nGSM 是时分多址，在发送时隙时会导致瞬时电流波动，由此会出现电压纹波现象。此时如果不处理妥当，这些频繁的电压纹波将会降低模块的性能。\n建议将此纹波控制在 300mV以内。在任何情况下，模块的供电都不应该低于它的最小电压。\n为了降低纹波等对电源的影响，我们建议：\n1. 在模块的电源输入端使用一颗 1000uF 或者更大的，低 ESR 的电容。这颗电容，越靠近模块的 VBAT管脚越好。\n2. 使用低阻的电源，电源线和 LAYOUT 走线。\n3. 电源走线越短越好。\n使用滤波电容给模块的供电滤波，如下表：\n表2-3\n\n2.3 开关机\n模块的开关机涉及到 2 个硬件信号， POWER_ON 和 VDD。\nPOWER_ON 是开关机最重要的信号，而 VDD 电平能说明模块是否已经开机。当 VDD 的电平是 0V时，说明此时处于关机状态。当 VDD 的电平是 2.85V 时，说明此时模块已经开机。\n表2-4\n\n2.3.1 模块开机\n模块处于关机状态时，PMU 工作在低功耗状态，只有 RTC 在工作。当 POWER_ON 信号为低电平并且持续超过 800ms 时，模块将开机。下图表明 POWER_ON 拉低 800ms 后成功开机：\n\n图 2-2 模块开机成功\n下图表明在 POWER_ON 信号拉低的时间为 600ms 时，模块无法开机：\n\n图 2-3 模块开机失败\n2.3.2 模块关机\n有以下两种模块关机方式：\n1. 把 POWER_ON 拉低超过 3s。\n\n图 2-4 模块关机成功\n模块开机后 POWER_ON 的常态是高电平。当把 POWER_ON 拉低超过 3s 后，模块将会关机。此关机会逐步关掉所有的应用接口（包括 UART,SIM card 等）和注销网络。\n2.4 时钟信号\n模块包含了一种实时时钟 (RTC) 机制，执行许多内部函数，其中之一是保持时间。RTC 子系统嵌入在 PMU，并且在所有模块工作模式（关闭、空闲、睡眠)下运行，只要供电在最低工作电平以上就一直运行。\n当主电源不供电时，备用电池或电容可以通过接口连接器的 RTC pin 脚进行供电。\n当主电源供电和 RTC 引脚与模块断开连接，RTC 定时器将会重置，并且当前时间和日期将会丢失。下一次通电，模块的时间和日期将需要再次设置。\n2.4.1 RTC 描述\n表2-5\n\n2.4.2 RTC 应用\n模块的时钟和数据可以按照以下方式进行设置应用：\n1. 自动从 GSM 网络检索。由于模块在 GSM 网络中，支持自动时区更新操作，它将与连接到网络时的日期和本地时间更新 RTC。RTC 会继续从那点时间开始运作。\n2. VBACKUP（pin6）的输入电压范围：2.0V~3.3V。当 VBACKUP 电压低于 2.0V，当前时间和日期将会丢失。\n2.4.3 RTC 功耗\n当模块断电后，仅 RTC 供电情况下模块的功耗情况：\n表2-6\n\n2.5 串口\nG510 有 3 个 UART 串口。\nUART1 是一个完全独立的 8 线串行通信接口 (UART1). 这是主串口。\nUART2 是一个 2 线串口，只支持部分 AT 命令。\nHOST UART 是个 Debug UART，主要用来下载，校准，Trace 等，不支持 AT 命令。\n2.5.1 UART1\n模块 UART1 是一个标准的 8 信号总线。这个 UART 用于与模块和命令接口、GPRS 数据、编程和软件升级之间的所有通信。\n模块被定义为 DCE，而用户的应用板被定义为 DTE。这些定义适用于 UART 信号的命名规定，和数据流动方向，如下表所示：\n表2-7\n\n推荐连接方法：\n表2-8\n\n支持所有的流控方式：硬件流控或非流控。\nUART 1 默认端口配置为 8 个数据位、1 个停止位和无奇偶校验。\n2.5.2 UART2\n表2-9\n\nUART2 支持部分 AT 命令，详见 AT 命令手册。\n表2-10\n\n2.5.3 HOST UART\nHOST UART 是个 Debug UART，主要用来下载，校准，Trace 等，不支持 AT 命令。此口只在生产调试时使用，用户只需接测试点。\n表2-11\n\n2.6 SIM 接口\n模块包含了一个 SIM 卡接口，这个接口符合 GSM 11.11 和 GSM 11.12 标准（基于 ISO/IEC 7816）。这些标准定义了 GSM SIM 卡的电气特性、 信令和协议规范。\n模块不包含 SIM 卡槽。SIM 卡槽必须放在模块外部的用户开发板上。模块的 SIM 卡接口包括了所有必须的信号，这些信号被接到接口连接器，直接并全部连接到外部的 SIM 卡。\n模块支持 1.8V 或者 2.85V 电平自动识别。当模块在开机后，首先 SIM_VCC 向外部 SIM 卡输出 1.8V电压来建立通信。如果通信不成功，SIM_VCC 会再次输出 2.85V 电压，并和 SIM 卡建立通信。\n表2-12\n\n2.6.1 SIM 连接\n下图显示了一个典型的 SIM 卡接口，连接到模块。在模块开发板上，使用 MOLEX （PN 912283001 &912360001）SIM 卡槽，来实现这种连接方式。\n无论 SIM_CD 是否使用，都必须上拉，保证 SIM 卡的检测稳定。模块内部已经将 SIM_DATA 信号上拉到 SIM_VCC，外围无需再上拉。\n图 2-5 SIM 卡参考电路\n\n2.6.2 SIM 设计准则\nSIM 卡接口和信号的设计特别重要。为了满足设计标准和规定，以下几点是必须要遵循的设计准则：\n1. SIM 卡的位置以及 SIM 信号的走线，必须远离任何可能的电磁干扰源，像射频天线和数字开关信号等。\n2. 在模块接口连接器和 SIM 卡槽之间，SIM 卡走线长度不应超过 100mm，这样满足 EMC 法则，同时提供信号的完整性。\n3. 为了避免 SIM 卡时钟和数据信号 （SIM_CLK 和 SIM_DATA） 之间的串扰，建议在开发板上将它们隔开，最好是由大地隔开。\n4. SIM 卡信号应使用低容性的保护性元器件进行 ESD 保护。建议使用 AVR M1005C270MAAB(TDK) ，并且 ESD 器件应该布局在 SIM 卡的附近。\n2.7 控制和指示接口\nG510 的一些信号是用来控制和显示模块的工作状态。以下描述为这些信号定义和应用。\n表2-13\n\n2.7.1 VDD 参考标准\n模块有一个规定的电压输出信号 VDD。要求输出 2.8V 电压，用于客户应用。能够提供 200mA 的电流，作为外部数字电路的电源。\n当模块开机时，VDD 输出。所以 VDD 可以指示模块的开机。\n注意：VDD 是来自模块的主电源，任何通过 VDD 供电的电路也都源自模块的 VBAT 供电。模块整体的供电电流受 VDD 工作的影响。\n表2-14\n\n2.7.2 EMERG_RST\nEMERG_RST 定义为紧急关机，此 pin 脚被拉低后 1s 内系统将会关机，如下图：\n注意：它只能作为紧急情况下使用，尽量减少使用此 pin 脚的次数。\n\n图 2-6 拉低 EMERG_RST, 模块紧急关机\n2.7.3 LPG\n作为交替产生的同步信号，这个控制脚可以用来驱动应用平台的 LED 指示灯。\n推荐电路如下：\n\n图 2-7 LPG 参考电路LED 和 PIN 脚的状态：LED 灭为高电平，LED 亮为低电平。\n表2-15\n\n3 电气特性和环境特性\n3.1 电气特性\n下表给出了模块接口信号的最大电气特性。\n注意：超出最大值可能会导致模块的永久性损坏。\n表3-1\n\n3.2 环境特性\n本表列出了模块工作的环境条件。\n注意：超出最大值可能会导致模块的永久性损坏。\n表3-2\n\n3.3 管脚定义说明\n下表总结了所有管脚规范。\n注意：不是由客户应用程序使用的接口必须悬空。模块采用了必要的内部电路，以保持与默认状态无关的信号。对于没有应用的管脚，不要连接任何的器件或施加任何的电压。\n表3-3\n\n注意： T=三态\n3.4 管脚定义图示\n\n图 3-1 管脚定义图\n4 结构设计\n4.1 结构尺寸图\n下图显示了模块的结构图：\n图 4-1 结构图\n\n4.2 推荐 PCB Layout\n下图为 PCB 的推荐布局：\n图 4-2 推荐 PCB 设计 （顶部视图）\n\nI. 附录 - 资源\n• 广和通G510模组烧写方法\n• 获取广和通G510 Gagent日志（教程中“4.获取广和通G510 Gagent日志”）\n• GAgent for 广和通Fibocom G510 04020027\n"},{"title":"HF-LPB100_datasheet_cn","url":"/zh-cn/module_source/HF/HF-LPB100.html","content":"1.产品特点\n●  支持802.11b/g/n无线标准\n●  自主开发MCU平台，超高性价比\n●  超低功耗\n●  支持STA/AP/AP+STA工作模式\n●  支持无线和远程升级固件\n●  支持多TCP链路接入（支持5路）应用\n●  支持外置或内置天线选项\n●  3.3V单电源供电\n●  超小尺寸: 23.1mm x 32.8mm x3.45±0.3mm\n●  产品通过FCC/CE标准认证\n2.产品参数\n\nI. 附录 - 资源\n• HF-LPB100_datasheet_cn下载\n• HF-LPB100串口烧写说明\n• 获取汉枫LPB100 Gagent日志（教程中“2.获取汉枫LPB100 Gagent日志”）\n• GAgent for HF LPB100 04020021\n"},{"title":"HF-LPB120_datasheet_cn","url":"/zh-cn/module_source/HF/HF-LPB120.html","content":"1.产品特点\n●  支持802.11b/g/n 无线标准\n●  支持STA/AP工作模式\n●  支持无线和远程升级固件，提供无线批量配置工具\n●  可提供SDK开发包，支持二次开发\n●  可选板载PCB天线或外置天线接口（I-PEX）\n●  超小尺寸：23.1mm x 32.8mm x 3.5mm\n●  产品通过FCC/CE/TELEC标准认证\n2.产品参数\n\nI. 附录 - 资源\n• HF-LPB120_datasheet_cn下载\n• HF-LPB120/HF-LPT120串口烧写说明\n• 获取汉枫LPB120/LPT120 Gagent日志（教程中“3.获取汉枫LPB120 Gagent日志”）\n• GAgent for HFLPT120/LPB120/LPT220 04020025\n"},{"title":"HF-LPT120_datasheet_cn","url":"/zh-cn/module_source/HF/HF-LPT120.html","content":"1.产品特点\n●  支持802.11b/g/n无线标准\n●  支持STA/AP工作模式\n●  支持无线和远程升级固件\n●  可提供SDK开发包，支持二次开发\n●  可选外置天线IPEX连接器或PCB天线\n●  3.3V单电源供电\n●  超小尺寸: 22mm x 13.5mm x6mm, 1x10mm 2mm 插针封装\n2.产品参数\n\nI. 附录 - 资源\n• HF-LPT120_datasheet_cn下载\n• HF-LPB120/HF-LPT120串口烧写说明\n• 获取汉枫LPB120/LPT120 Gagent日志（教程中“3.获取汉枫LPB120 Gagent日志”）\n• GAgent for HFLPT120/LPB120/LPT220 04020025\n"},{"title":"HF-LPT220_datasheet_cn","url":"/zh-cn/module_source/HF/HF-LPT220.html","content":"1.产品特点\n●  支持802.11b/g/n 无线标准\n●  支持STA/AP工作模式\n●  支持无线和远程升级固件\n●  可提供SDK开发包，支持二次开发\n●  可选板载PCB天线或外置天线接口\n●  超小尺寸：22mm x 13.5mm x 3mm\n●  产品通过FCC/CE/TELEC标准认证\n2.产品参数\n\nI. 附录 - 资源\n• HF-LPT220_datasheet_cn下载\n• GAgent for HFLPT120/LPB120/LPT220 04020025\n"},{"title":"TinyCon3350-M26_datasheet","url":"/zh-cn/module_source/TinyCon3350-M26/TinyCon3350-M26.html","content":"1 综述\nM26模块是一款工业级的四频段GSM/GPRS无线模块。其工作频段是：GSM850MHz，EGSM900MHz，DCS1800MHz和PCS1900MHz。\nM26具有15.8mm × 17.7mm × 2.3mm的超小尺寸，能够满足设备无线远程遥控设备的需求。\nM26是贴片式模块，44个管脚，采用LCC封装，并通过焊盘内嵌于各类数传产品应用中，提供了模块与客户主板间丰富的硬件接口。\n备注：该模块完全符合 RoHS 标准。\n1.1. 主要性能\n表 1：模块主要性能\n\n备注：当模块工作于此温度范围, 可能发生偏离 GSM 规范的现象，例如频偏和相位误差会增加，但是不会掉线。\n表 2：编码格式和耦合时最大网络数据速度率\n\n1.2. 功能框图\n下图为M26功能框图，阐述了其主要功能\n• 电源管理\n• 存储器\n• GSM射频\n• 接口部分\n-电源供电\n-开关机接口\n-串口\n-SIM卡接口\n\n图 1：功能框图\n1.3 管脚描述\n\n图 2：管脚分配图\n表 3：参数定义\n\n表 4：引脚描述\n\n1.4 Flash 空间分配\nTinyCon3350-M26模块内置了24Mbit Flash存储器。Flash地址分配如下图所示：\n\n图 3：Flash 空间分配图\nTinyCon3350-M26模块为用户分配了200KB的编程代码空间\nl RAM\nTinyCon3350-M26模块为嵌入式应用预留了100KB的内存编程\n2应用接口\nM26模块有44个 (1.5mm × 0.7mm)贴片引脚。以下章节详细阐述了模块各组接口的功能：\n• 电源供电 (请参考 3.3 章节)\n• 开关机控制口 (请参考 3.4 章节)\n• 省电技术 (请参考 3.5 章节)\n• RTC (请参考 3.7 章节)\n• 串口 (请参考 3.8 章节)\n• SIM 卡接口 (请参考 3.11 章节)\n2.1 电源供电\n2.1.1. 模块电源供电特性\n在 GSM/GPRS 模块应用设计中，电源设计是很重要的一部分。由于 GSM 发射时每隔 4.615ms 会有一个持续 577us（即 1/8 的 TDMA 周期（4.615ms））的突发脉冲。在突发脉冲阶段内，电源必须能够提供高的峰值电流，保证电压不会跌落到模块最低工作电压。\n对于 M26 模块，在最大发射功率等级下模块的峰值电流会达到 1.6A，这会引起 VBAT 端电压的跌落。为确保模块能够稳定正常工作，建议模块 VBAT 端的最大跌落电压不应超过 400mV。\n\n图 4：模块发射时的电压电流波形图\n2.1.2. 减少电压跌落\n模块电源 VBAT 电压输入范围为 3.3V~4.6V。为保证 VBAT 电压不会跌落到 3.3V 以下，在靠近模块VBAT 输入端，建议并联一个低 ESR(ESR=0.7Ω)的 100uF 的钽电容，以及 100nF、33pF（0603 封装）、10pF（0603 封装）滤波电容，VBAT 输入端参考电路如图 4 所示。并且建议 VBAT 的 PCB 走线尽量短且足够宽，减小 VBAT 走线的等效阻抗，确保在最大发射功率时大电流下不会产生太大的电压跌落。建议 VBAT走线宽度不少于 2mm，并且走线越长，线宽越宽。\n\n图 5：VBAT 输入参考电路\n2.1.3. 供电参考电路\n电源设计对模块的供电至关重要，必须选择能够提供至少 2A 电流能力的电源。若输入电压跟模块的供电电压的压差不是很大，建议选择 LDO 作为供电电源。若输入输出之间存在比较大的压差，则使用开关电源转换器。\n下图是+5V 供电的参考设计，采用了 Micrel 公司的 LDO，型号为 MIC29302WU。它的输出电压是 4.0V，负载电流峰值到 3A。为确保输出电源的稳定，建议在输出端预留一个稳压管，并且靠近模块 VBAT 管脚摆放。建议选择反向击穿电压为 5.1V，耗散功率为 1W 以上的稳压管。\n\n图 6：供电输入参考设计\n备注：建议通过控制电源芯片的使能脚控制模块的电源，当模块工作异常时可以通过控制使能脚重启模块；也可以通过 P 通道的 MOSFET 开关来控制模块电源供应。\n2.2. 开关机\n控制 PWRKEY 引脚的方法是直接使用一个按钮开关。按钮附近需放置一个 TVS 用以 ESD 保护。下图为参考电路：\n2.2.1 PWRKEY 引脚开机\n模块正常开机方式是通过 PWRKEY 引脚来开机。将 PWRKEY 置为低电平，大约 1s 后模块开机成功。\n推荐使用开集驱动电路来控制 PWRKEY 引脚。下图为参考电路：\n\n图 7：开集驱动开机参考电路\n另一种控制 PWRKEY 引脚的方法是直接使用一个按钮开关。按钮附近需放置一个 TVS用以 ESD 保护。下图为参考电路：\n\n图 8：按键开机参考电路\n开机时序图如下图所示：\n\n图 9：开机时序图\n备注：在拉低管脚 PWRKEY 之前，保证 VBAT 电压稳定。建议 VBAT 上电到管脚 PWRKEY 拉低之间的时间T1 为 100ms 左右。\n2.2.2. 关机\n模块通过以下的方式可以关机：\n• 正常关机：控制 PWRKEY 引脚关机\n• 低压关机：模块检测到 VBAT 低压时，会自动关机。\n2.2.2.1. PWRKEY 引脚关机\n模块在开机状态下，PWRKEY 管脚拉低一段时间，模块关机。\n关机过程中，模块需要注销GSM网络，注销时间与当前网络状态有关，经测定用时约2s~12s，因此建议延长 12s 后再对模块进行断电或重启的操作，以确保在完全关机之前让软件保存好重要数据。\n模块内核程序检测 PWRKEY 拉低后，通过回调 API 函数会使模块关机。\n关机之后，模块进入关机模式。关机时序见下图。\n\n图 10：关机时序\n备注：要实现关机功能，PWRKEY 引脚不能一直拉低。否则，关机后模块又上电重新开机了, 相当于模块重启。 \n2.2.2.2 低压自动关机\n低压将引起模块关机。模块会持续监测 VBAT 端的电压。如果出现以下几种情况，模块会通过回调函数提示给应用程序。\nl VBAT电压低于3.5V：低压告警。\nl VBAT电压低于3.3V：低压关机\n2.2.3 推荐的系统开关机电路\n为了确保OpenCPU系统的稳定性，建议使用一个低功耗的微处理器监控TinyCon3350-M26模块的运行状态。该微处理器应具有若干GPIO、一路可选的AD输入接口。系统架构框图如下图所示。该系统架构具有以下两个优点：\nl 当AD检测到VBAT电压过低或过高时，微处理器通过控制PWRKEY关闭模块，并且通过控制PMOS 管切断VBAT。\nl TinyCon3350-M26模块正常工作时，定时输出脉冲给微处理器。如果微处理器超时未检测到脉冲输入， 微处理器将首先切断VBAT，然后再给模块重新上电。\n\n图 11：推荐的系统开关机系统框图\n除此之外，看门狗器件也能被用于控制模块的电源。要求看门狗芯片的看门狗超时时间至少1.6s，如TI的TPS3823-33DBVR芯片。模块的一个GPIO口连接到看门狗的输入脚用来对看门狗喂狗。如果定时喂狗时间过了，看门狗将关闭模块电源。关于看门狗电路的示意图显示如下。\n\n图 12：看门狗电路\n备注：如果模块的电源由看门狗控制且模块仅仅由 VRTC 供电，当电源 VBAT 切断时，实时时钟误差大约为 1 天 5 分钟。\n2.3. RTC\nM26 模块支持 RTC 实时时钟功能，RTC 的供电设计可以参考如下的三种方式：\n•使用 VBAT 作为 RTC 的供电电源；\n当模块关机后且 VBAT 没有断电的情况下，实时时钟 RTC 还是有效的，因为此时 VBAT 仍旧在给模块的 RTC 域供电。在这种模式下，VRTC 管脚可以悬空处理。\n•使用 VRTC 作为 RTC 的供电电源；\n如果 VBAT 在模块关机后被移除，需要在 VRTC 管脚接入纽扣电池或者超级电容等类似的备份电源用以维持实时时钟 RTC。\n•同时使用 VBAT 和 VRTC 作为 RTC 的供电电源；\n由于仅给 VRTC 管脚供电来维持 RTC 时间，会产生大约每天 5 分钟的误差，因此当 RTC 功能需要时，建议给 VBAT 和 VRTC 管脚同时供电。推荐的 RTC 供电设计电路如下图所示：\n\n图 13: 使用不可充电电池给 VRTC 管脚供电\n\n图 14: 使用可充电电池给 VRTC 管脚供电\n\n图 15: 使用超级电容给 VRTC 管脚供电\n2.4. 串口\n主串口支持固定波特率和自适应波特率。自适应波特率支持范围 4800bps 到 115200bps。\n主串口：\n• TXD：发送数据到 DTE 设备的 RXD 端。\n• RXD：从 DTE 设备 TXD 端接收数据。\n表 5：串口逻辑电平\n\n表 6：串口管脚定义\n\n2.4.1. 主串口\n2.4.1.1. 主串口特点\n• 包括数据线 TXD 和 RXD。\n• 8 个数据位，无奇偶校验，一个停止位。\n• 硬件流控默认关闭，软件流控暂不支持。\n• GPRS 数传等。串口支持软件多路复用功能，软件升级。\n• 支持波特率：300，600，1200，2400，4800，9600，14400，19200，28800，38400，57600，115200。\n• 模块默认设置为自适应波特率。自适应波特率支持以下波特率：4800， 9600， 19200， 38400， 57600， 115200bps。\n2.4.1.2. 串口参考设计\n\n图 16：串口三线制连接方式示意图\n2.4.1.3. 软件升级\n主串口 TXD，RXD 可以用来升级软件。在软件升级过程中，PWRKEY 管脚必须拉低。软件升级可以参考下图连线：\n\n图 17：软件升级连线图\n2.4.2. 调试串口\n调试串口：\n• 数据线：DBG_TXD 和 DBG_RXD\n• 调试口仅用作软件调试，波特率配置为 460800bps\n• 串口会自动向外面输出 log 信息\n调试串口连线参考如下方式连接：\n\n图 18：软件调试连线图\n2.4.3. 串口应用\n3.3V 电平情况下的电平匹配电路参考设计如下。如果 MCU/ARM 是 3V 的电平，则根据分压原则，将电阻 5K6 要改为 10K。\n\n图 19：3.3V 电平转换电路\n备注：强烈建议当主机系统电平是 3V 或者 3.3V 时，在模块和主机的串口连接上加入分压电路以使电平匹配。对于更高的电压系统之间的电平匹配，需要在模块和主机之间增加电平转换芯片，要进一步了解信息，请参考文档 [14]。\n下图是标准 RS-232 接口和模块之间的连接示意图。客户需要确保电平转换芯片连接到模块的 IO 电压是 2.8V。\n\n图 20：RS232 电平转换电\n2.5 SIM 卡接口\nSIM 卡接口支持 GSM Phase1 规范的功能，同时也支持 GSM Phase 2+规范的功能和 FAST 64 kbps SIM 卡（用于 SIM 应用工具包）。\nSIM 卡通过模块内部的电源供电，支持 1.8V 和 3.0V 供电。\n表 7：SIM 卡接口管脚定义\n\n下图是使用 6-pin 的 SIM 卡座接口参考电路：\n图 21：6-pin SIM 卡座参考电路图\n\n在 SIM 卡接口的电路设计中，为了确保 SIM 卡的良好的性能和不被损坏，在电路设计中建议遵循以下设计原则：\n• SIM卡座靠近模块摆放，尽量保证SIM卡信号线布线不超过200mm。\n• SIM卡信号线布线远离RF线和VBAT电源线。\n• SIM卡座的地与模块的SIM_GND布线要短而粗。SIM_VDD与SIM_GND布线保证不小于0.5mm，且在SIM_VDD与GND之间的旁路电容不超过1uF，并且靠近SIM卡座摆放。\n• 为了防止SIM_CLK信号与SIM_DATA信号相互串扰，两者布线不能太靠近，并且在两条走线之间增加地屏蔽。此外，SIM_RST信号也需要地保护。\n• 为了确保良好的ESD性能，建议SIM卡的引脚增加TVS管。选择的TVS管寄生电容不大于50pF；ESD保护器件尽量靠近SIM卡卡座摆放，SIM卡信号走线应先从SIM卡卡座连到ESD保护器件再从ESD保护器件连到模块。在模块和SIM卡之间需要串联22欧姆的电阻用以抑制杂散EMI，增强ESD防护。SIM卡的外围器件应尽量靠近SIM卡座摆放。\n• 在SIM_DATA，SIM_VDD，SIM_CLK和SIM_RST线上并联33pF电容用于滤除的射频干扰。\n3 天线接口\nM26 包含两个天线接口，GSM 天线和 BT 天线接口。管脚 35 是 GSM 天线输入端，管脚 26 是 BT 天线输入端。GSM 和 BT 接口是具有 50Ω 特性阻抗的接口。\n3.1. GSM 天线接口\n模块提供了 GSM 天线接口引脚 RF_ANT。\n表 8：GSM 天线管脚定义\n\n3.1.1. 参考设计\n对于天线接口的外围电路设计，为了能够更好地调节射频性能，建议预留匹配电路。天线连接参考电路如下图所示。其中 C1，C2 缺省不贴，只贴 0 欧姆 R1 电阻。\n\n图 22：射频参考电路\nM26提供了一个RF焊盘接口供连接外部天线。从该焊盘到天线连接器间射频走线的特性阻抗要控制在50欧姆左右，且走线尽可能短。为了获得更好的射频性能，RF接口两侧各有两个接地焊盘。\n为了最小化 RF 走线或者 RF 线缆损耗，必须谨慎设计。建议线损和天线要满足下述两个表格的要求。\n表 9：线损要求\n\n表 10：天线要求\n\n3.1.2. RF 输出功率\n表 11：RF 传导功率\n\n3.1.3. RF 接收灵敏度\n表 12：RF 传导灵敏度\n\n3.1.4. 工作频率\n表 13：模块工作频率\n\n3.1.5. 推荐 RF 焊接方式\n如果连接外置天线的射频连接器是通过焊接方式与模块相连的，请务必注意连接线的剥线方式及焊接方法，尤其是地要焊接充分，请按照下图中正确的焊接方式进行操作，以避免因焊接不良引起线损增大。\n\n图 23：天线连接器焊接形式\n4 电气性能，可靠性\n4.1. 绝对最大值\n下表所示是模块数字、模拟管脚的电源供电电压电流最大耐受值。\n表 14：绝对最大值\n\n4.2. 工作温度\n下表所示为模块工作温度。\n表 15：工作温度\n\n备注：当模块工作在此温度范围时，工作性能可能会偏离 GSM 规范，例如频率误差或者相位误差会增大，但是不会掉线。\n4.3. 电源额定值\n表 16：模块电源额定值\n\n备注\n\n功率等级 5 \n\n功率等级 0 \n\n在 EGSM 900 频段下的 4 发 1 收功率有下降，故其耗流比 3 发 2 收要小。\n\n\n4.4. 耗流\n耗流值如下表所示。\n表 17：模块耗流\n\n备注：GPRS CLASS 12为默认设置。模块可以通过AT+QGPCLASS设置GPRS从CLASS1到CLASS12。设置较低的CLASS等级，模块的电源供电电流会降低要求。\n4.5. 静电防护\n在模块应用中，由于人体静电，微电子间带电摩擦等产生的静电，通过各种途径放电给模块，可能会对模块造成一定的损坏，所以ESD保护必须要重视，不管是在研发、生产组装、测试等过程，尤其在产品设计中，都应采取防ESD保护措施。如电路设计在接口处或易受ESD点增加ESD保护，生产中佩戴防静电手套等。\n下表为模块重点PIN脚的ESD耐受电压情况。\n表 18：ESD 性能参数（温度：25℃, 湿度：45%）\n\n5 机械尺寸\n该章节描述了模块的机械尺寸。\n5.1. 模块机械尺寸\n\n图 24：M26 俯视尺寸图（单位：毫米）\n\n图 25：M26 底视尺寸图（单位：毫米）\n5.2. 推荐封装\n\n图 26：推荐封装（单位：毫米）\n备注：\n\n保证 PCB 板上模块和其他元器件之间距离至少 3mm。\n\n上图两个半径 1.75mm 的圆形为对应模块的 RF 测试点，需要做 KEEPOUT 处理（即在主板上对应位置禁止铺铜和走线）。\n\n\n5.3. 模块俯视图\n\n图 27：模块俯视图\n5.4. 模块底视图\n\n图 28：模块底视图\nI. 附录 - 资源\n• 锐凌微TinyCon3350-M26须原厂烧写固件\n• 获取锐凌微TinyCon3350-M26 Gagent日志（即将推出）\n• GAgent for 锐凌微 TinyCon3350-M26 04020018\n"},{"title":"0a-esp8266ex_datasheet_cn","url":"/zh-cn/module_source/esp8266/esp8266_datasheet.html","content":"1.    概述\nESP8266EX 由乐鑫公司开发，提供了一套高度集成的 Wi-Fi SoC 解决方案，其低功耗、紧凑设计和高稳定性可以满足用户的需求。\nESP8266EX 拥有完整的且自成体系的 Wi-Fi 网络功能，既能够独立应用，也可以作为从机搭载于其他主机 MCU 运行。当 ESP8266EX 独立应用时，能够直接从外接 Flash 中启动。内置的高速缓冲存储器有利于提高系统性能，并且优化存储系统。此外 ESP8266EX 只需通过 SPI/SDIO 接口或 I2C/UART 口即可作为 Wi-Fi 适配器，应用到基于任何微控制器的设计中。\nESP8266EX 集成了天线开关、射频 balun、功耗放大器、低噪放大器和过滤器。这样紧凑的设计仅需极少的外部电路并且将 PCB 的尺寸降到最低。ESP8266EX 还集成了增强版的 Tensilica’s L106 钻一系列 32-bit 内核处理器，带片上SRAM。 ESP8266EX 可以通过 GPIO 外接传感器和其他设备。\n1.1WiFi协议\n• 支持 802.11 b/g/n/e/i。\n• 支持 Wi-Fi Direct (P2P)。\n• 基础结构型网络 (Infrastructure BSS) 工作站 (Station) 模式/P2P 模式/SoftAP 模式。\n• 支持 CCMP（CBC-MAC、计数器模式）、 TKIP (MIC、 RC4)、 WAPI (SMS4)、 WEP(RC4)、 CRC 的硬件加速器。\n• WPA/PA2 PSK 和 WPS。\n• 802.11 i 安全特征：预认证和 TSN。\n• 支持 802.11n (2.4 GHz)。\n• 支持 MIMO 1×1 和 2×1、 STBC、 A- MPDU 和 A-MSDU 帧聚合技术、 0.4μs 的保护间隔。\n• WMM 低功耗 U-APSD。\n• 多队列管理，充分利用802.11e 标准的 QoS 传输优先。\n• UMA 认证标准。\n• 802.1h/RFC1042 帧封装。\n• 分散 DMA，实现数据传输操作时 Zero Copy，优化 CPU 负载。\n• 自适应速率回退算法基于实际信噪比(SNR) 和丢包信息来控制最佳传输速率和发射功耗。\n• MAC 层上的自动动重传和回复以防止在慢速主机环境中的数据包丢弃。\n1.2.    技术参数\n表 1-1 主要技术参数\n\n1.3.    应用\n• 家庭自动化\n• 智能插座、智能灯\n• Mesh 网络\n• 工业无线控制\n• 婴儿监控器\n• IP 摄像机\n• 传感器网络\n2.管脚定义\n管脚布局如图 2-1 所示。\n\n图 2-1. 管脚布局\n管脚定义如表 2-1 所示。\n表 2-1. 管脚定义\n\n3.功能描述\nESP8266EX 的功能原理如图 3-1 所示。\n\n图 3-1. 功能原理图\n3.1. CPU、存储和 Flash\n3.1.1. CPU\nESP8266EX 内置 Tensilica L106， 32-bit 微处理器 (MCU)，具有超低功耗的 16-bit RSIC。CPU 时钟速度为 80 MHz，最高可达 160 MHz。支持实时操作系统 (RTOS)。目前 Wi-Fi 协议栈只用了 20% 的 MIPS，其他的都可以用来做应用编程和开发。 CPU 包括以下接口。\n• 可连接片内存储控制器和外部 Flash 的可配置 RAM/ROM 接口 (iBus)\n• 连接存储控制器的数据 RAM 接口 (dBus)\n• 访问寄存器的 AHB 接口\n3.1.2. 内置存储\nESP8266EX 芯片内置了存储控制器，包含 ROM 和 SRAM。 MCU 可以通过 iBus、 dBus和 AHB 接口访问存储控制器。在发起请求后，所有存储单元都可以被访问。存储仲裁器会根据处理器接受这些请求的时间，决定访问顺序。\n芯片内无可编程存储器，用户程序必须由外部 Flash 存储。\n3.1.3. 外置 Flash\nESP8266EX 使用外置 SPI Flash 存储用户程序。理论上最大可支持 16 MB 的存储。建议按照如下所示来分配 SPI Flash 容量。\n• 不支持 OTA：最少支持 512 kB\n• 可支持 OTA：最少支持 1 MB\n⚠ 注意：支持的 SPI 模式： Standard SPI、 Dual SPI 和 Quad SPI。因此在烧录程序到 Flash 时要选择正确的 SPI 模式，否则下载的固件／程序可能无法正常正作。\n3.2. AHB 和 AHB 模块\nAHB 模块充当仲裁器，通过 MAC、主机的 SDIO 和 CPU 控制 AHB 接口由于发送地址不同， AHB 数据请求可能到达以下两个从机中的一个。\n• APB 模块\n• 闪存控制器（通常在无主机的情况下）\n高速请求一般是用来访问 Flash 控制器，而访问寄存器通过的是 APB 模块。\nAPB 模块充当解码器。但只可以访问 ESP8266EX 主模块内可编程的寄存器。由于发送地址不同， APB 请求可能到达射频接收器、 SI/SPI、主机 SDIO、 GPIO、 UART、实时时钟(RTC)、 MAC 或数字基带。\n3.3. 时钟\n3.3.1. 高频时钟\n基于外部晶振， ESP8266EX内部晶体振荡器可以生成射频时钟。该时钟可用于驱动 Tx 和Rx 混频器。晶振频率在 24 MHz 到 52 MHz 之间。\n尽管晶体振荡器的内部校准功能使得一系列的晶体满足时钟生成条件，但是晶体的质量仍然是影响获得合适的相位噪声和 Wi-Fi 灵敏度的因素。请参照表 3-1 来测量频率偏移。\n表 3-1. 高频时钟参数\n\n3.3.2. 外部时钟参考要求\n外部时钟的频率在 24 MHz 到 52 MHz 之间。为了使射频性能良好，时钟需满足要求如表3-2 所示\n表 3-2. 外部时钟参考要求\n\n3.4. 射频\nESP8266EX 射频主要包含以下模块。\n• 2.4 GHz 接收器\n• 2.4 GHz 发射器\n• 高速时钟生成器和晶体振荡器\n• 实时时钟\n• 偏置电路与稳压器\n3.4.1. 信道频率\n根据 IEEE802.11b/g/n标准，射频收发器支持以下信道。\n表 3-3. 频率信道\n\n3.4.2. 2.4 GHz 接收器\n2.4 GHz 接收器把射频信号降频，变成正交基带信号，用 2 个高分辨率的高速 ADC 将后者转为数字信号。为了适应不同的信号频道， ESP8266EX 集成了射频滤波器、自动增益控制 (AGC)、 DC 偏移补偿电路和基带滤波器。\n3.4.3. 2.4 GHz 发射器\n2.4 GHz 发射器将正交基带信号升频到 2.4 GHz，使用大功耗互补金属氧化物半导(CMOS) 功耗放大器驱动天线。数字校准的使用进一步地改善了功耗放大器的线性，从而在 802.11b 传输中达到 +19.5 dBm 的平均功耗，在 802.11n 传输中达到 +16 dBm 的平均功耗，功能超强。为了抵消无线电接收器的瑕疵， ESP8266EX 还另增了以下校准措施。\n• 载波泄露\n• I/Q 相位匹配\n• 基带非线性\n这些内置的校准措施减少了生产测试所需的时间和设备。\n3.4.4. 时钟生成器\n时钟生成器为接收器和发射器生成 2.4 GHz 正交基带时钟信号，其所有部件均集成于芯⽚上，包括：电感器、变容二极管、闭环滤波器、监管者和分频器。\n时钟生成器含有内置校准电路和自测电路。正交时钟相位和相位噪声通过拥有专利的校准算法在芯片上进行最优处理，以确保接收器和发射器达到最佳性能。\n3.5. Wi-Fi\nESP8266EX 支持 TCP/IP 协议，完全遵循 802.11 b/g/n/e/i WLAN MAC 协议和 Wi-Fi Direct 标准。它支持分布式控制功能 (DCF) 下的基本服务集 (BSS) 操作，也支持符合最新的 Wi-Fi P2P 协议的 P2P 团体操作。 ESP8266EX 自动采用低层协议功能。\n• RTS/CTS\n• 确认字符\n• 分片和重组\n• 聚合\n• 帧封装 (802.11h/RFC 1042)\n• 自动信标监测/扫描\n• P2P Wi-Fi direct\n跟 P2P 发现程序一样，被动或主动扫描一旦在适当的指令下起动，就会自主完成。执行电源管理时，与主机互动最少，如此一来，工作时间达到最短。\n4. 外设接口\n4.1. 通用输入/输出接口 (GPIO)\nESP8266EX 共有 17 个 GPIO 管脚，通过配置适当的寄存器可以给它们分配不同的功能。\n每个 GPIO 都可以配置为内部上拉/下拉，或者被设置为高阻。当被配置为输入时，可通过读取寄存器获取输入值；输日也可以被设置为边缘触发或电平触发来产生 CPU 中断。简言之， IO 管脚是双向、非反相和三态的，带有三态控制的输入和输出缓冲器。\n这些管脚可以与其他功能复用，例如 I2C、 I2S、 UART、 PWM、 IR 遥控、 LED Light 和Button 接口等。\n选择性的保持功能可以应需植入 IO 中。当 IO 不由内外部电路驱动时，保持功能可以被用于保持上次的状态。保持功能给管脚引入一些正反馈。因此，管脚的外部驱动必须强于正反馈。脱离保持状态所需的驱动力很小，在 5μA 之内。\n4.2. SDIO\nESP8266EX 拥有 1 个从机 SDIO 接口，接口管脚定义如下表 4-1 所示。支持 4-bit 25MHz SDIO v1.1 和 4-bit 50 MHz SDIO v2.0。\n表 4-1. SDIO 管脚定义\n\n4.3. 串行外设接口 (SPI/HSPI)\nESP8266EX 拥有 1 个通用从机/主机 SPI， 1 个从机 SDIO/SPI，和 1 个通用从机/主机HSPI。所有接口的功能均由硬件实现。接口定义如下所示。\n4.3.1. 通用 SPI（主机/从机）\n表 4-2. SPI 接口定义\n\n说明：SPI 模式可由软件编程实现。时钟频率最⼤为 80 MHz。\n4.3.2. HSPI（从机）\n表 4-3. HSPI（从机）管脚定义\n\n4.4. I2C 接口\nESP8266EX 拥有 1 个 I2C 接口，用于连接微控制器以及外围设备，如传感器等。 I2C 接口定义如表 4-4 所示。\n表 4-4. I2C 管脚定义\n\nESP8266EX 既支持 I2C 主机也支持 I2C 从机功能。 I2C 接口功能可由软件编程实现，时钟频率最高约为 100 kHz，需高于从设备最慢速的时钟频率。\n4.5. I2S 接口\nESP8266EX 拥有 1 个 I2S 输入接口和 1 个 I2S 输出接口。 I2S 主要用于音频数据采集、处理和传输，也可用于串口数据输入输出，如支持 LED 彩灯（WS2812 系列）。 I2S 管脚定义如表 4-5 所示。 I2C 接口能可以使用复用 GPIO 通过软件编程实现，支持链表DMA。\n表 4-5. I2S 管脚定义\n\n4.6. 通用异步收发器 (UART)\nESP8266EX 拥有两个 UART 接口，分别为 UART0 和 UART，接口定义如表 4-6 所示。\n表 4-6. UART 管脚定义\n\n2 个 UART 接口的数据传输均由硬件实现。数据传输速度可达 115200*40 (4.5 Mbps)。\nUART0 可以用做通信接口，支持流控。由于 UART1 目前只有数据传输功能，所以一般用作打印 log。\n说明：\nUART0 默认会在上电启动期间输出一些打印，此期间打印内容的波特率与所用的外部晶振频率有关。使用 40 MHz 晶振时，该段打印波特率为 115200；使用 26 MHz 晶振时，该段打印波特率为 74880。如果打印信息影响设备功能，建议在上电期间将 U0TXD、 U0RXD 分别与 U0RTS (MTDO)， U0CTS (MTCK) 交换，以屏蔽打印。\n4.7. 脉冲宽度调制 (PWM)\nESP8266EX 拥有 4 个 PWM 输出接口，如表 4-7 所示。用户可自行扩展。\n表 4-7. PWM 管脚定义\n\nPWM 接口功能由软件实现。例如，在 LED 智能照明的示例中， PWM 通过定时器的中断实现，最小分辨率可达 44 ns。 PWM 频率的可调节范围为 1000μs 到 10000μs，即 100Hz 到 1 kHz 之间。当 PWM 频率为 1 kHz，占空⽐为 1/22727， 1 kHz 的刷新率下可达超过 14-bit 的分辨率。\n4.8. IR 遥控接口\nESP8266EX 芯片目前定义了 1 个 IR 红外遥控接口，该接口定义如表 4-8 所示。\n表 4-8. IR 红外遥控管脚定义\n\nIR 红外遥控接口由软件实现，接口使用 NEC 编码及调制解调，采用 38 kHz 的调制载波，占空比为 1/3 的方波。传输范围在 1m 左右，传输范围由 2 个因素决定，一个是 GPIO 口的最大额定电流，另一个是红外接收管内部的限流电阻的大小。电阻越大，电流越小，功耗也越小，反之亦然。传输半⻆度为 15° 到 30°，取决于红外接收管的辐射⽅向。\n4.9. ADC（模/数转换器）\nESP8266EX 内置了一个 10-bit 精度的 SAR ADC。 TOUT（管脚 6）定义如表 4-9 所示。\n表 4-9. ADC 管脚定义\n\nADC 端口（管脚 6 TOUT）可提供以下两种应用，但不可同时使用。\n• 测量 VDD3P3（管脚 3 和 4）上的电源电压。\n\n• 测量 TOUT（管脚 6）的输入电压。\n\n说明：\nSDK 包提供 esp_init_data_default.bin，并且包含射频初始化参数 (0 ~ 127 Bytes)。\nesp_init_data_default.bin 中的第 107 byte，命名为 ”vdd33_const”， 此参数的定义如下：\n• 当 vdd33_const = 0xff，ESP8266EX 芯片会进内内部自测 VDD3P3 管脚 3 和 管脚 4 上的电源电压，根据测量结果优化射频电路工作状态。\n• 当 18 =< vdd33_const =< 36，ESP8266EX 使用（vdd33_const/10）来校准和优化射频电路工作状态。\n• 当 vdd33_const < 18 或 36 < vdd33_const < 255 时，ESP8266EX 使用默认值 2.5V 来校准和优化射频电路工作状态。\n4.10. LED Light 和 Button 接口\nESP8266EX拥有多达 17 个 GPIO 接口，均可定义作为 LED 与 Button 的控制接口。基于目前 ESP8266EX 一些示例设计的应用，我们对 LED 与 Button 的 GPIO 接口定义如表 4-10 所示。\n表 4-10. LED 和 Button 管脚定义\n\n上述共定义了一个 Button 和 2 个 LED 的接口。通用情况下，MTCK 作为复位按键的控制；GPIO0 用作 Wi-Fi 用作状态指示灯；MTDI 用作与服务器通信的指示灯。\n5. 电气参数\n5.1. 电气特性\n表 5-1. 电气特性\n\n5.2. 功耗\n表 5-2. 功耗\n\n5.3. Wi-Fi 射频特征\n表 5-3 中数据是在室内温度下，电压为 3.3V 和 1.1V 时分别测得。\n表 5-3. Wi-Fi 射频特征\n\n6. 封装信息\n\n图 6-1. ESP8266EX 封装\n说明：\n• INST_NAME 指的是在 eagle_soc.h 定义下的 IO_MUX REGISTER，例如 MTDI_U 指的是PERIPHS_IO_MUX_MTDI_U。\n• Net Name 指的是原理图中的管脚名称。\n• 功能指的是每个管脚的多功能。\n• 功能 1 ~ 5 对应 SDK 中的功能 0 ~ 4。例如，将 MTDI 设置为 GPIO12，如下所示：\n- #define    FUNC_GPIO12        3    //defined    in    eagle_soc.h\n- PIN_FUNC_SELECT（PERIPHS_IO_MUX_MTDI_U,FUNC_GPIO12）\nI. 附录 - 资源\n• ESP8266串口烧写说明\n• 获取乐鑫ESP 8266 Gagent日志（教程中“1.获取乐鑫ESP 8266 Gagent日志”）\n• GAgent for ESP8266 04020024下载\n"}]